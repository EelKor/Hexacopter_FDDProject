var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"FLIGHT_hexacopter","ref":false,"files":[{"name":"ert_main.cpp","type":"source","group":"main","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Main file","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: ert_main.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.248\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu May 22 21:41:20 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include <stdio.h>\n#include <stdlib.h>\n#include \"FLIGHT_hexacopter.h\"\n#include \"FLIGHT_hexacopter_private.h\"\n#include \"rtwtypes.h\"\n#include \"limits.h\"\n#include \"rt_nonfinite.h\"\n#include \"ext_mode.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"nuttxinitialize.h\"\n#define UNUSED(x)                      x = x\n#define NAMELEN                        16\n\n// Function prototype declaration\nvoid exitFcn(int sig);\nvoid *terminateTask(void *arg);\nvoid *baseRateTask(void *arg);\nvoid *subrateTask(void *arg);\nvolatile boolean_T stopRequested = false;\nvolatile boolean_T runModel = true;\nextmodeErrorCode_T errorCode;\npx4_sem_t stopSem;\npx4_sem_t baserateTaskSem;\npx4_sem_t subrateTaskSem[1];\nint taskId[1];\npthread_t schedulerThread;\npthread_t baseRateThread;\npthread_t backgroundThread;\nvoid *threadJoinStatus;\nint terminatingmodel = 0;\npthread_t subRateThread[1];\nint subratePriority[1];\nextmodeSimulationTime_T getCurrentTaskTime(int tid)\n{\n  extmodeSimulationTime_T currentTime = 0;\n  switch (tid) {\n   case 1:\n    currentTime = (extmodeSimulationTime_T)\n      ((FLIGHT_hexacopter_M->Timing.clockTick1) * 0.004);\n    break;\n  }\n\n  return currentTime;\n}\n\nvoid *subrateTask(void *arg)\n{\n  int tid = *((int *) arg);\n  int subRateId;\n  subRateId = tid + 1;\n  while (runModel) {\n    px4_sem_wait(&subrateTaskSem[tid]);\n    if (terminatingmodel)\n      break;\n\n#ifdef MW_RTOS_DEBUG\n\n    printf(\" -subrate task %d semaphore received\\n\", subRateId);\n\n#endif\n\n    extmodeSimulationTime_T currentTime = getCurrentTaskTime(subRateId);\n    FLIGHT_hexacopter_step(subRateId);\n\n    // Get model outputs here\n\n    // Trigger External Mode event\n    extmodeEvent(subRateId, currentTime);\n  }\n\n  pthread_exit((void *)0);\n  return NULL;\n}\n\nvoid *baseRateTask(void *arg)\n{\n  runModel = (rtmGetErrorStatus(FLIGHT_hexacopter_M) == (NULL));\n  while (runModel) {\n    px4_sem_wait(&baserateTaskSem);\n\n#ifdef MW_RTOS_DEBUG\n\n    printf(\"*base rate task semaphore received\\n\");\n    fflush(stdout);\n\n#endif\n\n    if (rtmStepTask(FLIGHT_hexacopter_M, 1)\n        ) {\n      px4_sem_post(&subrateTaskSem[0]);\n    }\n\n    extmodeSimulationTime_T currentTime = (extmodeSimulationTime_T)\n      FLIGHT_hexacopter_M->Timing.taskTime0;\n    FLIGHT_hexacopter_step(0);\n\n    // Get model outputs here\n\n    // Trigger External Mode event\n    extmodeEvent(0, currentTime);\n    stopRequested = !((rtmGetErrorStatus(FLIGHT_hexacopter_M) == (NULL)));\n    runModel = !stopRequested && !extmodeSimulationComplete() &&\n      !extmodeStopRequested();\n  }\n\n  terminateTask(arg);\n  pthread_exit((void *)0);\n  return NULL;\n}\n\nvoid exitFcn(int sig)\n{\n  UNUSED(sig);\n  rtmSetErrorStatus(FLIGHT_hexacopter_M, \"stopping the model\");\n  runModel = 0;\n}\n\nvoid *terminateTask(void *arg)\n{\n  UNUSED(arg);\n  terminatingmodel = 1;\n\n  {\n    int i;\n\n    // Signal all periodic tasks to complete\n    for (i=0; i<1; i++) {\n      CHECK_STATUS(px4_sem_post(&subrateTaskSem[i]), 0, \"px4_sem_post\");\n      CHECK_STATUS(px4_sem_destroy(&subrateTaskSem[i]), 0, \"px4_sem_destroy\");\n    }\n\n    // Wait for all periodic tasks to complete\n    for (i=0; i<1; i++) {\n      CHECK_STATUS(pthread_join(subRateThread[i], &threadJoinStatus), 0,\n                   \"pthread_join\");\n    }\n\n    runModel = 0;\n\n    // Wait for background task to complete\n    CHECK_STATUS(pthread_join(backgroundThread, &threadJoinStatus), 0,\n                 \"pthread_join\");\n  }\n\n  MW_PX4_Terminate();\n\n  // Terminate model\n  FLIGHT_hexacopter_terminate();\n  extmodeReset();\n  px4_sem_post(&stopSem);\n  return NULL;\n}\n\nvoid *backgroundTask(void *arg)\n{\n  while (runModel) {\n    // Run External Mode background activities\n    errorCode = extmodeBackgroundRun();\n    if (errorCode != EXTMODE_SUCCESS) {\n      // Code to handle External Mode background task errors\n      // may be added here\n    }\n  }\n\n  pthread_exit((void *)0);\n  return NULL;\n}\n\nint px4_simulink_app_task_main (int argc, char *argv[])\n{\n  subratePriority[0] = 249;\n  px4_simulink_app_control_MAVLink();\n  rtmSetErrorStatus(FLIGHT_hexacopter_M, 0);\n\n  // Parse External Mode command line arguments\n  errorCode = extmodeParseArgs(argc, (const char_T **)argv);\n  if (errorCode != EXTMODE_SUCCESS) {\n    return (errorCode);\n  }\n\n  // Initialize model\n  FLIGHT_hexacopter_initialize();\n\n  // External Mode initialization\n  errorCode = extmodeInit(FLIGHT_hexacopter_M->extModeInfo, &rtmGetTFinal\n    (FLIGHT_hexacopter_M));\n  if (errorCode != EXTMODE_SUCCESS) {\n    // Code to handle External Mode initialization errors\n    // may be added here\n  }\n\n  if (errorCode == EXTMODE_SUCCESS) {\n    // Wait until a Start or Stop Request has been received from the Host\n    extmodeWaitForHostRequest(EXTMODE_WAIT_FOREVER);\n    if (extmodeStopRequested()) {\n      rtmSetStopRequested(FLIGHT_hexacopter_M, true);\n    }\n  }\n\n  // Call RTOS Initialization function\n  nuttxRTOSInit(0.001, 1);\n\n  // Wait for stop semaphore\n  px4_sem_wait(&stopSem);\n\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\n\n  {\n    int i;\n    for (i=0; i < MW_NUMBER_TIMER_DRIVEN_TASKS; i++) {\n      CHECK_STATUS(px4_sem_destroy(&timerTaskSem[i]), 0, \"px4_sem_destroy\");\n    }\n  }\n\n#endif\n\n  return 0;\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"FLIGHT_hexacopter.cpp","type":"source","group":"model","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: FLIGHT_hexacopter.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.248\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu May 22 21:41:20 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include \"FLIGHT_hexacopter.h\"\n#include \"FLIGHT_hexacopter_types.h\"\n#include \"rtwtypes.h\"\n#include \"FLIGHT_hexacopter_private.h\"\n#include <math.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rt_defines.h\"\n\n// Block signals (default storage)\nB_FLIGHT_hexacopter_T FLIGHT_hexacopter_B;\n\n// Block states (default storage)\nDW_FLIGHT_hexacopter_T FLIGHT_hexacopter_DW;\n\n// Real-time model\nRT_MODEL_FLIGHT_hexacopter_T FLIGHT_hexacopter_M_ = RT_MODEL_FLIGHT_hexacopter_T\n  ();\nRT_MODEL_FLIGHT_hexacopter_T *const FLIGHT_hexacopter_M = &FLIGHT_hexacopter_M_;\n\n// Forward declaration for local functions\nstatic void FLIGHT_hexacopter_PWM_setupImpl(px4_internal_block_PWM_FLIGHT_T *obj,\n  boolean_T armPWM, boolean_T forceFailsafe);\nstatic void rate_monotonic_scheduler(void);\n\n//\n// Set which subrates need to run this base step (base rate always runs).\n// This function must be called prior to calling the model step function\n// in order to remember which rates need to run this base step.  The\n// buffering of events allows for overlapping preemption.\n//\nvoid FLIGHT_hexacopter_SetEventsForThisBaseStep(boolean_T *eventFlags)\n{\n  // Task runs when its counter is zero, computed via rtmStepTask macro\n  eventFlags[1] = ((boolean_T)rtmStepTask(FLIGHT_hexacopter_M, 1));\n}\n\n//\n//         This function updates active task flag for each subrate\n//         and rate transition flags for tasks that exchange data.\n//         The function assumes rate-monotonic multitasking scheduler.\n//         The function must be called at model base rate so that\n//         the generated code self-manages all its subrates and rate\n//         transition flags.\n//\nstatic void rate_monotonic_scheduler(void)\n{\n  // To ensure a deterministic data transfer between two rates,\n  //  data is transferred at the priority of a fast task and the frequency\n  //  of the slow task.  The following flags indicate when the data transfer\n  //  happens.  That is, a rate interaction flag is set true when both rates\n  //  will run, and false otherwise.\n\n\n  // tid 0 shares data with slower tid rate: 1\n  FLIGHT_hexacopter_M->Timing.RateInteraction.TID0_1 =\n    (FLIGHT_hexacopter_M->Timing.TaskCounters.TID[1] == 0);\n\n  // Compute which subrates run during the next base time step.  Subrates\n  //  are an integer multiple of the base rate counter.  Therefore, the subtask\n  //  counter is reset when it reaches its limit (zero means run).\n\n  (FLIGHT_hexacopter_M->Timing.TaskCounters.TID[1])++;\n  if ((FLIGHT_hexacopter_M->Timing.TaskCounters.TID[1]) > 3) {// Sample time: [0.004s, 0.0s] \n    FLIGHT_hexacopter_M->Timing.TaskCounters.TID[1] = 0;\n  }\n}\n\n// System initialize for atomic system:\nvoid FLIGHT_he_PX4Timestamp_Init(DW_PX4Timestamp_FLIGHT_hexaco_T *localDW)\n{\n  // Start for MATLABSystem: '<S3>/PX4 Timestamp'\n  localDW->obj.matlabCodegenIsDeleted = false;\n  localDW->objisempty = true;\n  localDW->obj.isInitialized = 1;\n  localDW->obj.isSetupComplete = true;\n}\n\n// Output and update for atomic system:\nvoid FLIGHT_hexacop_PX4Timestamp(B_PX4Timestamp_FLIGHT_hexacop_T *localB)\n{\n  // MATLABSystem: '<S3>/PX4 Timestamp'\n  localB->PX4Timestamp = hrt_absolute_time();\n}\n\n// Termination for atomic system:\nvoid FLIGHT_he_PX4Timestamp_Term(DW_PX4Timestamp_FLIGHT_hexaco_T *localDW)\n{\n  // Terminate for MATLABSystem: '<S3>/PX4 Timestamp'\n  if (!localDW->obj.matlabCodegenIsDeleted) {\n    localDW->obj.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S3>/PX4 Timestamp'\n}\n\n// System initialize for atomic system:\nvoid FLIGHT__PX4Timestamp_b_Init(DW_PX4Timestamp_FLIGHT_hexa_b_T *localDW)\n{\n  // Start for MATLABSystem: '<S490>/PX4 Timestamp'\n  localDW->obj.matlabCodegenIsDeleted = false;\n  localDW->objisempty = true;\n  localDW->obj.isInitialized = 1;\n  localDW->obj.isSetupComplete = true;\n}\n\n// Output and update for atomic system:\nvoid FLIGHT_hexac_PX4Timestamp_o(B_PX4Timestamp_FLIGHT_hexac_l_T *localB)\n{\n  // MATLABSystem: '<S490>/PX4 Timestamp'\n  localB->PX4Timestamp = hrt_absolute_time();\n}\n\n// Termination for atomic system:\nvoid FLIGHT__PX4Timestamp_o_Term(DW_PX4Timestamp_FLIGHT_hexa_b_T *localDW)\n{\n  // Terminate for MATLABSystem: '<S490>/PX4 Timestamp'\n  if (!localDW->obj.matlabCodegenIsDeleted) {\n    localDW->obj.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S490>/PX4 Timestamp'\n}\n\n// System initialize for atomic system:\nvoid FLIGHT__PX4Timestamp_m_Init(DW_PX4Timestamp_FLIGHT_hexa_f_T *localDW)\n{\n  // Start for MATLABSystem: '<S504>/PX4 Timestamp'\n  localDW->obj.matlabCodegenIsDeleted = false;\n  localDW->objisempty = true;\n  localDW->obj.isInitialized = 1;\n  localDW->obj.isSetupComplete = true;\n}\n\n// Output and update for atomic system:\nvoid FLIGHT_hexac_PX4Timestamp_n(B_PX4Timestamp_FLIGHT_hexac_h_T *localB)\n{\n  // MATLABSystem: '<S504>/PX4 Timestamp'\n  localB->PX4Timestamp = hrt_absolute_time();\n}\n\n// Termination for atomic system:\nvoid FLIGHT__PX4Timestamp_k_Term(DW_PX4Timestamp_FLIGHT_hexa_f_T *localDW)\n{\n  // Terminate for MATLABSystem: '<S504>/PX4 Timestamp'\n  if (!localDW->obj.matlabCodegenIsDeleted) {\n    localDW->obj.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S504>/PX4 Timestamp'\n}\n\nreal32_T rt_roundf_snf(real32_T u)\n{\n  real32_T y;\n  if (static_cast<real32_T>(fabs(static_cast<real_T>(u))) < 8.388608E+6F) {\n    if (u >= 0.5F) {\n      y = static_cast<real32_T>(floor(static_cast<real_T>(u + 0.5F)));\n    } else if (u > -0.5F) {\n      y = u * 0.0F;\n    } else {\n      y = static_cast<real32_T>(ceil(static_cast<real_T>(u - 0.5F)));\n    }\n  } else {\n    y = u;\n  }\n\n  return y;\n}\n\nreal32_T rt_atan2f_snf(real32_T u0, real32_T u1)\n{\n  real32_T y;\n  if (rtIsNaNF(u0) || rtIsNaNF(u1)) {\n    y = (rtNaNF);\n  } else if (rtIsInfF(u0) && rtIsInfF(u1)) {\n    int32_T tmp;\n    int32_T tmp_0;\n    if (u0 > 0.0F) {\n      tmp = 1;\n    } else {\n      tmp = -1;\n    }\n\n    if (u1 > 0.0F) {\n      tmp_0 = 1;\n    } else {\n      tmp_0 = -1;\n    }\n\n    y = static_cast<real32_T>(atan2(static_cast<real_T>(static_cast<real32_T>\n      (tmp)), static_cast<real_T>(static_cast<real32_T>(tmp_0))));\n  } else if (u1 == 0.0F) {\n    if (u0 > 0.0F) {\n      y = RT_PIF / 2.0F;\n    } else if (u0 < 0.0F) {\n      y = -(RT_PIF / 2.0F);\n    } else {\n      y = 0.0F;\n    }\n  } else {\n    y = static_cast<real32_T>(atan2(static_cast<real_T>(u0), static_cast<real_T>\n      (u1)));\n  }\n\n  return y;\n}\n\nstatic void FLIGHT_hexacopter_PWM_setupImpl(px4_internal_block_PWM_FLIGHT_T *obj,\n  boolean_T armPWM, boolean_T forceFailsafe)\n{\n  obj->isMain = true;\n  pwm_open(&obj->actuatorAdvertiseObj, &obj->armAdvertiseObj);\n  obj->servoCount = 8;\n  if (armPWM) {\n    pwm_arm(&obj->armAdvertiseObj);\n    obj->isArmed = true;\n  } else {\n    pwm_disarm(&obj->armAdvertiseObj);\n    obj->isArmed = false;\n  }\n\n  obj->channelMask = 63;\n  if (obj->isMain) {\n    if (forceFailsafe) {\n      pwm_disarm(&obj->armAdvertiseObj);\n    } else {\n      pwm_arm(&obj->armAdvertiseObj);\n    }\n  }\n}\n\n// Model step function for TID0\nvoid FLIGHT_hexacopter_step0(void)     // Sample time: [0.001s, 0.0s]\n{\n  int32_T i;\n  real32_T ParamStep;\n  real32_T ParamStep_0;\n  real32_T ParamStep_1;\n  real32_T rtb_IProdOut;\n  real32_T rtb_IProdOut_h;\n  real32_T rtb_Integrator_cv;\n  real32_T rtb_Integrator_k;\n  real32_T rtb_Product2_a;\n  real32_T rtb_TSamp_p4;\n  real32_T rtb_d;\n  real32_T rtb_p;\n  real32_T rtb_r;\n  real32_T w_radps;\n  uint32_T tmp;\n  uint16_T tmp_0;\n  boolean_T b_varargout_1;\n  boolean_T rtb_Compare_a;\n\n  {                                    // Sample time: [0.001s, 0.0s]\n    rate_monotonic_scheduler();\n  }\n\n  // Reset subsysRan breadcrumbs\n  srClearBC(FLIGHT_hexacopter_DW.Mixer_SubsysRanBC);\n\n  // Reset subsysRan breadcrumbs\n  srClearBC(FLIGHT_hexacopter_DW.SAS_SubsysRanBC);\n\n  // Reset subsysRan breadcrumbs\n  srClearBC(FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC_c);\n\n  // RateTransition: '<Root>/rate_transition_arm'\n  if (FLIGHT_hexacopter_M->Timing.RateInteraction.TID0_1) {\n    // RateTransition: '<Root>/rate_transition_arm'\n    FLIGHT_hexacopter_B.rate_transition_arm =\n      FLIGHT_hexacopter_DW.rate_transition_arm_Buffer0;\n\n    // RateTransition: '<Root>/rate_transition_des_p'\n    FLIGHT_hexacopter_B.rate_transition_des_p =\n      FLIGHT_hexacopter_DW.rate_transition_des_p_Buffer0;\n\n    // RateTransition: '<Root>/rate_transition_des_q'\n    FLIGHT_hexacopter_B.rate_transition_des_q =\n      FLIGHT_hexacopter_DW.rate_transition_des_q_Buffer0;\n\n    // RateTransition: '<Root>/rate_transition_des_r'\n    FLIGHT_hexacopter_B.rate_transition_des_r =\n      FLIGHT_hexacopter_DW.rate_transition_des_r_Buffer0;\n  }\n\n  // End of RateTransition: '<Root>/rate_transition_arm'\n\n  // MATLABSystem: '<S497>/SourceBlock'\n  b_varargout_1 = uORB_read_step(FLIGHT_hexacopter_DW.obj_pe.orbMetadataObj,\n    &FLIGHT_hexacopter_DW.obj_pe.eventStructObj, &FLIGHT_hexacopter_B.r4, false,\n    1.0);\n\n  // Outputs for Enabled SubSystem: '<S497>/Enabled Subsystem' incorporates:\n  //   EnablePort: '<S498>/Enable'\n\n  // Start for MATLABSystem: '<S497>/SourceBlock'\n  if (b_varargout_1) {\n    // SignalConversion generated from: '<S498>/In1'\n    FLIGHT_hexacopter_B.In1_h = FLIGHT_hexacopter_B.r4;\n    srUpdateBC(FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC_c);\n  }\n\n  // End of Outputs for SubSystem: '<S497>/Enabled Subsystem'\n\n  // Outputs for Enabled SubSystem: '<Root>/SAS' incorporates:\n  //   EnablePort: '<S10>/Enable'\n\n  if (FLIGHT_hexacopter_B.rate_transition_arm) {\n    // MATLABSystem: '<S10>/Read Parameter10'\n    if (FLIGHT_hexacopter_DW.obj_c.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_c.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_c.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // MATLAB Function: '<S10>/MATLAB Function' incorporates:\n    //   MATLABSystem: '<S10>/Read Parameter10'\n    //\n    w_radps = ParamStep * 2.0F * 3.14159274F;\n\n    // Gain: '<S315>/tau'\n    rtb_Product2_a = FLIGHT_hexacopter_P.tau_Gain * w_radps;\n\n    // Product: '<S316>/Product2'\n    ParamStep = rtb_Product2_a * rtb_Product2_a;\n\n    // Bias: '<S316>/Bias'\n    rtb_d = ParamStep + FLIGHT_hexacopter_P.Bias_Bias;\n\n    // Gain: '<S316>/Gain'\n    rtb_Product2_a *= FLIGHT_hexacopter_P.Gain_Gain_i;\n\n    // Sum: '<S316>/Add1'\n    rtb_r = rtb_d + rtb_Product2_a;\n\n    // Sum: '<S315>/Sum' incorporates:\n    //   UnitDelay: '<S315>/Unit Delay1'\n\n    rtb_Integrator_cv = FLIGHT_hexacopter_B.In1_h.xyz[1] +\n      FLIGHT_hexacopter_DW.UnitDelay1_DSTATE;\n\n    // Sum: '<S315>/Sum1' incorporates:\n    //   Bias: '<S316>/Bias1'\n    //   Gain: '<S315>/Gain1'\n    //   Product: '<S315>/Product5'\n    //   Product: '<S316>/Product4'\n    //   Sum: '<S315>/Sum2'\n    //   UnaryMinus: '<S316>/Unary Minus'\n    //   UnitDelay: '<S315>/Unit Delay1'\n    //   UnitDelay: '<S315>/Unit Delay2'\n\n    FLIGHT_hexacopter_DW.UnitDelay1_DSTATE = ((-ParamStep +\n      FLIGHT_hexacopter_P.Bias1_Bias) / rtb_r * rtb_Integrator_cv +\n      FLIGHT_hexacopter_B.In1_h.xyz[1]) * FLIGHT_hexacopter_P.Gain1_Gain_j +\n      FLIGHT_hexacopter_DW.UnitDelay2_DSTATE;\n\n    // SampleTimeMath: '<S312>/TSamp' incorporates:\n    //   Product: '<S315>/Product1'\n    //   Product: '<S316>/Product3'\n    //\n    //  About '<S312>/TSamp':\n    //   y = u * K where K = 1 / ( w * Ts )\n    //\n    rtb_TSamp_p4 = ParamStep / rtb_r * rtb_Integrator_cv *\n      FLIGHT_hexacopter_P.TSamp_WtEt;\n\n    // MATLABSystem: '<S10>/Read Parameter5'\n    if (FLIGHT_hexacopter_DW.obj_h.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_h.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_h.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // Sum: '<S309>/Sum1'\n    rtb_Integrator_k = FLIGHT_hexacopter_B.rate_transition_des_q -\n      FLIGHT_hexacopter_B.In1_h.xyz[1];\n\n    // MATLABSystem: '<S10>/Read Parameter3'\n    if (FLIGHT_hexacopter_DW.obj_b.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_b.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_b.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_0);\n    if (b_varargout_1) {\n      ParamStep_0 = 0.0F;\n    }\n\n    // Sum: '<S309>/Sum5' incorporates:\n    //   DiscreteIntegrator: '<S350>/Integrator'\n    //   MATLABSystem: '<S10>/Read Parameter3'\n    //   MATLABSystem: '<S10>/Read Parameter5'\n    //   Product: '<S309>/Product2'\n    //   Product: '<S355>/PProd Out'\n    //   Sum: '<S312>/Diff'\n    //   Sum: '<S359>/Sum'\n    //   UnitDelay: '<S312>/UD'\n    //  *\n    //  Block description for '<S312>/Diff':\n    //\n    //   Add in CPU\n    //\n    //  Block description for '<S312>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_B.Sum5 = (rtb_Integrator_k * ParamStep_0 +\n      FLIGHT_hexacopter_DW.Integrator_DSTATE_p) - (rtb_TSamp_p4 -\n      FLIGHT_hexacopter_DW.UD_DSTATE_l) * ParamStep;\n\n    // MATLABSystem: '<S10>/Read Parameter4'\n    if (FLIGHT_hexacopter_DW.obj_p.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_p.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_p.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // Product: '<S347>/IProd Out' incorporates:\n    //   MATLABSystem: '<S10>/Read Parameter4'\n    //\n    rtb_IProdOut = rtb_Integrator_k * ParamStep;\n\n    // Sum: '<S315>/Sum3' incorporates:\n    //   Product: '<S315>/Product2'\n    //   Product: '<S316>/Product5'\n    //   Sum: '<S316>/Add3'\n    //   UnitDelay: '<S315>/Unit Delay2'\n\n    FLIGHT_hexacopter_DW.UnitDelay2_DSTATE = FLIGHT_hexacopter_B.In1_h.xyz[1] -\n      1.0F / rtb_r * (rtb_d - rtb_Product2_a) * rtb_Integrator_cv;\n\n    // Gain: '<S370>/tau'\n    rtb_Integrator_k = FLIGHT_hexacopter_P.tau_Gain_n * w_radps;\n\n    // Product: '<S371>/Product2'\n    rtb_Integrator_cv = rtb_Integrator_k * rtb_Integrator_k;\n\n    // Bias: '<S371>/Bias'\n    rtb_r = rtb_Integrator_cv + FLIGHT_hexacopter_P.Bias_Bias_b;\n\n    // Gain: '<S371>/Gain'\n    rtb_Integrator_k *= FLIGHT_hexacopter_P.Gain_Gain_e;\n\n    // Sum: '<S371>/Add1'\n    rtb_d = rtb_r + rtb_Integrator_k;\n\n    // Sum: '<S370>/Sum' incorporates:\n    //   UnitDelay: '<S370>/Unit Delay1'\n\n    rtb_Product2_a = FLIGHT_hexacopter_B.In1_h.xyz[0] +\n      FLIGHT_hexacopter_DW.UnitDelay1_DSTATE_f;\n\n    // Sum: '<S370>/Sum1' incorporates:\n    //   Bias: '<S371>/Bias1'\n    //   Gain: '<S370>/Gain1'\n    //   Product: '<S370>/Product5'\n    //   Product: '<S371>/Product4'\n    //   Sum: '<S370>/Sum2'\n    //   UnaryMinus: '<S371>/Unary Minus'\n    //   UnitDelay: '<S370>/Unit Delay1'\n    //   UnitDelay: '<S370>/Unit Delay2'\n\n    FLIGHT_hexacopter_DW.UnitDelay1_DSTATE_f = ((-rtb_Integrator_cv +\n      FLIGHT_hexacopter_P.Bias1_Bias_n) / rtb_d * rtb_Product2_a +\n      FLIGHT_hexacopter_B.In1_h.xyz[0]) * FLIGHT_hexacopter_P.Gain1_Gain_e +\n      FLIGHT_hexacopter_DW.UnitDelay2_DSTATE_c;\n\n    // SampleTimeMath: '<S367>/TSamp' incorporates:\n    //   Product: '<S370>/Product1'\n    //   Product: '<S371>/Product3'\n    //\n    //  About '<S367>/TSamp':\n    //   y = u * K where K = 1 / ( w * Ts )\n    //\n    rtb_Integrator_cv = rtb_Integrator_cv / rtb_d * rtb_Product2_a *\n      FLIGHT_hexacopter_P.TSamp_WtEt_m;\n\n    // MATLABSystem: '<S10>/Read Parameter2'\n    if (FLIGHT_hexacopter_DW.obj_da.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_da.SampleTime =\n        FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_da.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // Sum: '<S310>/Sum1'\n    rtb_p = FLIGHT_hexacopter_B.rate_transition_des_p -\n      FLIGHT_hexacopter_B.In1_h.xyz[0];\n\n    // MATLABSystem: '<S10>/read_mc_rollrate_p'\n    if (FLIGHT_hexacopter_DW.obj_i.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_i.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_i.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_0);\n    if (b_varargout_1) {\n      ParamStep_0 = 0.0F;\n    }\n\n    // Sum: '<S310>/Sum5' incorporates:\n    //   DiscreteIntegrator: '<S405>/Integrator'\n    //   MATLABSystem: '<S10>/Read Parameter2'\n    //   MATLABSystem: '<S10>/read_mc_rollrate_p'\n    //   Product: '<S310>/Product2'\n    //   Product: '<S410>/PProd Out'\n    //   Sum: '<S367>/Diff'\n    //   Sum: '<S414>/Sum'\n    //   UnitDelay: '<S367>/UD'\n    //  *\n    //  Block description for '<S367>/Diff':\n    //\n    //   Add in CPU\n    //\n    //  Block description for '<S367>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_B.Sum5_d = (rtb_p * ParamStep_0 +\n      FLIGHT_hexacopter_DW.Integrator_DSTATE_c) - (rtb_Integrator_cv -\n      FLIGHT_hexacopter_DW.UD_DSTATE_m) * ParamStep;\n\n    // MATLABSystem: '<S10>/Read Parameter1'\n    if (FLIGHT_hexacopter_DW.obj_ea.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_ea.SampleTime =\n        FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_ea.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // Product: '<S402>/IProd Out' incorporates:\n    //   MATLABSystem: '<S10>/Read Parameter1'\n    //\n    rtb_IProdOut_h = rtb_p * ParamStep;\n\n    // Sum: '<S370>/Sum3' incorporates:\n    //   Product: '<S370>/Product2'\n    //   Product: '<S371>/Product5'\n    //   Sum: '<S371>/Add3'\n    //   UnitDelay: '<S370>/Unit Delay2'\n\n    FLIGHT_hexacopter_DW.UnitDelay2_DSTATE_c = FLIGHT_hexacopter_B.In1_h.xyz[0]\n      - 1.0F / rtb_d * (rtb_r - rtb_Integrator_k) * rtb_Product2_a;\n\n    // Gain: '<S425>/tau'\n    rtb_p = FLIGHT_hexacopter_P.tau_Gain_c * w_radps;\n\n    // Product: '<S426>/Product2'\n    rtb_Integrator_k = rtb_p * rtb_p;\n\n    // Bias: '<S426>/Bias'\n    rtb_r = rtb_Integrator_k + FLIGHT_hexacopter_P.Bias_Bias_c;\n\n    // Gain: '<S426>/Gain'\n    rtb_p *= FLIGHT_hexacopter_P.Gain_Gain_b;\n\n    // Sum: '<S426>/Add1'\n    rtb_d = rtb_r + rtb_p;\n\n    // Sum: '<S425>/Sum' incorporates:\n    //   UnitDelay: '<S425>/Unit Delay1'\n\n    rtb_Product2_a = FLIGHT_hexacopter_B.In1_h.xyz[2] +\n      FLIGHT_hexacopter_DW.UnitDelay1_DSTATE_e;\n\n    // Sum: '<S425>/Sum1' incorporates:\n    //   Bias: '<S426>/Bias1'\n    //   Gain: '<S425>/Gain1'\n    //   Product: '<S425>/Product5'\n    //   Product: '<S426>/Product4'\n    //   Sum: '<S425>/Sum2'\n    //   UnaryMinus: '<S426>/Unary Minus'\n    //   UnitDelay: '<S425>/Unit Delay1'\n    //   UnitDelay: '<S425>/Unit Delay2'\n\n    FLIGHT_hexacopter_DW.UnitDelay1_DSTATE_e = ((-rtb_Integrator_k +\n      FLIGHT_hexacopter_P.Bias1_Bias_i) / rtb_d * rtb_Product2_a +\n      FLIGHT_hexacopter_B.In1_h.xyz[2]) * FLIGHT_hexacopter_P.Gain1_Gain_iw +\n      FLIGHT_hexacopter_DW.UnitDelay2_DSTATE_e;\n\n    // SampleTimeMath: '<S422>/TSamp' incorporates:\n    //   Product: '<S425>/Product1'\n    //   Product: '<S426>/Product3'\n    //\n    //  About '<S422>/TSamp':\n    //   y = u * K where K = 1 / ( w * Ts )\n    //\n    w_radps = rtb_Integrator_k / rtb_d * rtb_Product2_a *\n      FLIGHT_hexacopter_P.TSamp_WtEt_p;\n\n    // MATLABSystem: '<S10>/Read Parameter8'\n    if (FLIGHT_hexacopter_DW.obj_i4.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_i4.SampleTime =\n        FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_i4.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // MATLABSystem: '<S10>/Read Parameter6'\n    if (FLIGHT_hexacopter_DW.obj_a.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_a.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_a.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_0);\n    if (b_varargout_1) {\n      ParamStep_0 = 0.0F;\n    }\n\n    // Sum: '<S311>/Sum1'\n    rtb_Integrator_k = FLIGHT_hexacopter_B.rate_transition_des_r -\n      FLIGHT_hexacopter_B.In1_h.xyz[2];\n\n    // MATLABSystem: '<S10>/Read Parameter9'\n    if (FLIGHT_hexacopter_DW.obj_e.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_e.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_e.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_1);\n    if (b_varargout_1) {\n      ParamStep_1 = 0.0F;\n    }\n\n    // Sum: '<S10>/Sum' incorporates:\n    //   DiscreteIntegrator: '<S460>/Integrator'\n    //   MATLABSystem: '<S10>/Read Parameter6'\n    //   MATLABSystem: '<S10>/Read Parameter8'\n    //   MATLABSystem: '<S10>/Read Parameter9'\n    //   Product: '<S10>/yawrate_feedforward'\n    //   Product: '<S311>/Product2'\n    //   Product: '<S465>/PProd Out'\n    //   Sum: '<S311>/Sum5'\n    //   Sum: '<S422>/Diff'\n    //   Sum: '<S469>/Sum'\n    //   UnitDelay: '<S422>/UD'\n    //  *\n    //  Block description for '<S422>/Diff':\n    //\n    //   Add in CPU\n    //\n    //  Block description for '<S422>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_B.Sum = ((rtb_Integrator_k * ParamStep_0 +\n      FLIGHT_hexacopter_DW.Integrator_DSTATE_g) - (w_radps -\n      FLIGHT_hexacopter_DW.UD_DSTATE_jy) * ParamStep) + ParamStep_1 *\n      FLIGHT_hexacopter_B.rate_transition_des_r;\n\n    // MATLABSystem: '<S10>/Read Parameter7'\n    if (FLIGHT_hexacopter_DW.obj_j.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_j.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_j.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // Sum: '<S425>/Sum3' incorporates:\n    //   Product: '<S425>/Product2'\n    //   Product: '<S426>/Product5'\n    //   Sum: '<S426>/Add3'\n    //   UnitDelay: '<S425>/Unit Delay2'\n\n    FLIGHT_hexacopter_DW.UnitDelay2_DSTATE_e = FLIGHT_hexacopter_B.In1_h.xyz[2]\n      - 1.0F / rtb_d * (rtb_r - rtb_p) * rtb_Product2_a;\n\n    // Update for UnitDelay: '<S312>/UD'\n    //\n    //  Block description for '<S312>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_l = rtb_TSamp_p4;\n\n    // Update for DiscreteIntegrator: '<S350>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_p +=\n      FLIGHT_hexacopter_P.Integrator_gainval * rtb_IProdOut;\n\n    // Update for UnitDelay: '<S367>/UD'\n    //\n    //  Block description for '<S367>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_m = rtb_Integrator_cv;\n\n    // Update for DiscreteIntegrator: '<S405>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_c +=\n      FLIGHT_hexacopter_P.Integrator_gainval_b * rtb_IProdOut_h;\n\n    // Update for UnitDelay: '<S422>/UD'\n    //\n    //  Block description for '<S422>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_jy = w_radps;\n\n    // Update for DiscreteIntegrator: '<S460>/Integrator' incorporates:\n    //   MATLABSystem: '<S10>/Read Parameter7'\n    //   Product: '<S457>/IProd Out'\n    //\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_g += rtb_Integrator_k * ParamStep *\n      FLIGHT_hexacopter_P.Integrator_gainval_p;\n    srUpdateBC(FLIGHT_hexacopter_DW.SAS_SubsysRanBC);\n  }\n\n  // End of Outputs for SubSystem: '<Root>/SAS'\n\n  // RateTransition: '<Root>/Rate Transition1' incorporates:\n  //   RateTransition: '<Root>/rate_transition_throttle'\n\n  if (FLIGHT_hexacopter_M->Timing.RateInteraction.TID0_1) {\n    // RateTransition: '<Root>/Rate Transition1'\n    FLIGHT_hexacopter_B.RateTransition1 =\n      FLIGHT_hexacopter_DW.RateTransition1_Buffer0;\n\n    // RateTransition: '<Root>/rate_transition_ctrl_sw'\n    FLIGHT_hexacopter_B.rate_transition_ctrl_sw =\n      FLIGHT_hexacopter_DW.rate_transition_ctrl_sw_Buffer0;\n\n    // RateTransition: '<Root>/rate_transition_throttle'\n    FLIGHT_hexacopter_B.rate_transition_throttle =\n      FLIGHT_hexacopter_DW.rate_transition_throttle_Buffer;\n  }\n\n  // End of RateTransition: '<Root>/Rate Transition1'\n\n  // MATLAB Function: '<S13>/MATLAB Function' incorporates:\n  //   Constant: '<S488>/Constant'\n  //   RelationalOperator: '<S488>/Compare'\n\n  if (FLIGHT_hexacopter_B.rate_transition_ctrl_sw >=\n      FLIGHT_hexacopter_P.CompareToConstant_const) {\n    rtb_Product2_a = FLIGHT_hexacopter_B.RateTransition1;\n  } else {\n    rtb_Product2_a = FLIGHT_hexacopter_B.Sum5_d;\n  }\n\n  // End of MATLAB Function: '<S13>/MATLAB Function'\n\n  // Outputs for Enabled SubSystem: '<Root>/Mixer' incorporates:\n  //   EnablePort: '<S7>/Enable'\n\n  if (FLIGHT_hexacopter_B.rate_transition_arm) {\n    // MATLAB Function: '<S7>/pwm_out2'\n    // Function description:\n    //   Control allocation. The quadrotor type is X-configuration,\n    //   and the airframe is as follows:\n    // 3↓   1↑\n    //   \\ /\n    //   / \\\n    // 2↑   4↓\n    // Input：\n    //   Roll, Pitch, Yaw: attitude controller output.\n    //   Thrust\n    //  M1 = uint16(Thrust*scale + (- Roll + Pitch + Yaw) * scale_att + idle_PWM); \n    //  M2 = uint16(Thrust*scale + (Roll - Pitch + Yaw) * scale_att + idle_PWM); \n    //  M3 = uint16(Thrust*scale + (Roll + Pitch - Yaw) * scale_att + idle_PWM); \n    //  M4 = uint16(Thrust*scale + (- Roll - Pitch - Yaw) * scale_att + idle_PWM); \n    //  Hex X\n    //  M1 = ((Pitch + Roll / 2 - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M2 = ((Pitch - Roll / 2 + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M3 = ((-Roll - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM;\n    //  M4 = ((-Pitch - Roll / 2 + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M5 = ((-Pitch + Roll / 2 - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M6 = ((Roll + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM;\n    //  M7 = 1000;\n    //  M8 = 1000;\n    //  Hex X (From Adam)\n    //  Hex X (Version 2)\n    //  Roll/Yaw\n    //  M1 = ((-Roll - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM;\n    //  M2 = ((Roll + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM;\n    //  % + Pitch/Roll\n    //  M6 = ((Pitch + Roll / 2 - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M4 = ((Pitch - Roll / 2 + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  % - Pitch/Roll\n    //  M5 = ((-Pitch - Roll / 2 + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M3 = ((-Pitch + Roll / 2 - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    rtb_d = rt_roundf_snf(((-rtb_Product2_a - FLIGHT_hexacopter_B.Sum) *\n      FLIGHT_hexacopter_B.rate_transition_throttle / 3.0F +\n      FLIGHT_hexacopter_B.rate_transition_throttle) * 1000.0F);\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S7>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S7>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[0] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[0] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[0] = static_cast<uint16_T>(tmp);\n    }\n\n    // MATLAB Function: '<S7>/pwm_out2'\n    rtb_d = rt_roundf_snf(((rtb_Product2_a + FLIGHT_hexacopter_B.Sum) *\n      FLIGHT_hexacopter_B.rate_transition_throttle / 3.0F +\n      FLIGHT_hexacopter_B.rate_transition_throttle) * 1000.0F);\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S7>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S7>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[1] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[1] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[1] = static_cast<uint16_T>(tmp);\n    }\n\n    // MATLAB Function: '<S7>/pwm_out2'\n    rtb_d = rt_roundf_snf((((rtb_Product2_a / 2.0F + FLIGHT_hexacopter_B.Sum5) -\n      FLIGHT_hexacopter_B.Sum) * FLIGHT_hexacopter_B.rate_transition_throttle /\n      3.0F + FLIGHT_hexacopter_B.rate_transition_throttle) * 1000.0F);\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S7>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S7>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[2] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[2] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[2] = static_cast<uint16_T>(tmp);\n    }\n\n    // MATLAB Function: '<S7>/pwm_out2'\n    rtb_d = rt_roundf_snf((((-FLIGHT_hexacopter_B.Sum5 - rtb_Product2_a / 2.0F)\n      + FLIGHT_hexacopter_B.Sum) * FLIGHT_hexacopter_B.rate_transition_throttle /\n      3.0F + FLIGHT_hexacopter_B.rate_transition_throttle) * 1000.0F);\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S7>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S7>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[3] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[3] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[3] = static_cast<uint16_T>(tmp);\n    }\n\n    // MATLAB Function: '<S7>/pwm_out2'\n    rtb_d = rt_roundf_snf((((FLIGHT_hexacopter_B.Sum5 - rtb_Product2_a / 2.0F) +\n      FLIGHT_hexacopter_B.Sum) * FLIGHT_hexacopter_B.rate_transition_throttle /\n      3.0F + FLIGHT_hexacopter_B.rate_transition_throttle) * 1000.0F);\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S7>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S7>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[4] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[4] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[4] = static_cast<uint16_T>(tmp);\n    }\n\n    // MATLAB Function: '<S7>/pwm_out2'\n    rtb_d = rt_roundf_snf((((rtb_Product2_a / 2.0F - FLIGHT_hexacopter_B.Sum5) -\n      FLIGHT_hexacopter_B.Sum) * FLIGHT_hexacopter_B.rate_transition_throttle /\n      3.0F + FLIGHT_hexacopter_B.rate_transition_throttle) * 1000.0F);\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S7>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S7>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[5] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[5] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[5] = static_cast<uint16_T>(tmp);\n    }\n\n    srUpdateBC(FLIGHT_hexacopter_DW.Mixer_SubsysRanBC);\n  }\n\n  // End of Outputs for SubSystem: '<Root>/Mixer'\n\n  // DataTypeConversion: '<S4>/Data Type Conversion6'\n  for (i = 0; i < 6; i++) {\n    FLIGHT_hexacopter_B.DataTypeConversion6[i] =\n      FLIGHT_hexacopter_B.Output_Limits1[i];\n  }\n\n  // End of DataTypeConversion: '<S4>/Data Type Conversion6'\n\n  // MATLABSystem: '<S4>/Read Parameter13'\n  if (FLIGHT_hexacopter_DW.obj_gv.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_gv.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_gv.MW_PARAMHANDLE,\n    MW_INT32, &i);\n  if (b_varargout_1) {\n    i = 0;\n  }\n\n  // RateTransition: '<Root>/Rate Transition4'\n  if (FLIGHT_hexacopter_M->Timing.RateInteraction.TID0_1) {\n    // RateTransition: '<Root>/Rate Transition4'\n    FLIGHT_hexacopter_B.RateTransition4 =\n      FLIGHT_hexacopter_DW.RateTransition4_Buffer0;\n  }\n\n  // End of RateTransition: '<Root>/Rate Transition4'\n\n  // RelationalOperator: '<S185>/Compare' incorporates:\n  //   Constant: '<S185>/Constant'\n\n  rtb_Compare_a = (FLIGHT_hexacopter_B.RateTransition4 >=\n                   FLIGHT_hexacopter_P.CompareToConstant_const_g);\n\n  // MATLABSystem: '<S4>/Read Parameter1'\n  if (FLIGHT_hexacopter_DW.obj_j5.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_j5.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_j5.MW_PARAMHANDLE,\n    MW_INT32, &FLIGHT_hexacopter_B.ParamStep_cx);\n  if (b_varargout_1) {\n    FLIGHT_hexacopter_B.ParamStep_cx = 0;\n  }\n\n  // MATLABSystem: '<S4>/Read Parameter2'\n  if (FLIGHT_hexacopter_DW.obj_ao.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_ao.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_ao.MW_PARAMHANDLE,\n    MW_INT32, &FLIGHT_hexacopter_B.ParamStep_b);\n  if (b_varargout_1) {\n    FLIGHT_hexacopter_B.ParamStep_b = 0;\n  }\n\n  // MATLABSystem: '<S4>/Read Parameter3'\n  if (FLIGHT_hexacopter_DW.obj_nt.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_nt.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_nt.MW_PARAMHANDLE,\n    MW_INT32, &FLIGHT_hexacopter_B.ParamStep_p);\n  if (b_varargout_1) {\n    FLIGHT_hexacopter_B.ParamStep_p = 0;\n  }\n\n  // MATLABSystem: '<S4>/Read Parameter4'\n  if (FLIGHT_hexacopter_DW.obj_cx.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_cx.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_cx.MW_PARAMHANDLE,\n    MW_INT32, &FLIGHT_hexacopter_B.ParamStep_cv);\n  if (b_varargout_1) {\n    FLIGHT_hexacopter_B.ParamStep_cv = 0;\n  }\n\n  // MATLABSystem: '<S4>/Read Parameter5'\n  if (FLIGHT_hexacopter_DW.obj_aq.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_aq.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_aq.MW_PARAMHANDLE,\n    MW_INT32, &FLIGHT_hexacopter_B.ParamStep_f);\n  if (b_varargout_1) {\n    FLIGHT_hexacopter_B.ParamStep_f = 0;\n  }\n\n  // Switch: '<S4>/Switch' incorporates:\n  //   Constant: '<S4>/Constant'\n  //   DataTypeConversion: '<S4>/Data Type Conversion3'\n  //   MATLABSystem: '<S4>/Read Parameter13'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.u0 = i;\n  } else {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Constant_Value_mc;\n  }\n\n  // Gain: '<S186>/Gain' incorporates:\n  //   Switch: '<S4>/Switch'\n\n  FLIGHT_hexacopter_B.u0 *= FLIGHT_hexacopter_P.Gain_Gain_j;\n\n  // Saturate: '<S186>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S186>/Constant'\n  //   Product: '<S186>/Product'\n  //   Saturate: '<S186>/Saturation'\n  //   Sum: '<S186>/Sum'\n  //   Sum: '<S186>/Sum1'\n\n  FLIGHT_hexacopter_B.u0 = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[0]) -\n    FLIGHT_hexacopter_P.Constant_Value_k) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_k);\n  if (rtIsNaN(FLIGHT_hexacopter_B.u0) || rtIsInf(FLIGHT_hexacopter_B.u0)) {\n    FLIGHT_hexacopter_B.u0 = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.u0 = fmod(FLIGHT_hexacopter_B.u0, 65536.0);\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7'\n  FLIGHT_hexacopter_B.DataTypeConversion7[0] = static_cast<uint16_T>\n    (FLIGHT_hexacopter_B.u0 < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-\n       static_cast<int16_T>(static_cast<uint16_T>(-FLIGHT_hexacopter_B.u0)))) :\n     static_cast<int32_T>(static_cast<uint16_T>(FLIGHT_hexacopter_B.u0)));\n\n  // Switch: '<S4>/Switch1' incorporates:\n  //   Constant: '<S4>/Constant1'\n  //   DataTypeConversion: '<S4>/Data Type Conversion2'\n  //   MATLABSystem: '<S4>/Read Parameter1'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_B.ParamStep_cx;\n  } else {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Constant1_Value;\n  }\n\n  // Gain: '<S187>/Gain' incorporates:\n  //   Switch: '<S4>/Switch1'\n\n  FLIGHT_hexacopter_B.u0 *= FLIGHT_hexacopter_P.Gain_Gain_h;\n\n  // Saturate: '<S187>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat_m) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat_m;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat_o)\n  {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat_o;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S187>/Constant'\n  //   Product: '<S187>/Product'\n  //   Saturate: '<S187>/Saturation'\n  //   Sum: '<S187>/Sum'\n  //   Sum: '<S187>/Sum1'\n\n  FLIGHT_hexacopter_B.u0 = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[1]) -\n    FLIGHT_hexacopter_P.Constant_Value_ms) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_ms);\n  if (rtIsNaN(FLIGHT_hexacopter_B.u0) || rtIsInf(FLIGHT_hexacopter_B.u0)) {\n    FLIGHT_hexacopter_B.u0 = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.u0 = fmod(FLIGHT_hexacopter_B.u0, 65536.0);\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7'\n  FLIGHT_hexacopter_B.DataTypeConversion7[1] = static_cast<uint16_T>\n    (FLIGHT_hexacopter_B.u0 < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-\n       static_cast<int16_T>(static_cast<uint16_T>(-FLIGHT_hexacopter_B.u0)))) :\n     static_cast<int32_T>(static_cast<uint16_T>(FLIGHT_hexacopter_B.u0)));\n\n  // Switch: '<S4>/Switch2' incorporates:\n  //   Constant: '<S4>/Constant2'\n  //   DataTypeConversion: '<S4>/Data Type Conversion'\n  //   MATLABSystem: '<S4>/Read Parameter2'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_B.ParamStep_b;\n  } else {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Constant2_Value;\n  }\n\n  // Gain: '<S188>/Gain' incorporates:\n  //   Switch: '<S4>/Switch2'\n\n  FLIGHT_hexacopter_B.u0 *= FLIGHT_hexacopter_P.Gain_Gain_c;\n\n  // Saturate: '<S188>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat_b) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat_b;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat_g)\n  {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat_g;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S188>/Constant'\n  //   Product: '<S188>/Product'\n  //   Saturate: '<S188>/Saturation'\n  //   Sum: '<S188>/Sum'\n  //   Sum: '<S188>/Sum1'\n\n  FLIGHT_hexacopter_B.u0 = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[2]) -\n    FLIGHT_hexacopter_P.Constant_Value_i) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_i);\n  if (rtIsNaN(FLIGHT_hexacopter_B.u0) || rtIsInf(FLIGHT_hexacopter_B.u0)) {\n    FLIGHT_hexacopter_B.u0 = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.u0 = fmod(FLIGHT_hexacopter_B.u0, 65536.0);\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7'\n  FLIGHT_hexacopter_B.DataTypeConversion7[2] = static_cast<uint16_T>\n    (FLIGHT_hexacopter_B.u0 < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-\n       static_cast<int16_T>(static_cast<uint16_T>(-FLIGHT_hexacopter_B.u0)))) :\n     static_cast<int32_T>(static_cast<uint16_T>(FLIGHT_hexacopter_B.u0)));\n\n  // Switch: '<S4>/Switch3' incorporates:\n  //   Constant: '<S4>/Constant3'\n  //   DataTypeConversion: '<S4>/Data Type Conversion4'\n  //   MATLABSystem: '<S4>/Read Parameter3'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_B.ParamStep_p;\n  } else {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Constant3_Value;\n  }\n\n  // Gain: '<S189>/Gain' incorporates:\n  //   Switch: '<S4>/Switch3'\n\n  FLIGHT_hexacopter_B.u0 *= FLIGHT_hexacopter_P.Gain_Gain_n;\n\n  // Saturate: '<S189>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat_be) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat_be;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat_e)\n  {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat_e;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S189>/Constant'\n  //   Product: '<S189>/Product'\n  //   Saturate: '<S189>/Saturation'\n  //   Sum: '<S189>/Sum'\n  //   Sum: '<S189>/Sum1'\n\n  FLIGHT_hexacopter_B.u0 = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[3]) -\n    FLIGHT_hexacopter_P.Constant_Value_j) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_j);\n  if (rtIsNaN(FLIGHT_hexacopter_B.u0) || rtIsInf(FLIGHT_hexacopter_B.u0)) {\n    FLIGHT_hexacopter_B.u0 = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.u0 = fmod(FLIGHT_hexacopter_B.u0, 65536.0);\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7'\n  FLIGHT_hexacopter_B.DataTypeConversion7[3] = static_cast<uint16_T>\n    (FLIGHT_hexacopter_B.u0 < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-\n       static_cast<int16_T>(static_cast<uint16_T>(-FLIGHT_hexacopter_B.u0)))) :\n     static_cast<int32_T>(static_cast<uint16_T>(FLIGHT_hexacopter_B.u0)));\n\n  // Switch: '<S4>/Switch4' incorporates:\n  //   Constant: '<S4>/Constant4'\n  //   DataTypeConversion: '<S4>/Data Type Conversion1'\n  //   MATLABSystem: '<S4>/Read Parameter4'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_B.ParamStep_cv;\n  } else {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Constant4_Value;\n  }\n\n  // Gain: '<S190>/Gain' incorporates:\n  //   Switch: '<S4>/Switch4'\n\n  FLIGHT_hexacopter_B.u0 *= FLIGHT_hexacopter_P.Gain_Gain_f;\n\n  // Saturate: '<S190>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat_d) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat_d;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat_l)\n  {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat_l;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S190>/Constant'\n  //   Product: '<S190>/Product'\n  //   Saturate: '<S190>/Saturation'\n  //   Sum: '<S190>/Sum'\n  //   Sum: '<S190>/Sum1'\n\n  FLIGHT_hexacopter_B.u0 = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[4]) -\n    FLIGHT_hexacopter_P.Constant_Value_lw) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_lw);\n  if (rtIsNaN(FLIGHT_hexacopter_B.u0) || rtIsInf(FLIGHT_hexacopter_B.u0)) {\n    FLIGHT_hexacopter_B.u0 = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.u0 = fmod(FLIGHT_hexacopter_B.u0, 65536.0);\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7'\n  FLIGHT_hexacopter_B.DataTypeConversion7[4] = static_cast<uint16_T>\n    (FLIGHT_hexacopter_B.u0 < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-\n       static_cast<int16_T>(static_cast<uint16_T>(-FLIGHT_hexacopter_B.u0)))) :\n     static_cast<int32_T>(static_cast<uint16_T>(FLIGHT_hexacopter_B.u0)));\n\n  // Switch: '<S4>/Switch5' incorporates:\n  //   Constant: '<S4>/Constant5'\n  //   DataTypeConversion: '<S4>/Data Type Conversion5'\n  //   MATLABSystem: '<S4>/Read Parameter5'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_B.ParamStep_f;\n  } else {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Constant5_Value;\n  }\n\n  // Gain: '<S191>/Gain' incorporates:\n  //   Switch: '<S4>/Switch5'\n\n  FLIGHT_hexacopter_B.u0 *= FLIGHT_hexacopter_P.Gain_Gain_m;\n\n  // Saturate: '<S191>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat_i) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat_i;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat_n)\n  {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat_n;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S191>/Constant'\n  //   Product: '<S191>/Product'\n  //   Saturate: '<S191>/Saturation'\n  //   Sum: '<S191>/Sum'\n  //   Sum: '<S191>/Sum1'\n\n  FLIGHT_hexacopter_B.u0 = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[5]) -\n    FLIGHT_hexacopter_P.Constant_Value_ox) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_ox);\n  if (rtIsNaN(FLIGHT_hexacopter_B.u0) || rtIsInf(FLIGHT_hexacopter_B.u0)) {\n    FLIGHT_hexacopter_B.u0 = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.u0 = fmod(FLIGHT_hexacopter_B.u0, 65536.0);\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7'\n  FLIGHT_hexacopter_B.DataTypeConversion7[5] = static_cast<uint16_T>\n    (FLIGHT_hexacopter_B.u0 < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-\n       static_cast<int16_T>(static_cast<uint16_T>(-FLIGHT_hexacopter_B.u0)))) :\n     static_cast<int32_T>(static_cast<uint16_T>(FLIGHT_hexacopter_B.u0)));\n\n  // RateTransition: '<Root>/Rate Transition7'\n  if (FLIGHT_hexacopter_M->Timing.RateInteraction.TID0_1) {\n    // RateTransition: '<Root>/Rate Transition7'\n    FLIGHT_hexacopter_B.RateTransition7 =\n      FLIGHT_hexacopter_DW.RateTransition7_Buffer0;\n  }\n\n  // End of RateTransition: '<Root>/Rate Transition7'\n\n  // MATLABSystem: '<Root>/PX4 PWM Output'\n  for (i = 0; i < 8; i++) {\n    FLIGHT_hexacopter_B.pwmValue[i] = 0U;\n  }\n\n  FLIGHT_hexacopter_B.pwmValue[0] = FLIGHT_hexacopter_B.DataTypeConversion7[0];\n  FLIGHT_hexacopter_B.pwmValue[1] = FLIGHT_hexacopter_B.DataTypeConversion7[1];\n  FLIGHT_hexacopter_B.pwmValue[2] = FLIGHT_hexacopter_B.DataTypeConversion7[2];\n  FLIGHT_hexacopter_B.pwmValue[3] = FLIGHT_hexacopter_B.DataTypeConversion7[3];\n  FLIGHT_hexacopter_B.pwmValue[4] = FLIGHT_hexacopter_B.DataTypeConversion7[4];\n  FLIGHT_hexacopter_B.pwmValue[5] = FLIGHT_hexacopter_B.DataTypeConversion7[5];\n  if (FLIGHT_hexacopter_B.rate_transition_arm) {\n    if (!FLIGHT_hexacopter_DW.obj_dl.isArmed) {\n      FLIGHT_hexacopter_DW.obj_dl.isArmed = true;\n      pwm_arm(&FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n    }\n\n    pwm_setServo(FLIGHT_hexacopter_DW.obj_dl.servoCount,\n                 FLIGHT_hexacopter_DW.obj_dl.channelMask,\n                 &FLIGHT_hexacopter_B.pwmValue[0],\n                 FLIGHT_hexacopter_DW.obj_dl.isMain,\n                 &FLIGHT_hexacopter_DW.obj_dl.actuatorAdvertiseObj);\n  } else {\n    pwm_disarm(&FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n    FLIGHT_hexacopter_DW.obj_dl.isArmed = false;\n    pwm_resetServo(FLIGHT_hexacopter_DW.obj_dl.servoCount,\n                   FLIGHT_hexacopter_DW.obj_dl.isMain,\n                   &FLIGHT_hexacopter_DW.obj_dl.actuatorAdvertiseObj);\n  }\n\n  if (FLIGHT_hexacopter_DW.obj_dl.isMain) {\n    if (FLIGHT_hexacopter_B.RateTransition7) {\n      pwm_disarm(&FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n    } else {\n      pwm_arm(&FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n    }\n  }\n\n  // End of MATLABSystem: '<Root>/PX4 PWM Output'\n  FLIGHT_hexac_PX4Timestamp_o(&FLIGHT_hexacopter_B.PX4Timestamp_n);\n  FLIGHT_hexac_PX4Timestamp_o(&FLIGHT_hexacopter_B.PX4Timestamp_p);\n\n  // BusAssignment: '<S494>/Bus Assignment' incorporates:\n  //   Constant: '<S493>/Constant'\n  //   Gain: '<S493>/Gain'\n  //   MATLABSystem: '<S15>/PX4 Timestamp'\n  //   MATLABSystem: '<S494>/PX4 Timestamp'\n  //   Saturate: '<S493>/Saturation'\n  //   Sum: '<S493>/Subtract'\n\n  FLIGHT_hexacopter_B.BusAssignment.timestamp =\n    FLIGHT_hexacopter_B.PX4Timestamp_n.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment.timestamp_sample =\n    FLIGHT_hexacopter_B.PX4Timestamp_p.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment.reversible_flags = 0U;\n  for (i = 0; i < 6; i++) {\n    // DataTypeConversion: '<Root>/Data Type Conversion'\n    FLIGHT_hexacopter_B.ParamStep_cx = FLIGHT_hexacopter_B.Output_Limits1[i];\n\n    // Saturate: '<S493>/Saturation'\n    if (FLIGHT_hexacopter_B.ParamStep_cx >\n        FLIGHT_hexacopter_P.Saturation_UpperSat_ep) {\n      rtb_d = FLIGHT_hexacopter_P.Saturation_UpperSat_ep;\n    } else if (FLIGHT_hexacopter_B.ParamStep_cx <\n               FLIGHT_hexacopter_P.Saturation_LowerSat_p) {\n      rtb_d = FLIGHT_hexacopter_P.Saturation_LowerSat_p;\n    } else {\n      rtb_d = static_cast<real32_T>(FLIGHT_hexacopter_B.ParamStep_cx);\n    }\n\n    FLIGHT_hexacopter_B.BusAssignment.control[i] = (rtb_d -\n      FLIGHT_hexacopter_P.Constant_Value_e) * FLIGHT_hexacopter_P.Gain_Gain_mg;\n\n    // Saturate: '<S493>/Saturation' incorporates:\n    //   Constant: '<S15>/Constant1'\n    //   Constant: '<S493>/Constant'\n    //   Gain: '<S493>/Gain'\n    //   Sum: '<S493>/Subtract'\n\n    rtb_Product2_a = FLIGHT_hexacopter_P.Constant1_Value_i[i];\n    if (rtb_Product2_a > FLIGHT_hexacopter_P.Saturation_UpperSat_ep) {\n      rtb_Product2_a = FLIGHT_hexacopter_P.Saturation_UpperSat_ep;\n    } else if (rtb_Product2_a < FLIGHT_hexacopter_P.Saturation_LowerSat_p) {\n      rtb_Product2_a = FLIGHT_hexacopter_P.Saturation_LowerSat_p;\n    }\n\n    FLIGHT_hexacopter_B.BusAssignment.control[i + 6] = (rtb_Product2_a -\n      FLIGHT_hexacopter_P.Constant_Value_e) * FLIGHT_hexacopter_P.Gain_Gain_mg;\n    FLIGHT_hexacopter_B.BusAssignment._padding0[i] = 0U;\n  }\n\n  // End of BusAssignment: '<S494>/Bus Assignment'\n\n  // MATLABSystem: '<S496>/SinkBlock' incorporates:\n  //   BusAssignment: '<S494>/Bus Assignment'\n\n  uORB_write_step(FLIGHT_hexacopter_DW.obj_hf.orbMetadataObj,\n                  &FLIGHT_hexacopter_DW.obj_hf.orbAdvertiseObj,\n                  &FLIGHT_hexacopter_B.BusAssignment);\n  FLIGHT_hexac_PX4Timestamp_o(&FLIGHT_hexacopter_B.PX4Timestamp_o);\n\n  // BusAssignment: '<S490>/Bus Assignment' incorporates:\n  //   MATLABSystem: '<S490>/PX4 Timestamp'\n\n  FLIGHT_hexacopter_B.BusAssignment_gi.timestamp =\n    FLIGHT_hexacopter_B.PX4Timestamp_o.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment_gi.control_power[0] = 0.0F;\n  FLIGHT_hexacopter_B.BusAssignment_gi.control_power[1] =\n    FLIGHT_hexacopter_B.Sum5;\n  FLIGHT_hexacopter_B.BusAssignment_gi.control_power[2] =\n    FLIGHT_hexacopter_B.Sum;\n  FLIGHT_hexacopter_B.BusAssignment_gi._padding0[0] = 0U;\n  FLIGHT_hexacopter_B.BusAssignment_gi._padding0[1] = 0U;\n  FLIGHT_hexacopter_B.BusAssignment_gi._padding0[2] = 0U;\n  FLIGHT_hexacopter_B.BusAssignment_gi._padding0[3] = 0U;\n\n  // MATLABSystem: '<S492>/SinkBlock' incorporates:\n  //   BusAssignment: '<S490>/Bus Assignment'\n\n  uORB_write_step(FLIGHT_hexacopter_DW.obj_jk.orbMetadataObj,\n                  &FLIGHT_hexacopter_DW.obj_jk.orbAdvertiseObj,\n                  &FLIGHT_hexacopter_B.BusAssignment_gi);\n\n  // RateTransition: '<Root>/Rate Transition'\n  if (FLIGHT_hexacopter_M->Timing.RateInteraction.TID0_1) {\n    FLIGHT_hexacopter_DW.RateTransition_Buffer[0] =\n      FLIGHT_hexacopter_B.In1_h.xyz[0];\n    FLIGHT_hexacopter_DW.RateTransition_Buffer[1] =\n      FLIGHT_hexacopter_B.In1_h.xyz[1];\n    FLIGHT_hexacopter_DW.RateTransition_Buffer[2] =\n      FLIGHT_hexacopter_B.In1_h.xyz[2];\n  }\n\n  // End of RateTransition: '<Root>/Rate Transition'\n\n  // Update absolute time\n  // The \"clockTick0\" counts the number of times the code of this task has\n  //  been executed. The absolute time is the multiplication of \"clockTick0\"\n  //  and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\n  //  overflow during the application lifespan selected.\n\n  FLIGHT_hexacopter_M->Timing.taskTime0 =\n    ((time_T)(++FLIGHT_hexacopter_M->Timing.clockTick0)) *\n    FLIGHT_hexacopter_M->Timing.stepSize0;\n}\n\n// Model step function for TID1\nvoid FLIGHT_hexacopter_step1(void)     // Sample time: [0.004s, 0.0s]\n{\n  int32_T i;\n  real32_T rtb_DeadZone;\n  real32_T rtb_Diff_c;\n  real32_T rtb_PProdOut_ev_idx_0;\n  real32_T rtb_PProdOut_ev_idx_1;\n  real32_T rtb_Product5_m;\n  real32_T rtb_Saturation1;\n  real32_T rtb_SinCos_o2;\n  real32_T rtb_TmpSignalConversionAtSFun_0;\n  real32_T rtb_TmpSignalConversionAtSFun_1;\n  real32_T rtb_des_x;\n  real32_T rtb_des_z;\n  int8_T tmp;\n  int8_T tmp_0;\n  boolean_T exitg1;\n  boolean_T flag_pos;\n  boolean_T guard1;\n  boolean_T rtb_NOT;\n  boolean_T rtb_NOT_h;\n\n  // Reset subsysRan breadcrumbs\n  srClearBC(FLIGHT_hexacopter_DW.CAS_SubsysRanBC);\n\n  // Reset subsysRan breadcrumbs\n  srClearBC(FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC_k);\n\n  // Reset subsysRan breadcrumbs\n  srClearBC(FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC_l);\n\n  // Reset subsysRan breadcrumbs\n  srClearBC(FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC_o);\n\n  // Reset subsysRan breadcrumbs\n  srClearBC(FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC_j);\n\n  // Reset subsysRan breadcrumbs\n  srClearBC(FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC);\n\n  // MATLABSystem: '<S306>/SourceBlock'\n  flag_pos = uORB_read_step(FLIGHT_hexacopter_DW.obj_n2.orbMetadataObj,\n    &FLIGHT_hexacopter_DW.obj_n2.eventStructObj, &FLIGHT_hexacopter_B.r2, false,\n    1.0);\n\n  // Outputs for Enabled SubSystem: '<S306>/Enabled Subsystem' incorporates:\n  //   EnablePort: '<S307>/Enable'\n\n  // Start for MATLABSystem: '<S306>/SourceBlock'\n  if (flag_pos) {\n    // SignalConversion generated from: '<S307>/In1'\n    FLIGHT_hexacopter_B.In1_i = FLIGHT_hexacopter_B.r2;\n    srUpdateBC(FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC_o);\n  }\n\n  // End of Outputs for SubSystem: '<S306>/Enabled Subsystem'\n  for (i = 0; i < 18; i++) {\n    // SignalConversion generated from: '<S9>/Bus Selector'\n    FLIGHT_hexacopter_B.values[i] = FLIGHT_hexacopter_B.In1_i.values[i];\n  }\n\n  // RateTransition: '<Root>/Rate Transition4'\n  FLIGHT_hexacopter_DW.RateTransition4_Buffer0 = FLIGHT_hexacopter_B.values[7];\n\n  // RateTransition: '<Root>/rate_transition_ctrl_sw'\n  FLIGHT_hexacopter_DW.rate_transition_ctrl_sw_Buffer0 =\n    FLIGHT_hexacopter_B.values[9];\n\n  // MATLABSystem: '<S304>/SourceBlock'\n  flag_pos = uORB_read_step(FLIGHT_hexacopter_DW.obj_ab.orbMetadataObj,\n    &FLIGHT_hexacopter_DW.obj_ab.eventStructObj, &FLIGHT_hexacopter_B.r1, false,\n    1.0);\n\n  // Outputs for Enabled SubSystem: '<S304>/Enabled Subsystem' incorporates:\n  //   EnablePort: '<S305>/Enable'\n\n  // Start for MATLABSystem: '<S304>/SourceBlock'\n  if (flag_pos) {\n    // SignalConversion generated from: '<S305>/In1'\n    FLIGHT_hexacopter_B.In1_k = FLIGHT_hexacopter_B.r1;\n    srUpdateBC(FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC_l);\n  }\n\n  // End of Outputs for SubSystem: '<S304>/Enabled Subsystem'\n\n  // MATLAB Function: '<Root>/quat2eul'\n  //  Quaternion conversion to Euler angles based on the PX4 Firmware v1.10.2\n  //  release.\n  FLIGHT_hexacopter_B.ypr[1] = static_cast<real32_T>(asin(static_cast<real_T>\n    ((FLIGHT_hexacopter_B.In1_k.q[1] * FLIGHT_hexacopter_B.In1_k.q[3] -\n      FLIGHT_hexacopter_B.In1_k.q[0] * FLIGHT_hexacopter_B.In1_k.q[2]) * -2.0F)));\n  FLIGHT_hexacopter_B.ypr[2] = rt_atan2f_snf((FLIGHT_hexacopter_B.In1_k.q[0] *\n    FLIGHT_hexacopter_B.In1_k.q[1] + FLIGHT_hexacopter_B.In1_k.q[2] *\n    FLIGHT_hexacopter_B.In1_k.q[3]) * 2.0F, ((FLIGHT_hexacopter_B.In1_k.q[0] *\n    FLIGHT_hexacopter_B.In1_k.q[0] - FLIGHT_hexacopter_B.In1_k.q[1] *\n    FLIGHT_hexacopter_B.In1_k.q[1]) - FLIGHT_hexacopter_B.In1_k.q[2] *\n    FLIGHT_hexacopter_B.In1_k.q[2]) + FLIGHT_hexacopter_B.In1_k.q[3] *\n    FLIGHT_hexacopter_B.In1_k.q[3]);\n\n  // MATLABSystem: '<S500>/SourceBlock'\n  flag_pos = uORB_read_step(FLIGHT_hexacopter_DW.obj_hm.orbMetadataObj,\n    &FLIGHT_hexacopter_DW.obj_hm.eventStructObj, &FLIGHT_hexacopter_B.r5, false,\n    1.0);\n\n  // Outputs for Enabled SubSystem: '<S500>/Enabled Subsystem' incorporates:\n  //   EnablePort: '<S502>/Enable'\n\n  // Start for MATLABSystem: '<S500>/SourceBlock'\n  if (flag_pos) {\n    // SignalConversion generated from: '<S502>/In1'\n    FLIGHT_hexacopter_B.In1_n = FLIGHT_hexacopter_B.r5;\n    srUpdateBC(FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC_j);\n  }\n\n  // End of Outputs for SubSystem: '<S500>/Enabled Subsystem'\n\n  // Outputs for Atomic SubSystem: '<Root>/Stabilized_Mode'\n  // Gain: '<S12>/Gain1' incorporates:\n  //   Constant: '<S12>/Constant2'\n  //   Sum: '<S12>/Sum2'\n\n  FLIGHT_hexacopter_B.Product5_l = (static_cast<real32_T>\n    (FLIGHT_hexacopter_B.values[1]) - FLIGHT_hexacopter_P.Constant2_Value_i) *\n    FLIGHT_hexacopter_P.Gain1_Gain_m;\n\n  // DeadZone: '<S12>/Dead Zone1'\n  if (FLIGHT_hexacopter_B.Product5_l > FLIGHT_hexacopter_P.DeadZone1_End_m) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_B.Product5_l -\n      FLIGHT_hexacopter_P.DeadZone1_End_m;\n  } else if (FLIGHT_hexacopter_B.Product5_l >=\n             FLIGHT_hexacopter_P.DeadZone1_Start_c) {\n    rtb_SinCos_o2 = 0.0F;\n  } else {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_B.Product5_l -\n      FLIGHT_hexacopter_P.DeadZone1_Start_c;\n  }\n\n  // End of DeadZone: '<S12>/Dead Zone1'\n\n  // Saturate: '<S12>/Saturation2'\n  if (rtb_SinCos_o2 > FLIGHT_hexacopter_P.Saturation2_UpperSat) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation2_UpperSat;\n  } else if (rtb_SinCos_o2 < FLIGHT_hexacopter_P.Saturation2_LowerSat) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation2_LowerSat;\n  }\n\n  // Gain: '<S12>/Gain5' incorporates:\n  //   Saturate: '<S12>/Saturation2'\n\n  FLIGHT_hexacopter_B.Gain5 = FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_PITCH *\n    rtb_SinCos_o2;\n\n  // Gain: '<S12>/Gain2' incorporates:\n  //   Constant: '<S12>/Constant1'\n  //   Sum: '<S12>/Sum1'\n\n  FLIGHT_hexacopter_B.Product5_l = (static_cast<real32_T>\n    (FLIGHT_hexacopter_B.values[3]) - FLIGHT_hexacopter_P.Constant1_Value_l) *\n    FLIGHT_hexacopter_P.Gain2_Gain_a;\n\n  // DeadZone: '<S12>/Dead Zone2'\n  if (FLIGHT_hexacopter_B.Product5_l > FLIGHT_hexacopter_P.DeadZone2_End_e) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_B.Product5_l -\n      FLIGHT_hexacopter_P.DeadZone2_End_e;\n  } else if (FLIGHT_hexacopter_B.Product5_l >=\n             FLIGHT_hexacopter_P.DeadZone2_Start_o) {\n    rtb_SinCos_o2 = 0.0F;\n  } else {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_B.Product5_l -\n      FLIGHT_hexacopter_P.DeadZone2_Start_o;\n  }\n\n  // End of DeadZone: '<S12>/Dead Zone2'\n\n  // Saturate: '<S12>/Saturation1'\n  if (rtb_SinCos_o2 > FLIGHT_hexacopter_P.Saturation1_UpperSat_l) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation1_UpperSat_l;\n  } else if (rtb_SinCos_o2 < FLIGHT_hexacopter_P.Saturation1_LowerSat_i) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation1_LowerSat_i;\n  }\n\n  // Gain: '<S12>/Gain6' incorporates:\n  //   Saturate: '<S12>/Saturation1'\n\n  FLIGHT_hexacopter_B.Gain6 = FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_RATE_Y *\n    rtb_SinCos_o2;\n\n  // Gain: '<S12>/Gain' incorporates:\n  //   Constant: '<S12>/Constant'\n  //   Sum: '<S12>/Sum'\n\n  FLIGHT_hexacopter_B.Product5_l = static_cast<real32_T>((static_cast<real_T>\n    (FLIGHT_hexacopter_B.values[2]) - FLIGHT_hexacopter_P.Constant_Value_c) *\n    FLIGHT_hexacopter_P.Gain_Gain);\n\n  // DeadZone: '<S12>/Dead Zone3'\n  if (FLIGHT_hexacopter_B.Product5_l > FLIGHT_hexacopter_P.DeadZone3_End_l) {\n    FLIGHT_hexacopter_B.Saturation = FLIGHT_hexacopter_B.Product5_l -\n      FLIGHT_hexacopter_P.DeadZone3_End_l;\n  } else if (FLIGHT_hexacopter_B.Product5_l >=\n             FLIGHT_hexacopter_P.DeadZone3_Start_p) {\n    FLIGHT_hexacopter_B.Saturation = 0.0F;\n  } else {\n    FLIGHT_hexacopter_B.Saturation = FLIGHT_hexacopter_B.Product5_l -\n      FLIGHT_hexacopter_P.DeadZone3_Start_p;\n  }\n\n  // Saturate: '<S12>/Saturation'\n  if (FLIGHT_hexacopter_B.Saturation > FLIGHT_hexacopter_P.Saturation_UpperSat_o)\n  {\n    // DeadZone: '<S12>/Dead Zone3' incorporates:\n    //   Saturate: '<S12>/Saturation'\n\n    FLIGHT_hexacopter_B.Saturation = FLIGHT_hexacopter_P.Saturation_UpperSat_o;\n  } else if (FLIGHT_hexacopter_B.Saturation <\n             FLIGHT_hexacopter_P.Saturation_LowerSat_el) {\n    // DeadZone: '<S12>/Dead Zone3' incorporates:\n    //   Saturate: '<S12>/Saturation'\n\n    FLIGHT_hexacopter_B.Saturation = FLIGHT_hexacopter_P.Saturation_LowerSat_el;\n  }\n\n  // End of Saturate: '<S12>/Saturation'\n  // Gain: '<S12>/Gain3' incorporates:\n  //   Constant: '<S12>/Constant3'\n  //   Sum: '<S12>/Sum3'\n\n  FLIGHT_hexacopter_B.Product5_l = (static_cast<real32_T>\n    (FLIGHT_hexacopter_B.values[0]) - FLIGHT_hexacopter_P.Constant3_Value_e) *\n    FLIGHT_hexacopter_P.Gain3_Gain;\n\n  // DeadZone: '<S12>/Dead Zone'\n  if (FLIGHT_hexacopter_B.Product5_l > FLIGHT_hexacopter_P.DeadZone_End) {\n    rtb_Product5_m = FLIGHT_hexacopter_B.Product5_l -\n      FLIGHT_hexacopter_P.DeadZone_End;\n  } else if (FLIGHT_hexacopter_B.Product5_l >=\n             FLIGHT_hexacopter_P.DeadZone_Start) {\n    rtb_Product5_m = 0.0F;\n  } else {\n    rtb_Product5_m = FLIGHT_hexacopter_B.Product5_l -\n      FLIGHT_hexacopter_P.DeadZone_Start;\n  }\n\n  // End of DeadZone: '<S12>/Dead Zone'\n  // Outputs for Atomic SubSystem: '<Root>/If Action Subsystem'\n  // Fcn: '<S22>/Fcn2' incorporates:\n  //   DataTypeConversion: '<S22>/Data Type Conversion1'\n  //   Fcn: '<S192>/Fcn2'\n\n  FLIGHT_hexacopter_B.ParamStep_c = (static_cast<real32_T>\n    (FLIGHT_hexacopter_B.values[0]) - 1514.0F) / 500.0F;\n\n  // End of Outputs for SubSystem: '<Root>/If Action Subsystem'\n\n  // DeadZone: '<S22>/Dead Zone3' incorporates:\n  //   Fcn: '<S22>/Fcn2'\n\n  if (FLIGHT_hexacopter_B.ParamStep_c > FLIGHT_hexacopter_P.DeadZone3_End_n) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_B.ParamStep_c -\n      FLIGHT_hexacopter_P.DeadZone3_End_n;\n  } else if (FLIGHT_hexacopter_B.ParamStep_c >=\n             FLIGHT_hexacopter_P.DeadZone3_Start_l) {\n    rtb_SinCos_o2 = 0.0F;\n  } else {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_B.ParamStep_c -\n      FLIGHT_hexacopter_P.DeadZone3_Start_l;\n  }\n\n  // End of DeadZone: '<S22>/Dead Zone3'\n\n  // Saturate: '<S22>/Saturation9'\n  if (rtb_SinCos_o2 > FLIGHT_hexacopter_P.Saturation9_UpperSat_c) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation9_UpperSat_c;\n  } else if (rtb_SinCos_o2 < FLIGHT_hexacopter_P.Saturation9_LowerSat_i) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation9_LowerSat_i;\n  }\n\n  // Gain: '<S22>/Gain1' incorporates:\n  //   Saturate: '<S22>/Saturation9'\n\n  FLIGHT_hexacopter_B.Gain1 = FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_ROLL *\n    rtb_SinCos_o2;\n\n  // Outputs for Atomic SubSystem: '<Root>/If Action Subsystem'\n  // Fcn: '<S22>/Fcn1' incorporates:\n  //   DataTypeConversion: '<S22>/Data Type Conversion2'\n  //   Fcn: '<S192>/Fcn1'\n\n  rtb_Diff_c = (static_cast<real32_T>(FLIGHT_hexacopter_B.values[1]) - 1514.0F) /\n    500.0F;\n\n  // End of Outputs for SubSystem: '<Root>/If Action Subsystem'\n\n  // DeadZone: '<S22>/Dead Zone1' incorporates:\n  //   Fcn: '<S22>/Fcn1'\n\n  if (rtb_Diff_c > FLIGHT_hexacopter_P.DeadZone1_End_mj) {\n    rtb_SinCos_o2 = rtb_Diff_c - FLIGHT_hexacopter_P.DeadZone1_End_mj;\n  } else if (rtb_Diff_c >= FLIGHT_hexacopter_P.DeadZone1_Start_n) {\n    rtb_SinCos_o2 = 0.0F;\n  } else {\n    rtb_SinCos_o2 = rtb_Diff_c - FLIGHT_hexacopter_P.DeadZone1_Start_n;\n  }\n\n  // End of DeadZone: '<S22>/Dead Zone1'\n\n  // Saturate: '<S22>/Saturation1'\n  if (rtb_SinCos_o2 > FLIGHT_hexacopter_P.Saturation1_UpperSat_d) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation1_UpperSat_d;\n  } else if (rtb_SinCos_o2 < FLIGHT_hexacopter_P.Saturation1_LowerSat_b) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation1_LowerSat_b;\n  }\n\n  // Gain: '<S22>/Gain2' incorporates:\n  //   Saturate: '<S22>/Saturation1'\n\n  FLIGHT_hexacopter_B.Gain2 = FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_PITCH *\n    rtb_SinCos_o2;\n\n  // Outputs for Atomic SubSystem: '<Root>/If Action Subsystem'\n  // Fcn: '<S22>/Fcn7' incorporates:\n  //   DataTypeConversion: '<S22>/Data Type Conversion10'\n  //   Fcn: '<S192>/Fcn7'\n\n  rtb_TmpSignalConversionAtSFun_0 = (static_cast<real32_T>\n    (FLIGHT_hexacopter_B.values[3]) - 1514.0F) / 500.0F;\n\n  // End of Outputs for SubSystem: '<Root>/If Action Subsystem'\n\n  // DeadZone: '<S22>/Dead Zone2' incorporates:\n  //   Fcn: '<S22>/Fcn7'\n\n  if (rtb_TmpSignalConversionAtSFun_0 > FLIGHT_hexacopter_P.DeadZone2_End_b) {\n    rtb_SinCos_o2 = rtb_TmpSignalConversionAtSFun_0 -\n      FLIGHT_hexacopter_P.DeadZone2_End_b;\n  } else if (rtb_TmpSignalConversionAtSFun_0 >=\n             FLIGHT_hexacopter_P.DeadZone2_Start_m) {\n    rtb_SinCos_o2 = 0.0F;\n  } else {\n    rtb_SinCos_o2 = rtb_TmpSignalConversionAtSFun_0 -\n      FLIGHT_hexacopter_P.DeadZone2_Start_m;\n  }\n\n  // End of DeadZone: '<S22>/Dead Zone2'\n\n  // Saturate: '<S22>/Saturation3'\n  if (rtb_SinCos_o2 > FLIGHT_hexacopter_P.Saturation3_UpperSat_d) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation3_UpperSat_d;\n  } else if (rtb_SinCos_o2 < FLIGHT_hexacopter_P.Saturation3_LowerSat_n) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation3_LowerSat_n;\n  }\n\n  // Gain: '<S22>/Gain3' incorporates:\n  //   Saturate: '<S22>/Saturation3'\n\n  FLIGHT_hexacopter_B.Gain3 = FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_RATE_Y *\n    rtb_SinCos_o2;\n\n  // Outputs for Atomic SubSystem: '<Root>/If Action Subsystem'\n  // Fcn: '<S22>/Fcn3' incorporates:\n  //   DataTypeConversion: '<S22>/Data Type Conversion11'\n  //   Fcn: '<S192>/Fcn3'\n\n  rtb_TmpSignalConversionAtSFun_1 = (static_cast<real32_T>\n    (FLIGHT_hexacopter_B.values[2]) - 1514.0F) / 500.0F;\n\n  // End of Outputs for SubSystem: '<Root>/If Action Subsystem'\n\n  // DeadZone: '<S22>/Dead Zone4' incorporates:\n  //   Fcn: '<S22>/Fcn3'\n\n  if (rtb_TmpSignalConversionAtSFun_1 > FLIGHT_hexacopter_P.DeadZone4_End_a) {\n    rtb_SinCos_o2 = rtb_TmpSignalConversionAtSFun_1 -\n      FLIGHT_hexacopter_P.DeadZone4_End_a;\n  } else if (rtb_TmpSignalConversionAtSFun_1 >=\n             FLIGHT_hexacopter_P.DeadZone4_Start_o) {\n    rtb_SinCos_o2 = 0.0F;\n  } else {\n    rtb_SinCos_o2 = rtb_TmpSignalConversionAtSFun_1 -\n      FLIGHT_hexacopter_P.DeadZone4_Start_o;\n  }\n\n  // End of DeadZone: '<S22>/Dead Zone4'\n\n  // Saturate: '<S22>/Saturation10'\n  if (rtb_SinCos_o2 > FLIGHT_hexacopter_P.Saturation10_UpperSat_g) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation10_UpperSat_g;\n  } else if (rtb_SinCos_o2 < FLIGHT_hexacopter_P.Saturation10_LowerSat_f) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation10_LowerSat_f;\n  }\n\n  // Gain: '<S22>/Gain' incorporates:\n  //   Saturate: '<S22>/Saturation10'\n\n  FLIGHT_hexacopter_B.Gain = FLIGHT_hexacopter_P.Gain_Gain_er * rtb_SinCos_o2;\n\n  // MATLABSystem: '<S301>/SourceBlock'\n  flag_pos = uORB_read_step(FLIGHT_hexacopter_DW.obj_kk.orbMetadataObj,\n    &FLIGHT_hexacopter_DW.obj_kk.eventStructObj, &FLIGHT_hexacopter_B.r, false,\n    1.0);\n\n  // Outputs for Enabled SubSystem: '<S301>/Enabled Subsystem' incorporates:\n  //   EnablePort: '<S303>/Enable'\n\n  // Start for MATLABSystem: '<S301>/SourceBlock'\n  if (flag_pos) {\n    // SignalConversion generated from: '<S303>/In1'\n    FLIGHT_hexacopter_B.In1 = FLIGHT_hexacopter_B.r;\n    srUpdateBC(FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC_k);\n  }\n\n  // End of Outputs for SubSystem: '<S301>/Enabled Subsystem'\n\n  // Gain: '<S1>/Gain' incorporates:\n  //   Sum: '<S1>/Sum3'\n\n  FLIGHT_hexacopter_B.IProdOut_d = (FLIGHT_hexacopter_B.Gain -\n    FLIGHT_hexacopter_B.In1.vz) * FLIGHT_hexacopter_P.Gain_Gain_ob;\n\n  // MATLABSystem: '<S1>/Read Parameter2'\n  if (FLIGHT_hexacopter_DW.obj_in.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n  {\n    FLIGHT_hexacopter_DW.obj_in.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_in.MW_PARAMHANDLE, MW_SINGLE,\n    &FLIGHT_hexacopter_B.ParamStep);\n  if (flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep = 0.0F;\n  }\n\n  // Outputs for Atomic SubSystem: '<Root>/If Action Subsystem'\n  // Logic: '<S1>/AND' incorporates:\n  //   Logic: '<S5>/AND'\n\n  rtb_NOT_h = !FLIGHT_hexacopter_B.In1_n.armed;\n\n  // End of Outputs for SubSystem: '<Root>/If Action Subsystem'\n\n  // Logic: '<S1>/NOT' incorporates:\n  //   Constant: '<S23>/Constant'\n  //   Logic: '<S1>/AND'\n  //   RelationalOperator: '<S23>/Compare'\n\n  rtb_NOT = (rtb_NOT_h || (FLIGHT_hexacopter_B.values[5] <=\n              FLIGHT_hexacopter_P.CompareToConstant1_const));\n\n  // DiscreteIntegrator: '<S60>/Integrator'\n  if (rtb_NOT || (FLIGHT_hexacopter_DW.Integrator_PrevResetState != 0)) {\n    FLIGHT_hexacopter_DW.Integrator_DSTATE =\n      FLIGHT_hexacopter_P.PIDController_InitialConditio_a;\n  }\n\n  // MATLABSystem: '<S1>/Read Parameter4'\n  if (FLIGHT_hexacopter_DW.obj_lx.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n  {\n    FLIGHT_hexacopter_DW.obj_lx.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_lx.MW_PARAMHANDLE, MW_SINGLE,\n    &FLIGHT_hexacopter_B.ParamStep_m);\n  if (flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep_m = 0.0F;\n  }\n\n  // DiscreteIntegrator: '<S55>/Filter'\n  if (rtb_NOT || (FLIGHT_hexacopter_DW.Filter_PrevResetState != 0)) {\n    FLIGHT_hexacopter_DW.Filter_DSTATE =\n      FLIGHT_hexacopter_P.PIDController_InitialConditionF;\n  }\n\n  // Product: '<S63>/NProd Out' incorporates:\n  //   Constant: '<S1>/Constant'\n  //   DiscreteIntegrator: '<S55>/Filter'\n  //   MATLABSystem: '<S1>/Read Parameter4'\n  //   Product: '<S53>/DProd Out'\n  //   Sum: '<S55>/SumD'\n  //\n  FLIGHT_hexacopter_B.NProdOut = (FLIGHT_hexacopter_B.IProdOut_d *\n    FLIGHT_hexacopter_B.ParamStep_m - FLIGHT_hexacopter_DW.Filter_DSTATE) *\n    FLIGHT_hexacopter_P.Constant_Value_gx;\n\n  // Sum: '<S69>/Sum' incorporates:\n  //   DiscreteIntegrator: '<S60>/Integrator'\n  //   MATLABSystem: '<S1>/Read Parameter2'\n  //   Product: '<S65>/PProd Out'\n  //\n  rtb_DeadZone = (FLIGHT_hexacopter_B.IProdOut_d * FLIGHT_hexacopter_B.ParamStep\n                  + FLIGHT_hexacopter_DW.Integrator_DSTATE) +\n    FLIGHT_hexacopter_B.NProdOut;\n\n  // MATLABSystem: '<S1>/Read Parameter1'\n  if (FLIGHT_hexacopter_DW.obj_m.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    FLIGHT_hexacopter_DW.obj_m.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_m.MW_PARAMHANDLE, MW_SINGLE,\n    &FLIGHT_hexacopter_B.ParamStep);\n  if (flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep = 0.0F;\n  }\n\n  // Saturate: '<S67>/Saturation'\n  if (rtb_DeadZone > FLIGHT_hexacopter_P.PIDController_UpperSaturationLi) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.PIDController_UpperSaturationLi;\n  } else if (rtb_DeadZone < FLIGHT_hexacopter_P.PIDController_LowerSaturationLi)\n  {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.PIDController_LowerSaturationLi;\n  } else {\n    rtb_SinCos_o2 = rtb_DeadZone;\n  }\n\n  // Sum: '<S1>/Sum6' incorporates:\n  //   MATLABSystem: '<S1>/Read Parameter1'\n  //   Saturate: '<S67>/Saturation'\n  //\n  rtb_Saturation1 = rtb_SinCos_o2 + FLIGHT_hexacopter_B.ParamStep;\n\n  // Saturate: '<S1>/Saturation1'\n  if (rtb_Saturation1 > FLIGHT_hexacopter_P.Saturation1_UpperSat_lr) {\n    rtb_Saturation1 = FLIGHT_hexacopter_P.Saturation1_UpperSat_lr;\n  } else if (rtb_Saturation1 < FLIGHT_hexacopter_P.Saturation1_LowerSat_e) {\n    rtb_Saturation1 = FLIGHT_hexacopter_P.Saturation1_LowerSat_e;\n  }\n\n  // End of Saturate: '<S1>/Saturation1'\n\n  // Outputs for Atomic SubSystem: '<Root>/If Action Subsystem'\n  // Trigonometry: '<S249>/SinCos'\n  FLIGHT_hexacopter_B.Product5_l = static_cast<real32_T>(sin(static_cast<real_T>\n    (FLIGHT_hexacopter_B.In1.heading)));\n  rtb_SinCos_o2 = static_cast<real32_T>(cos(static_cast<real_T>\n    (FLIGHT_hexacopter_B.In1.heading)));\n\n  // MATLABSystem: '<S194>/Read Parameter'\n  if (FLIGHT_hexacopter_DW.obj_eq.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n  {\n    FLIGHT_hexacopter_DW.obj_eq.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_eq.MW_PARAMHANDLE, MW_SINGLE,\n    &FLIGHT_hexacopter_B.ParamStep);\n  if (flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep = 0.0F;\n  }\n\n  // Logic: '<S5>/NOT' incorporates:\n  //   Constant: '<S193>/Constant'\n  //   Logic: '<S5>/AND'\n  //   RelationalOperator: '<S193>/Compare'\n\n  rtb_NOT_h = (rtb_NOT_h || (FLIGHT_hexacopter_B.values[5] <=\n    FLIGHT_hexacopter_P.CompareToConstant2_const));\n\n  // DiscreteIntegrator: '<S5>/Discrete-Time Integrator'\n  if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_IC_LOADI != 0) {\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l =\n      FLIGHT_hexacopter_B.In1.x;\n    if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l >\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator_UpperSat) {\n      FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l =\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator_UpperSat;\n    } else if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l <\n               FLIGHT_hexacopter_P.DiscreteTimeIntegrator_LowerSat) {\n      FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l =\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator_LowerSat;\n    }\n  }\n\n  if (rtb_NOT_h || (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_PrevRese != 0))\n  {\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l =\n      FLIGHT_hexacopter_B.In1.x;\n    if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l >\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator_UpperSat) {\n      FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l =\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator_UpperSat;\n    } else if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l <\n               FLIGHT_hexacopter_P.DiscreteTimeIntegrator_LowerSat) {\n      FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l =\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator_LowerSat;\n    }\n  }\n\n  rtb_des_x = FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l;\n\n  // DiscreteIntegrator: '<S5>/Discrete-Time Integrator1'\n  if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_IC_LOAD != 0) {\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE =\n      FLIGHT_hexacopter_B.In1.y;\n    if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE >\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_UpperSa) {\n      FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE =\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_UpperSa;\n    } else if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE <\n               FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_LowerSa) {\n      FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE =\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_LowerSa;\n    }\n  }\n\n  if (rtb_NOT_h || (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_PrevRes != 0))\n  {\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE =\n      FLIGHT_hexacopter_B.In1.y;\n    if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE >\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_UpperSa) {\n      FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE =\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_UpperSa;\n    } else if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE <\n               FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_LowerSa) {\n      FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE =\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_LowerSa;\n    }\n  }\n\n  rtb_des_z = FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE;\n\n  // Product: '<S235>/PProd Out' incorporates:\n  //   DiscreteIntegrator: '<S5>/Discrete-Time Integrator'\n  //   DiscreteIntegrator: '<S5>/Discrete-Time Integrator1'\n  //   MATLABSystem: '<S194>/Read Parameter'\n  //   Sum: '<S194>/Sum'\n  //\n  rtb_PProdOut_ev_idx_0 = (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l\n    - FLIGHT_hexacopter_B.In1.x) * FLIGHT_hexacopter_B.ParamStep;\n  rtb_PProdOut_ev_idx_1 = (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE -\n    FLIGHT_hexacopter_B.In1.y) * FLIGHT_hexacopter_B.ParamStep;\n\n  // MATLABSystem: '<S195>/Read Parameter'\n  if (FLIGHT_hexacopter_DW.obj_pi.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n  {\n    FLIGHT_hexacopter_DW.obj_pi.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_pi.MW_PARAMHANDLE, MW_SINGLE,\n    &FLIGHT_hexacopter_B.ParamStep);\n  if (flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep = 0.0F;\n  }\n\n  // Sum: '<S195>/Sum'\n  FLIGHT_hexacopter_B.absxk = rtb_PProdOut_ev_idx_0 - FLIGHT_hexacopter_B.In1.vx;\n  FLIGHT_hexacopter_B.cfromc = rtb_PProdOut_ev_idx_1 -\n    FLIGHT_hexacopter_B.In1.vy;\n\n  // Saturate: '<S195>/Saturation' incorporates:\n  //   Gain: '<S249>/Gain'\n  //   MATLABSystem: '<S195>/Read Parameter'\n  //   Product: '<S247>/MatrixMultiply'\n  //   Product: '<S288>/PProd Out'\n  //   Reshape: '<S249>/Reshape'\n  //   Reshape: '<S249>/Reshape1'\n  //\n  FLIGHT_hexacopter_B.ParamStep_m = (rtb_SinCos_o2 * FLIGHT_hexacopter_B.absxk +\n    FLIGHT_hexacopter_B.Product5_l * FLIGHT_hexacopter_B.cfromc) *\n    FLIGHT_hexacopter_B.ParamStep;\n  FLIGHT_hexacopter_B.Product5_l = (FLIGHT_hexacopter_P.Gain_Gain_a *\n    FLIGHT_hexacopter_B.Product5_l * FLIGHT_hexacopter_B.absxk + rtb_SinCos_o2 *\n    FLIGHT_hexacopter_B.cfromc) * FLIGHT_hexacopter_B.ParamStep;\n\n  // DeadZone: '<S192>/Dead Zone3'\n  if (FLIGHT_hexacopter_B.ParamStep_c > FLIGHT_hexacopter_P.DeadZone3_End) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_B.ParamStep_c -\n      FLIGHT_hexacopter_P.DeadZone3_End;\n  } else if (FLIGHT_hexacopter_B.ParamStep_c >=\n             FLIGHT_hexacopter_P.DeadZone3_Start) {\n    rtb_SinCos_o2 = 0.0F;\n  } else {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_B.ParamStep_c -\n      FLIGHT_hexacopter_P.DeadZone3_Start;\n  }\n\n  // End of DeadZone: '<S192>/Dead Zone3'\n\n  // Saturate: '<S192>/Saturation9'\n  if (rtb_SinCos_o2 > FLIGHT_hexacopter_P.Saturation9_UpperSat) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation9_UpperSat;\n  } else if (rtb_SinCos_o2 < FLIGHT_hexacopter_P.Saturation9_LowerSat) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation9_LowerSat;\n  }\n\n  // Gain: '<S192>/Gain1' incorporates:\n  //   Saturate: '<S192>/Saturation9'\n\n  FLIGHT_hexacopter_B.Gain1_k = FLIGHT_hexacopter_P.MAX_CONTROL_VELOCITY_XY *\n    rtb_SinCos_o2;\n\n  // DeadZone: '<S192>/Dead Zone1'\n  if (rtb_Diff_c > FLIGHT_hexacopter_P.DeadZone1_End) {\n    rtb_SinCos_o2 = rtb_Diff_c - FLIGHT_hexacopter_P.DeadZone1_End;\n  } else if (rtb_Diff_c >= FLIGHT_hexacopter_P.DeadZone1_Start) {\n    rtb_SinCos_o2 = 0.0F;\n  } else {\n    rtb_SinCos_o2 = rtb_Diff_c - FLIGHT_hexacopter_P.DeadZone1_Start;\n  }\n\n  // End of DeadZone: '<S192>/Dead Zone1'\n\n  // Saturate: '<S192>/Saturation1'\n  if (rtb_SinCos_o2 > FLIGHT_hexacopter_P.Saturation1_UpperSat) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation1_UpperSat;\n  } else if (rtb_SinCos_o2 < FLIGHT_hexacopter_P.Saturation1_LowerSat) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation1_LowerSat;\n  }\n\n  // Gain: '<S192>/Gain2' incorporates:\n  //   Saturate: '<S192>/Saturation1'\n\n  FLIGHT_hexacopter_B.Gain2_l = FLIGHT_hexacopter_P.Gain2_Gain * rtb_SinCos_o2;\n\n  // DeadZone: '<S192>/Dead Zone2'\n  if (rtb_TmpSignalConversionAtSFun_0 > FLIGHT_hexacopter_P.DeadZone2_End) {\n    rtb_SinCos_o2 = rtb_TmpSignalConversionAtSFun_0 -\n      FLIGHT_hexacopter_P.DeadZone2_End;\n  } else if (rtb_TmpSignalConversionAtSFun_0 >=\n             FLIGHT_hexacopter_P.DeadZone2_Start) {\n    rtb_SinCos_o2 = 0.0F;\n  } else {\n    rtb_SinCos_o2 = rtb_TmpSignalConversionAtSFun_0 -\n      FLIGHT_hexacopter_P.DeadZone2_Start;\n  }\n\n  // End of DeadZone: '<S192>/Dead Zone2'\n\n  // Saturate: '<S192>/Saturation3'\n  if (rtb_SinCos_o2 > FLIGHT_hexacopter_P.Saturation3_UpperSat) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation3_UpperSat;\n  } else if (rtb_SinCos_o2 < FLIGHT_hexacopter_P.Saturation3_LowerSat) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation3_LowerSat;\n  }\n\n  // Gain: '<S192>/Gain3' incorporates:\n  //   Saturate: '<S192>/Saturation3'\n\n  FLIGHT_hexacopter_B.Gain3_g = FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_RATE_Y *\n    rtb_SinCos_o2;\n\n  // DeadZone: '<S192>/Dead Zone4'\n  if (rtb_TmpSignalConversionAtSFun_1 > FLIGHT_hexacopter_P.DeadZone4_End) {\n    rtb_SinCos_o2 = rtb_TmpSignalConversionAtSFun_1 -\n      FLIGHT_hexacopter_P.DeadZone4_End;\n  } else if (rtb_TmpSignalConversionAtSFun_1 >=\n             FLIGHT_hexacopter_P.DeadZone4_Start) {\n    rtb_SinCos_o2 = 0.0F;\n  } else {\n    rtb_SinCos_o2 = rtb_TmpSignalConversionAtSFun_1 -\n      FLIGHT_hexacopter_P.DeadZone4_Start;\n  }\n\n  // End of DeadZone: '<S192>/Dead Zone4'\n\n  // Saturate: '<S192>/Saturation10'\n  if (rtb_SinCos_o2 > FLIGHT_hexacopter_P.Saturation10_UpperSat) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation10_UpperSat;\n  } else if (rtb_SinCos_o2 < FLIGHT_hexacopter_P.Saturation10_LowerSat) {\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation10_LowerSat;\n  }\n\n  // Gain: '<S192>/Gain' incorporates:\n  //   Saturate: '<S192>/Saturation10'\n\n  FLIGHT_hexacopter_B.Gain_m = FLIGHT_hexacopter_P.Gain_Gain_o * rtb_SinCos_o2;\n\n  // Update for DiscreteIntegrator: '<S5>/Discrete-Time Integrator'\n  FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_IC_LOADI = 0U;\n  FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l +=\n    FLIGHT_hexacopter_P.DiscreteTimeIntegrator_gainval *\n    FLIGHT_hexacopter_B.Gain2_l;\n  if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l >\n      FLIGHT_hexacopter_P.DiscreteTimeIntegrator_UpperSat) {\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l =\n      FLIGHT_hexacopter_P.DiscreteTimeIntegrator_UpperSat;\n  } else if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l <\n             FLIGHT_hexacopter_P.DiscreteTimeIntegrator_LowerSat) {\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l =\n      FLIGHT_hexacopter_P.DiscreteTimeIntegrator_LowerSat;\n  }\n\n  FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_PrevRese = static_cast<int8_T>\n    (rtb_NOT_h);\n\n  // Update for DiscreteIntegrator: '<S5>/Discrete-Time Integrator1' incorporates:\n  //   DiscreteIntegrator: '<S5>/Discrete-Time Integrator'\n\n  FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_IC_LOAD = 0U;\n  FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE +=\n    FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_gainval *\n    FLIGHT_hexacopter_B.Gain1_k;\n  if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE >\n      FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_UpperSa) {\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE =\n      FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_UpperSa;\n  } else if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE <\n             FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_LowerSa) {\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE =\n      FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_LowerSa;\n  }\n\n  FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_PrevRes = static_cast<int8_T>\n    (rtb_NOT_h);\n\n  // End of Update for DiscreteIntegrator: '<S5>/Discrete-Time Integrator1'\n  // End of Outputs for SubSystem: '<Root>/If Action Subsystem'\n\n  // MATLABSystem: '<S501>/SourceBlock'\n  flag_pos = uORB_read_step(FLIGHT_hexacopter_DW.obj_bw.orbMetadataObj,\n    &FLIGHT_hexacopter_DW.obj_bw.eventStructObj, &FLIGHT_hexacopter_B.r3, false,\n    1.0);\n\n  // Outputs for Enabled SubSystem: '<S501>/Enabled Subsystem' incorporates:\n  //   EnablePort: '<S503>/Enable'\n\n  // Start for MATLABSystem: '<S501>/SourceBlock'\n  if (flag_pos) {\n    // SignalConversion generated from: '<S503>/In1'\n    FLIGHT_hexacopter_B.In1_f = FLIGHT_hexacopter_B.r3;\n    srUpdateBC(FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC);\n  }\n\n  // End of Outputs for SubSystem: '<S501>/Enabled Subsystem'\n\n  // MATLAB Function: '<S18>/MATLAB Function'\n  switch (FLIGHT_hexacopter_B.In1_f.nav_state) {\n   case 1:\n    //  ALT Mode\n    flag_pos = false;\n    rtb_NOT_h = true;\n    break;\n\n   case 2:\n    //  POS Mode\n    flag_pos = true;\n    rtb_NOT_h = false;\n    break;\n\n   default:\n    //  STAB mode\n    flag_pos = false;\n    rtb_NOT_h = false;\n    break;\n  }\n\n  // End of MATLAB Function: '<S18>/MATLAB Function'\n\n  // Outputs for Atomic SubSystem: '<Root>/If Action Subsystem'\n  // Saturate: '<S195>/Saturation'\n  if (FLIGHT_hexacopter_B.Product5_l > FLIGHT_hexacopter_P.Saturation_UpperSat_e)\n  {\n    // SignalConversion generated from: '<S6>/ SFunction ' incorporates:\n    //   MATLAB Function: '<Root>/MATLAB Function'\n\n    FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_P.Saturation_UpperSat_e;\n  } else if (FLIGHT_hexacopter_B.Product5_l <\n             FLIGHT_hexacopter_P.Saturation_LowerSat_a) {\n    // SignalConversion generated from: '<S6>/ SFunction ' incorporates:\n    //   MATLAB Function: '<Root>/MATLAB Function'\n\n    FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_P.Saturation_LowerSat_a;\n  }\n\n  if (FLIGHT_hexacopter_B.ParamStep_m >\n      FLIGHT_hexacopter_P.Saturation_UpperSat_e) {\n    FLIGHT_hexacopter_B.ParamStep_m = FLIGHT_hexacopter_P.Saturation_UpperSat_e;\n  } else if (FLIGHT_hexacopter_B.ParamStep_m <\n             FLIGHT_hexacopter_P.Saturation_LowerSat_a) {\n    FLIGHT_hexacopter_B.ParamStep_m = FLIGHT_hexacopter_P.Saturation_LowerSat_a;\n  }\n\n  // SignalConversion generated from: '<S6>/ SFunction ' incorporates:\n  //   Gain: '<S195>/Gain1'\n  //   MATLAB Function: '<Root>/MATLAB Function'\n  //   Saturate: '<S195>/Saturation'\n\n  rtb_TmpSignalConversionAtSFun_1 = FLIGHT_hexacopter_P.Gain1_Gain_i *\n    FLIGHT_hexacopter_B.ParamStep_m;\n\n  // End of Outputs for SubSystem: '<Root>/If Action Subsystem'\n  rtb_TmpSignalConversionAtSFun_0 = FLIGHT_hexacopter_B.Gain3;\n\n  // MATLAB Function: '<Root>/MATLAB Function' incorporates:\n  //   Gain: '<S12>/Gain4'\n  //   Saturate: '<S12>/Saturation3'\n  //   SignalConversion generated from: '<S6>/ SFunction '\n\n  if ((FLIGHT_hexacopter_B.values[5] < 1800) || (!flag_pos)) {\n    if ((FLIGHT_hexacopter_B.values[5] < 1800) && (FLIGHT_hexacopter_B.values[5]\n         >= 1400) && rtb_NOT_h) {\n      //  Altitude\n      FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_B.Gain1;\n      rtb_TmpSignalConversionAtSFun_1 = FLIGHT_hexacopter_B.Gain2;\n    } else {\n      // Outputs for Atomic SubSystem: '<Root>/Stabilized_Mode'\n      // Saturate: '<S12>/Saturation3'\n      //  Stablized\n      if (rtb_Product5_m > FLIGHT_hexacopter_P.Saturation3_UpperSat_b) {\n        rtb_Product5_m = FLIGHT_hexacopter_P.Saturation3_UpperSat_b;\n      } else if (rtb_Product5_m < FLIGHT_hexacopter_P.Saturation3_LowerSat_j) {\n        rtb_Product5_m = FLIGHT_hexacopter_P.Saturation3_LowerSat_j;\n      }\n\n      FLIGHT_hexacopter_B.Product5_l =\n        FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_ROLL * rtb_Product5_m;\n\n      // End of Outputs for SubSystem: '<Root>/Stabilized_Mode'\n      rtb_TmpSignalConversionAtSFun_1 = FLIGHT_hexacopter_B.Gain5;\n      rtb_TmpSignalConversionAtSFun_0 = FLIGHT_hexacopter_B.Gain6;\n      rtb_Saturation1 = FLIGHT_hexacopter_B.Saturation;\n    }\n  } else {\n    //  position\n  }\n\n  // RelationalOperator: '<S183>/Compare' incorporates:\n  //   Constant: '<S183>/Constant'\n\n  rtb_NOT_h = (FLIGHT_hexacopter_B.values[6] >=\n               FLIGHT_hexacopter_P.CompareToConstant1_const_e);\n  FLIGHT_hexacop_PX4Timestamp(&FLIGHT_hexacopter_B.PX4Timestamp);\n\n  // MATLABSystem: '<S3>/Read Parameter1'\n  if (FLIGHT_hexacopter_DW.obj_ct.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n  {\n    FLIGHT_hexacopter_DW.obj_ct.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_ct.MW_PARAMHANDLE, MW_SINGLE,\n    &FLIGHT_hexacopter_B.ParamStep);\n  if (flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep = 0.0F;\n  }\n\n  // MATLABSystem: '<S3>/Read Parameter'\n  if (FLIGHT_hexacopter_DW.obj_cf.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n  {\n    FLIGHT_hexacopter_DW.obj_cf.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_cf.MW_PARAMHANDLE, MW_SINGLE,\n    &FLIGHT_hexacopter_B.ParamStep_m);\n  if (flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep_m = 0.0F;\n  }\n\n  // MATLABSystem: '<S3>/Read Parameter2'\n  if (FLIGHT_hexacopter_DW.obj_l.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    FLIGHT_hexacopter_DW.obj_l.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_l.MW_PARAMHANDLE, MW_INT32,\n    &i);\n  if (flag_pos) {\n    i = 0;\n  }\n\n  // MATLAB Function: '<S3>/MATLAB Function' incorporates:\n  //   DataTypeConversion: '<S3>/Data Type Conversion'\n  //   DataTypeConversion: '<S3>/Data Type Conversion1'\n  //   DataTypeConversion: '<S3>/Data Type Conversion2'\n  //   DataTypeConversion: '<S3>/Data Type Conversion3'\n  //   DataTypeConversion: '<S3>/Data Type Conversion4'\n  //   DataTypeConversion: '<S3>/Data Type Conversion5'\n  //   MATLABSystem: '<S3>/PX4 Timestamp'\n  //   MATLABSystem: '<S3>/Read Parameter'\n  //   MATLABSystem: '<S3>/Read Parameter1'\n  //   MATLABSystem: '<S3>/Read Parameter2'\n  //\n  FLIGHT_hexacopter_B.out_roll = FLIGHT_hexacopter_B.Product5_l;\n  FLIGHT_hexacopter_B.out_pitch = rtb_TmpSignalConversionAtSFun_1;\n  FLIGHT_hexacopter_B.out_yawrate = rtb_TmpSignalConversionAtSFun_0;\n  if (rtb_NOT_h && (FLIGHT_hexacopter_DW.start_time_usec == -1.0)) {\n    FLIGHT_hexacopter_DW.start_time_usec = static_cast<real_T>\n      (FLIGHT_hexacopter_B.PX4Timestamp.PX4Timestamp);\n  }\n\n  if (rtb_NOT_h && (FLIGHT_hexacopter_DW.start_time_usec > 0.0)) {\n    //  time calculation\n    FLIGHT_hexacopter_B.reletive_time_sec = (static_cast<real_T>\n      (FLIGHT_hexacopter_B.PX4Timestamp.PX4Timestamp) -\n      FLIGHT_hexacopter_DW.start_time_usec) * 1.0E-6;\n  } else {\n    FLIGHT_hexacopter_DW.start_time_usec = -1.0;\n    FLIGHT_hexacopter_B.reletive_time_sec = 0.0;\n  }\n\n  //  Define Doublet\n  FLIGHT_hexacopter_B.peak_angle_rad = FLIGHT_hexacopter_B.ParamStep *\n    0.017453292519943295;\n\n  //  Default Output\n  //  Generate Doublet Command\n  if (rtb_NOT_h) {\n    switch (i) {\n     case 1:\n      if ((FLIGHT_hexacopter_B.reletive_time_sec >= 0.0) &&\n          (FLIGHT_hexacopter_B.reletive_time_sec <\n           FLIGHT_hexacopter_B.ParamStep_m)) {\n        FLIGHT_hexacopter_B.out_roll = FLIGHT_hexacopter_B.peak_angle_rad;\n      } else if ((FLIGHT_hexacopter_B.reletive_time_sec >=\n                  FLIGHT_hexacopter_B.ParamStep_m) &&\n                 (FLIGHT_hexacopter_B.reletive_time_sec < static_cast<real_T>\n                  (FLIGHT_hexacopter_B.ParamStep_m) +\n                  FLIGHT_hexacopter_B.ParamStep_m)) {\n        FLIGHT_hexacopter_B.out_roll = -FLIGHT_hexacopter_B.peak_angle_rad;\n      } else {\n        FLIGHT_hexacopter_B.out_roll = 0.0;\n      }\n      break;\n\n     case 2:\n      if ((FLIGHT_hexacopter_B.reletive_time_sec >= 0.0) &&\n          (FLIGHT_hexacopter_B.reletive_time_sec <\n           FLIGHT_hexacopter_B.ParamStep_m)) {\n        FLIGHT_hexacopter_B.out_pitch = FLIGHT_hexacopter_B.peak_angle_rad;\n      } else if ((FLIGHT_hexacopter_B.reletive_time_sec >=\n                  FLIGHT_hexacopter_B.ParamStep_m) &&\n                 (FLIGHT_hexacopter_B.reletive_time_sec < static_cast<real_T>\n                  (FLIGHT_hexacopter_B.ParamStep_m) +\n                  FLIGHT_hexacopter_B.ParamStep_m)) {\n        FLIGHT_hexacopter_B.out_pitch = -FLIGHT_hexacopter_B.peak_angle_rad;\n      } else {\n        FLIGHT_hexacopter_B.out_pitch = 0.0;\n      }\n      break;\n\n     case 3:\n      if ((FLIGHT_hexacopter_B.reletive_time_sec >= 0.0) &&\n          (FLIGHT_hexacopter_B.reletive_time_sec <\n           FLIGHT_hexacopter_B.ParamStep_m)) {\n        FLIGHT_hexacopter_B.out_yawrate = FLIGHT_hexacopter_B.peak_angle_rad;\n      } else if ((FLIGHT_hexacopter_B.reletive_time_sec >=\n                  FLIGHT_hexacopter_B.ParamStep_m) &&\n                 (FLIGHT_hexacopter_B.reletive_time_sec < static_cast<real_T>\n                  (FLIGHT_hexacopter_B.ParamStep_m) +\n                  FLIGHT_hexacopter_B.ParamStep_m)) {\n        FLIGHT_hexacopter_B.out_yawrate = -FLIGHT_hexacopter_B.peak_angle_rad;\n      } else {\n        FLIGHT_hexacopter_B.out_yawrate = 0.0;\n      }\n      break;\n    }\n  }\n\n  // End of MATLAB Function: '<S3>/MATLAB Function'\n\n  // Outputs for Enabled SubSystem: '<Root>/CAS' incorporates:\n  //   EnablePort: '<S2>/Enable'\n\n  if (FLIGHT_hexacopter_B.In1_n.armed) {\n    // MATLABSystem: '<S2>/Read Parameter9'\n    if (FLIGHT_hexacopter_DW.obj_k4.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n    {\n      FLIGHT_hexacopter_DW.obj_k4.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    }\n\n    flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_k4.MW_PARAMHANDLE,\n      MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep);\n    if (flag_pos) {\n      FLIGHT_hexacopter_B.ParamStep = 0.0F;\n    }\n\n    // Gain: '<S77>/Gain1' incorporates:\n    //   MATLABSystem: '<S2>/Read Parameter9'\n    //\n    FLIGHT_hexacopter_B.ParamStep_m = FLIGHT_hexacopter_P.Gain1_Gain_g *\n      FLIGHT_hexacopter_B.ParamStep;\n\n    // MATLABSystem: '<S2>/Read Parameter'\n    if (FLIGHT_hexacopter_DW.obj_jz.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n    {\n      FLIGHT_hexacopter_DW.obj_jz.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    }\n\n    flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_jz.MW_PARAMHANDLE,\n      MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep);\n    if (flag_pos) {\n      FLIGHT_hexacopter_B.ParamStep = 0.0F;\n    }\n\n    // Product: '<S170>/PProd Out' incorporates:\n    //   DataTypeConversion: '<S3>/Data Type Conversion8'\n    //   MATLABSystem: '<S2>/Read Parameter'\n    //   Sum: '<S2>/Sum3'\n    //\n    FLIGHT_hexacopter_B.ParamStep *= static_cast<real32_T>\n      (FLIGHT_hexacopter_B.out_roll) - FLIGHT_hexacopter_B.ypr[2];\n\n    // Switch: '<S173>/Switch2' incorporates:\n    //   RelationalOperator: '<S173>/LowerRelop1'\n\n    if (FLIGHT_hexacopter_B.ParamStep > FLIGHT_hexacopter_B.ParamStep_m) {\n      // Switch: '<S173>/Switch2'\n      FLIGHT_hexacopter_B.Switch2 = FLIGHT_hexacopter_B.ParamStep_m;\n    } else {\n      // Gain: '<S2>/Gain'\n      FLIGHT_hexacopter_B.ParamStep_m *= FLIGHT_hexacopter_P.Gain_Gain_m3;\n\n      // Switch: '<S173>/Switch' incorporates:\n      //   RelationalOperator: '<S173>/UpperRelop'\n\n      if (FLIGHT_hexacopter_B.ParamStep < FLIGHT_hexacopter_B.ParamStep_m) {\n        // Switch: '<S173>/Switch2'\n        FLIGHT_hexacopter_B.Switch2 = FLIGHT_hexacopter_B.ParamStep_m;\n      } else {\n        // Switch: '<S173>/Switch2'\n        FLIGHT_hexacopter_B.Switch2 = FLIGHT_hexacopter_B.ParamStep;\n      }\n\n      // End of Switch: '<S173>/Switch'\n    }\n\n    // End of Switch: '<S173>/Switch2'\n\n    // MATLABSystem: '<S2>/Read Parameter10'\n    if (FLIGHT_hexacopter_DW.obj_ds.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n    {\n      FLIGHT_hexacopter_DW.obj_ds.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    }\n\n    flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_ds.MW_PARAMHANDLE,\n      MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep);\n    if (flag_pos) {\n      FLIGHT_hexacopter_B.ParamStep = 0.0F;\n    }\n\n    // Gain: '<S78>/Gain1' incorporates:\n    //   MATLABSystem: '<S2>/Read Parameter10'\n    //\n    FLIGHT_hexacopter_B.ParamStep_m = FLIGHT_hexacopter_P.Gain1_Gain_c *\n      FLIGHT_hexacopter_B.ParamStep;\n\n    // MATLABSystem: '<S2>/Read Parameter1'\n    if (FLIGHT_hexacopter_DW.obj_o.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n    {\n      FLIGHT_hexacopter_DW.obj_o.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    }\n\n    flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_o.MW_PARAMHANDLE,\n      MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep);\n    if (flag_pos) {\n      FLIGHT_hexacopter_B.ParamStep = 0.0F;\n    }\n\n    // Product: '<S119>/PProd Out' incorporates:\n    //   DataTypeConversion: '<S3>/Data Type Conversion7'\n    //   MATLABSystem: '<S2>/Read Parameter1'\n    //   Sum: '<S2>/Sum2'\n    //\n    FLIGHT_hexacopter_B.ParamStep *= static_cast<real32_T>\n      (FLIGHT_hexacopter_B.out_pitch) - FLIGHT_hexacopter_B.ypr[1];\n\n    // Switch: '<S122>/Switch2' incorporates:\n    //   RelationalOperator: '<S122>/LowerRelop1'\n\n    if (FLIGHT_hexacopter_B.ParamStep > FLIGHT_hexacopter_B.ParamStep_m) {\n      // Switch: '<S122>/Switch2'\n      FLIGHT_hexacopter_B.Switch2_i = FLIGHT_hexacopter_B.ParamStep_m;\n    } else {\n      // Gain: '<S2>/Gain1'\n      FLIGHT_hexacopter_B.ParamStep_m *= FLIGHT_hexacopter_P.Gain1_Gain;\n\n      // Switch: '<S122>/Switch' incorporates:\n      //   RelationalOperator: '<S122>/UpperRelop'\n\n      if (FLIGHT_hexacopter_B.ParamStep < FLIGHT_hexacopter_B.ParamStep_m) {\n        // Switch: '<S122>/Switch2'\n        FLIGHT_hexacopter_B.Switch2_i = FLIGHT_hexacopter_B.ParamStep_m;\n      } else {\n        // Switch: '<S122>/Switch2'\n        FLIGHT_hexacopter_B.Switch2_i = FLIGHT_hexacopter_B.ParamStep;\n      }\n\n      // End of Switch: '<S122>/Switch'\n    }\n\n    // End of Switch: '<S122>/Switch2'\n    srUpdateBC(FLIGHT_hexacopter_DW.CAS_SubsysRanBC);\n  }\n\n  // End of Outputs for SubSystem: '<Root>/CAS'\n\n  // S-Function (sdspdiag2): '<S477>/Create Diagonal Matrix' incorporates:\n  //   Constant: '<S477>/Constant'\n  //   Constant: '<S477>/Constant1'\n  //   Constant: '<S477>/Constant2'\n  //   SignalConversion generated from: '<S477>/Create Diagonal Matrix'\n\n  for (i = 0; i < 9; i++) {\n    FLIGHT_hexacopter_B.CreateDiagonalMatrix[i] = 0.0F;\n  }\n\n  FLIGHT_hexacopter_B.CreateDiagonalMatrix[0] = FLIGHT_hexacopter_P.Jxx;\n  FLIGHT_hexacopter_B.CreateDiagonalMatrix[4] = FLIGHT_hexacopter_P.Jyy;\n  FLIGHT_hexacopter_B.CreateDiagonalMatrix[8] = FLIGHT_hexacopter_P.Jzz;\n\n  // End of S-Function (sdspdiag2): '<S477>/Create Diagonal Matrix'\n\n  // RateTransition: '<Root>/rate_transition_throttle'\n  FLIGHT_hexacopter_DW.rate_transition_throttle_Buffer = rtb_Saturation1;\n\n  // MATLAB Function: '<S11>/Omega_phi'\n  FLIGHT_hexacopter_B.ParamStep = static_cast<real32_T>(tan(static_cast<real_T>\n    (FLIGHT_hexacopter_B.ypr[1])));\n  FLIGHT_hexacopter_B.TmpSignalConversionAtSFun_c[0] = 1.0F;\n  FLIGHT_hexacopter_B.TmpSignalConversionAtSFun_c[1] = static_cast<real32_T>(sin\n    (static_cast<real_T>(FLIGHT_hexacopter_B.ypr[2]))) *\n    FLIGHT_hexacopter_B.ParamStep;\n  FLIGHT_hexacopter_B.TmpSignalConversionAtSFun_c[2] = static_cast<real32_T>(cos\n    (static_cast<real_T>(FLIGHT_hexacopter_B.ypr[2]))) *\n    FLIGHT_hexacopter_B.ParamStep;\n  for (i = 0; i < 3; i++) {\n    // MATLAB Function: '<S11>/MATLAB Function1' incorporates:\n    //   S-Function (sdspdiag2): '<S477>/Create Diagonal Matrix'\n\n    FLIGHT_hexacopter_B.G1[i] = (FLIGHT_hexacopter_B.CreateDiagonalMatrix[3 * i\n      + 1] * FLIGHT_hexacopter_B.TmpSignalConversionAtSFun_c[1] +\n      FLIGHT_hexacopter_B.CreateDiagonalMatrix[3 * i]) +\n      FLIGHT_hexacopter_B.CreateDiagonalMatrix[3 * i + 2] *\n      FLIGHT_hexacopter_B.TmpSignalConversionAtSFun_c[2];\n\n    // SampleTimeMath: '<S480>/TSamp'\n    //\n    //  About '<S480>/TSamp':\n    //   y = u * K where K = 1 / ( w * Ts )\n    //\n    FLIGHT_hexacopter_B.ParamStep =\n      FLIGHT_hexacopter_B.TmpSignalConversionAtSFun_c[i] *\n      FLIGHT_hexacopter_P.TSamp_WtEt_k;\n    FLIGHT_hexacopter_B.TSamp[i] = FLIGHT_hexacopter_B.ParamStep;\n\n    // Sum: '<S480>/Diff' incorporates:\n    //   SampleTimeMath: '<S480>/TSamp'\n    //   UnitDelay: '<S480>/UD'\n    //\n    //  About '<S480>/TSamp':\n    //   y = u * K where K = 1 / ( w * Ts )\n    //    *\n    //  Block description for '<S480>/Diff':\n    //\n    //   Add in CPU\n    //\n    //  Block description for '<S480>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE[i] = FLIGHT_hexacopter_B.ParamStep -\n      FLIGHT_hexacopter_DW.UD_DSTATE[i];\n  }\n\n  // SampleTimeMath: '<S478>/TSamp' incorporates:\n  //   DataTypeConversion: '<S3>/Data Type Conversion8'\n  //\n  //  About '<S478>/TSamp':\n  //   y = u * K where K = 1 / ( w * Ts )\n  //\n  rtb_Product5_m = static_cast<real32_T>(FLIGHT_hexacopter_B.out_roll) *\n    FLIGHT_hexacopter_P.TSamp_WtEt_c;\n\n  // Sum: '<S478>/Diff' incorporates:\n  //   UnitDelay: '<S478>/UD'\n  //\n  //  Block description for '<S478>/Diff':\n  //\n  //   Add in CPU\n  //\n  //  Block description for '<S478>/UD':\n  //\n  //   Store in Global RAM\n\n  rtb_Diff_c = rtb_Product5_m - FLIGHT_hexacopter_DW.UD_DSTATE_j;\n\n  // SampleTimeMath: '<S479>/TSamp'\n  //\n  //  About '<S479>/TSamp':\n  //   y = u * K where K = 1 / ( w * Ts )\n  //\n  rtb_TmpSignalConversionAtSFun_1 = rtb_Diff_c *\n    FLIGHT_hexacopter_P.TSamp_WtEt_b;\n\n  // Sum: '<S11>/Subtract' incorporates:\n  //   DataTypeConversion: '<S3>/Data Type Conversion8'\n\n  rtb_TmpSignalConversionAtSFun_0 = FLIGHT_hexacopter_B.ypr[2] -\n    static_cast<real32_T>(FLIGHT_hexacopter_B.out_roll);\n\n  // SampleTimeMath: '<S481>/TSamp'\n  //\n  //  About '<S481>/TSamp':\n  //   y = u * K where K = 1 / ( w * Ts )\n  //\n  FLIGHT_hexacopter_B.Product5_l = rtb_TmpSignalConversionAtSFun_0 *\n    FLIGHT_hexacopter_P.TSamp_WtEt_py;\n\n  // MATLABSystem: '<S11>/Read Parameter'\n  if (FLIGHT_hexacopter_DW.obj_g.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    FLIGHT_hexacopter_DW.obj_g.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_g.MW_PARAMHANDLE, MW_SINGLE,\n    &FLIGHT_hexacopter_B.ParamStep);\n  if (flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep = 0.0F;\n  }\n\n  // MATLABSystem: '<S11>/Read Parameter1'\n  if (FLIGHT_hexacopter_DW.obj_d.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    FLIGHT_hexacopter_DW.obj_d.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_d.MW_PARAMHANDLE, MW_SINGLE,\n    &FLIGHT_hexacopter_B.ParamStep_m);\n  if (flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep_m = 0.0F;\n  }\n\n  // MATLABSystem: '<S11>/Read Parameter2'\n  if (FLIGHT_hexacopter_DW.obj_k.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    FLIGHT_hexacopter_DW.obj_k.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_k.MW_PARAMHANDLE, MW_SINGLE,\n    &FLIGHT_hexacopter_B.ParamStep_c);\n  if (flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep_c = 0.0F;\n  }\n\n  // MATLAB Function: '<S11>/MATLAB Function3' incorporates:\n  //   DiscreteIntegrator: '<S11>/Discrete-Time Integrator'\n  //   MATLABSystem: '<S11>/Read Parameter'\n  //   MATLABSystem: '<S11>/Read Parameter1'\n  //   MATLABSystem: '<S11>/Read Parameter2'\n  //   Sum: '<S481>/Diff'\n  //   UnitDelay: '<S481>/UD'\n  //  *\n  //  Block description for '<S481>/Diff':\n  //\n  //   Add in CPU\n  //\n  //  Block description for '<S481>/UD':\n  //\n  //   Store in Global RAM\n\n  //  PID Like Sliding Surface\n  FLIGHT_hexacopter_B.ParamStep_c = ((FLIGHT_hexacopter_B.Product5_l -\n    FLIGHT_hexacopter_DW.UD_DSTATE_n) * FLIGHT_hexacopter_B.ParamStep_c +\n    FLIGHT_hexacopter_B.ParamStep * rtb_TmpSignalConversionAtSFun_0) +\n    FLIGHT_hexacopter_B.ParamStep_m *\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE;\n\n  // MATLABSystem: '<S11>/Read Parameter3'\n  if (FLIGHT_hexacopter_DW.obj_n.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    FLIGHT_hexacopter_DW.obj_n.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_n.MW_PARAMHANDLE, MW_SINGLE,\n    &FLIGHT_hexacopter_B.ParamStep);\n  if (flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep = 0.0F;\n  }\n\n  // MATLABSystem: '<S11>/Read Parameter4'\n  if (FLIGHT_hexacopter_DW.obj.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    FLIGHT_hexacopter_DW.obj.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj.MW_PARAMHANDLE, MW_SINGLE,\n    &FLIGHT_hexacopter_B.ParamStep_m);\n  if (flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep_m = 0.0F;\n  }\n\n  // MATLAB Function: '<S11>/MATLAB Function2'\n  flag_pos = true;\n  FLIGHT_hexacopter_B.ypr[0] = 0.0F;\n  if (rtIsInfF(FLIGHT_hexacopter_B.G1[0]) || rtIsNaNF(FLIGHT_hexacopter_B.G1[0]))\n  {\n    flag_pos = false;\n  }\n\n  if (flag_pos && (rtIsInfF(FLIGHT_hexacopter_B.G1[1]) || rtIsNaNF\n                   (FLIGHT_hexacopter_B.G1[1]))) {\n    flag_pos = false;\n  }\n\n  if (flag_pos && (rtIsInfF(FLIGHT_hexacopter_B.G1[2]) || rtIsNaNF\n                   (FLIGHT_hexacopter_B.G1[2]))) {\n    flag_pos = false;\n  }\n\n  if (!flag_pos) {\n    FLIGHT_hexacopter_B.ypr[0] = (rtNaNF);\n  } else {\n    flag_pos = false;\n    rtb_SinCos_o2 = 0.0F;\n    i = 0;\n    exitg1 = false;\n    while ((!exitg1) && (i < 3)) {\n      FLIGHT_hexacopter_B.absxk = static_cast<real32_T>(fabs(static_cast<real_T>\n        (FLIGHT_hexacopter_B.G1[i])));\n      if (rtIsNaNF(FLIGHT_hexacopter_B.absxk)) {\n        rtb_SinCos_o2 = (rtNaNF);\n        exitg1 = true;\n      } else {\n        if (FLIGHT_hexacopter_B.absxk > rtb_SinCos_o2) {\n          rtb_SinCos_o2 = FLIGHT_hexacopter_B.absxk;\n        }\n\n        i++;\n      }\n    }\n\n    FLIGHT_hexacopter_B.absxk = rtb_SinCos_o2;\n    guard1 = false;\n    if ((rtb_SinCos_o2 > 0.0F) && (rtb_SinCos_o2 < 9.09494702E-13F)) {\n      flag_pos = true;\n      FLIGHT_hexacopter_B.absxk = 9.09494702E-13F;\n      guard1 = true;\n    } else if (rtb_SinCos_o2 > 1.09951163E+12F) {\n      flag_pos = true;\n      FLIGHT_hexacopter_B.absxk = 1.09951163E+12F;\n      guard1 = true;\n    }\n\n    if (guard1) {\n      FLIGHT_hexacopter_B.cfromc = rtb_SinCos_o2;\n      FLIGHT_hexacopter_B.ctoc = FLIGHT_hexacopter_B.absxk;\n      rtb_NOT_h = true;\n      while (rtb_NOT_h) {\n        FLIGHT_hexacopter_B.b_absxk = FLIGHT_hexacopter_B.cfromc *\n          1.97215226E-31F;\n        FLIGHT_hexacopter_B.t = FLIGHT_hexacopter_B.ctoc / 5.0706024E+30F;\n        if ((FLIGHT_hexacopter_B.b_absxk > FLIGHT_hexacopter_B.ctoc) &&\n            (FLIGHT_hexacopter_B.ctoc != 0.0F)) {\n          FLIGHT_hexacopter_B.mul = 1.97215226E-31F;\n          FLIGHT_hexacopter_B.cfromc = FLIGHT_hexacopter_B.b_absxk;\n        } else if (FLIGHT_hexacopter_B.t > FLIGHT_hexacopter_B.cfromc) {\n          FLIGHT_hexacopter_B.mul = 5.0706024E+30F;\n          FLIGHT_hexacopter_B.ctoc = FLIGHT_hexacopter_B.t;\n        } else {\n          FLIGHT_hexacopter_B.mul = FLIGHT_hexacopter_B.ctoc /\n            FLIGHT_hexacopter_B.cfromc;\n          rtb_NOT_h = false;\n        }\n\n        FLIGHT_hexacopter_B.G1[0] *= FLIGHT_hexacopter_B.mul;\n        FLIGHT_hexacopter_B.G1[1] *= FLIGHT_hexacopter_B.mul;\n        FLIGHT_hexacopter_B.G1[2] *= FLIGHT_hexacopter_B.mul;\n      }\n    }\n\n    FLIGHT_hexacopter_B.ctoc = 1.29246971E-26F;\n    FLIGHT_hexacopter_B.b_absxk = static_cast<real32_T>(fabs(static_cast<real_T>\n      (FLIGHT_hexacopter_B.G1[0])));\n    if (FLIGHT_hexacopter_B.b_absxk > 1.29246971E-26F) {\n      FLIGHT_hexacopter_B.cfromc = 1.0F;\n      FLIGHT_hexacopter_B.ctoc = FLIGHT_hexacopter_B.b_absxk;\n    } else {\n      FLIGHT_hexacopter_B.t = FLIGHT_hexacopter_B.b_absxk / 1.29246971E-26F;\n      FLIGHT_hexacopter_B.cfromc = FLIGHT_hexacopter_B.t * FLIGHT_hexacopter_B.t;\n    }\n\n    FLIGHT_hexacopter_B.b_absxk = static_cast<real32_T>(fabs(static_cast<real_T>\n      (FLIGHT_hexacopter_B.G1[1])));\n    if (FLIGHT_hexacopter_B.b_absxk > FLIGHT_hexacopter_B.ctoc) {\n      FLIGHT_hexacopter_B.t = FLIGHT_hexacopter_B.ctoc /\n        FLIGHT_hexacopter_B.b_absxk;\n      FLIGHT_hexacopter_B.cfromc = FLIGHT_hexacopter_B.cfromc *\n        FLIGHT_hexacopter_B.t * FLIGHT_hexacopter_B.t + 1.0F;\n      FLIGHT_hexacopter_B.ctoc = FLIGHT_hexacopter_B.b_absxk;\n    } else {\n      FLIGHT_hexacopter_B.t = FLIGHT_hexacopter_B.b_absxk /\n        FLIGHT_hexacopter_B.ctoc;\n      FLIGHT_hexacopter_B.cfromc += FLIGHT_hexacopter_B.t *\n        FLIGHT_hexacopter_B.t;\n    }\n\n    FLIGHT_hexacopter_B.b_absxk = static_cast<real32_T>(fabs(static_cast<real_T>\n      (FLIGHT_hexacopter_B.G1[2])));\n    if (FLIGHT_hexacopter_B.b_absxk > FLIGHT_hexacopter_B.ctoc) {\n      FLIGHT_hexacopter_B.t = FLIGHT_hexacopter_B.ctoc /\n        FLIGHT_hexacopter_B.b_absxk;\n      FLIGHT_hexacopter_B.cfromc = FLIGHT_hexacopter_B.cfromc *\n        FLIGHT_hexacopter_B.t * FLIGHT_hexacopter_B.t + 1.0F;\n      FLIGHT_hexacopter_B.ctoc = FLIGHT_hexacopter_B.b_absxk;\n    } else {\n      FLIGHT_hexacopter_B.t = FLIGHT_hexacopter_B.b_absxk /\n        FLIGHT_hexacopter_B.ctoc;\n      FLIGHT_hexacopter_B.cfromc += FLIGHT_hexacopter_B.t *\n        FLIGHT_hexacopter_B.t;\n    }\n\n    FLIGHT_hexacopter_B.cfromc = FLIGHT_hexacopter_B.ctoc * static_cast<real32_T>\n      (sqrt(static_cast<real_T>(FLIGHT_hexacopter_B.cfromc)));\n    if (FLIGHT_hexacopter_B.cfromc > 0.0F) {\n      if (FLIGHT_hexacopter_B.G1[0] < 0.0F) {\n        FLIGHT_hexacopter_B.cfromc = -FLIGHT_hexacopter_B.cfromc;\n      }\n\n      if (static_cast<real32_T>(fabs(static_cast<real_T>\n            (FLIGHT_hexacopter_B.cfromc))) >= 9.86076132E-32F) {\n        FLIGHT_hexacopter_B.ctoc = 1.0F / FLIGHT_hexacopter_B.cfromc;\n        FLIGHT_hexacopter_B.G1[0] *= FLIGHT_hexacopter_B.ctoc;\n        FLIGHT_hexacopter_B.G1[1] *= FLIGHT_hexacopter_B.ctoc;\n        FLIGHT_hexacopter_B.G1[2] *= FLIGHT_hexacopter_B.ctoc;\n      } else {\n        FLIGHT_hexacopter_B.G1[0] /= FLIGHT_hexacopter_B.cfromc;\n        FLIGHT_hexacopter_B.G1[1] /= FLIGHT_hexacopter_B.cfromc;\n        FLIGHT_hexacopter_B.G1[2] /= FLIGHT_hexacopter_B.cfromc;\n      }\n\n      FLIGHT_hexacopter_B.G1[0]++;\n      FLIGHT_hexacopter_B.cfromc = -FLIGHT_hexacopter_B.cfromc;\n    } else {\n      FLIGHT_hexacopter_B.cfromc = 0.0F;\n    }\n\n    if (FLIGHT_hexacopter_B.cfromc != 0.0F) {\n      FLIGHT_hexacopter_B.ctoc = static_cast<real32_T>(fabs(static_cast<real_T>\n        (FLIGHT_hexacopter_B.cfromc)));\n      FLIGHT_hexacopter_B.b_absxk = FLIGHT_hexacopter_B.cfromc /\n        FLIGHT_hexacopter_B.ctoc;\n      FLIGHT_hexacopter_B.cfromc = FLIGHT_hexacopter_B.ctoc;\n      FLIGHT_hexacopter_B.U[0] = (-FLIGHT_hexacopter_B.G1[0] + 1.0F) *\n        FLIGHT_hexacopter_B.b_absxk;\n      FLIGHT_hexacopter_B.U[1] = FLIGHT_hexacopter_B.b_absxk *\n        -FLIGHT_hexacopter_B.G1[1];\n      FLIGHT_hexacopter_B.U[2] = FLIGHT_hexacopter_B.b_absxk *\n        -FLIGHT_hexacopter_B.G1[2];\n    } else {\n      FLIGHT_hexacopter_B.U[1] = 0.0F;\n      FLIGHT_hexacopter_B.U[2] = 0.0F;\n      FLIGHT_hexacopter_B.U[0] = 1.0F;\n    }\n\n    if (flag_pos) {\n      flag_pos = true;\n      while (flag_pos) {\n        FLIGHT_hexacopter_B.ctoc = FLIGHT_hexacopter_B.absxk * 1.97215226E-31F;\n        FLIGHT_hexacopter_B.b_absxk = rtb_SinCos_o2 / 5.0706024E+30F;\n        if ((FLIGHT_hexacopter_B.ctoc > rtb_SinCos_o2) && (rtb_SinCos_o2 != 0.0F))\n        {\n          FLIGHT_hexacopter_B.t = 1.97215226E-31F;\n          FLIGHT_hexacopter_B.absxk = FLIGHT_hexacopter_B.ctoc;\n        } else if (FLIGHT_hexacopter_B.b_absxk > FLIGHT_hexacopter_B.absxk) {\n          FLIGHT_hexacopter_B.t = 5.0706024E+30F;\n          rtb_SinCos_o2 = FLIGHT_hexacopter_B.b_absxk;\n        } else {\n          FLIGHT_hexacopter_B.t = rtb_SinCos_o2 / FLIGHT_hexacopter_B.absxk;\n          flag_pos = false;\n        }\n\n        FLIGHT_hexacopter_B.cfromc *= FLIGHT_hexacopter_B.t;\n      }\n    }\n\n    rtb_SinCos_o2 = 1.0F;\n    flag_pos = (rtIsInfF(FLIGHT_hexacopter_B.cfromc) || rtIsNaNF\n                (FLIGHT_hexacopter_B.cfromc));\n    if (flag_pos) {\n      FLIGHT_hexacopter_B.absxk = (rtNaNF);\n    } else if (FLIGHT_hexacopter_B.cfromc < 2.3509887E-38F) {\n      FLIGHT_hexacopter_B.absxk = 1.4013E-45F;\n    } else {\n      frexp(static_cast<real_T>(FLIGHT_hexacopter_B.cfromc),\n            &FLIGHT_hexacopter_B.r_k);\n      FLIGHT_hexacopter_B.absxk = static_cast<real32_T>(ldexp(1.0,\n        FLIGHT_hexacopter_B.r_k - 24));\n    }\n\n    FLIGHT_hexacopter_B.absxk *= 3.0F;\n    if (flag_pos) {\n      FLIGHT_hexacopter_B.absxk = 3.402823466E+38F;\n    }\n\n    FLIGHT_hexacopter_B.r_k = 0;\n    if (FLIGHT_hexacopter_B.cfromc > FLIGHT_hexacopter_B.absxk) {\n      FLIGHT_hexacopter_B.r_k = 1;\n    }\n\n    if (FLIGHT_hexacopter_B.r_k > 0) {\n      FLIGHT_hexacopter_B.absxk = 1.0F / FLIGHT_hexacopter_B.cfromc;\n      for (FLIGHT_hexacopter_B.r_k = 1; FLIGHT_hexacopter_B.r_k < 2;\n           FLIGHT_hexacopter_B.r_k++) {\n        rtb_SinCos_o2 *= FLIGHT_hexacopter_B.absxk;\n      }\n\n      for (FLIGHT_hexacopter_B.r_k = 0; FLIGHT_hexacopter_B.r_k < 3;\n           FLIGHT_hexacopter_B.r_k++) {\n        for (i = FLIGHT_hexacopter_B.r_k + 1; i <= FLIGHT_hexacopter_B.r_k + 1;\n             i++) {\n          FLIGHT_hexacopter_B.ypr[i - 1] = 0.0F;\n        }\n      }\n\n      FLIGHT_hexacopter_B.br = 0;\n      for (FLIGHT_hexacopter_B.r_k = 0; FLIGHT_hexacopter_B.r_k < 3;\n           FLIGHT_hexacopter_B.r_k++) {\n        FLIGHT_hexacopter_B.br++;\n        for (i = FLIGHT_hexacopter_B.br; i <= FLIGHT_hexacopter_B.br; i += 3) {\n          for (FLIGHT_hexacopter_B.b_ic = FLIGHT_hexacopter_B.r_k + 1;\n               FLIGHT_hexacopter_B.b_ic <= FLIGHT_hexacopter_B.r_k + 1;\n               FLIGHT_hexacopter_B.b_ic++) {\n            FLIGHT_hexacopter_B.ypr[FLIGHT_hexacopter_B.b_ic - 1] +=\n              FLIGHT_hexacopter_B.U[i - 1] * rtb_SinCos_o2;\n          }\n        }\n      }\n    }\n  }\n\n  // MATLAB Function: '<S11>/MATLAB Function4'\n  if (rtIsNaNF(FLIGHT_hexacopter_B.ParamStep_c)) {\n    rtb_SinCos_o2 = (rtNaNF);\n  } else if (FLIGHT_hexacopter_B.ParamStep_c < 0.0F) {\n    rtb_SinCos_o2 = -1.0F;\n  } else {\n    rtb_SinCos_o2 = (FLIGHT_hexacopter_B.ParamStep_c > 0.0F);\n  }\n\n  // MATLAB Function: '<S11>/MATLAB Function' incorporates:\n  //   RateTransition: '<Root>/Rate Transition'\n  //   Sum: '<S480>/Diff'\n  //\n  //  Block description for '<S480>/Diff':\n  //\n  //   Add in CPU\n\n  FLIGHT_hexacopter_B.absxk = (FLIGHT_hexacopter_DW.UD_DSTATE[0] *\n    FLIGHT_hexacopter_DW.RateTransition_Buffer[0] +\n    FLIGHT_hexacopter_DW.UD_DSTATE[1] *\n    FLIGHT_hexacopter_DW.RateTransition_Buffer[1]) +\n    FLIGHT_hexacopter_DW.UD_DSTATE[2] *\n    FLIGHT_hexacopter_DW.RateTransition_Buffer[2];\n\n  // MATLAB Function: '<S11>/MATLAB Function2' incorporates:\n  //   Constant: '<S477>/Constant'\n  //   Constant: '<S477>/Constant1'\n  //   Constant: '<S477>/Constant2'\n  //   MATLAB Function: '<S11>/MATLAB Function'\n  //   MATLAB Function: '<S11>/MATLAB Function4'\n  //   MATLABSystem: '<S11>/Read Parameter3'\n  //   MATLABSystem: '<S11>/Read Parameter4'\n  //   Product: '<S477>/Divide'\n  //   Product: '<S477>/Divide1'\n  //   Product: '<S477>/Divide2'\n  //   Product: '<S477>/Product'\n  //   Product: '<S477>/Product1'\n  //   Product: '<S477>/Product2'\n  //   Product: '<S477>/Product3'\n  //   Product: '<S477>/Product4'\n  //   Product: '<S477>/Product5'\n  //   RateTransition: '<Root>/Rate Transition'\n  //   Saturate: '<S11>/Saturation2'\n  //   Sum: '<S477>/Add'\n  //   Sum: '<S477>/Add1'\n  //   Sum: '<S477>/Add2'\n  //   Sum: '<S479>/Diff'\n  //   UnitDelay: '<S479>/UD'\n  //  *\n  //  Block description for '<S479>/Diff':\n  //\n  //   Add in CPU\n  //\n  //  Block description for '<S479>/UD':\n  //\n  //   Store in Global RAM\n\n  FLIGHT_hexacopter_B.ParamStep = (-(((((((FLIGHT_hexacopter_P.Jzz -\n    FLIGHT_hexacopter_P.Jxx) / FLIGHT_hexacopter_P.Jyy *\n    (FLIGHT_hexacopter_DW.RateTransition_Buffer[0] *\n     FLIGHT_hexacopter_DW.RateTransition_Buffer[2]) *\n    FLIGHT_hexacopter_B.TmpSignalConversionAtSFun_c[1] +\n    (FLIGHT_hexacopter_P.Jyy - FLIGHT_hexacopter_P.Jzz) /\n    FLIGHT_hexacopter_P.Jxx * (FLIGHT_hexacopter_DW.RateTransition_Buffer[1] *\n    FLIGHT_hexacopter_DW.RateTransition_Buffer[2])) + (FLIGHT_hexacopter_P.Jxx -\n    FLIGHT_hexacopter_P.Jyy) / FLIGHT_hexacopter_P.Jzz *\n    (FLIGHT_hexacopter_DW.RateTransition_Buffer[0] *\n     FLIGHT_hexacopter_DW.RateTransition_Buffer[1]) *\n    FLIGHT_hexacopter_B.TmpSignalConversionAtSFun_c[2]) +\n    FLIGHT_hexacopter_B.absxk) - (rtb_TmpSignalConversionAtSFun_1 -\n    FLIGHT_hexacopter_DW.UD_DSTATE_g)) + (FLIGHT_hexacopter_B.absxk - rtb_Diff_c)\n    * 0.0F) + 0.0F * rtb_TmpSignalConversionAtSFun_0) +\n    (-FLIGHT_hexacopter_B.ParamStep * rtb_SinCos_o2 -\n     FLIGHT_hexacopter_B.ParamStep_m * FLIGHT_hexacopter_B.ParamStep_c)) *\n    FLIGHT_hexacopter_B.ypr[0];\n\n  // Saturate: '<S11>/Saturation2'\n  if (FLIGHT_hexacopter_B.ParamStep > FLIGHT_hexacopter_P.Saturation2_UpperSat_i)\n  {\n    FLIGHT_hexacopter_B.ParamStep = FLIGHT_hexacopter_P.Saturation2_UpperSat_i;\n  } else if (FLIGHT_hexacopter_B.ParamStep <\n             FLIGHT_hexacopter_P.Saturation2_LowerSat_k) {\n    FLIGHT_hexacopter_B.ParamStep = FLIGHT_hexacopter_P.Saturation2_LowerSat_k;\n  }\n\n  // RateTransition: '<Root>/Rate Transition1'\n  FLIGHT_hexacopter_DW.RateTransition1_Buffer0 = FLIGHT_hexacopter_B.ParamStep;\n\n  // RateTransition: '<Root>/rate_transition_des_p'\n  FLIGHT_hexacopter_DW.rate_transition_des_p_Buffer0 =\n    FLIGHT_hexacopter_B.Switch2;\n\n  // RateTransition: '<Root>/rate_transition_des_q'\n  FLIGHT_hexacopter_DW.rate_transition_des_q_Buffer0 =\n    FLIGHT_hexacopter_B.Switch2_i;\n  FLIGHT_hexac_PX4Timestamp_n(&FLIGHT_hexacopter_B.PX4Timestamp_i);\n\n  // BusAssignment: '<S510>/Bus Assignment' incorporates:\n  //   Constant: '<S21>/Constant'\n  //   DataTypeConversion: '<S3>/Data Type Conversion9'\n  //   MATLABSystem: '<S510>/PX4 Timestamp'\n\n  FLIGHT_hexacopter_B.BusAssignment_a.timestamp =\n    FLIGHT_hexacopter_B.PX4Timestamp_i.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment_a.roll = FLIGHT_hexacopter_B.Switch2;\n  FLIGHT_hexacopter_B.BusAssignment_a.pitch = FLIGHT_hexacopter_B.Switch2_i;\n  FLIGHT_hexacopter_B.BusAssignment_a.yaw = static_cast<real32_T>\n    (FLIGHT_hexacopter_B.out_yawrate);\n  FLIGHT_hexacopter_B.BusAssignment_a.thrust_body[0] =\n    FLIGHT_hexacopter_P.Constant_Value_ll;\n  FLIGHT_hexacopter_B.BusAssignment_a.thrust_body[1] =\n    FLIGHT_hexacopter_P.Constant_Value_ll;\n  FLIGHT_hexacopter_B.BusAssignment_a.thrust_body[2] = rtb_Saturation1;\n  FLIGHT_hexacopter_B.BusAssignment_a.reset_integral = false;\n  for (i = 0; i < 7; i++) {\n    FLIGHT_hexacopter_B.BusAssignment_a._padding0[i] = 0U;\n  }\n\n  // End of BusAssignment: '<S510>/Bus Assignment'\n\n  // MATLABSystem: '<S512>/SinkBlock' incorporates:\n  //   BusAssignment: '<S510>/Bus Assignment'\n\n  uORB_write_step(FLIGHT_hexacopter_DW.obj_mq.orbMetadataObj,\n                  &FLIGHT_hexacopter_DW.obj_mq.orbAdvertiseObj,\n                  &FLIGHT_hexacopter_B.BusAssignment_a);\n\n  // RateTransition: '<Root>/rate_transition_des_r' incorporates:\n  //   DataTypeConversion: '<S3>/Data Type Conversion9'\n\n  FLIGHT_hexacopter_DW.rate_transition_des_r_Buffer0 = static_cast<real32_T>\n    (FLIGHT_hexacopter_B.out_yawrate);\n  FLIGHT_hexac_PX4Timestamp_n(&FLIGHT_hexacopter_B.PX4Timestamp_nd);\n\n  // BusAssignment: '<S504>/Bus Assignment' incorporates:\n  //   Constant: '<Root>/Constant'\n  //   DataTypeConversion: '<S3>/Data Type Conversion7'\n  //   DataTypeConversion: '<S3>/Data Type Conversion8'\n  //   DataTypeConversion: '<S3>/Data Type Conversion9'\n  //   MATLABSystem: '<S504>/PX4 Timestamp'\n\n  FLIGHT_hexacopter_B.BusAssignment_p.timestamp =\n    FLIGHT_hexacopter_B.PX4Timestamp_nd.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment_p.roll_body = static_cast<real32_T>\n    (FLIGHT_hexacopter_B.out_roll);\n  FLIGHT_hexacopter_B.BusAssignment_p.pitch_body = static_cast<real32_T>\n    (FLIGHT_hexacopter_B.out_pitch);\n  FLIGHT_hexacopter_B.BusAssignment_p.yaw_body =\n    FLIGHT_hexacopter_P.Constant_Value_a5;\n  FLIGHT_hexacopter_B.BusAssignment_p.yaw_sp_move_rate = static_cast<real32_T>\n    (FLIGHT_hexacopter_B.out_yawrate);\n  FLIGHT_hexacopter_B.BusAssignment_p.q_d[0] = 0.0F;\n  FLIGHT_hexacopter_B.BusAssignment_p.q_d[1] = 0.0F;\n  FLIGHT_hexacopter_B.BusAssignment_p.q_d[2] = 0.0F;\n  FLIGHT_hexacopter_B.BusAssignment_p.q_d[3] = 0.0F;\n  FLIGHT_hexacopter_B.BusAssignment_p.thrust_body[0] = 0.0F;\n  FLIGHT_hexacopter_B.BusAssignment_p.thrust_body[1] = 0.0F;\n  FLIGHT_hexacopter_B.BusAssignment_p.thrust_body[2] = 0.0F;\n  FLIGHT_hexacopter_B.BusAssignment_p.reset_integral = false;\n  FLIGHT_hexacopter_B.BusAssignment_p.fw_control_yaw_wheel = false;\n  FLIGHT_hexacopter_B.BusAssignment_p._padding0[0] = 0U;\n  FLIGHT_hexacopter_B.BusAssignment_p._padding0[1] = 0U;\n\n  // MATLABSystem: '<S507>/SinkBlock' incorporates:\n  //   BusAssignment: '<S504>/Bus Assignment'\n\n  uORB_write_step(FLIGHT_hexacopter_DW.obj_ez.orbMetadataObj,\n                  &FLIGHT_hexacopter_DW.obj_ez.orbAdvertiseObj,\n                  &FLIGHT_hexacopter_B.BusAssignment_p);\n  FLIGHT_hexacop_PX4Timestamp(&FLIGHT_hexacopter_B.PX4Timestamp_pn);\n\n  // BusAssignment: '<S20>/Bus Assignment' incorporates:\n  //   Constant: '<S508>/Constant'\n\n  FLIGHT_hexacopter_B.BusAssignment_g = FLIGHT_hexacopter_P.Constant_Value_n;\n\n  // BusAssignment: '<S20>/Bus Assignment' incorporates:\n  //   MATLABSystem: '<S20>/PX4 Timestamp'\n\n  FLIGHT_hexacopter_B.BusAssignment_g.timestamp =\n    FLIGHT_hexacopter_B.PX4Timestamp_pn.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment_g.vx = rtb_PProdOut_ev_idx_0;\n  FLIGHT_hexacopter_B.BusAssignment_g.vy = rtb_PProdOut_ev_idx_1;\n  FLIGHT_hexacopter_B.BusAssignment_g.vz = FLIGHT_hexacopter_B.Gain;\n  FLIGHT_hexacopter_B.BusAssignment_g.x = rtb_des_x;\n  FLIGHT_hexacopter_B.BusAssignment_g.y = rtb_des_z;\n  FLIGHT_hexacopter_B.BusAssignment_g.z = 0.0F;\n\n  // MATLABSystem: '<S509>/SinkBlock' incorporates:\n  //   BusAssignment: '<S20>/Bus Assignment'\n\n  uORB_write_step(FLIGHT_hexacopter_DW.obj_pa.orbMetadataObj,\n                  &FLIGHT_hexacopter_DW.obj_pa.orbAdvertiseObj,\n                  &FLIGHT_hexacopter_B.BusAssignment_g);\n\n  // DeadZone: '<S52>/DeadZone'\n  if (rtb_DeadZone > FLIGHT_hexacopter_P.PIDController_UpperSaturationLi) {\n    rtb_DeadZone -= FLIGHT_hexacopter_P.PIDController_UpperSaturationLi;\n  } else if (rtb_DeadZone >= FLIGHT_hexacopter_P.PIDController_LowerSaturationLi)\n  {\n    rtb_DeadZone = 0.0F;\n  } else {\n    rtb_DeadZone -= FLIGHT_hexacopter_P.PIDController_LowerSaturationLi;\n  }\n\n  // End of DeadZone: '<S52>/DeadZone'\n\n  // MATLABSystem: '<S1>/Read Parameter3'\n  if (FLIGHT_hexacopter_DW.obj_l5.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n  {\n    FLIGHT_hexacopter_DW.obj_l5.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_l5.MW_PARAMHANDLE, MW_SINGLE,\n    &FLIGHT_hexacopter_B.ParamStep);\n  if (flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep = 0.0F;\n  }\n\n  // Product: '<S57>/IProd Out' incorporates:\n  //   MATLABSystem: '<S1>/Read Parameter3'\n  //\n  FLIGHT_hexacopter_B.IProdOut_d *= FLIGHT_hexacopter_B.ParamStep;\n\n  // RateTransition: '<Root>/Rate Transition7'\n  FLIGHT_hexacopter_DW.RateTransition7_Buffer0 =\n    FLIGHT_hexacopter_B.In1_n.manual_lockdown;\n\n  // RateTransition: '<Root>/rate_transition_arm'\n  FLIGHT_hexacopter_DW.rate_transition_arm_Buffer0 =\n    FLIGHT_hexacopter_B.In1_n.armed;\n\n  // Switch: '<S50>/Switch1' incorporates:\n  //   Constant: '<S50>/Clamping_zero'\n  //   Constant: '<S50>/Constant'\n  //   Constant: '<S50>/Constant2'\n  //   RelationalOperator: '<S50>/fix for DT propagation issue'\n\n  if (rtb_DeadZone > FLIGHT_hexacopter_P.Clamping_zero_Value) {\n    tmp = FLIGHT_hexacopter_P.Constant_Value_ko;\n  } else {\n    tmp = FLIGHT_hexacopter_P.Constant2_Value_e;\n  }\n\n  // Switch: '<S50>/Switch2' incorporates:\n  //   Constant: '<S50>/Clamping_zero'\n  //   Constant: '<S50>/Constant3'\n  //   Constant: '<S50>/Constant4'\n  //   RelationalOperator: '<S50>/fix for DT propagation issue1'\n\n  if (FLIGHT_hexacopter_B.IProdOut_d > FLIGHT_hexacopter_P.Clamping_zero_Value)\n  {\n    tmp_0 = FLIGHT_hexacopter_P.Constant3_Value_i;\n  } else {\n    tmp_0 = FLIGHT_hexacopter_P.Constant4_Value_d;\n  }\n\n  // Switch: '<S50>/Switch' incorporates:\n  //   Constant: '<S50>/Clamping_zero'\n  //   Constant: '<S50>/Constant1'\n  //   Logic: '<S50>/AND3'\n  //   RelationalOperator: '<S50>/Equal1'\n  //   RelationalOperator: '<S50>/Relational Operator'\n  //   Switch: '<S50>/Switch1'\n  //   Switch: '<S50>/Switch2'\n\n  if ((FLIGHT_hexacopter_P.Clamping_zero_Value != rtb_DeadZone) && (tmp == tmp_0))\n  {\n    FLIGHT_hexacopter_B.IProdOut_d = FLIGHT_hexacopter_P.Constant1_Value_g;\n  }\n\n  // Update for DiscreteIntegrator: '<S60>/Integrator' incorporates:\n  //   Switch: '<S50>/Switch'\n\n  FLIGHT_hexacopter_DW.Integrator_DSTATE +=\n    FLIGHT_hexacopter_P.Integrator_gainval_h * FLIGHT_hexacopter_B.IProdOut_d;\n  if (FLIGHT_hexacopter_DW.Integrator_DSTATE >\n      FLIGHT_hexacopter_P.PIDController_UpperIntegratorSa) {\n    FLIGHT_hexacopter_DW.Integrator_DSTATE =\n      FLIGHT_hexacopter_P.PIDController_UpperIntegratorSa;\n  } else if (FLIGHT_hexacopter_DW.Integrator_DSTATE <\n             FLIGHT_hexacopter_P.PIDController_LowerIntegratorSa) {\n    FLIGHT_hexacopter_DW.Integrator_DSTATE =\n      FLIGHT_hexacopter_P.PIDController_LowerIntegratorSa;\n  }\n\n  FLIGHT_hexacopter_DW.Integrator_PrevResetState = static_cast<int8_T>(rtb_NOT);\n\n  // Update for DiscreteIntegrator: '<S55>/Filter' incorporates:\n  //   DiscreteIntegrator: '<S60>/Integrator'\n\n  FLIGHT_hexacopter_DW.Filter_DSTATE += FLIGHT_hexacopter_P.Filter_gainval *\n    FLIGHT_hexacopter_B.NProdOut;\n  FLIGHT_hexacopter_DW.Filter_PrevResetState = static_cast<int8_T>(rtb_NOT);\n\n  // Update for UnitDelay: '<S480>/UD' incorporates:\n  //   SampleTimeMath: '<S480>/TSamp'\n  //   Sum: '<S480>/Diff'\n  //\n  //  About '<S480>/TSamp':\n  //   y = u * K where K = 1 / ( w * Ts )\n  //    *\n  //  Block description for '<S480>/UD':\n  //\n  //   Store in Global RAM\n  //\n  //  Block description for '<S480>/Diff':\n  //\n  //   Add in CPU\n\n  FLIGHT_hexacopter_DW.UD_DSTATE[0] = FLIGHT_hexacopter_B.TSamp[0];\n  FLIGHT_hexacopter_DW.UD_DSTATE[1] = FLIGHT_hexacopter_B.TSamp[1];\n  FLIGHT_hexacopter_DW.UD_DSTATE[2] = FLIGHT_hexacopter_B.TSamp[2];\n\n  // Update for UnitDelay: '<S478>/UD'\n  //\n  //  Block description for '<S478>/UD':\n  //\n  //   Store in Global RAM\n\n  FLIGHT_hexacopter_DW.UD_DSTATE_j = rtb_Product5_m;\n\n  // Update for UnitDelay: '<S479>/UD'\n  //\n  //  Block description for '<S479>/UD':\n  //\n  //   Store in Global RAM\n\n  FLIGHT_hexacopter_DW.UD_DSTATE_g = rtb_TmpSignalConversionAtSFun_1;\n\n  // Update for UnitDelay: '<S481>/UD'\n  //\n  //  Block description for '<S481>/UD':\n  //\n  //   Store in Global RAM\n\n  FLIGHT_hexacopter_DW.UD_DSTATE_n = FLIGHT_hexacopter_B.Product5_l;\n\n  // Update for DiscreteIntegrator: '<S11>/Discrete-Time Integrator'\n  FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE +=\n    FLIGHT_hexacopter_P.DiscreteTimeIntegrator_gainva_c *\n    rtb_TmpSignalConversionAtSFun_0;\n\n  // Update absolute time\n  // The \"clockTick1\" counts the number of times the code of this task has\n  //  been executed. The resolution of this integer timer is 0.004, which is the step size\n  //  of the task. Size of \"clockTick1\" ensures timer will not overflow during the\n  //  application lifespan selected.\n\n  FLIGHT_hexacopter_M->Timing.clockTick1++;\n}\n\n// Use this function only if you need to maintain compatibility with an existing static main program.\nvoid FLIGHT_hexacopter_step(int_T tid)\n{\n  switch (tid) {\n   case 0 :\n    FLIGHT_hexacopter_step0();\n    break;\n\n   case 1 :\n    FLIGHT_hexacopter_step1();\n    break;\n\n   default :\n    // do nothing\n    break;\n  }\n}\n\n// Model initialize function\nvoid FLIGHT_hexacopter_initialize(void)\n{\n  // Registration code\n\n  // initialize non-finites\n  rt_InitInfAndNaN(sizeof(real_T));\n  rtmSetTFinal(FLIGHT_hexacopter_M, -1);\n  FLIGHT_hexacopter_M->Timing.stepSize0 = 0.001;\n\n  // External mode info\n  FLIGHT_hexacopter_M->Sizes.checksums[0] = (2104700510U);\n  FLIGHT_hexacopter_M->Sizes.checksums[1] = (3657748109U);\n  FLIGHT_hexacopter_M->Sizes.checksums[2] = (4038555708U);\n  FLIGHT_hexacopter_M->Sizes.checksums[3] = (3861511901U);\n\n  {\n    static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE;\n    static RTWExtModeInfo rt_ExtModeInfo;\n    static const sysRanDType *systemRan[97];\n    FLIGHT_hexacopter_M->extModeInfo = (&rt_ExtModeInfo);\n    rteiSetSubSystemActiveVectorAddresses(&rt_ExtModeInfo, systemRan);\n    systemRan[0] = &rtAlwaysEnabled;\n    systemRan[1] = &rtAlwaysEnabled;\n    systemRan[2] = &rtAlwaysEnabled;\n    systemRan[3] = &rtAlwaysEnabled;\n    systemRan[4] = &rtAlwaysEnabled;\n    systemRan[5] = &rtAlwaysEnabled;\n    systemRan[6] = &rtAlwaysEnabled;\n    systemRan[7] = &rtAlwaysEnabled;\n    systemRan[8] = &rtAlwaysEnabled;\n    systemRan[9] = (sysRanDType *)&FLIGHT_hexacopter_DW.CAS_SubsysRanBC;\n    systemRan[10] = (sysRanDType *)&FLIGHT_hexacopter_DW.CAS_SubsysRanBC;\n    systemRan[11] = (sysRanDType *)&FLIGHT_hexacopter_DW.CAS_SubsysRanBC;\n    systemRan[12] = (sysRanDType *)&FLIGHT_hexacopter_DW.CAS_SubsysRanBC;\n    systemRan[13] = (sysRanDType *)&FLIGHT_hexacopter_DW.CAS_SubsysRanBC;\n    systemRan[14] = (sysRanDType *)&FLIGHT_hexacopter_DW.CAS_SubsysRanBC;\n    systemRan[15] = (sysRanDType *)&FLIGHT_hexacopter_DW.CAS_SubsysRanBC;\n    systemRan[16] = &rtAlwaysEnabled;\n    systemRan[17] = &rtAlwaysEnabled;\n    systemRan[18] = &rtAlwaysEnabled;\n    systemRan[19] = &rtAlwaysEnabled;\n    systemRan[20] = &rtAlwaysEnabled;\n    systemRan[21] = &rtAlwaysEnabled;\n    systemRan[22] = &rtAlwaysEnabled;\n    systemRan[23] = &rtAlwaysEnabled;\n    systemRan[24] = &rtAlwaysEnabled;\n    systemRan[25] = &rtAlwaysEnabled;\n    systemRan[26] = &rtAlwaysEnabled;\n    systemRan[27] = &rtAlwaysEnabled;\n    systemRan[28] = &rtAlwaysEnabled;\n    systemRan[29] = &rtAlwaysEnabled;\n    systemRan[30] = &rtAlwaysEnabled;\n    systemRan[31] = &rtAlwaysEnabled;\n    systemRan[32] = &rtAlwaysEnabled;\n    systemRan[33] = &rtAlwaysEnabled;\n    systemRan[34] = &rtAlwaysEnabled;\n    systemRan[35] = &rtAlwaysEnabled;\n    systemRan[36] = &rtAlwaysEnabled;\n    systemRan[37] = &rtAlwaysEnabled;\n    systemRan[38] = &rtAlwaysEnabled;\n    systemRan[39] = &rtAlwaysEnabled;\n    systemRan[40] = &rtAlwaysEnabled;\n    systemRan[41] = &rtAlwaysEnabled;\n    systemRan[42] = &rtAlwaysEnabled;\n    systemRan[43] = (sysRanDType *)&FLIGHT_hexacopter_DW.Mixer_SubsysRanBC;\n    systemRan[44] = (sysRanDType *)&FLIGHT_hexacopter_DW.Mixer_SubsysRanBC;\n    systemRan[45] = &rtAlwaysEnabled;\n    systemRan[46] = (sysRanDType *)\n      &FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC_k;\n    systemRan[47] = &rtAlwaysEnabled;\n    systemRan[48] = (sysRanDType *)\n      &FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC_l;\n    systemRan[49] = &rtAlwaysEnabled;\n    systemRan[50] = (sysRanDType *)\n      &FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC_o;\n    systemRan[51] = &rtAlwaysEnabled;\n    systemRan[52] = (sysRanDType *)&FLIGHT_hexacopter_DW.SAS_SubsysRanBC;\n    systemRan[53] = (sysRanDType *)&FLIGHT_hexacopter_DW.SAS_SubsysRanBC;\n    systemRan[54] = (sysRanDType *)&FLIGHT_hexacopter_DW.SAS_SubsysRanBC;\n    systemRan[55] = (sysRanDType *)&FLIGHT_hexacopter_DW.SAS_SubsysRanBC;\n    systemRan[56] = (sysRanDType *)&FLIGHT_hexacopter_DW.SAS_SubsysRanBC;\n    systemRan[57] = (sysRanDType *)&FLIGHT_hexacopter_DW.SAS_SubsysRanBC;\n    systemRan[58] = (sysRanDType *)&FLIGHT_hexacopter_DW.SAS_SubsysRanBC;\n    systemRan[59] = (sysRanDType *)&FLIGHT_hexacopter_DW.SAS_SubsysRanBC;\n    systemRan[60] = (sysRanDType *)&FLIGHT_hexacopter_DW.SAS_SubsysRanBC;\n    systemRan[61] = (sysRanDType *)&FLIGHT_hexacopter_DW.SAS_SubsysRanBC;\n    systemRan[62] = (sysRanDType *)&FLIGHT_hexacopter_DW.SAS_SubsysRanBC;\n    systemRan[63] = (sysRanDType *)&FLIGHT_hexacopter_DW.SAS_SubsysRanBC;\n    systemRan[64] = (sysRanDType *)&FLIGHT_hexacopter_DW.SAS_SubsysRanBC;\n    systemRan[65] = &rtAlwaysEnabled;\n    systemRan[66] = &rtAlwaysEnabled;\n    systemRan[67] = &rtAlwaysEnabled;\n    systemRan[68] = &rtAlwaysEnabled;\n    systemRan[69] = &rtAlwaysEnabled;\n    systemRan[70] = &rtAlwaysEnabled;\n    systemRan[71] = &rtAlwaysEnabled;\n    systemRan[72] = &rtAlwaysEnabled;\n    systemRan[73] = &rtAlwaysEnabled;\n    systemRan[74] = &rtAlwaysEnabled;\n    systemRan[75] = &rtAlwaysEnabled;\n    systemRan[76] = &rtAlwaysEnabled;\n    systemRan[77] = &rtAlwaysEnabled;\n    systemRan[78] = &rtAlwaysEnabled;\n    systemRan[79] = &rtAlwaysEnabled;\n    systemRan[80] = &rtAlwaysEnabled;\n    systemRan[81] = &rtAlwaysEnabled;\n    systemRan[82] = &rtAlwaysEnabled;\n    systemRan[83] = &rtAlwaysEnabled;\n    systemRan[84] = (sysRanDType *)\n      &FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC_c;\n    systemRan[85] = &rtAlwaysEnabled;\n    systemRan[86] = &rtAlwaysEnabled;\n    systemRan[87] = (sysRanDType *)\n      &FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC_j;\n    systemRan[88] = &rtAlwaysEnabled;\n    systemRan[89] = (sysRanDType *)\n      &FLIGHT_hexacopter_DW.EnabledSubsystem_SubsysRanBC;\n    systemRan[90] = &rtAlwaysEnabled;\n    systemRan[91] = &rtAlwaysEnabled;\n    systemRan[92] = &rtAlwaysEnabled;\n    systemRan[93] = &rtAlwaysEnabled;\n    systemRan[94] = &rtAlwaysEnabled;\n    systemRan[95] = &rtAlwaysEnabled;\n    systemRan[96] = &rtAlwaysEnabled;\n    rteiSetModelMappingInfoPtr(FLIGHT_hexacopter_M->extModeInfo,\n      &FLIGHT_hexacopter_M->SpecialInfo.mappingInfo);\n    rteiSetChecksumsPtr(FLIGHT_hexacopter_M->extModeInfo,\n                        FLIGHT_hexacopter_M->Sizes.checksums);\n    rteiSetTPtr(FLIGHT_hexacopter_M->extModeInfo, rtmGetTPtr(FLIGHT_hexacopter_M));\n  }\n\n  {\n    static const char_T ParameterNameStr[14] = \"FDD_M1_STATUS\";\n    static const char_T ParameterNameStr_0[14] = \"FDD_M2_STATUS\";\n    static const char_T ParameterNameStr_1[14] = \"FDD_M3_STATUS\";\n    static const char_T ParameterNameStr_2[14] = \"FDD_M4_STATUS\";\n    static const char_T ParameterNameStr_3[14] = \"FDD_M5_STATUS\";\n    static const char_T ParameterNameStr_4[14] = \"FDD_M6_STATUS\";\n    static const char_T ParameterNameStr_5[16] = \"MPC_Z_VEL_P_ACC\";\n    static const char_T ParameterNameStr_6[16] = \"MPC_Z_VEL_D_ACC\";\n    static const char_T ParameterNameStr_7[14] = \"MPC_THR_HOVER\";\n    static const char_T ParameterNameStr_8[17] = \"DOUBLET_PEAK_ANG\";\n    static const char_T ParameterNameStr_9[11] = \"DOUBLET_DT\";\n    static const char_T ParameterNameStr_a[13] = \"DOUBLET_AXIS\";\n    static const char_T ParameterNameStr_b[8] = \"K_SMC_P\";\n    static const char_T ParameterNameStr_c[8] = \"K_SMC_I\";\n    static const char_T ParameterNameStr_d[8] = \"K_SMC_D\";\n    static const char_T ParameterNameStr_e[10] = \"K_REACH_S\";\n    static const char_T ParameterNameStr_f[10] = \"K_REACH_P\";\n    static const char_T ParameterNameStr_g[16] = \"MPC_Z_VEL_I_ACC\";\n    static const char_T ParameterNameStr_h[16] = \"MC_ROLLRATE_MAX\";\n    static const char_T ParameterNameStr_i[10] = \"MC_ROLL_P\";\n    static const char_T ParameterNameStr_j[17] = \"MC_PITCHRATE_MAX\";\n    static const char_T ParameterNameStr_k[11] = \"MC_PITCH_P\";\n    static const char_T ParameterNameStr_l[9] = \"MPC_XY_P\";\n    static const char_T ParameterNameStr_m[17] = \"MPC_XY_VEL_P_ACC\";\n    static const char_T ParameterNameStr_n[17] = \"IMU_DGYRO_CUTOFF\";\n    static const char_T ParameterNameStr_o[15] = \"MC_PITCHRATE_D\";\n    static const char_T ParameterNameStr_p[15] = \"MC_PITCHRATE_P\";\n    static const char_T ParameterNameStr_q[15] = \"MC_PITCHRATE_I\";\n    static const char_T ParameterNameStr_r[14] = \"MC_ROLLRATE_D\";\n    static const char_T ParameterNameStr_s[14] = \"MC_ROLLRATE_P\";\n    static const char_T ParameterNameStr_t[14] = \"MC_ROLLRATE_I\";\n    static const char_T ParameterNameStr_u[13] = \"MC_YAWRATE_D\";\n    static const char_T ParameterNameStr_v[13] = \"MC_YAWRATE_P\";\n    static const char_T ParameterNameStr_w[14] = \"MC_YAWRATE_FF\";\n    static const char_T ParameterNameStr_x[13] = \"MC_YAWRATE_I\";\n    real_T tmp;\n    int32_T i;\n\n    // Start for RateTransition: '<Root>/rate_transition_arm'\n    FLIGHT_hexacopter_B.rate_transition_arm =\n      FLIGHT_hexacopter_P.rate_transition_arm_InitialCond;\n\n    // Start for RateTransition: '<Root>/rate_transition_des_p'\n    FLIGHT_hexacopter_B.rate_transition_des_p =\n      FLIGHT_hexacopter_P.rate_transition_des_p_InitialCo;\n\n    // Start for RateTransition: '<Root>/rate_transition_des_q'\n    FLIGHT_hexacopter_B.rate_transition_des_q =\n      FLIGHT_hexacopter_P.rate_transition_des_q_InitialCo;\n\n    // Start for RateTransition: '<Root>/rate_transition_des_r'\n    FLIGHT_hexacopter_B.rate_transition_des_r =\n      FLIGHT_hexacopter_P.rate_transition_des_r_InitialCo;\n\n    // Start for RateTransition: '<Root>/Rate Transition1'\n    FLIGHT_hexacopter_B.RateTransition1 =\n      FLIGHT_hexacopter_P.RateTransition1_InitialConditio;\n\n    // Start for RateTransition: '<Root>/rate_transition_ctrl_sw'\n    FLIGHT_hexacopter_B.rate_transition_ctrl_sw =\n      FLIGHT_hexacopter_P.rate_transition_ctrl_sw_Initial;\n\n    // Start for RateTransition: '<Root>/rate_transition_throttle'\n    FLIGHT_hexacopter_B.rate_transition_throttle =\n      FLIGHT_hexacopter_P.rate_transition_throttle_Initia;\n\n    // Start for RateTransition: '<Root>/Rate Transition4'\n    FLIGHT_hexacopter_B.RateTransition4 =\n      FLIGHT_hexacopter_P.RateTransition4_InitialConditio;\n\n    // Start for RateTransition: '<Root>/Rate Transition7'\n    FLIGHT_hexacopter_B.RateTransition7 =\n      FLIGHT_hexacopter_P.RateTransition7_InitialConditio;\n\n    // InitializeConditions for RateTransition: '<Root>/rate_transition_arm'\n    FLIGHT_hexacopter_DW.rate_transition_arm_Buffer0 =\n      FLIGHT_hexacopter_P.rate_transition_arm_InitialCond;\n\n    // InitializeConditions for RateTransition: '<Root>/rate_transition_des_p'\n    FLIGHT_hexacopter_DW.rate_transition_des_p_Buffer0 =\n      FLIGHT_hexacopter_P.rate_transition_des_p_InitialCo;\n\n    // InitializeConditions for RateTransition: '<Root>/rate_transition_des_q'\n    FLIGHT_hexacopter_DW.rate_transition_des_q_Buffer0 =\n      FLIGHT_hexacopter_P.rate_transition_des_q_InitialCo;\n\n    // InitializeConditions for RateTransition: '<Root>/rate_transition_des_r'\n    FLIGHT_hexacopter_DW.rate_transition_des_r_Buffer0 =\n      FLIGHT_hexacopter_P.rate_transition_des_r_InitialCo;\n\n    // InitializeConditions for RateTransition: '<Root>/Rate Transition1'\n    FLIGHT_hexacopter_DW.RateTransition1_Buffer0 =\n      FLIGHT_hexacopter_P.RateTransition1_InitialConditio;\n\n    // InitializeConditions for RateTransition: '<Root>/rate_transition_ctrl_sw' \n    FLIGHT_hexacopter_DW.rate_transition_ctrl_sw_Buffer0 =\n      FLIGHT_hexacopter_P.rate_transition_ctrl_sw_Initial;\n\n    // InitializeConditions for RateTransition: '<Root>/rate_transition_throttle' \n    FLIGHT_hexacopter_DW.rate_transition_throttle_Buffer =\n      FLIGHT_hexacopter_P.rate_transition_throttle_Initia;\n\n    // InitializeConditions for RateTransition: '<Root>/Rate Transition4'\n    FLIGHT_hexacopter_DW.RateTransition4_Buffer0 =\n      FLIGHT_hexacopter_P.RateTransition4_InitialConditio;\n\n    // InitializeConditions for RateTransition: '<Root>/Rate Transition7'\n    FLIGHT_hexacopter_DW.RateTransition7_Buffer0 =\n      FLIGHT_hexacopter_P.RateTransition7_InitialConditio;\n\n    // InitializeConditions for DiscreteIntegrator: '<S60>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE =\n      FLIGHT_hexacopter_P.PIDController_InitialConditio_a;\n\n    // InitializeConditions for DiscreteIntegrator: '<S55>/Filter'\n    FLIGHT_hexacopter_DW.Filter_DSTATE =\n      FLIGHT_hexacopter_P.PIDController_InitialConditionF;\n\n    // InitializeConditions for UnitDelay: '<S480>/UD' incorporates:\n    //   Sum: '<S480>/Diff'\n    //\n    //  Block description for '<S480>/UD':\n    //\n    //   Store in Global RAM\n    //\n    //  Block description for '<S480>/Diff':\n    //\n    //   Add in CPU\n\n    FLIGHT_hexacopter_DW.UD_DSTATE[0] =\n      FLIGHT_hexacopter_P.DiscreteDerivative2_ICPrevSca_a;\n    FLIGHT_hexacopter_DW.UD_DSTATE[1] =\n      FLIGHT_hexacopter_P.DiscreteDerivative2_ICPrevSca_a;\n    FLIGHT_hexacopter_DW.UD_DSTATE[2] =\n      FLIGHT_hexacopter_P.DiscreteDerivative2_ICPrevSca_a;\n\n    // InitializeConditions for UnitDelay: '<S478>/UD'\n    //\n    //  Block description for '<S478>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_j =\n      FLIGHT_hexacopter_P.DiscreteDerivative_ICPrevScaled;\n\n    // InitializeConditions for UnitDelay: '<S479>/UD'\n    //\n    //  Block description for '<S479>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_g =\n      FLIGHT_hexacopter_P.DiscreteDerivative1_ICPrevScale;\n\n    // InitializeConditions for UnitDelay: '<S481>/UD'\n    //\n    //  Block description for '<S481>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_n =\n      FLIGHT_hexacopter_P.DiscreteDerivative3_ICPrevScale;\n\n    // InitializeConditions for DiscreteIntegrator: '<S11>/Discrete-Time Integrator' \n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE =\n      FLIGHT_hexacopter_P.DiscreteTimeIntegrator_IC;\n\n    // SystemInitialize for Enabled SubSystem: '<Root>/CAS'\n    // Start for MATLABSystem: '<S2>/Read Parameter9'\n    FLIGHT_hexacopter_DW.obj_k4.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_k4.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_k4.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_k4.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_k4.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_k4.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_h[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_k4.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S2>/Read Parameter9'\n\n    // Start for MATLABSystem: '<S2>/Read Parameter'\n    FLIGHT_hexacopter_DW.obj_jz.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_jz.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_jz.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_jz.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_jz.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_jz.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_i[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_jz.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S2>/Read Parameter'\n\n    // Start for MATLABSystem: '<S2>/Read Parameter10'\n    FLIGHT_hexacopter_DW.obj_ds.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_ds.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_ds.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_ds.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_ds.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_ds.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_j[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_ds.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S2>/Read Parameter10'\n\n    // Start for MATLABSystem: '<S2>/Read Parameter1'\n    FLIGHT_hexacopter_DW.obj_o.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_o.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_o.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_o.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_o.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_o.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_k[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_o.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S2>/Read Parameter1'\n\n    // SystemInitialize for Switch: '<S173>/Switch2' incorporates:\n    //   Outport: '<S2>/des_p'\n\n    FLIGHT_hexacopter_B.Switch2 = FLIGHT_hexacopter_P.des_p_Y0;\n\n    // SystemInitialize for Switch: '<S122>/Switch2' incorporates:\n    //   Outport: '<S2>/des_q'\n\n    FLIGHT_hexacopter_B.Switch2_i = FLIGHT_hexacopter_P.des_q_Y0;\n\n    // End of SystemInitialize for SubSystem: '<Root>/CAS'\n\n    // SystemInitialize for MATLAB Function: '<S3>/MATLAB Function'\n    FLIGHT_hexacopter_DW.start_time_usec = -1.0;\n\n    // InitializeConditions for DiscreteIntegrator: '<S5>/Discrete-Time Integrator' \n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_IC_LOADI = 1U;\n\n    // InitializeConditions for DiscreteIntegrator: '<S5>/Discrete-Time Integrator1' \n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_IC_LOAD = 1U;\n\n    // Start for MATLABSystem: '<S194>/Read Parameter'\n    FLIGHT_hexacopter_DW.obj_eq.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_eq.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_eq.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_eq.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_eq.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_eq.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_l[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_eq.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S194>/Read Parameter'\n\n    // Start for MATLABSystem: '<S195>/Read Parameter'\n    FLIGHT_hexacopter_DW.obj_pi.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_pi.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_pi.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_pi.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_pi.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_pi.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_m[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_pi.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S195>/Read Parameter'\n    // End of SystemInitialize for SubSystem: '<Root>/If Action Subsystem'\n\n    // SystemInitialize for Enabled SubSystem: '<Root>/Mixer'\n    for (i = 0; i < 6; i++) {\n      // SystemInitialize for Saturate: '<S7>/Output_Limits1' incorporates:\n      //   Outport: '<S7>/PWM'\n\n      FLIGHT_hexacopter_B.Output_Limits1[i] = FLIGHT_hexacopter_P.PWM_Y0;\n    }\n\n    // End of SystemInitialize for SubSystem: '<Root>/Mixer'\n\n    // SystemInitialize for Enabled SubSystem: '<S301>/Enabled Subsystem'\n    // SystemInitialize for SignalConversion generated from: '<S303>/In1' incorporates:\n    //   Outport: '<S303>/Out1'\n\n    FLIGHT_hexacopter_B.In1 = FLIGHT_hexacopter_P.Out1_Y0;\n\n    // End of SystemInitialize for SubSystem: '<S301>/Enabled Subsystem'\n\n    // SystemInitialize for Enabled SubSystem: '<S304>/Enabled Subsystem'\n    // SystemInitialize for SignalConversion generated from: '<S305>/In1' incorporates:\n    //   Outport: '<S305>/Out1'\n\n    FLIGHT_hexacopter_B.In1_k = FLIGHT_hexacopter_P.Out1_Y0_d;\n\n    // End of SystemInitialize for SubSystem: '<S304>/Enabled Subsystem'\n\n    // SystemInitialize for Enabled SubSystem: '<S306>/Enabled Subsystem'\n    // SystemInitialize for SignalConversion generated from: '<S307>/In1' incorporates:\n    //   Outport: '<S307>/Out1'\n\n    FLIGHT_hexacopter_B.In1_i = FLIGHT_hexacopter_P.Out1_Y0_o;\n\n    // End of SystemInitialize for SubSystem: '<S306>/Enabled Subsystem'\n\n    // SystemInitialize for Enabled SubSystem: '<Root>/SAS'\n    // InitializeConditions for UnitDelay: '<S315>/Unit Delay1'\n    FLIGHT_hexacopter_DW.UnitDelay1_DSTATE =\n      FLIGHT_hexacopter_P.UnitDelay1_InitialCondition;\n\n    // InitializeConditions for UnitDelay: '<S315>/Unit Delay2'\n    FLIGHT_hexacopter_DW.UnitDelay2_DSTATE =\n      FLIGHT_hexacopter_P.UnitDelay2_InitialCondition;\n\n    // InitializeConditions for UnitDelay: '<S312>/UD'\n    //\n    //  Block description for '<S312>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_l =\n      FLIGHT_hexacopter_P.DiscreteDerivative2_ICPrevScale;\n\n    // InitializeConditions for DiscreteIntegrator: '<S350>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_p =\n      FLIGHT_hexacopter_P.pid_ctrl_rollrate_InitialCondit;\n\n    // InitializeConditions for UnitDelay: '<S370>/Unit Delay1'\n    FLIGHT_hexacopter_DW.UnitDelay1_DSTATE_f =\n      FLIGHT_hexacopter_P.UnitDelay1_InitialCondition_p;\n\n    // InitializeConditions for UnitDelay: '<S370>/Unit Delay2'\n    FLIGHT_hexacopter_DW.UnitDelay2_DSTATE_c =\n      FLIGHT_hexacopter_P.UnitDelay2_InitialCondition_e;\n\n    // InitializeConditions for UnitDelay: '<S367>/UD'\n    //\n    //  Block description for '<S367>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_m =\n      FLIGHT_hexacopter_P.DiscreteDerivative2_ICPrevSca_n;\n\n    // InitializeConditions for DiscreteIntegrator: '<S405>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_c =\n      FLIGHT_hexacopter_P.pid_ctrl_rollrate_InitialCond_j;\n\n    // InitializeConditions for UnitDelay: '<S425>/Unit Delay1'\n    FLIGHT_hexacopter_DW.UnitDelay1_DSTATE_e =\n      FLIGHT_hexacopter_P.UnitDelay1_InitialCondition_e;\n\n    // InitializeConditions for UnitDelay: '<S425>/Unit Delay2'\n    FLIGHT_hexacopter_DW.UnitDelay2_DSTATE_e =\n      FLIGHT_hexacopter_P.UnitDelay2_InitialCondition_m;\n\n    // InitializeConditions for UnitDelay: '<S422>/UD'\n    //\n    //  Block description for '<S422>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_jy =\n      FLIGHT_hexacopter_P.DiscreteDerivative2_ICPrevSca_o;\n\n    // InitializeConditions for DiscreteIntegrator: '<S460>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_g =\n      FLIGHT_hexacopter_P.pid_ctrl_rollrate_InitialCond_p;\n\n    // Start for MATLABSystem: '<S10>/Read Parameter10'\n    FLIGHT_hexacopter_DW.obj_c.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_c.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_c.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_c.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_c.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_c.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_n[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_c.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter10'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter5'\n    FLIGHT_hexacopter_DW.obj_h.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_h.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_h.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_h.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_h.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_h.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_o[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_h.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter5'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter3'\n    FLIGHT_hexacopter_DW.obj_b.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_b.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_b.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_b.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_b.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_b.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_p[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_b.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter3'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter4'\n    FLIGHT_hexacopter_DW.obj_p.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_p.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_p.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_p.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_p.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_p.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_q[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_p.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter4'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter2'\n    FLIGHT_hexacopter_DW.obj_da.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_da.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_da.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_da.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_da.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_da.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_r[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_da.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter2'\n\n    // Start for MATLABSystem: '<S10>/read_mc_rollrate_p'\n    FLIGHT_hexacopter_DW.obj_i.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_i.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_i.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_i.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_i.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_i.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_s[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_i.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/read_mc_rollrate_p'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter1'\n    FLIGHT_hexacopter_DW.obj_ea.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_ea.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_ea.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_ea.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_ea.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_ea.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_t[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_ea.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter1'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter8'\n    FLIGHT_hexacopter_DW.obj_i4.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_i4.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_i4.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_i4.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_i4.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_i4.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_u[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_i4.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter8'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter6'\n    FLIGHT_hexacopter_DW.obj_a.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_a.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_a.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_a.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_a.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_a.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_v[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_a.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter6'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter9'\n    FLIGHT_hexacopter_DW.obj_e.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_e.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_e.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_e.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_e.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_e.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_w[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_e.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter9'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter7'\n    FLIGHT_hexacopter_DW.obj_j.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_j.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_j.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_j.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_j.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_j.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_x[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_j.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter7'\n\n    // SystemInitialize for Sum: '<S310>/Sum5' incorporates:\n    //   Outport: '<S10>/tau_roll'\n\n    FLIGHT_hexacopter_B.Sum5_d = FLIGHT_hexacopter_P.tau_roll_Y0;\n\n    // SystemInitialize for Sum: '<S309>/Sum5' incorporates:\n    //   Outport: '<S10>/tau_pitch'\n\n    FLIGHT_hexacopter_B.Sum5 = FLIGHT_hexacopter_P.tau_pitch_Y0;\n\n    // SystemInitialize for Sum: '<S10>/Sum' incorporates:\n    //   Outport: '<S10>/tau_yaw'\n\n    FLIGHT_hexacopter_B.Sum = FLIGHT_hexacopter_P.tau_yaw_Y0;\n\n    // End of SystemInitialize for SubSystem: '<Root>/SAS'\n    // SystemInitialize for Enabled SubSystem: '<S497>/Enabled Subsystem'\n    // SystemInitialize for SignalConversion generated from: '<S498>/In1' incorporates:\n    //   Outport: '<S498>/Out1'\n\n    FLIGHT_hexacopter_B.In1_h = FLIGHT_hexacopter_P.Out1_Y0_p;\n\n    // End of SystemInitialize for SubSystem: '<S497>/Enabled Subsystem'\n\n    // SystemInitialize for Enabled SubSystem: '<S501>/Enabled Subsystem'\n    // SystemInitialize for SignalConversion generated from: '<S503>/In1' incorporates:\n    //   Outport: '<S503>/Out1'\n\n    FLIGHT_hexacopter_B.In1_f = FLIGHT_hexacopter_P.Out1_Y0_a;\n\n    // End of SystemInitialize for SubSystem: '<S501>/Enabled Subsystem'\n\n    // SystemInitialize for Enabled SubSystem: '<S500>/Enabled Subsystem'\n    // SystemInitialize for SignalConversion generated from: '<S502>/In1' incorporates:\n    //   Outport: '<S502>/Out1'\n\n    FLIGHT_hexacopter_B.In1_n = FLIGHT_hexacopter_P.Out1_Y0_h;\n\n    // End of SystemInitialize for SubSystem: '<S500>/Enabled Subsystem'\n\n    // Start for MATLABSystem: '<S497>/SourceBlock'\n    FLIGHT_hexacopter_DW.obj_pe.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_pe.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_pe.orbMetadataObj = ORB_ID(vehicle_angular_velocity);\n    uORB_read_initialize(FLIGHT_hexacopter_DW.obj_pe.orbMetadataObj,\n                         &FLIGHT_hexacopter_DW.obj_pe.eventStructObj);\n    FLIGHT_hexacopter_DW.obj_pe.isSetupComplete = true;\n\n    // Start for MATLABSystem: '<S4>/Read Parameter13'\n    FLIGHT_hexacopter_DW.obj_gv.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_gv.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_gv.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_gv.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_gv.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_gv.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_gv.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter13'\n\n    // Start for MATLABSystem: '<S4>/Read Parameter1'\n    FLIGHT_hexacopter_DW.obj_j5.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_j5.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_j5.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_j5.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_j5.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_j5.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_0[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_j5.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter1'\n\n    // Start for MATLABSystem: '<S4>/Read Parameter2'\n    FLIGHT_hexacopter_DW.obj_ao.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_ao.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_ao.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_ao.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_ao.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_ao.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_1[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_ao.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter2'\n\n    // Start for MATLABSystem: '<S4>/Read Parameter3'\n    FLIGHT_hexacopter_DW.obj_nt.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_nt.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_nt.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_nt.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_nt.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_nt.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_2[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_nt.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter3'\n\n    // Start for MATLABSystem: '<S4>/Read Parameter4'\n    FLIGHT_hexacopter_DW.obj_cx.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_cx.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_cx.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_cx.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_cx.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_cx.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_3[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_cx.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter4'\n\n    // Start for MATLABSystem: '<S4>/Read Parameter5'\n    FLIGHT_hexacopter_DW.obj_aq.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_aq.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_aq.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_aq.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_aq.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_aq.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_4[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_aq.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter5'\n\n    // Start for MATLABSystem: '<Root>/PX4 PWM Output'\n    FLIGHT_hexacopter_DW.obj_dl.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_dl.isSetupComplete = false;\n    FLIGHT_hexacopter_DW.obj_dl.isInitialized = 1;\n    FLIGHT_hexacopter_PWM_setupImpl(&FLIGHT_hexacopter_DW.obj_dl, false, false);\n    FLIGHT_hexacopter_DW.obj_dl.isSetupComplete = true;\n    FLIGHT__PX4Timestamp_b_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_n);\n    FLIGHT__PX4Timestamp_b_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_p);\n\n    // Start for MATLABSystem: '<S496>/SinkBlock' incorporates:\n    //   BusAssignment: '<S494>/Bus Assignment'\n\n    FLIGHT_hexacopter_DW.obj_hf.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_hf.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_hf.orbMetadataObj = ORB_ID(actuator_motors);\n    uORB_write_initialize(FLIGHT_hexacopter_DW.obj_hf.orbMetadataObj,\n                          &FLIGHT_hexacopter_DW.obj_hf.orbAdvertiseObj,\n                          &FLIGHT_hexacopter_B.BusAssignment, 1);\n    FLIGHT_hexacopter_DW.obj_hf.isSetupComplete = true;\n    FLIGHT__PX4Timestamp_b_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_o);\n\n    // Start for MATLABSystem: '<S492>/SinkBlock' incorporates:\n    //   BusAssignment: '<S490>/Bus Assignment'\n\n    FLIGHT_hexacopter_DW.obj_jk.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_jk.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_jk.orbMetadataObj = ORB_ID\n      (actuator_controls_status_0);\n    uORB_write_initialize(FLIGHT_hexacopter_DW.obj_jk.orbMetadataObj,\n                          &FLIGHT_hexacopter_DW.obj_jk.orbAdvertiseObj,\n                          &FLIGHT_hexacopter_B.BusAssignment_gi, 1);\n    FLIGHT_hexacopter_DW.obj_jk.isSetupComplete = true;\n\n    // Start for MATLABSystem: '<S306>/SourceBlock'\n    FLIGHT_hexacopter_DW.obj_n2.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_n2.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_n2.orbMetadataObj = ORB_ID(input_rc);\n    uORB_read_initialize(FLIGHT_hexacopter_DW.obj_n2.orbMetadataObj,\n                         &FLIGHT_hexacopter_DW.obj_n2.eventStructObj);\n    FLIGHT_hexacopter_DW.obj_n2.isSetupComplete = true;\n\n    // Start for MATLABSystem: '<S304>/SourceBlock'\n    FLIGHT_hexacopter_DW.obj_ab.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_ab.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_ab.orbMetadataObj = ORB_ID(vehicle_odometry);\n    uORB_read_initialize(FLIGHT_hexacopter_DW.obj_ab.orbMetadataObj,\n                         &FLIGHT_hexacopter_DW.obj_ab.eventStructObj);\n    FLIGHT_hexacopter_DW.obj_ab.isSetupComplete = true;\n\n    // Start for MATLABSystem: '<S500>/SourceBlock'\n    FLIGHT_hexacopter_DW.obj_hm.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_hm.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_hm.orbMetadataObj = ORB_ID(actuator_armed);\n    uORB_read_initialize(FLIGHT_hexacopter_DW.obj_hm.orbMetadataObj,\n                         &FLIGHT_hexacopter_DW.obj_hm.eventStructObj);\n    FLIGHT_hexacopter_DW.obj_hm.isSetupComplete = true;\n\n    // Start for MATLABSystem: '<S301>/SourceBlock'\n    FLIGHT_hexacopter_DW.obj_kk.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_kk.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_kk.orbMetadataObj = ORB_ID(vehicle_local_position);\n    uORB_read_initialize(FLIGHT_hexacopter_DW.obj_kk.orbMetadataObj,\n                         &FLIGHT_hexacopter_DW.obj_kk.eventStructObj);\n    FLIGHT_hexacopter_DW.obj_kk.isSetupComplete = true;\n\n    // Start for MATLABSystem: '<S1>/Read Parameter2'\n    FLIGHT_hexacopter_DW.obj_in.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_in.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_in.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_in.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_in.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_in.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_5[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_in.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S1>/Read Parameter2'\n\n    // Start for MATLABSystem: '<S1>/Read Parameter4'\n    FLIGHT_hexacopter_DW.obj_lx.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_lx.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_lx.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_lx.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_lx.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_lx.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_6[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_lx.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S1>/Read Parameter4'\n\n    // Start for MATLABSystem: '<S1>/Read Parameter1'\n    FLIGHT_hexacopter_DW.obj_m.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_m.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_m.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_m.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_m.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_m.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_7[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_m.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S1>/Read Parameter1'\n\n    // Start for MATLABSystem: '<S501>/SourceBlock'\n    FLIGHT_hexacopter_DW.obj_bw.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_bw.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_bw.orbMetadataObj = ORB_ID(vehicle_status);\n    uORB_read_initialize(FLIGHT_hexacopter_DW.obj_bw.orbMetadataObj,\n                         &FLIGHT_hexacopter_DW.obj_bw.eventStructObj);\n    FLIGHT_hexacopter_DW.obj_bw.isSetupComplete = true;\n    FLIGHT_he_PX4Timestamp_Init(&FLIGHT_hexacopter_DW.PX4Timestamp);\n\n    // Start for MATLABSystem: '<S3>/Read Parameter1'\n    FLIGHT_hexacopter_DW.obj_ct.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_ct.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_ct.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_ct.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_ct.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_ct.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_8[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_ct.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S3>/Read Parameter1'\n\n    // Start for MATLABSystem: '<S3>/Read Parameter'\n    FLIGHT_hexacopter_DW.obj_cf.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_cf.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_cf.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_cf.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_cf.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_cf.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_9[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_cf.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S3>/Read Parameter'\n\n    // Start for MATLABSystem: '<S3>/Read Parameter2'\n    FLIGHT_hexacopter_DW.obj_l.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_l.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_l.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_l.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_l.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_l.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_a[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_l.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S3>/Read Parameter2'\n\n    // Start for MATLABSystem: '<S11>/Read Parameter'\n    FLIGHT_hexacopter_DW.obj_g.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_g.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_g.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_g.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_g.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_g.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_b[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_g.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S11>/Read Parameter'\n\n    // Start for MATLABSystem: '<S11>/Read Parameter1'\n    FLIGHT_hexacopter_DW.obj_d.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_d.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_d.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_d.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_d.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_d.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_c[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_d.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S11>/Read Parameter1'\n\n    // Start for MATLABSystem: '<S11>/Read Parameter2'\n    FLIGHT_hexacopter_DW.obj_k.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_k.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_k.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_k.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_k.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_k.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_d[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_k.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S11>/Read Parameter2'\n\n    // Start for MATLABSystem: '<S11>/Read Parameter3'\n    FLIGHT_hexacopter_DW.obj_n.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_n.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_n.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_n.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_n.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_n.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_e[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_n.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S11>/Read Parameter3'\n\n    // Start for MATLABSystem: '<S11>/Read Parameter4'\n    FLIGHT_hexacopter_DW.obj.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj.MW_PARAMHANDLE = MW_Init_Param(&ParameterNameStr_f\n      [0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S11>/Read Parameter4'\n    FLIGHT__PX4Timestamp_m_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_i);\n\n    // Start for MATLABSystem: '<S512>/SinkBlock' incorporates:\n    //   BusAssignment: '<S510>/Bus Assignment'\n\n    FLIGHT_hexacopter_DW.obj_mq.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_mq.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_mq.orbMetadataObj = ORB_ID(vehicle_rates_setpoint);\n    uORB_write_initialize(FLIGHT_hexacopter_DW.obj_mq.orbMetadataObj,\n                          &FLIGHT_hexacopter_DW.obj_mq.orbAdvertiseObj,\n                          &FLIGHT_hexacopter_B.BusAssignment_a, 1);\n    FLIGHT_hexacopter_DW.obj_mq.isSetupComplete = true;\n    FLIGHT__PX4Timestamp_m_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_nd);\n\n    // Start for MATLABSystem: '<S507>/SinkBlock' incorporates:\n    //   BusAssignment: '<S504>/Bus Assignment'\n\n    FLIGHT_hexacopter_DW.obj_ez.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_ez.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_ez.orbMetadataObj = ORB_ID\n      (vehicle_attitude_setpoint);\n    uORB_write_initialize(FLIGHT_hexacopter_DW.obj_ez.orbMetadataObj,\n                          &FLIGHT_hexacopter_DW.obj_ez.orbAdvertiseObj,\n                          &FLIGHT_hexacopter_B.BusAssignment_p, 1);\n    FLIGHT_hexacopter_DW.obj_ez.isSetupComplete = true;\n    FLIGHT_he_PX4Timestamp_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_pn);\n\n    // Start for MATLABSystem: '<S509>/SinkBlock' incorporates:\n    //   BusAssignment: '<S20>/Bus Assignment'\n\n    FLIGHT_hexacopter_DW.obj_pa.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_pa.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_pa.orbMetadataObj = ORB_ID\n      (vehicle_local_position_setpoint);\n    uORB_write_initialize(FLIGHT_hexacopter_DW.obj_pa.orbMetadataObj,\n                          &FLIGHT_hexacopter_DW.obj_pa.orbAdvertiseObj,\n                          &FLIGHT_hexacopter_B.BusAssignment_g, 1);\n    FLIGHT_hexacopter_DW.obj_pa.isSetupComplete = true;\n\n    // Start for MATLABSystem: '<S1>/Read Parameter3'\n    FLIGHT_hexacopter_DW.obj_l5.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_l5.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_l5.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_l5.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_l5.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_l5.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_g[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_l5.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S1>/Read Parameter3'\n  }\n}\n\n// Model terminate function\nvoid FLIGHT_hexacopter_terminate(void)\n{\n  // Terminate for MATLABSystem: '<S497>/SourceBlock'\n  if (!FLIGHT_hexacopter_DW.obj_pe.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_pe.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_pe.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_pe.isSetupComplete) {\n      uORB_read_terminate(&FLIGHT_hexacopter_DW.obj_pe.eventStructObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S497>/SourceBlock'\n\n  // Terminate for Enabled SubSystem: '<Root>/SAS'\n  // Terminate for MATLABSystem: '<S10>/Read Parameter10'\n  if (!FLIGHT_hexacopter_DW.obj_c.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_c.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter10'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter5'\n  if (!FLIGHT_hexacopter_DW.obj_h.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_h.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter5'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter3'\n  if (!FLIGHT_hexacopter_DW.obj_b.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_b.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter3'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter4'\n  if (!FLIGHT_hexacopter_DW.obj_p.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_p.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter4'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter2'\n  if (!FLIGHT_hexacopter_DW.obj_da.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_da.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter2'\n\n  // Terminate for MATLABSystem: '<S10>/read_mc_rollrate_p'\n  if (!FLIGHT_hexacopter_DW.obj_i.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_i.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/read_mc_rollrate_p'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter1'\n  if (!FLIGHT_hexacopter_DW.obj_ea.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_ea.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter1'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter8'\n  if (!FLIGHT_hexacopter_DW.obj_i4.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_i4.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter8'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter6'\n  if (!FLIGHT_hexacopter_DW.obj_a.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_a.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter6'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter9'\n  if (!FLIGHT_hexacopter_DW.obj_e.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_e.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter9'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter7'\n  if (!FLIGHT_hexacopter_DW.obj_j.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_j.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter7'\n  // End of Terminate for SubSystem: '<Root>/SAS'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter13'\n  if (!FLIGHT_hexacopter_DW.obj_gv.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_gv.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter13'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter1'\n  if (!FLIGHT_hexacopter_DW.obj_j5.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_j5.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter1'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter2'\n  if (!FLIGHT_hexacopter_DW.obj_ao.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_ao.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter2'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter3'\n  if (!FLIGHT_hexacopter_DW.obj_nt.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_nt.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter3'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter4'\n  if (!FLIGHT_hexacopter_DW.obj_cx.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_cx.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter4'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter5'\n  if (!FLIGHT_hexacopter_DW.obj_aq.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_aq.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter5'\n\n  // Terminate for MATLABSystem: '<Root>/PX4 PWM Output'\n  if (!FLIGHT_hexacopter_DW.obj_dl.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_dl.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_dl.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_dl.isSetupComplete) {\n      pwm_disarm(&FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n      pwm_resetServo(FLIGHT_hexacopter_DW.obj_dl.servoCount,\n                     FLIGHT_hexacopter_DW.obj_dl.isMain,\n                     &FLIGHT_hexacopter_DW.obj_dl.actuatorAdvertiseObj);\n      pwm_close(FLIGHT_hexacopter_DW.obj_dl.servoCount,\n                &FLIGHT_hexacopter_DW.obj_dl.actuatorAdvertiseObj,\n                &FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<Root>/PX4 PWM Output'\n  FLIGHT__PX4Timestamp_o_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_n);\n  FLIGHT__PX4Timestamp_o_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_p);\n\n  // Terminate for MATLABSystem: '<S496>/SinkBlock'\n  if (!FLIGHT_hexacopter_DW.obj_hf.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_hf.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_hf.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_hf.isSetupComplete) {\n      uORB_write_terminate(&FLIGHT_hexacopter_DW.obj_hf.orbAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S496>/SinkBlock'\n  FLIGHT__PX4Timestamp_o_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_o);\n\n  // Terminate for MATLABSystem: '<S492>/SinkBlock'\n  if (!FLIGHT_hexacopter_DW.obj_jk.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_jk.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_jk.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_jk.isSetupComplete) {\n      uORB_write_terminate(&FLIGHT_hexacopter_DW.obj_jk.orbAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S492>/SinkBlock'\n  // Terminate for MATLABSystem: '<S306>/SourceBlock'\n  if (!FLIGHT_hexacopter_DW.obj_n2.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_n2.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_n2.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_n2.isSetupComplete) {\n      uORB_read_terminate(&FLIGHT_hexacopter_DW.obj_n2.eventStructObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S306>/SourceBlock'\n\n  // Terminate for MATLABSystem: '<S304>/SourceBlock'\n  if (!FLIGHT_hexacopter_DW.obj_ab.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_ab.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_ab.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_ab.isSetupComplete) {\n      uORB_read_terminate(&FLIGHT_hexacopter_DW.obj_ab.eventStructObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S304>/SourceBlock'\n\n  // Terminate for MATLABSystem: '<S500>/SourceBlock'\n  if (!FLIGHT_hexacopter_DW.obj_hm.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_hm.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_hm.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_hm.isSetupComplete) {\n      uORB_read_terminate(&FLIGHT_hexacopter_DW.obj_hm.eventStructObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S500>/SourceBlock'\n  // Terminate for MATLABSystem: '<S301>/SourceBlock'\n  if (!FLIGHT_hexacopter_DW.obj_kk.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_kk.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_kk.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_kk.isSetupComplete) {\n      uORB_read_terminate(&FLIGHT_hexacopter_DW.obj_kk.eventStructObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S301>/SourceBlock'\n\n  // Terminate for MATLABSystem: '<S1>/Read Parameter2'\n  if (!FLIGHT_hexacopter_DW.obj_in.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_in.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S1>/Read Parameter2'\n\n  // Terminate for MATLABSystem: '<S1>/Read Parameter4'\n  if (!FLIGHT_hexacopter_DW.obj_lx.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_lx.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S1>/Read Parameter4'\n\n  // Terminate for MATLABSystem: '<S1>/Read Parameter1'\n  if (!FLIGHT_hexacopter_DW.obj_m.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_m.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S1>/Read Parameter1'\n\n  // Terminate for Atomic SubSystem: '<Root>/If Action Subsystem'\n  // Terminate for MATLABSystem: '<S194>/Read Parameter'\n  if (!FLIGHT_hexacopter_DW.obj_eq.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_eq.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S194>/Read Parameter'\n\n  // Terminate for MATLABSystem: '<S195>/Read Parameter'\n  if (!FLIGHT_hexacopter_DW.obj_pi.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_pi.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S195>/Read Parameter'\n  // Terminate for MATLABSystem: '<S501>/SourceBlock'\n  if (!FLIGHT_hexacopter_DW.obj_bw.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_bw.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_bw.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_bw.isSetupComplete) {\n      uORB_read_terminate(&FLIGHT_hexacopter_DW.obj_bw.eventStructObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S501>/SourceBlock'\n  FLIGHT_he_PX4Timestamp_Term(&FLIGHT_hexacopter_DW.PX4Timestamp);\n\n  // Terminate for MATLABSystem: '<S3>/Read Parameter1'\n  if (!FLIGHT_hexacopter_DW.obj_ct.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_ct.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S3>/Read Parameter1'\n\n  // Terminate for MATLABSystem: '<S3>/Read Parameter'\n  if (!FLIGHT_hexacopter_DW.obj_cf.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_cf.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S3>/Read Parameter'\n\n  // Terminate for MATLABSystem: '<S3>/Read Parameter2'\n  if (!FLIGHT_hexacopter_DW.obj_l.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_l.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S3>/Read Parameter2'\n\n  // Terminate for Enabled SubSystem: '<Root>/CAS'\n  // Terminate for MATLABSystem: '<S2>/Read Parameter9'\n  if (!FLIGHT_hexacopter_DW.obj_k4.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_k4.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter9'\n\n  // Terminate for MATLABSystem: '<S2>/Read Parameter'\n  if (!FLIGHT_hexacopter_DW.obj_jz.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_jz.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter'\n\n  // Terminate for MATLABSystem: '<S2>/Read Parameter10'\n  if (!FLIGHT_hexacopter_DW.obj_ds.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_ds.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter10'\n\n  // Terminate for MATLABSystem: '<S2>/Read Parameter1'\n  if (!FLIGHT_hexacopter_DW.obj_o.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_o.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter1'\n  // End of Terminate for SubSystem: '<Root>/CAS'\n\n  // Terminate for MATLABSystem: '<S11>/Read Parameter'\n  if (!FLIGHT_hexacopter_DW.obj_g.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_g.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S11>/Read Parameter'\n\n  // Terminate for MATLABSystem: '<S11>/Read Parameter1'\n  if (!FLIGHT_hexacopter_DW.obj_d.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_d.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S11>/Read Parameter1'\n\n  // Terminate for MATLABSystem: '<S11>/Read Parameter2'\n  if (!FLIGHT_hexacopter_DW.obj_k.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_k.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S11>/Read Parameter2'\n\n  // Terminate for MATLABSystem: '<S11>/Read Parameter3'\n  if (!FLIGHT_hexacopter_DW.obj_n.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_n.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S11>/Read Parameter3'\n\n  // Terminate for MATLABSystem: '<S11>/Read Parameter4'\n  if (!FLIGHT_hexacopter_DW.obj.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S11>/Read Parameter4'\n  FLIGHT__PX4Timestamp_k_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_i);\n\n  // Terminate for MATLABSystem: '<S512>/SinkBlock'\n  if (!FLIGHT_hexacopter_DW.obj_mq.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_mq.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_mq.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_mq.isSetupComplete) {\n      uORB_write_terminate(&FLIGHT_hexacopter_DW.obj_mq.orbAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S512>/SinkBlock'\n  FLIGHT__PX4Timestamp_k_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_nd);\n\n  // Terminate for MATLABSystem: '<S507>/SinkBlock'\n  if (!FLIGHT_hexacopter_DW.obj_ez.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_ez.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_ez.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_ez.isSetupComplete) {\n      uORB_write_terminate(&FLIGHT_hexacopter_DW.obj_ez.orbAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S507>/SinkBlock'\n  FLIGHT_he_PX4Timestamp_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_pn);\n\n  // Terminate for MATLABSystem: '<S509>/SinkBlock'\n  if (!FLIGHT_hexacopter_DW.obj_pa.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_pa.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_pa.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_pa.isSetupComplete) {\n      uORB_write_terminate(&FLIGHT_hexacopter_DW.obj_pa.orbAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S509>/SinkBlock'\n\n  // Terminate for MATLABSystem: '<S1>/Read Parameter3'\n  if (!FLIGHT_hexacopter_DW.obj_l5.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_l5.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S1>/Read Parameter3'\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"FLIGHT_hexacopter.h","type":"header","group":"model","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: FLIGHT_hexacopter.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.248\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu May 22 21:41:20 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef FLIGHT_hexacopter_h_\n#define FLIGHT_hexacopter_h_\n#include <drivers/drv_hrt.h>\n#include <poll.h>\n#include <uORB/uORB.h>\n#include \"rtwtypes.h\"\n#include \"rtw_extmode.h\"\n#include \"sysran_types.h\"\n#include \"MW_Parameter.h\"\n#include \"MW_ParameterRead.h\"\n#include \"MW_PX4_PWM.h\"\n#include \"MW_uORB_Read.h\"\n#include \"MW_uORB_Write.h\"\n#include \"FLIGHT_hexacopter_types.h\"\n#include <uORB/topics/vehicle_local_position.h>\n#include <uORB/topics/vehicle_odometry.h>\n#include <uORB/topics/input_rc.h>\n#include <uORB/topics/vehicle_status.h>\n#include <uORB/topics/actuator_motors.h>\n#include <uORB/topics/vehicle_local_position_setpoint.h>\n#include <uORB/topics/vehicle_attitude_setpoint.h>\n#include <uORB/topics/vehicle_angular_velocity.h>\n#include <uORB/topics/vehicle_rates_setpoint.h>\n#include <uORB/topics/actuator_controls_status.h>\n#include <uORB/topics/actuator_armed.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <stddef.h>\n\n// Macros for accessing real-time model data structure\n#ifndef rtmGetFinalTime\n#define rtmGetFinalTime(rtm)           ((rtm)->Timing.tFinal)\n#endif\n\n#ifndef rtmGetRTWExtModeInfo\n#define rtmGetRTWExtModeInfo(rtm)      ((rtm)->extModeInfo)\n#endif\n\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmStepTask\n#define rtmStepTask(rtm, idx)          ((rtm)->Timing.TaskCounters.TID[(idx)] == 0)\n#endif\n\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\n#endif\n\n#ifndef rtmSetStopRequested\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\n#endif\n\n#ifndef rtmGetStopRequestedPtr\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\n#endif\n\n#ifndef rtmGetT\n#define rtmGetT(rtm)                   ((rtm)->Timing.taskTime0)\n#endif\n\n#ifndef rtmGetTFinal\n#define rtmGetTFinal(rtm)              ((rtm)->Timing.tFinal)\n#endif\n\n#ifndef rtmGetTPtr\n#define rtmGetTPtr(rtm)                (&(rtm)->Timing.taskTime0)\n#endif\n\n#ifndef rtmTaskCounter\n#define rtmTaskCounter(rtm, idx)       ((rtm)->Timing.TaskCounters.TID[(idx)])\n#endif\n\n// Block signals for system '<S3>/PX4 Timestamp'\nstruct B_PX4Timestamp_FLIGHT_hexacop_T {\n  uint64_T PX4Timestamp;               // '<S3>/PX4 Timestamp'\n};\n\n// Block states (default storage) for system '<S3>/PX4 Timestamp'\nstruct DW_PX4Timestamp_FLIGHT_hexaco_T {\n  px4_internal_block_getPX4Abso_T obj; // '<S3>/PX4 Timestamp'\n  boolean_T objisempty;                // '<S3>/PX4 Timestamp'\n};\n\n// Block signals for system '<S490>/PX4 Timestamp'\nstruct B_PX4Timestamp_FLIGHT_hexac_l_T {\n  uint64_T PX4Timestamp;               // '<S490>/PX4 Timestamp'\n};\n\n// Block states (default storage) for system '<S490>/PX4 Timestamp'\nstruct DW_PX4Timestamp_FLIGHT_hexa_b_T {\n  px4_internal_block_getPX4Abso_T obj; // '<S490>/PX4 Timestamp'\n  boolean_T objisempty;                // '<S490>/PX4 Timestamp'\n};\n\n// Block signals for system '<S504>/PX4 Timestamp'\nstruct B_PX4Timestamp_FLIGHT_hexac_h_T {\n  uint64_T PX4Timestamp;               // '<S504>/PX4 Timestamp'\n};\n\n// Block states (default storage) for system '<S504>/PX4 Timestamp'\nstruct DW_PX4Timestamp_FLIGHT_hexa_f_T {\n  px4_internal_block_getPX4Abso_T obj; // '<S504>/PX4 Timestamp'\n  boolean_T objisempty;                // '<S504>/PX4 Timestamp'\n};\n\n// Block signals (default storage)\nstruct B_FLIGHT_hexacopter_T {\n  px4_Bus_vehicle_local_position In1;  // '<S303>/In1'\n  px4_Bus_vehicle_local_position r;\n  px4_Bus_vehicle_odometry In1_k;      // '<S305>/In1'\n  px4_Bus_vehicle_odometry r1;\n  px4_Bus_input_rc In1_i;              // '<S307>/In1'\n  px4_Bus_input_rc r2;\n  px4_Bus_vehicle_status In1_f;        // '<S503>/In1'\n  px4_Bus_actuator_motors BusAssignment;// '<S494>/Bus Assignment'\n  px4_Bus_vehicle_status r3;\n  px4_Bus_vehicle_local_position_setpoint BusAssignment_g;// '<S20>/Bus Assignment' \n  px4_Bus_vehicle_attitude_setpoint BusAssignment_p;// '<S504>/Bus Assignment'\n  px4_Bus_vehicle_angular_velocity r4;\n  px4_Bus_vehicle_rates_setpoint BusAssignment_a;// '<S510>/Bus Assignment'\n  px4_Bus_vehicle_angular_velocity In1_h;// '<S498>/In1'\n  real32_T CreateDiagonalMatrix[9];    // '<S477>/Create Diagonal Matrix'\n  px4_Bus_actuator_controls_status BusAssignment_gi;// '<S490>/Bus Assignment'\n  uint16_T pwmValue[8];\n  px4_Bus_actuator_armed In1_n;        // '<S502>/In1'\n  px4_Bus_actuator_armed r5;\n  real32_T U[3];\n  real32_T TmpSignalConversionAtSFun_c[3];// '<S11>/MATLAB Function'\n  real32_T TSamp[3];                   // '<S480>/TSamp'\n  real32_T ypr[3];\n  real32_T G1[3];\n  uint16_T DataTypeConversion6[6];     // '<S4>/Data Type Conversion6'\n  real_T reletive_time_sec;\n  real_T peak_angle_rad;\n  real_T out_roll;\n  real_T out_pitch;\n  real_T out_yawrate;\n  real_T u0;\n  real32_T rate_transition_des_p;      // '<Root>/rate_transition_des_p'\n  real32_T rate_transition_des_q;      // '<Root>/rate_transition_des_q'\n  real32_T rate_transition_des_r;      // '<Root>/rate_transition_des_r'\n  real32_T RateTransition1;            // '<Root>/Rate Transition1'\n  real32_T rate_transition_throttle;   // '<Root>/rate_transition_throttle'\n  real32_T Gain1;                      // '<S22>/Gain1'\n  real32_T Gain2;                      // '<S22>/Gain2'\n  real32_T Gain3;                      // '<S22>/Gain3'\n  real32_T Gain;                       // '<S22>/Gain'\n  real32_T Gain5;                      // '<S12>/Gain5'\n  real32_T Gain6;                      // '<S12>/Gain6'\n  real32_T Saturation;                 // '<S12>/Saturation'\n  real32_T Sum5;                       // '<S309>/Sum5'\n  real32_T Sum5_d;                     // '<S310>/Sum5'\n  real32_T Sum;                        // '<S10>/Sum'\n  real32_T Gain1_k;                    // '<S192>/Gain1'\n  real32_T Gain2_l;                    // '<S192>/Gain2'\n  real32_T Gain3_g;                    // '<S192>/Gain3'\n  real32_T Gain_m;                     // '<S192>/Gain'\n  real32_T Switch2;                    // '<S173>/Switch2'\n  real32_T Switch2_i;                  // '<S122>/Switch2'\n  real32_T absxk;\n  real32_T cfromc;\n  real32_T ctoc;\n  real32_T mul;\n  real32_T b_absxk;\n  real32_T t;\n  real32_T ParamStep;\n  real32_T ParamStep_m;\n  real32_T ParamStep_c;\n  real32_T Product5_l;                 // '<S477>/Product5'\n  real32_T IProdOut_d;                 // '<S57>/IProd Out'\n  real32_T NProdOut;                   // '<S63>/NProd Out'\n  int32_T r_k;\n  int32_T br;\n  int32_T b_ic;\n  int32_T ParamStep_cx;\n  int32_T ParamStep_b;\n  int32_T ParamStep_p;\n  int32_T ParamStep_cv;\n  int32_T ParamStep_f;\n  uint16_T rate_transition_ctrl_sw;    // '<Root>/rate_transition_ctrl_sw'\n  uint16_T RateTransition4;            // '<Root>/Rate Transition4'\n  uint16_T DataTypeConversion7[6];     // '<S4>/Data Type Conversion7'\n  uint16_T values[18];\n                  // '<S9>/SigConversion_InsertedFor_Bus Selector_at_outport_0'\n  uint16_T Output_Limits1[6];          // '<S7>/Output_Limits1'\n  boolean_T rate_transition_arm;       // '<Root>/rate_transition_arm'\n  boolean_T RateTransition7;           // '<Root>/Rate Transition7'\n  B_PX4Timestamp_FLIGHT_hexac_h_T PX4Timestamp_i;// '<S504>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexacop_T PX4Timestamp_pn;// '<S3>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexac_h_T PX4Timestamp_nd;// '<S504>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexac_l_T PX4Timestamp_n;// '<S490>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexac_l_T PX4Timestamp_p;// '<S490>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexac_l_T PX4Timestamp_o;// '<S490>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexacop_T PX4Timestamp;// '<S3>/PX4 Timestamp'\n};\n\n// Block states (default storage) for system '<Root>'\nstruct DW_FLIGHT_hexacopter_T {\n  px4_internal_block_ParameterU_T obj; // '<S11>/Read Parameter4'\n  px4_internal_block_ParameterU_T obj_n;// '<S11>/Read Parameter3'\n  px4_internal_block_ParameterU_T obj_k;// '<S11>/Read Parameter2'\n  px4_internal_block_ParameterU_T obj_d;// '<S11>/Read Parameter1'\n  px4_internal_block_ParameterU_T obj_g;// '<S11>/Read Parameter'\n  px4_internal_block_ParameterU_T obj_i;// '<S10>/read_mc_rollrate_p'\n  px4_internal_block_ParameterU_T obj_e;// '<S10>/Read Parameter9'\n  px4_internal_block_ParameterU_T obj_i4;// '<S10>/Read Parameter8'\n  px4_internal_block_ParameterU_T obj_j;// '<S10>/Read Parameter7'\n  px4_internal_block_ParameterU_T obj_a;// '<S10>/Read Parameter6'\n  px4_internal_block_ParameterU_T obj_h;// '<S10>/Read Parameter5'\n  px4_internal_block_ParameterU_T obj_p;// '<S10>/Read Parameter4'\n  px4_internal_block_ParameterU_T obj_b;// '<S10>/Read Parameter3'\n  px4_internal_block_ParameterU_T obj_da;// '<S10>/Read Parameter2'\n  px4_internal_block_ParameterU_T obj_c;// '<S10>/Read Parameter10'\n  px4_internal_block_ParameterU_T obj_ea;// '<S10>/Read Parameter1'\n  px4_internal_block_ParameterU_T obj_pi;// '<S195>/Read Parameter'\n  px4_internal_block_ParameterU_T obj_eq;// '<S194>/Read Parameter'\n  px4_internal_block_ParameterU_T obj_aq;// '<S4>/Read Parameter5'\n  px4_internal_block_ParameterU_T obj_cx;// '<S4>/Read Parameter4'\n  px4_internal_block_ParameterU_T obj_nt;// '<S4>/Read Parameter3'\n  px4_internal_block_ParameterU_T obj_ao;// '<S4>/Read Parameter2'\n  px4_internal_block_ParameterU_T obj_gv;// '<S4>/Read Parameter13'\n  px4_internal_block_ParameterU_T obj_j5;// '<S4>/Read Parameter1'\n  px4_internal_block_ParameterU_T obj_l;// '<S3>/Read Parameter2'\n  px4_internal_block_ParameterU_T obj_ct;// '<S3>/Read Parameter1'\n  px4_internal_block_ParameterU_T obj_cf;// '<S3>/Read Parameter'\n  px4_internal_block_ParameterU_T obj_k4;// '<S2>/Read Parameter9'\n  px4_internal_block_ParameterU_T obj_ds;// '<S2>/Read Parameter10'\n  px4_internal_block_ParameterU_T obj_o;// '<S2>/Read Parameter1'\n  px4_internal_block_ParameterU_T obj_jz;// '<S2>/Read Parameter'\n  px4_internal_block_ParameterU_T obj_lx;// '<S1>/Read Parameter4'\n  px4_internal_block_ParameterU_T obj_l5;// '<S1>/Read Parameter3'\n  px4_internal_block_ParameterU_T obj_in;// '<S1>/Read Parameter2'\n  px4_internal_block_ParameterU_T obj_m;// '<S1>/Read Parameter1'\n  px4_internal_block_Subscriber_T obj_bw;// '<S501>/SourceBlock'\n  px4_internal_block_Subscriber_T obj_hm;// '<S500>/SourceBlock'\n  px4_internal_block_Subscriber_T obj_pe;// '<S497>/SourceBlock'\n  px4_internal_block_Subscriber_T obj_n2;// '<S306>/SourceBlock'\n  px4_internal_block_Subscriber_T obj_ab;// '<S304>/SourceBlock'\n  px4_internal_block_Subscriber_T obj_kk;// '<S301>/SourceBlock'\n  px4_internal_block_PWM_FLIGHT_T obj_dl;// '<Root>/PX4 PWM Output'\n  px4_internal_block_Publisher__T obj_mq;// '<S512>/SinkBlock'\n  px4_internal_block_Publisher__T obj_pa;// '<S509>/SinkBlock'\n  px4_internal_block_Publisher__T obj_ez;// '<S507>/SinkBlock'\n  px4_internal_block_Publisher__T obj_hf;// '<S496>/SinkBlock'\n  px4_internal_block_Publisher__T obj_jk;// '<S492>/SinkBlock'\n  real_T start_time_usec;              // '<S3>/MATLAB Function'\n  struct {\n    void *LoggedData[2];\n  } Scope1_PWORK;                      // '<Root>/Scope1'\n\n  real32_T Integrator_DSTATE;          // '<S60>/Integrator'\n  real32_T Filter_DSTATE;              // '<S55>/Filter'\n  real32_T UD_DSTATE[3];               // '<S480>/UD'\n  real32_T UD_DSTATE_j;                // '<S478>/UD'\n  real32_T UD_DSTATE_g;                // '<S479>/UD'\n  real32_T UD_DSTATE_n;                // '<S481>/UD'\n  real32_T DiscreteTimeIntegrator_DSTATE;// '<S11>/Discrete-Time Integrator'\n  real32_T UnitDelay1_DSTATE;          // '<S315>/Unit Delay1'\n  real32_T UnitDelay2_DSTATE;          // '<S315>/Unit Delay2'\n  real32_T UD_DSTATE_l;                // '<S312>/UD'\n  real32_T Integrator_DSTATE_p;        // '<S350>/Integrator'\n  real32_T UnitDelay1_DSTATE_f;        // '<S370>/Unit Delay1'\n  real32_T UnitDelay2_DSTATE_c;        // '<S370>/Unit Delay2'\n  real32_T UD_DSTATE_m;                // '<S367>/UD'\n  real32_T Integrator_DSTATE_c;        // '<S405>/Integrator'\n  real32_T UnitDelay1_DSTATE_e;        // '<S425>/Unit Delay1'\n  real32_T UnitDelay2_DSTATE_e;        // '<S425>/Unit Delay2'\n  real32_T UD_DSTATE_jy;               // '<S422>/UD'\n  real32_T Integrator_DSTATE_g;        // '<S460>/Integrator'\n  real32_T DiscreteTimeIntegrator_DSTATE_l;// '<S5>/Discrete-Time Integrator'\n  real32_T DiscreteTimeIntegrator1_DSTATE;// '<S5>/Discrete-Time Integrator1'\n  real32_T rate_transition_des_p_Buffer0;// '<Root>/rate_transition_des_p'\n  real32_T rate_transition_des_q_Buffer0;// '<Root>/rate_transition_des_q'\n  real32_T rate_transition_des_r_Buffer0;// '<Root>/rate_transition_des_r'\n  real32_T RateTransition1_Buffer0;    // '<Root>/Rate Transition1'\n  real32_T rate_transition_throttle_Buffer;// '<Root>/rate_transition_throttle'\n  real32_T RateTransition_Buffer[3];   // '<Root>/Rate Transition'\n  uint16_T rate_transition_ctrl_sw_Buffer0;// '<Root>/rate_transition_ctrl_sw'\n  uint16_T RateTransition4_Buffer0;    // '<Root>/Rate Transition4'\n  int8_T Integrator_PrevResetState;    // '<S60>/Integrator'\n  int8_T Filter_PrevResetState;        // '<S55>/Filter'\n  int8_T EnabledSubsystem_SubsysRanBC; // '<S501>/Enabled Subsystem'\n  int8_T EnabledSubsystem_SubsysRanBC_j;// '<S500>/Enabled Subsystem'\n  int8_T EnabledSubsystem_SubsysRanBC_c;// '<S497>/Enabled Subsystem'\n  int8_T SAS_SubsysRanBC;              // '<Root>/SAS'\n  int8_T EnabledSubsystem_SubsysRanBC_o;// '<S306>/Enabled Subsystem'\n  int8_T EnabledSubsystem_SubsysRanBC_l;// '<S304>/Enabled Subsystem'\n  int8_T EnabledSubsystem_SubsysRanBC_k;// '<S301>/Enabled Subsystem'\n  int8_T Mixer_SubsysRanBC;            // '<Root>/Mixer'\n  int8_T DiscreteTimeIntegrator_PrevRese;// '<S5>/Discrete-Time Integrator'\n  int8_T DiscreteTimeIntegrator1_PrevRes;// '<S5>/Discrete-Time Integrator1'\n  int8_T CAS_SubsysRanBC;              // '<Root>/CAS'\n  uint8_T DiscreteTimeIntegrator_IC_LOADI;// '<S5>/Discrete-Time Integrator'\n  uint8_T DiscreteTimeIntegrator1_IC_LOAD;// '<S5>/Discrete-Time Integrator1'\n  boolean_T rate_transition_arm_Buffer0;// '<Root>/rate_transition_arm'\n  boolean_T RateTransition7_Buffer0;   // '<Root>/Rate Transition7'\n  DW_PX4Timestamp_FLIGHT_hexa_f_T PX4Timestamp_i;// '<S504>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexaco_T PX4Timestamp_pn;// '<S3>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexa_f_T PX4Timestamp_nd;// '<S504>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexa_b_T PX4Timestamp_n;// '<S490>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexa_b_T PX4Timestamp_p;// '<S490>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexa_b_T PX4Timestamp_o;// '<S490>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexaco_T PX4Timestamp;// '<S3>/PX4 Timestamp'\n};\n\n// Parameters (default storage)\nstruct P_FLIGHT_hexacopter_T_ {\n  real_T SampleTime;                   // Variable: SampleTime\n                                          //  Referenced by:\n                                          //    '<S1>/Read Parameter1'\n                                          //    '<S1>/Read Parameter2'\n                                          //    '<S1>/Read Parameter3'\n                                          //    '<S1>/Read Parameter4'\n                                          //    '<S2>/Read Parameter'\n                                          //    '<S2>/Read Parameter1'\n                                          //    '<S2>/Read Parameter10'\n                                          //    '<S2>/Read Parameter9'\n                                          //    '<S3>/Read Parameter'\n                                          //    '<S3>/Read Parameter1'\n                                          //    '<S3>/Read Parameter2'\n                                          //    '<S11>/Read Parameter'\n                                          //    '<S11>/Read Parameter1'\n                                          //    '<S11>/Read Parameter2'\n                                          //    '<S11>/Read Parameter3'\n                                          //    '<S11>/Read Parameter4'\n                                          //    '<S194>/Read Parameter'\n                                          //    '<S195>/Read Parameter'\n\n  real_T SampleTime_SAS;               // Variable: SampleTime_SAS\n                                          //  Referenced by:\n                                          //    '<S4>/Read Parameter1'\n                                          //    '<S4>/Read Parameter13'\n                                          //    '<S4>/Read Parameter2'\n                                          //    '<S4>/Read Parameter3'\n                                          //    '<S4>/Read Parameter4'\n                                          //    '<S4>/Read Parameter5'\n                                          //    '<S10>/Read Parameter1'\n                                          //    '<S10>/Read Parameter10'\n                                          //    '<S10>/Read Parameter2'\n                                          //    '<S10>/Read Parameter3'\n                                          //    '<S10>/Read Parameter4'\n                                          //    '<S10>/Read Parameter5'\n                                          //    '<S10>/Read Parameter6'\n                                          //    '<S10>/Read Parameter7'\n                                          //    '<S10>/Read Parameter8'\n                                          //    '<S10>/Read Parameter9'\n                                          //    '<S10>/read_mc_rollrate_p'\n\n  real32_T Jxx;                        // Variable: Jxx\n                                          //  Referenced by: '<S477>/Constant'\n\n  real32_T Jyy;                        // Variable: Jyy\n                                          //  Referenced by: '<S477>/Constant1'\n\n  real32_T Jzz;                        // Variable: Jzz\n                                          //  Referenced by: '<S477>/Constant2'\n\n  real32_T MAX_CONTROL_ANGLE_PITCH;    // Variable: MAX_CONTROL_ANGLE_PITCH\n                                          //  Referenced by:\n                                          //    '<S12>/Gain5'\n                                          //    '<S22>/Gain2'\n\n  real32_T MAX_CONTROL_ANGLE_RATE_Y;   // Variable: MAX_CONTROL_ANGLE_RATE_Y\n                                          //  Referenced by:\n                                          //    '<S12>/Gain6'\n                                          //    '<S22>/Gain3'\n                                          //    '<S192>/Gain3'\n\n  real32_T MAX_CONTROL_ANGLE_ROLL;     // Variable: MAX_CONTROL_ANGLE_ROLL\n                                          //  Referenced by:\n                                          //    '<S12>/Gain4'\n                                          //    '<S22>/Gain1'\n\n  real32_T MAX_CONTROL_VELOCITY_XY;    // Variable: MAX_CONTROL_VELOCITY_XY\n                                          //  Referenced by: '<S192>/Gain1'\n\n  real32_T DiscreteDerivative2_ICPrevScale;\n                              // Mask Parameter: DiscreteDerivative2_ICPrevScale\n                                 //  Referenced by: '<S312>/UD'\n\n  real32_T DiscreteDerivative2_ICPrevSca_n;\n                              // Mask Parameter: DiscreteDerivative2_ICPrevSca_n\n                                 //  Referenced by: '<S367>/UD'\n\n  real32_T DiscreteDerivative2_ICPrevSca_o;\n                              // Mask Parameter: DiscreteDerivative2_ICPrevSca_o\n                                 //  Referenced by: '<S422>/UD'\n\n  real32_T DiscreteDerivative2_ICPrevSca_a;\n                              // Mask Parameter: DiscreteDerivative2_ICPrevSca_a\n                                 //  Referenced by: '<S480>/UD'\n\n  real32_T DiscreteDerivative_ICPrevScaled;\n                              // Mask Parameter: DiscreteDerivative_ICPrevScaled\n                                 //  Referenced by: '<S478>/UD'\n\n  real32_T DiscreteDerivative1_ICPrevScale;\n                              // Mask Parameter: DiscreteDerivative1_ICPrevScale\n                                 //  Referenced by: '<S479>/UD'\n\n  real32_T DiscreteDerivative3_ICPrevScale;\n                              // Mask Parameter: DiscreteDerivative3_ICPrevScale\n                                 //  Referenced by: '<S481>/UD'\n\n  real32_T PIDController_InitialConditionF;\n                              // Mask Parameter: PIDController_InitialConditionF\n                                 //  Referenced by: '<S55>/Filter'\n\n  real32_T pid_ctrl_rollrate_InitialCondit;\n                              // Mask Parameter: pid_ctrl_rollrate_InitialCondit\n                                 //  Referenced by: '<S350>/Integrator'\n\n  real32_T pid_ctrl_rollrate_InitialCond_j;\n                              // Mask Parameter: pid_ctrl_rollrate_InitialCond_j\n                                 //  Referenced by: '<S405>/Integrator'\n\n  real32_T pid_ctrl_rollrate_InitialCond_p;\n                              // Mask Parameter: pid_ctrl_rollrate_InitialCond_p\n                                 //  Referenced by: '<S460>/Integrator'\n\n  real32_T PIDController_InitialConditio_a;\n                              // Mask Parameter: PIDController_InitialConditio_a\n                                 //  Referenced by: '<S60>/Integrator'\n\n  real32_T PIDController_LowerIntegratorSa;\n                              // Mask Parameter: PIDController_LowerIntegratorSa\n                                 //  Referenced by: '<S60>/Integrator'\n\n  real32_T PIDController_LowerSaturationLi;\n                              // Mask Parameter: PIDController_LowerSaturationLi\n                                 //  Referenced by:\n                                 //    '<S67>/Saturation'\n                                 //    '<S52>/DeadZone'\n\n  real32_T PIDController_UpperIntegratorSa;\n                              // Mask Parameter: PIDController_UpperIntegratorSa\n                                 //  Referenced by: '<S60>/Integrator'\n\n  real32_T PIDController_UpperSaturationLi;\n                              // Mask Parameter: PIDController_UpperSaturationLi\n                                 //  Referenced by:\n                                 //    '<S67>/Saturation'\n                                 //    '<S52>/DeadZone'\n\n  uint16_T CompareToConstant2_const; // Mask Parameter: CompareToConstant2_const\n                                        //  Referenced by: '<S193>/Constant'\n\n  uint16_T CompareToConstant_const;   // Mask Parameter: CompareToConstant_const\n                                         //  Referenced by: '<S488>/Constant'\n\n  uint16_T CompareToConstant_const_g;\n                                    // Mask Parameter: CompareToConstant_const_g\n                                       //  Referenced by: '<S185>/Constant'\n\n  uint16_T CompareToConstant1_const; // Mask Parameter: CompareToConstant1_const\n                                        //  Referenced by: '<S23>/Constant'\n\n  uint16_T CompareToConstant1_const_e;\n                                   // Mask Parameter: CompareToConstant1_const_e\n                                      //  Referenced by: '<S183>/Constant'\n\n  px4_Bus_vehicle_local_position Out1_Y0;// Computed Parameter: Out1_Y0\n                                            //  Referenced by: '<S303>/Out1'\n\n  px4_Bus_vehicle_local_position Constant_Value;// Computed Parameter: Constant_Value\n                                                   //  Referenced by: '<S301>/Constant'\n\n  px4_Bus_vehicle_odometry Out1_Y0_d;  // Computed Parameter: Out1_Y0_d\n                                          //  Referenced by: '<S305>/Out1'\n\n  px4_Bus_vehicle_odometry Constant_Value_g;// Computed Parameter: Constant_Value_g\n                                               //  Referenced by: '<S304>/Constant'\n\n  px4_Bus_actuator_motors Constant_Value_m;// Computed Parameter: Constant_Value_m\n                                              //  Referenced by: '<S495>/Constant'\n\n  px4_Bus_input_rc Out1_Y0_o;          // Computed Parameter: Out1_Y0_o\n                                          //  Referenced by: '<S307>/Out1'\n\n  px4_Bus_input_rc Constant_Value_m1;  // Computed Parameter: Constant_Value_m1\n                                          //  Referenced by: '<S306>/Constant'\n\n  px4_Bus_vehicle_status Out1_Y0_a;    // Computed Parameter: Out1_Y0_a\n                                          //  Referenced by: '<S503>/Out1'\n\n  px4_Bus_vehicle_status Constant_Value_o;// Computed Parameter: Constant_Value_o\n                                             //  Referenced by: '<S501>/Constant'\n\n  px4_Bus_vehicle_local_position_setpoint Constant_Value_n;// Computed Parameter: Constant_Value_n\n                                                              //  Referenced by: '<S508>/Constant'\n\n  px4_Bus_vehicle_attitude_setpoint Constant_Value_l;// Computed Parameter: Constant_Value_l\n                                                        //  Referenced by: '<S506>/Constant'\n\n  px4_Bus_vehicle_angular_velocity Out1_Y0_p;// Computed Parameter: Out1_Y0_p\n                                                //  Referenced by: '<S498>/Out1'\n\n  px4_Bus_vehicle_angular_velocity Constant_Value_gk;// Computed Parameter: Constant_Value_gk\n                                                        //  Referenced by: '<S497>/Constant'\n\n  px4_Bus_vehicle_rates_setpoint Constant_Value_ni;// Computed Parameter: Constant_Value_ni\n                                                      //  Referenced by: '<S511>/Constant'\n\n  px4_Bus_actuator_controls_status Constant_Value_a;// Computed Parameter: Constant_Value_a\n                                                       //  Referenced by: '<S491>/Constant'\n\n  px4_Bus_actuator_armed Out1_Y0_h;    // Computed Parameter: Out1_Y0_h\n                                          //  Referenced by: '<S502>/Out1'\n\n  px4_Bus_actuator_armed Constant_Value_m3;// Computed Parameter: Constant_Value_m3\n                                              //  Referenced by: '<S500>/Constant'\n\n  real_T Constant1_Value;              // Expression: 100\n                                          //  Referenced by: '<S4>/Constant1'\n\n  real_T Constant2_Value;              // Expression: 100\n                                          //  Referenced by: '<S4>/Constant2'\n\n  real_T Constant3_Value;              // Expression: 100\n                                          //  Referenced by: '<S4>/Constant3'\n\n  real_T Constant4_Value;              // Expression: 100\n                                          //  Referenced by: '<S4>/Constant4'\n\n  real_T Constant5_Value;              // Expression: 100\n                                          //  Referenced by: '<S4>/Constant5'\n\n  real_T Constant_Value_mc;            // Expression: 100\n                                          //  Referenced by: '<S4>/Constant'\n\n  real_T Constant_Value_c;             // Expression: 1094\n                                          //  Referenced by: '<S12>/Constant'\n\n  real_T Gain_Gain;                    // Expression: 1/800\n                                          //  Referenced by: '<S12>/Gain'\n\n  real_T Gain_Gain_j;                  // Expression: 0.01\n                                          //  Referenced by: '<S186>/Gain'\n\n  real_T Saturation_UpperSat;          // Expression: 1\n                                          //  Referenced by: '<S186>/Saturation'\n\n  real_T Saturation_LowerSat;          // Expression: 0\n                                          //  Referenced by: '<S186>/Saturation'\n\n  real_T Gain_Gain_h;                  // Expression: 0.01\n                                          //  Referenced by: '<S187>/Gain'\n\n  real_T Saturation_UpperSat_m;        // Expression: 1\n                                          //  Referenced by: '<S187>/Saturation'\n\n  real_T Saturation_LowerSat_o;        // Expression: 0\n                                          //  Referenced by: '<S187>/Saturation'\n\n  real_T Gain_Gain_c;                  // Expression: 0.01\n                                          //  Referenced by: '<S188>/Gain'\n\n  real_T Saturation_UpperSat_b;        // Expression: 1\n                                          //  Referenced by: '<S188>/Saturation'\n\n  real_T Saturation_LowerSat_g;        // Expression: 0\n                                          //  Referenced by: '<S188>/Saturation'\n\n  real_T Gain_Gain_n;                  // Expression: 0.01\n                                          //  Referenced by: '<S189>/Gain'\n\n  real_T Saturation_UpperSat_be;       // Expression: 1\n                                          //  Referenced by: '<S189>/Saturation'\n\n  real_T Saturation_LowerSat_e;        // Expression: 0\n                                          //  Referenced by: '<S189>/Saturation'\n\n  real_T Gain_Gain_f;                  // Expression: 0.01\n                                          //  Referenced by: '<S190>/Gain'\n\n  real_T Saturation_UpperSat_d;        // Expression: 1\n                                          //  Referenced by: '<S190>/Saturation'\n\n  real_T Saturation_LowerSat_l;        // Expression: 0\n                                          //  Referenced by: '<S190>/Saturation'\n\n  real_T Gain_Gain_m;                  // Expression: 0.01\n                                          //  Referenced by: '<S191>/Gain'\n\n  real_T Saturation_UpperSat_i;        // Expression: 1\n                                          //  Referenced by: '<S191>/Saturation'\n\n  real_T Saturation_LowerSat_n;        // Expression: 0\n                                          //  Referenced by: '<S191>/Saturation'\n\n  real32_T Gain1_Gain;                 // Computed Parameter: Gain1_Gain\n                                          //  Referenced by: '<S2>/Gain1'\n\n  real32_T Gain_Gain_m3;               // Computed Parameter: Gain_Gain_m3\n                                          //  Referenced by: '<S2>/Gain'\n\n  real32_T des_p_Y0;                   // Computed Parameter: des_p_Y0\n                                          //  Referenced by: '<S2>/des_p'\n\n  real32_T des_q_Y0;                   // Computed Parameter: des_q_Y0\n                                          //  Referenced by: '<S2>/des_q'\n\n  real32_T Gain1_Gain_g;               // Computed Parameter: Gain1_Gain_g\n                                          //  Referenced by: '<S77>/Gain1'\n\n  real32_T Gain1_Gain_c;               // Computed Parameter: Gain1_Gain_c\n                                          //  Referenced by: '<S78>/Gain1'\n\n  real32_T Gain_Gain_a;                // Computed Parameter: Gain_Gain_a\n                                          //  Referenced by: '<S249>/Gain'\n\n  real32_T DiscreteTimeIntegrator_gainval;\n                           // Computed Parameter: DiscreteTimeIntegrator_gainval\n                              //  Referenced by: '<S5>/Discrete-Time Integrator'\n\n  real32_T DiscreteTimeIntegrator_UpperSat;\n                          // Computed Parameter: DiscreteTimeIntegrator_UpperSat\n                             //  Referenced by: '<S5>/Discrete-Time Integrator'\n\n  real32_T DiscreteTimeIntegrator_LowerSat;\n                          // Computed Parameter: DiscreteTimeIntegrator_LowerSat\n                             //  Referenced by: '<S5>/Discrete-Time Integrator'\n\n  real32_T DiscreteTimeIntegrator1_gainval;\n                          // Computed Parameter: DiscreteTimeIntegrator1_gainval\n                             //  Referenced by: '<S5>/Discrete-Time Integrator1'\n\n  real32_T DiscreteTimeIntegrator1_UpperSa;\n                          // Computed Parameter: DiscreteTimeIntegrator1_UpperSa\n                             //  Referenced by: '<S5>/Discrete-Time Integrator1'\n\n  real32_T DiscreteTimeIntegrator1_LowerSa;\n                          // Computed Parameter: DiscreteTimeIntegrator1_LowerSa\n                             //  Referenced by: '<S5>/Discrete-Time Integrator1'\n\n  real32_T Saturation_UpperSat_e;   // Computed Parameter: Saturation_UpperSat_e\n                                       //  Referenced by: '<S195>/Saturation'\n\n  real32_T Saturation_LowerSat_a;   // Computed Parameter: Saturation_LowerSat_a\n                                       //  Referenced by: '<S195>/Saturation'\n\n  real32_T Gain1_Gain_i;               // Computed Parameter: Gain1_Gain_i\n                                          //  Referenced by: '<S195>/Gain1'\n\n  real32_T DeadZone3_Start;            // Computed Parameter: DeadZone3_Start\n                                          //  Referenced by: '<S192>/Dead Zone3'\n\n  real32_T DeadZone3_End;              // Computed Parameter: DeadZone3_End\n                                          //  Referenced by: '<S192>/Dead Zone3'\n\n  real32_T Saturation9_UpperSat;     // Computed Parameter: Saturation9_UpperSat\n                                        //  Referenced by: '<S192>/Saturation9'\n\n  real32_T Saturation9_LowerSat;     // Computed Parameter: Saturation9_LowerSat\n                                        //  Referenced by: '<S192>/Saturation9'\n\n  real32_T DeadZone1_Start;            // Computed Parameter: DeadZone1_Start\n                                          //  Referenced by: '<S192>/Dead Zone1'\n\n  real32_T DeadZone1_End;              // Computed Parameter: DeadZone1_End\n                                          //  Referenced by: '<S192>/Dead Zone1'\n\n  real32_T Saturation1_UpperSat;     // Computed Parameter: Saturation1_UpperSat\n                                        //  Referenced by: '<S192>/Saturation1'\n\n  real32_T Saturation1_LowerSat;     // Computed Parameter: Saturation1_LowerSat\n                                        //  Referenced by: '<S192>/Saturation1'\n\n  real32_T Gain2_Gain;                 // Computed Parameter: Gain2_Gain\n                                          //  Referenced by: '<S192>/Gain2'\n\n  real32_T DeadZone2_Start;            // Computed Parameter: DeadZone2_Start\n                                          //  Referenced by: '<S192>/Dead Zone2'\n\n  real32_T DeadZone2_End;              // Computed Parameter: DeadZone2_End\n                                          //  Referenced by: '<S192>/Dead Zone2'\n\n  real32_T Saturation3_UpperSat;     // Computed Parameter: Saturation3_UpperSat\n                                        //  Referenced by: '<S192>/Saturation3'\n\n  real32_T Saturation3_LowerSat;     // Computed Parameter: Saturation3_LowerSat\n                                        //  Referenced by: '<S192>/Saturation3'\n\n  real32_T DeadZone4_Start;            // Computed Parameter: DeadZone4_Start\n                                          //  Referenced by: '<S192>/Dead Zone4'\n\n  real32_T DeadZone4_End;              // Computed Parameter: DeadZone4_End\n                                          //  Referenced by: '<S192>/Dead Zone4'\n\n  real32_T Saturation10_UpperSat;   // Computed Parameter: Saturation10_UpperSat\n                                       //  Referenced by: '<S192>/Saturation10'\n\n  real32_T Saturation10_LowerSat;   // Computed Parameter: Saturation10_LowerSat\n                                       //  Referenced by: '<S192>/Saturation10'\n\n  real32_T Gain_Gain_o;                // Computed Parameter: Gain_Gain_o\n                                          //  Referenced by: '<S192>/Gain'\n\n  real32_T tau_roll_Y0;                // Computed Parameter: tau_roll_Y0\n                                          //  Referenced by: '<S10>/tau_roll'\n\n  real32_T tau_pitch_Y0;               // Computed Parameter: tau_pitch_Y0\n                                          //  Referenced by: '<S10>/tau_pitch'\n\n  real32_T tau_yaw_Y0;                 // Computed Parameter: tau_yaw_Y0\n                                          //  Referenced by: '<S10>/tau_yaw'\n\n  real32_T tau_Gain;                   // Computed Parameter: tau_Gain\n                                          //  Referenced by: '<S315>/tau'\n\n  real32_T Bias1_Bias;                 // Computed Parameter: Bias1_Bias\n                                          //  Referenced by: '<S316>/Bias1'\n\n  real32_T Bias_Bias;                  // Computed Parameter: Bias_Bias\n                                          //  Referenced by: '<S316>/Bias'\n\n  real32_T Gain_Gain_i;                // Computed Parameter: Gain_Gain_i\n                                          //  Referenced by: '<S316>/Gain'\n\n  real32_T UnitDelay1_InitialCondition;\n                              // Computed Parameter: UnitDelay1_InitialCondition\n                                 //  Referenced by: '<S315>/Unit Delay1'\n\n  real32_T Gain1_Gain_j;               // Computed Parameter: Gain1_Gain_j\n                                          //  Referenced by: '<S315>/Gain1'\n\n  real32_T UnitDelay2_InitialCondition;\n                              // Computed Parameter: UnitDelay2_InitialCondition\n                                 //  Referenced by: '<S315>/Unit Delay2'\n\n  real32_T TSamp_WtEt;                 // Computed Parameter: TSamp_WtEt\n                                          //  Referenced by: '<S312>/TSamp'\n\n  real32_T Integrator_gainval;         // Computed Parameter: Integrator_gainval\n                                          //  Referenced by: '<S350>/Integrator'\n\n  real32_T tau_Gain_n;                 // Computed Parameter: tau_Gain_n\n                                          //  Referenced by: '<S370>/tau'\n\n  real32_T Bias1_Bias_n;               // Computed Parameter: Bias1_Bias_n\n                                          //  Referenced by: '<S371>/Bias1'\n\n  real32_T Bias_Bias_b;                // Computed Parameter: Bias_Bias_b\n                                          //  Referenced by: '<S371>/Bias'\n\n  real32_T Gain_Gain_e;                // Computed Parameter: Gain_Gain_e\n                                          //  Referenced by: '<S371>/Gain'\n\n  real32_T UnitDelay1_InitialCondition_p;\n                            // Computed Parameter: UnitDelay1_InitialCondition_p\n                               //  Referenced by: '<S370>/Unit Delay1'\n\n  real32_T Gain1_Gain_e;               // Computed Parameter: Gain1_Gain_e\n                                          //  Referenced by: '<S370>/Gain1'\n\n  real32_T UnitDelay2_InitialCondition_e;\n                            // Computed Parameter: UnitDelay2_InitialCondition_e\n                               //  Referenced by: '<S370>/Unit Delay2'\n\n  real32_T TSamp_WtEt_m;               // Computed Parameter: TSamp_WtEt_m\n                                          //  Referenced by: '<S367>/TSamp'\n\n  real32_T Integrator_gainval_b;     // Computed Parameter: Integrator_gainval_b\n                                        //  Referenced by: '<S405>/Integrator'\n\n  real32_T tau_Gain_c;                 // Computed Parameter: tau_Gain_c\n                                          //  Referenced by: '<S425>/tau'\n\n  real32_T Bias1_Bias_i;               // Computed Parameter: Bias1_Bias_i\n                                          //  Referenced by: '<S426>/Bias1'\n\n  real32_T Bias_Bias_c;                // Computed Parameter: Bias_Bias_c\n                                          //  Referenced by: '<S426>/Bias'\n\n  real32_T Gain_Gain_b;                // Computed Parameter: Gain_Gain_b\n                                          //  Referenced by: '<S426>/Gain'\n\n  real32_T UnitDelay1_InitialCondition_e;\n                            // Computed Parameter: UnitDelay1_InitialCondition_e\n                               //  Referenced by: '<S425>/Unit Delay1'\n\n  real32_T Gain1_Gain_iw;              // Computed Parameter: Gain1_Gain_iw\n                                          //  Referenced by: '<S425>/Gain1'\n\n  real32_T UnitDelay2_InitialCondition_m;\n                            // Computed Parameter: UnitDelay2_InitialCondition_m\n                               //  Referenced by: '<S425>/Unit Delay2'\n\n  real32_T TSamp_WtEt_p;               // Computed Parameter: TSamp_WtEt_p\n                                          //  Referenced by: '<S422>/TSamp'\n\n  real32_T Integrator_gainval_p;     // Computed Parameter: Integrator_gainval_p\n                                        //  Referenced by: '<S460>/Integrator'\n\n  real32_T Constant2_Value_i;          // Computed Parameter: Constant2_Value_i\n                                          //  Referenced by: '<S12>/Constant2'\n\n  real32_T Gain1_Gain_m;               // Computed Parameter: Gain1_Gain_m\n                                          //  Referenced by: '<S12>/Gain1'\n\n  real32_T DeadZone1_Start_c;          // Computed Parameter: DeadZone1_Start_c\n                                          //  Referenced by: '<S12>/Dead Zone1'\n\n  real32_T DeadZone1_End_m;            // Computed Parameter: DeadZone1_End_m\n                                          //  Referenced by: '<S12>/Dead Zone1'\n\n  real32_T Saturation2_UpperSat;     // Computed Parameter: Saturation2_UpperSat\n                                        //  Referenced by: '<S12>/Saturation2'\n\n  real32_T Saturation2_LowerSat;     // Computed Parameter: Saturation2_LowerSat\n                                        //  Referenced by: '<S12>/Saturation2'\n\n  real32_T Constant1_Value_l;          // Computed Parameter: Constant1_Value_l\n                                          //  Referenced by: '<S12>/Constant1'\n\n  real32_T Gain2_Gain_a;               // Computed Parameter: Gain2_Gain_a\n                                          //  Referenced by: '<S12>/Gain2'\n\n  real32_T DeadZone2_Start_o;          // Computed Parameter: DeadZone2_Start_o\n                                          //  Referenced by: '<S12>/Dead Zone2'\n\n  real32_T DeadZone2_End_e;            // Computed Parameter: DeadZone2_End_e\n                                          //  Referenced by: '<S12>/Dead Zone2'\n\n  real32_T Saturation1_UpperSat_l; // Computed Parameter: Saturation1_UpperSat_l\n                                      //  Referenced by: '<S12>/Saturation1'\n\n  real32_T Saturation1_LowerSat_i; // Computed Parameter: Saturation1_LowerSat_i\n                                      //  Referenced by: '<S12>/Saturation1'\n\n  real32_T DeadZone3_Start_p;          // Computed Parameter: DeadZone3_Start_p\n                                          //  Referenced by: '<S12>/Dead Zone3'\n\n  real32_T DeadZone3_End_l;            // Computed Parameter: DeadZone3_End_l\n                                          //  Referenced by: '<S12>/Dead Zone3'\n\n  real32_T Saturation_UpperSat_o;   // Computed Parameter: Saturation_UpperSat_o\n                                       //  Referenced by: '<S12>/Saturation'\n\n  real32_T Saturation_LowerSat_el; // Computed Parameter: Saturation_LowerSat_el\n                                      //  Referenced by: '<S12>/Saturation'\n\n  real32_T Constant3_Value_e;          // Computed Parameter: Constant3_Value_e\n                                          //  Referenced by: '<S12>/Constant3'\n\n  real32_T Gain3_Gain;                 // Computed Parameter: Gain3_Gain\n                                          //  Referenced by: '<S12>/Gain3'\n\n  real32_T DeadZone_Start;             // Computed Parameter: DeadZone_Start\n                                          //  Referenced by: '<S12>/Dead Zone'\n\n  real32_T DeadZone_End;               // Computed Parameter: DeadZone_End\n                                          //  Referenced by: '<S12>/Dead Zone'\n\n  real32_T Saturation3_UpperSat_b; // Computed Parameter: Saturation3_UpperSat_b\n                                      //  Referenced by: '<S12>/Saturation3'\n\n  real32_T Saturation3_LowerSat_j; // Computed Parameter: Saturation3_LowerSat_j\n                                      //  Referenced by: '<S12>/Saturation3'\n\n  real32_T Constant1_Value_g;          // Computed Parameter: Constant1_Value_g\n                                          //  Referenced by: '<S50>/Constant1'\n\n  real32_T rate_transition_des_p_InitialCo;\n                          // Computed Parameter: rate_transition_des_p_InitialCo\n                             //  Referenced by: '<Root>/rate_transition_des_p'\n\n  real32_T rate_transition_des_q_InitialCo;\n                          // Computed Parameter: rate_transition_des_q_InitialCo\n                             //  Referenced by: '<Root>/rate_transition_des_q'\n\n  real32_T rate_transition_des_r_InitialCo;\n                          // Computed Parameter: rate_transition_des_r_InitialCo\n                             //  Referenced by: '<Root>/rate_transition_des_r'\n\n  real32_T RateTransition1_InitialConditio;\n                          // Computed Parameter: RateTransition1_InitialConditio\n                             //  Referenced by: '<Root>/Rate Transition1'\n\n  real32_T rate_transition_throttle_Initia;\n                          // Computed Parameter: rate_transition_throttle_Initia\n                             //  Referenced by: '<Root>/rate_transition_throttle'\n\n  real32_T Constant1_Value_i[6];       // Computed Parameter: Constant1_Value_i\n                                          //  Referenced by: '<S15>/Constant1'\n\n  real32_T Saturation_UpperSat_ep; // Computed Parameter: Saturation_UpperSat_ep\n                                      //  Referenced by: '<S493>/Saturation'\n\n  real32_T Saturation_LowerSat_p;   // Computed Parameter: Saturation_LowerSat_p\n                                       //  Referenced by: '<S493>/Saturation'\n\n  real32_T Constant_Value_e;           // Computed Parameter: Constant_Value_e\n                                          //  Referenced by: '<S493>/Constant'\n\n  real32_T Gain_Gain_mg;               // Computed Parameter: Gain_Gain_mg\n                                          //  Referenced by: '<S493>/Gain'\n\n  real32_T Constant_Value_k;           // Computed Parameter: Constant_Value_k\n                                          //  Referenced by: '<S186>/Constant'\n\n  real32_T Constant_Value_ms;          // Computed Parameter: Constant_Value_ms\n                                          //  Referenced by: '<S187>/Constant'\n\n  real32_T Constant_Value_i;           // Computed Parameter: Constant_Value_i\n                                          //  Referenced by: '<S188>/Constant'\n\n  real32_T Constant_Value_j;           // Computed Parameter: Constant_Value_j\n                                          //  Referenced by: '<S189>/Constant'\n\n  real32_T Constant_Value_lw;          // Computed Parameter: Constant_Value_lw\n                                          //  Referenced by: '<S190>/Constant'\n\n  real32_T Constant_Value_ox;          // Computed Parameter: Constant_Value_ox\n                                          //  Referenced by: '<S191>/Constant'\n\n  real32_T DeadZone3_Start_l;          // Computed Parameter: DeadZone3_Start_l\n                                          //  Referenced by: '<S22>/Dead Zone3'\n\n  real32_T DeadZone3_End_n;            // Computed Parameter: DeadZone3_End_n\n                                          //  Referenced by: '<S22>/Dead Zone3'\n\n  real32_T Saturation9_UpperSat_c; // Computed Parameter: Saturation9_UpperSat_c\n                                      //  Referenced by: '<S22>/Saturation9'\n\n  real32_T Saturation9_LowerSat_i; // Computed Parameter: Saturation9_LowerSat_i\n                                      //  Referenced by: '<S22>/Saturation9'\n\n  real32_T DeadZone1_Start_n;          // Computed Parameter: DeadZone1_Start_n\n                                          //  Referenced by: '<S22>/Dead Zone1'\n\n  real32_T DeadZone1_End_mj;           // Computed Parameter: DeadZone1_End_mj\n                                          //  Referenced by: '<S22>/Dead Zone1'\n\n  real32_T Saturation1_UpperSat_d; // Computed Parameter: Saturation1_UpperSat_d\n                                      //  Referenced by: '<S22>/Saturation1'\n\n  real32_T Saturation1_LowerSat_b; // Computed Parameter: Saturation1_LowerSat_b\n                                      //  Referenced by: '<S22>/Saturation1'\n\n  real32_T DeadZone2_Start_m;          // Computed Parameter: DeadZone2_Start_m\n                                          //  Referenced by: '<S22>/Dead Zone2'\n\n  real32_T DeadZone2_End_b;            // Computed Parameter: DeadZone2_End_b\n                                          //  Referenced by: '<S22>/Dead Zone2'\n\n  real32_T Saturation3_UpperSat_d; // Computed Parameter: Saturation3_UpperSat_d\n                                      //  Referenced by: '<S22>/Saturation3'\n\n  real32_T Saturation3_LowerSat_n; // Computed Parameter: Saturation3_LowerSat_n\n                                      //  Referenced by: '<S22>/Saturation3'\n\n  real32_T DeadZone4_Start_o;          // Computed Parameter: DeadZone4_Start_o\n                                          //  Referenced by: '<S22>/Dead Zone4'\n\n  real32_T DeadZone4_End_a;            // Computed Parameter: DeadZone4_End_a\n                                          //  Referenced by: '<S22>/Dead Zone4'\n\n  real32_T Saturation10_UpperSat_g;\n                                  // Computed Parameter: Saturation10_UpperSat_g\n                                     //  Referenced by: '<S22>/Saturation10'\n\n  real32_T Saturation10_LowerSat_f;\n                                  // Computed Parameter: Saturation10_LowerSat_f\n                                     //  Referenced by: '<S22>/Saturation10'\n\n  real32_T Gain_Gain_er;               // Computed Parameter: Gain_Gain_er\n                                          //  Referenced by: '<S22>/Gain'\n\n  real32_T Gain_Gain_ob;               // Computed Parameter: Gain_Gain_ob\n                                          //  Referenced by: '<S1>/Gain'\n\n  real32_T Integrator_gainval_h;     // Computed Parameter: Integrator_gainval_h\n                                        //  Referenced by: '<S60>/Integrator'\n\n  real32_T Filter_gainval;             // Computed Parameter: Filter_gainval\n                                          //  Referenced by: '<S55>/Filter'\n\n  real32_T Constant_Value_gx;          // Computed Parameter: Constant_Value_gx\n                                          //  Referenced by: '<S1>/Constant'\n\n  real32_T Saturation1_UpperSat_lr;\n                                  // Computed Parameter: Saturation1_UpperSat_lr\n                                     //  Referenced by: '<S1>/Saturation1'\n\n  real32_T Saturation1_LowerSat_e; // Computed Parameter: Saturation1_LowerSat_e\n                                      //  Referenced by: '<S1>/Saturation1'\n\n  real32_T TSamp_WtEt_k;               // Computed Parameter: TSamp_WtEt_k\n                                          //  Referenced by: '<S480>/TSamp'\n\n  real32_T TSamp_WtEt_c;               // Computed Parameter: TSamp_WtEt_c\n                                          //  Referenced by: '<S478>/TSamp'\n\n  real32_T TSamp_WtEt_b;               // Computed Parameter: TSamp_WtEt_b\n                                          //  Referenced by: '<S479>/TSamp'\n\n  real32_T TSamp_WtEt_py;              // Computed Parameter: TSamp_WtEt_py\n                                          //  Referenced by: '<S481>/TSamp'\n\n  real32_T DiscreteTimeIntegrator_gainva_c;\n                          // Computed Parameter: DiscreteTimeIntegrator_gainva_c\n                             //  Referenced by: '<S11>/Discrete-Time Integrator'\n\n  real32_T DiscreteTimeIntegrator_IC;\n                                // Computed Parameter: DiscreteTimeIntegrator_IC\n                                   //  Referenced by: '<S11>/Discrete-Time Integrator'\n\n  real32_T Saturation2_UpperSat_i; // Computed Parameter: Saturation2_UpperSat_i\n                                      //  Referenced by: '<S11>/Saturation2'\n\n  real32_T Saturation2_LowerSat_k; // Computed Parameter: Saturation2_LowerSat_k\n                                      //  Referenced by: '<S11>/Saturation2'\n\n  real32_T Constant_Value_ll;          // Computed Parameter: Constant_Value_ll\n                                          //  Referenced by: '<S21>/Constant'\n\n  real32_T Constant_Value_a5;          // Computed Parameter: Constant_Value_a5\n                                          //  Referenced by: '<Root>/Constant'\n\n  real32_T Clamping_zero_Value;       // Computed Parameter: Clamping_zero_Value\n                                         //  Referenced by: '<S50>/Clamping_zero'\n\n  uint16_T PWM_Y0;                     // Computed Parameter: PWM_Y0\n                                          //  Referenced by: '<S7>/PWM'\n\n  uint16_T Output_Limits1_UpperSat;\n                                  // Computed Parameter: Output_Limits1_UpperSat\n                                     //  Referenced by: '<S7>/Output_Limits1'\n\n  uint16_T Output_Limits1_LowerSat;\n                                  // Computed Parameter: Output_Limits1_LowerSat\n                                     //  Referenced by: '<S7>/Output_Limits1'\n\n  uint16_T rate_transition_ctrl_sw_Initial;\n                          // Computed Parameter: rate_transition_ctrl_sw_Initial\n                             //  Referenced by: '<Root>/rate_transition_ctrl_sw'\n\n  uint16_T RateTransition4_InitialConditio;\n                          // Computed Parameter: RateTransition4_InitialConditio\n                             //  Referenced by: '<Root>/Rate Transition4'\n\n  boolean_T rate_transition_arm_InitialCond;\n                          // Computed Parameter: rate_transition_arm_InitialCond\n                             //  Referenced by: '<Root>/rate_transition_arm'\n\n  boolean_T RateTransition7_InitialConditio;\n                          // Computed Parameter: RateTransition7_InitialConditio\n                             //  Referenced by: '<Root>/Rate Transition7'\n\n  int8_T Constant_Value_ko;            // Computed Parameter: Constant_Value_ko\n                                          //  Referenced by: '<S50>/Constant'\n\n  int8_T Constant2_Value_e;            // Computed Parameter: Constant2_Value_e\n                                          //  Referenced by: '<S50>/Constant2'\n\n  int8_T Constant3_Value_i;            // Computed Parameter: Constant3_Value_i\n                                          //  Referenced by: '<S50>/Constant3'\n\n  int8_T Constant4_Value_d;            // Computed Parameter: Constant4_Value_d\n                                          //  Referenced by: '<S50>/Constant4'\n\n};\n\n// Real-time Model Data Structure\nstruct tag_RTM_FLIGHT_hexacopter_T {\n  const char_T *errorStatus;\n  RTWExtModeInfo *extModeInfo;\n\n  //\n  //  Sizes:\n  //  The following substructure contains sizes information\n  //  for many of the model attributes such as inputs, outputs,\n  //  dwork, sample times, etc.\n\n  struct {\n    uint32_T checksums[4];\n  } Sizes;\n\n  //\n  //  SpecialInfo:\n  //  The following substructure contains special information\n  //  related to other components that are dependent on RTW.\n\n  struct {\n    const void *mappingInfo;\n  } SpecialInfo;\n\n  //\n  //  Timing:\n  //  The following substructure contains information regarding\n  //  the timing information for the model.\n\n  struct {\n    time_T taskTime0;\n    uint32_T clockTick0;\n    time_T stepSize0;\n    uint32_T clockTick1;\n    struct {\n      uint8_T TID[2];\n    } TaskCounters;\n\n    struct {\n      boolean_T TID0_1;\n    } RateInteraction;\n\n    time_T tFinal;\n    boolean_T stopRequestedFlag;\n  } Timing;\n};\n\n// Block parameters (default storage)\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern P_FLIGHT_hexacopter_T FLIGHT_hexacopter_P;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n// Block signals (default storage)\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern struct B_FLIGHT_hexacopter_T FLIGHT_hexacopter_B;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n// Block states (default storage)\nextern struct DW_FLIGHT_hexacopter_T FLIGHT_hexacopter_DW;\n\n// External function called from main\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern void FLIGHT_hexacopter_SetEventsForThisBaseStep(boolean_T *eventFlags);\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  // Model entry point functions\n  extern void FLIGHT_hexacopter_initialize(void);\n  extern void FLIGHT_hexacopter_step0(void);\n  extern void FLIGHT_hexacopter_step1(void);\n  extern void FLIGHT_hexacopter_step(int_T tid);\n  extern void FLIGHT_hexacopter_terminate(void);\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n// Real-time Model object\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern RT_MODEL_FLIGHT_hexacopter_T *const FLIGHT_hexacopter_M;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\nextern volatile boolean_T stopRequested;\nextern volatile boolean_T runModel;\n\n//-\n//  These blocks were eliminated from the model due to optimizations:\n//\n//  Block '<S122>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S122>/Data Type Propagation' : Unused code path elimination\n//  Block '<S173>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S173>/Data Type Propagation' : Unused code path elimination\n//  Block '<S301>/NOT' : Unused code path elimination\n//  Block '<S304>/NOT' : Unused code path elimination\n//  Block '<S302>/Signal Copy' : Unused code path elimination\n//  Block '<S302>/Signal Copy1' : Unused code path elimination\n//  Block '<S302>/Signal Copy2' : Unused code path elimination\n//  Block '<S306>/NOT' : Unused code path elimination\n//  Block '<S312>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S367>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S422>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S478>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S479>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S480>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S481>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S497>/NOT' : Unused code path elimination\n//  Block '<S500>/NOT' : Unused code path elimination\n//  Block '<S501>/NOT' : Unused code path elimination\n//  Block '<S19>/Constant' : Unused code path elimination\n//  Block '<S505>/1//2' : Unused code path elimination\n//  Block '<S505>/q0' : Unused code path elimination\n//  Block '<S505>/q1' : Unused code path elimination\n//  Block '<S505>/q2' : Unused code path elimination\n//  Block '<S505>/q3' : Unused code path elimination\n//  Block '<S505>/sincos' : Unused code path elimination\n//  Block '<S8>/Data Type Conversion' : Eliminate redundant data type conversion\n//  Block '<S8>/Data Type Conversion9' : Eliminate redundant data type conversion\n//  Block '<S477>/Data Type Conversion' : Eliminate redundant data type conversion\n//  Block '<S477>/Data Type Conversion1' : Eliminate redundant data type conversion\n//  Block '<S15>/Data Type Conversion1' : Eliminate redundant data type conversion\n\n\n//-\n//  The generated code includes comments that allow you to trace directly\n//  back to the appropriate location in the model.  The basic format\n//  is <system>/block_name, where system is the system number (uniquely\n//  assigned by Simulink) and block_name is the name of the block.\n//\n//  Use the MATLAB hilite_system command to trace the generated code back\n//  to the model.  For example,\n//\n//  hilite_system('<S3>')    - opens system 3\n//  hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n//\n//  Here is the system hierarchy for this model\n//\n//  '<Root>' : 'FLIGHT_hexacopter'\n//  '<S1>'   : 'FLIGHT_hexacopter/Altitude_Mode'\n//  '<S2>'   : 'FLIGHT_hexacopter/CAS'\n//  '<S3>'   : 'FLIGHT_hexacopter/Doublet_Generator'\n//  '<S4>'   : 'FLIGHT_hexacopter/Fault_Injection'\n//  '<S5>'   : 'FLIGHT_hexacopter/If Action Subsystem'\n//  '<S6>'   : 'FLIGHT_hexacopter/MATLAB Function'\n//  '<S7>'   : 'FLIGHT_hexacopter/Mixer'\n//  '<S8>'   : 'FLIGHT_hexacopter/Read uORB'\n//  '<S9>'   : 'FLIGHT_hexacopter/Remote Control'\n//  '<S10>'  : 'FLIGHT_hexacopter/SAS'\n//  '<S11>'  : 'FLIGHT_hexacopter/SMC'\n//  '<S12>'  : 'FLIGHT_hexacopter/Stabilized_Mode'\n//  '<S13>'  : 'FLIGHT_hexacopter/Subsystem'\n//  '<S14>'  : 'FLIGHT_hexacopter/actuator_controls'\n//  '<S15>'  : 'FLIGHT_hexacopter/actuator_outputs_motors'\n//  '<S16>'  : 'FLIGHT_hexacopter/quat2eul'\n//  '<S17>'  : 'FLIGHT_hexacopter/sub_vehicle_angular_velocity'\n//  '<S18>'  : 'FLIGHT_hexacopter/sub_vehicle_status'\n//  '<S19>'  : 'FLIGHT_hexacopter/vehicle_attitude_setpoint'\n//  '<S20>'  : 'FLIGHT_hexacopter/vehicle_local_position_setpoint'\n//  '<S21>'  : 'FLIGHT_hexacopter/vehicle_rate_setpoint'\n//  '<S22>'  : 'FLIGHT_hexacopter/Altitude_Mode/Altitude_Mode_Stick2Command'\n//  '<S23>'  : 'FLIGHT_hexacopter/Altitude_Mode/Compare To Constant1'\n//  '<S24>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller'\n//  '<S25>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Anti-windup'\n//  '<S26>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/D Gain'\n//  '<S27>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/External Derivative'\n//  '<S28>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Filter'\n//  '<S29>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Filter ICs'\n//  '<S30>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/I Gain'\n//  '<S31>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Ideal P Gain'\n//  '<S32>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Ideal P Gain Fdbk'\n//  '<S33>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Integrator'\n//  '<S34>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Integrator ICs'\n//  '<S35>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/N Copy'\n//  '<S36>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/N Gain'\n//  '<S37>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/P Copy'\n//  '<S38>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Parallel P Gain'\n//  '<S39>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Reset Signal'\n//  '<S40>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Saturation'\n//  '<S41>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Saturation Fdbk'\n//  '<S42>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Sum'\n//  '<S43>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Sum Fdbk'\n//  '<S44>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Tracking Mode'\n//  '<S45>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Tracking Mode Sum'\n//  '<S46>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Tsamp - Integral'\n//  '<S47>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Tsamp - Ngain'\n//  '<S48>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/postSat Signal'\n//  '<S49>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/preSat Signal'\n//  '<S50>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Anti-windup/Disc. Clamping Parallel'\n//  '<S51>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Anti-windup/Disc. Clamping Parallel/Dead Zone'\n//  '<S52>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\n//  '<S53>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/D Gain/External Parameters'\n//  '<S54>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/External Derivative/Error'\n//  '<S55>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Filter/Disc. Forward Euler Filter'\n//  '<S56>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Filter ICs/Internal IC - Filter'\n//  '<S57>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/I Gain/External Parameters'\n//  '<S58>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Ideal P Gain/Passthrough'\n//  '<S59>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Ideal P Gain Fdbk/Disabled'\n//  '<S60>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Integrator/Discrete'\n//  '<S61>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Integrator ICs/Internal IC'\n//  '<S62>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/N Copy/Disabled'\n//  '<S63>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/N Gain/External Parameters'\n//  '<S64>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/P Copy/Disabled'\n//  '<S65>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Parallel P Gain/External Parameters'\n//  '<S66>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Reset Signal/External Reset'\n//  '<S67>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Saturation/Enabled'\n//  '<S68>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Saturation Fdbk/Disabled'\n//  '<S69>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Sum/Sum_PID'\n//  '<S70>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Sum Fdbk/Disabled'\n//  '<S71>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Tracking Mode/Disabled'\n//  '<S72>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Tracking Mode Sum/Passthrough'\n//  '<S73>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Tsamp - Integral/TsSignalSpecification'\n//  '<S74>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Tsamp - Ngain/Passthrough'\n//  '<S75>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/postSat Signal/Forward_Path'\n//  '<S76>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/preSat Signal/Forward_Path'\n//  '<S77>'  : 'FLIGHT_hexacopter/CAS/Degrees to Radians'\n//  '<S78>'  : 'FLIGHT_hexacopter/CAS/Degrees to Radians1'\n//  '<S79>'  : 'FLIGHT_hexacopter/CAS/PID Controller3'\n//  '<S80>'  : 'FLIGHT_hexacopter/CAS/PID Controller4'\n//  '<S81>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Anti-windup'\n//  '<S82>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/D Gain'\n//  '<S83>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/External Derivative'\n//  '<S84>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Filter'\n//  '<S85>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Filter ICs'\n//  '<S86>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/I Gain'\n//  '<S87>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Ideal P Gain'\n//  '<S88>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Ideal P Gain Fdbk'\n//  '<S89>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Integrator'\n//  '<S90>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Integrator ICs'\n//  '<S91>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/N Copy'\n//  '<S92>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/N Gain'\n//  '<S93>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/P Copy'\n//  '<S94>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Parallel P Gain'\n//  '<S95>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Reset Signal'\n//  '<S96>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Saturation'\n//  '<S97>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Saturation Fdbk'\n//  '<S98>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Sum'\n//  '<S99>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Sum Fdbk'\n//  '<S100>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tracking Mode'\n//  '<S101>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tracking Mode Sum'\n//  '<S102>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tsamp - Integral'\n//  '<S103>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tsamp - Ngain'\n//  '<S104>' : 'FLIGHT_hexacopter/CAS/PID Controller3/postSat Signal'\n//  '<S105>' : 'FLIGHT_hexacopter/CAS/PID Controller3/preSat Signal'\n//  '<S106>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Anti-windup/Disabled'\n//  '<S107>' : 'FLIGHT_hexacopter/CAS/PID Controller3/D Gain/Disabled'\n//  '<S108>' : 'FLIGHT_hexacopter/CAS/PID Controller3/External Derivative/Disabled'\n//  '<S109>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Filter/Disabled'\n//  '<S110>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Filter ICs/Disabled'\n//  '<S111>' : 'FLIGHT_hexacopter/CAS/PID Controller3/I Gain/Disabled'\n//  '<S112>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Ideal P Gain/Passthrough'\n//  '<S113>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Ideal P Gain Fdbk/Disabled'\n//  '<S114>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Integrator/Disabled'\n//  '<S115>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Integrator ICs/Disabled'\n//  '<S116>' : 'FLIGHT_hexacopter/CAS/PID Controller3/N Copy/Disabled wSignal Specification'\n//  '<S117>' : 'FLIGHT_hexacopter/CAS/PID Controller3/N Gain/Disabled'\n//  '<S118>' : 'FLIGHT_hexacopter/CAS/PID Controller3/P Copy/Disabled'\n//  '<S119>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Parallel P Gain/External Parameters'\n//  '<S120>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Reset Signal/Disabled'\n//  '<S121>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Saturation/External'\n//  '<S122>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Saturation/External/Saturation Dynamic'\n//  '<S123>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Saturation Fdbk/Disabled'\n//  '<S124>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Sum/Passthrough_P'\n//  '<S125>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Sum Fdbk/Disabled'\n//  '<S126>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tracking Mode/Disabled'\n//  '<S127>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tracking Mode Sum/Passthrough'\n//  '<S128>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tsamp - Integral/TsSignalSpecification'\n//  '<S129>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tsamp - Ngain/Passthrough'\n//  '<S130>' : 'FLIGHT_hexacopter/CAS/PID Controller3/postSat Signal/Forward_Path'\n//  '<S131>' : 'FLIGHT_hexacopter/CAS/PID Controller3/preSat Signal/Forward_Path'\n//  '<S132>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Anti-windup'\n//  '<S133>' : 'FLIGHT_hexacopter/CAS/PID Controller4/D Gain'\n//  '<S134>' : 'FLIGHT_hexacopter/CAS/PID Controller4/External Derivative'\n//  '<S135>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Filter'\n//  '<S136>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Filter ICs'\n//  '<S137>' : 'FLIGHT_hexacopter/CAS/PID Controller4/I Gain'\n//  '<S138>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Ideal P Gain'\n//  '<S139>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Ideal P Gain Fdbk'\n//  '<S140>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Integrator'\n//  '<S141>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Integrator ICs'\n//  '<S142>' : 'FLIGHT_hexacopter/CAS/PID Controller4/N Copy'\n//  '<S143>' : 'FLIGHT_hexacopter/CAS/PID Controller4/N Gain'\n//  '<S144>' : 'FLIGHT_hexacopter/CAS/PID Controller4/P Copy'\n//  '<S145>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Parallel P Gain'\n//  '<S146>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Reset Signal'\n//  '<S147>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Saturation'\n//  '<S148>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Saturation Fdbk'\n//  '<S149>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Sum'\n//  '<S150>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Sum Fdbk'\n//  '<S151>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tracking Mode'\n//  '<S152>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tracking Mode Sum'\n//  '<S153>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tsamp - Integral'\n//  '<S154>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tsamp - Ngain'\n//  '<S155>' : 'FLIGHT_hexacopter/CAS/PID Controller4/postSat Signal'\n//  '<S156>' : 'FLIGHT_hexacopter/CAS/PID Controller4/preSat Signal'\n//  '<S157>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Anti-windup/Disabled'\n//  '<S158>' : 'FLIGHT_hexacopter/CAS/PID Controller4/D Gain/Disabled'\n//  '<S159>' : 'FLIGHT_hexacopter/CAS/PID Controller4/External Derivative/Disabled'\n//  '<S160>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Filter/Disabled'\n//  '<S161>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Filter ICs/Disabled'\n//  '<S162>' : 'FLIGHT_hexacopter/CAS/PID Controller4/I Gain/Disabled'\n//  '<S163>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Ideal P Gain/Passthrough'\n//  '<S164>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Ideal P Gain Fdbk/Disabled'\n//  '<S165>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Integrator/Disabled'\n//  '<S166>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Integrator ICs/Disabled'\n//  '<S167>' : 'FLIGHT_hexacopter/CAS/PID Controller4/N Copy/Disabled wSignal Specification'\n//  '<S168>' : 'FLIGHT_hexacopter/CAS/PID Controller4/N Gain/Disabled'\n//  '<S169>' : 'FLIGHT_hexacopter/CAS/PID Controller4/P Copy/Disabled'\n//  '<S170>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Parallel P Gain/External Parameters'\n//  '<S171>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Reset Signal/Disabled'\n//  '<S172>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Saturation/External'\n//  '<S173>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Saturation/External/Saturation Dynamic'\n//  '<S174>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Saturation Fdbk/Disabled'\n//  '<S175>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Sum/Passthrough_P'\n//  '<S176>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Sum Fdbk/Disabled'\n//  '<S177>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tracking Mode/Disabled'\n//  '<S178>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tracking Mode Sum/Passthrough'\n//  '<S179>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tsamp - Integral/TsSignalSpecification'\n//  '<S180>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tsamp - Ngain/Passthrough'\n//  '<S181>' : 'FLIGHT_hexacopter/CAS/PID Controller4/postSat Signal/Forward_Path'\n//  '<S182>' : 'FLIGHT_hexacopter/CAS/PID Controller4/preSat Signal/Forward_Path'\n//  '<S183>' : 'FLIGHT_hexacopter/Doublet_Generator/Compare To Constant1'\n//  '<S184>' : 'FLIGHT_hexacopter/Doublet_Generator/MATLAB Function'\n//  '<S185>' : 'FLIGHT_hexacopter/Fault_Injection/Compare To Constant'\n//  '<S186>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference'\n//  '<S187>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference1'\n//  '<S188>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference2'\n//  '<S189>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference3'\n//  '<S190>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference4'\n//  '<S191>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference5'\n//  '<S192>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude_Mode_Stick2Command'\n//  '<S193>' : 'FLIGHT_hexacopter/If Action Subsystem/Compare To Constant2'\n//  '<S194>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller'\n//  '<S195>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller'\n//  '<S196>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude'\n//  '<S197>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Anti-windup'\n//  '<S198>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/D Gain'\n//  '<S199>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/External Derivative'\n//  '<S200>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Filter'\n//  '<S201>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Filter ICs'\n//  '<S202>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/I Gain'\n//  '<S203>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Ideal P Gain'\n//  '<S204>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Ideal P Gain Fdbk'\n//  '<S205>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Integrator'\n//  '<S206>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Integrator ICs'\n//  '<S207>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/N Copy'\n//  '<S208>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/N Gain'\n//  '<S209>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/P Copy'\n//  '<S210>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Parallel P Gain'\n//  '<S211>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Reset Signal'\n//  '<S212>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Saturation'\n//  '<S213>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Saturation Fdbk'\n//  '<S214>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Sum'\n//  '<S215>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Sum Fdbk'\n//  '<S216>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tracking Mode'\n//  '<S217>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tracking Mode Sum'\n//  '<S218>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tsamp - Integral'\n//  '<S219>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tsamp - Ngain'\n//  '<S220>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/postSat Signal'\n//  '<S221>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/preSat Signal'\n//  '<S222>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Anti-windup/Disabled'\n//  '<S223>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/D Gain/Disabled'\n//  '<S224>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/External Derivative/Disabled'\n//  '<S225>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Filter/Disabled'\n//  '<S226>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Filter ICs/Disabled'\n//  '<S227>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/I Gain/Disabled'\n//  '<S228>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Ideal P Gain/Passthrough'\n//  '<S229>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Ideal P Gain Fdbk/Disabled'\n//  '<S230>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Integrator/Disabled'\n//  '<S231>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Integrator ICs/Disabled'\n//  '<S232>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/N Copy/Disabled wSignal Specification'\n//  '<S233>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/N Gain/Disabled'\n//  '<S234>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/P Copy/Disabled'\n//  '<S235>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Parallel P Gain/External Parameters'\n//  '<S236>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Reset Signal/Disabled'\n//  '<S237>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Saturation/Passthrough'\n//  '<S238>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Saturation Fdbk/Disabled'\n//  '<S239>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Sum/Passthrough_P'\n//  '<S240>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Sum Fdbk/Disabled'\n//  '<S241>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tracking Mode/Disabled'\n//  '<S242>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tracking Mode Sum/Passthrough'\n//  '<S243>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tsamp - Integral/TsSignalSpecification'\n//  '<S244>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tsamp - Ngain/Passthrough'\n//  '<S245>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/postSat Signal/Forward_Path'\n//  '<S246>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/preSat Signal/Forward_Path'\n//  '<S247>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/NED2Body1'\n//  '<S248>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude'\n//  '<S249>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/NED2Body1/Calculate Transformation Matrix'\n//  '<S250>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Anti-windup'\n//  '<S251>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/D Gain'\n//  '<S252>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/External Derivative'\n//  '<S253>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Filter'\n//  '<S254>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Filter ICs'\n//  '<S255>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/I Gain'\n//  '<S256>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Ideal P Gain'\n//  '<S257>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Ideal P Gain Fdbk'\n//  '<S258>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Integrator'\n//  '<S259>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Integrator ICs'\n//  '<S260>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/N Copy'\n//  '<S261>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/N Gain'\n//  '<S262>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/P Copy'\n//  '<S263>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Parallel P Gain'\n//  '<S264>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Reset Signal'\n//  '<S265>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Saturation'\n//  '<S266>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Saturation Fdbk'\n//  '<S267>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Sum'\n//  '<S268>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Sum Fdbk'\n//  '<S269>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tracking Mode'\n//  '<S270>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tracking Mode Sum'\n//  '<S271>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tsamp - Integral'\n//  '<S272>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tsamp - Ngain'\n//  '<S273>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/postSat Signal'\n//  '<S274>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/preSat Signal'\n//  '<S275>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Anti-windup/Disabled'\n//  '<S276>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/D Gain/Disabled'\n//  '<S277>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/External Derivative/Disabled'\n//  '<S278>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Filter/Disabled'\n//  '<S279>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Filter ICs/Disabled'\n//  '<S280>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/I Gain/Disabled'\n//  '<S281>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Ideal P Gain/Passthrough'\n//  '<S282>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Ideal P Gain Fdbk/Disabled'\n//  '<S283>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Integrator/Disabled'\n//  '<S284>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Integrator ICs/Disabled'\n//  '<S285>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/N Copy/Disabled wSignal Specification'\n//  '<S286>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/N Gain/Disabled'\n//  '<S287>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/P Copy/Disabled'\n//  '<S288>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Parallel P Gain/External Parameters'\n//  '<S289>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Reset Signal/Disabled'\n//  '<S290>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Saturation/Passthrough'\n//  '<S291>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Saturation Fdbk/Disabled'\n//  '<S292>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Sum/Passthrough_P'\n//  '<S293>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Sum Fdbk/Disabled'\n//  '<S294>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tracking Mode/Disabled'\n//  '<S295>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tracking Mode Sum/Passthrough'\n//  '<S296>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tsamp - Integral/TsSignalSpecification'\n//  '<S297>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tsamp - Ngain/Passthrough'\n//  '<S298>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/postSat Signal/Forward_Path'\n//  '<S299>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/preSat Signal/Forward_Path'\n//  '<S300>' : 'FLIGHT_hexacopter/Mixer/pwm_out2'\n//  '<S301>' : 'FLIGHT_hexacopter/Read uORB/PX4 uORB Read'\n//  '<S302>' : 'FLIGHT_hexacopter/Read uORB/Vehicle Attitude'\n//  '<S303>' : 'FLIGHT_hexacopter/Read uORB/PX4 uORB Read/Enabled Subsystem'\n//  '<S304>' : 'FLIGHT_hexacopter/Read uORB/Vehicle Attitude/PX4 uORB Read'\n//  '<S305>' : 'FLIGHT_hexacopter/Read uORB/Vehicle Attitude/PX4 uORB Read/Enabled Subsystem'\n//  '<S306>' : 'FLIGHT_hexacopter/Remote Control/PX4 uORB Read'\n//  '<S307>' : 'FLIGHT_hexacopter/Remote Control/PX4 uORB Read/Enabled Subsystem'\n//  '<S308>' : 'FLIGHT_hexacopter/SAS/MATLAB Function'\n//  '<S309>' : 'FLIGHT_hexacopter/SAS/Pitchrate'\n//  '<S310>' : 'FLIGHT_hexacopter/SAS/Rollrate'\n//  '<S311>' : 'FLIGHT_hexacopter/SAS/Yawrate'\n//  '<S312>' : 'FLIGHT_hexacopter/SAS/Pitchrate/Discrete Derivative2'\n//  '<S313>' : 'FLIGHT_hexacopter/SAS/Pitchrate/Discrete Varying Lowpass2'\n//  '<S314>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate'\n//  '<S315>' : 'FLIGHT_hexacopter/SAS/Pitchrate/Discrete Varying Lowpass2/SOS1'\n//  '<S316>' : 'FLIGHT_hexacopter/SAS/Pitchrate/Discrete Varying Lowpass2/SOS1/Arithmetic'\n//  '<S317>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Anti-windup'\n//  '<S318>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/D Gain'\n//  '<S319>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/External Derivative'\n//  '<S320>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Filter'\n//  '<S321>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Filter ICs'\n//  '<S322>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/I Gain'\n//  '<S323>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Ideal P Gain'\n//  '<S324>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Ideal P Gain Fdbk'\n//  '<S325>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Integrator'\n//  '<S326>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Integrator ICs'\n//  '<S327>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/N Copy'\n//  '<S328>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/N Gain'\n//  '<S329>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/P Copy'\n//  '<S330>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Parallel P Gain'\n//  '<S331>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Reset Signal'\n//  '<S332>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Saturation'\n//  '<S333>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Saturation Fdbk'\n//  '<S334>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Sum'\n//  '<S335>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Sum Fdbk'\n//  '<S336>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Tracking Mode'\n//  '<S337>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Tracking Mode Sum'\n//  '<S338>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Tsamp - Integral'\n//  '<S339>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Tsamp - Ngain'\n//  '<S340>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/postSat Signal'\n//  '<S341>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/preSat Signal'\n//  '<S342>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Anti-windup/Passthrough'\n//  '<S343>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/D Gain/Disabled'\n//  '<S344>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/External Derivative/Disabled'\n//  '<S345>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Filter/Disabled'\n//  '<S346>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Filter ICs/Disabled'\n//  '<S347>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/I Gain/External Parameters'\n//  '<S348>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Ideal P Gain/Passthrough'\n//  '<S349>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Ideal P Gain Fdbk/Disabled'\n//  '<S350>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Integrator/Discrete'\n//  '<S351>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Integrator ICs/Internal IC'\n//  '<S352>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/N Copy/Disabled wSignal Specification'\n//  '<S353>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/N Gain/Disabled'\n//  '<S354>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/P Copy/Disabled'\n//  '<S355>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Parallel P Gain/External Parameters'\n//  '<S356>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Reset Signal/Disabled'\n//  '<S357>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Saturation/Passthrough'\n//  '<S358>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Saturation Fdbk/Disabled'\n//  '<S359>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Sum/Sum_PI'\n//  '<S360>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Sum Fdbk/Disabled'\n//  '<S361>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Tracking Mode/Disabled'\n//  '<S362>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Tracking Mode Sum/Passthrough'\n//  '<S363>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Tsamp - Integral/TsSignalSpecification'\n//  '<S364>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Tsamp - Ngain/Passthrough'\n//  '<S365>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/postSat Signal/Forward_Path'\n//  '<S366>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/preSat Signal/Forward_Path'\n//  '<S367>' : 'FLIGHT_hexacopter/SAS/Rollrate/Discrete Derivative2'\n//  '<S368>' : 'FLIGHT_hexacopter/SAS/Rollrate/Discrete Varying Lowpass2'\n//  '<S369>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate'\n//  '<S370>' : 'FLIGHT_hexacopter/SAS/Rollrate/Discrete Varying Lowpass2/SOS1'\n//  '<S371>' : 'FLIGHT_hexacopter/SAS/Rollrate/Discrete Varying Lowpass2/SOS1/Arithmetic'\n//  '<S372>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Anti-windup'\n//  '<S373>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/D Gain'\n//  '<S374>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/External Derivative'\n//  '<S375>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Filter'\n//  '<S376>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Filter ICs'\n//  '<S377>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/I Gain'\n//  '<S378>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Ideal P Gain'\n//  '<S379>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Ideal P Gain Fdbk'\n//  '<S380>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Integrator'\n//  '<S381>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Integrator ICs'\n//  '<S382>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/N Copy'\n//  '<S383>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/N Gain'\n//  '<S384>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/P Copy'\n//  '<S385>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Parallel P Gain'\n//  '<S386>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Reset Signal'\n//  '<S387>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Saturation'\n//  '<S388>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Saturation Fdbk'\n//  '<S389>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Sum'\n//  '<S390>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Sum Fdbk'\n//  '<S391>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Tracking Mode'\n//  '<S392>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Tracking Mode Sum'\n//  '<S393>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Tsamp - Integral'\n//  '<S394>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Tsamp - Ngain'\n//  '<S395>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/postSat Signal'\n//  '<S396>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/preSat Signal'\n//  '<S397>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Anti-windup/Passthrough'\n//  '<S398>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/D Gain/Disabled'\n//  '<S399>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/External Derivative/Disabled'\n//  '<S400>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Filter/Disabled'\n//  '<S401>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Filter ICs/Disabled'\n//  '<S402>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/I Gain/External Parameters'\n//  '<S403>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Ideal P Gain/Passthrough'\n//  '<S404>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Ideal P Gain Fdbk/Disabled'\n//  '<S405>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Integrator/Discrete'\n//  '<S406>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Integrator ICs/Internal IC'\n//  '<S407>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/N Copy/Disabled wSignal Specification'\n//  '<S408>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/N Gain/Disabled'\n//  '<S409>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/P Copy/Disabled'\n//  '<S410>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Parallel P Gain/External Parameters'\n//  '<S411>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Reset Signal/Disabled'\n//  '<S412>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Saturation/Passthrough'\n//  '<S413>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Saturation Fdbk/Disabled'\n//  '<S414>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Sum/Sum_PI'\n//  '<S415>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Sum Fdbk/Disabled'\n//  '<S416>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Tracking Mode/Disabled'\n//  '<S417>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Tracking Mode Sum/Passthrough'\n//  '<S418>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Tsamp - Integral/TsSignalSpecification'\n//  '<S419>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Tsamp - Ngain/Passthrough'\n//  '<S420>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/postSat Signal/Forward_Path'\n//  '<S421>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/preSat Signal/Forward_Path'\n//  '<S422>' : 'FLIGHT_hexacopter/SAS/Yawrate/Discrete Derivative2'\n//  '<S423>' : 'FLIGHT_hexacopter/SAS/Yawrate/Discrete Varying Lowpass2'\n//  '<S424>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate'\n//  '<S425>' : 'FLIGHT_hexacopter/SAS/Yawrate/Discrete Varying Lowpass2/SOS1'\n//  '<S426>' : 'FLIGHT_hexacopter/SAS/Yawrate/Discrete Varying Lowpass2/SOS1/Arithmetic'\n//  '<S427>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Anti-windup'\n//  '<S428>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/D Gain'\n//  '<S429>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/External Derivative'\n//  '<S430>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Filter'\n//  '<S431>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Filter ICs'\n//  '<S432>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/I Gain'\n//  '<S433>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Ideal P Gain'\n//  '<S434>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Ideal P Gain Fdbk'\n//  '<S435>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Integrator'\n//  '<S436>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Integrator ICs'\n//  '<S437>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/N Copy'\n//  '<S438>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/N Gain'\n//  '<S439>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/P Copy'\n//  '<S440>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Parallel P Gain'\n//  '<S441>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Reset Signal'\n//  '<S442>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Saturation'\n//  '<S443>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Saturation Fdbk'\n//  '<S444>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Sum'\n//  '<S445>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Sum Fdbk'\n//  '<S446>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Tracking Mode'\n//  '<S447>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Tracking Mode Sum'\n//  '<S448>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Tsamp - Integral'\n//  '<S449>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Tsamp - Ngain'\n//  '<S450>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/postSat Signal'\n//  '<S451>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/preSat Signal'\n//  '<S452>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Anti-windup/Passthrough'\n//  '<S453>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/D Gain/Disabled'\n//  '<S454>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/External Derivative/Disabled'\n//  '<S455>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Filter/Disabled'\n//  '<S456>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Filter ICs/Disabled'\n//  '<S457>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/I Gain/External Parameters'\n//  '<S458>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Ideal P Gain/Passthrough'\n//  '<S459>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Ideal P Gain Fdbk/Disabled'\n//  '<S460>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Integrator/Discrete'\n//  '<S461>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Integrator ICs/Internal IC'\n//  '<S462>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/N Copy/Disabled wSignal Specification'\n//  '<S463>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/N Gain/Disabled'\n//  '<S464>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/P Copy/Disabled'\n//  '<S465>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Parallel P Gain/External Parameters'\n//  '<S466>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Reset Signal/Disabled'\n//  '<S467>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Saturation/Passthrough'\n//  '<S468>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Saturation Fdbk/Disabled'\n//  '<S469>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Sum/Sum_PI'\n//  '<S470>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Sum Fdbk/Disabled'\n//  '<S471>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Tracking Mode/Disabled'\n//  '<S472>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Tracking Mode Sum/Passthrough'\n//  '<S473>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Tsamp - Integral/TsSignalSpecification'\n//  '<S474>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Tsamp - Ngain/Passthrough'\n//  '<S475>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/postSat Signal/Forward_Path'\n//  '<S476>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/preSat Signal/Forward_Path'\n//  '<S477>' : 'FLIGHT_hexacopter/SMC/Calc_Fx_Gx'\n//  '<S478>' : 'FLIGHT_hexacopter/SMC/Discrete Derivative'\n//  '<S479>' : 'FLIGHT_hexacopter/SMC/Discrete Derivative1'\n//  '<S480>' : 'FLIGHT_hexacopter/SMC/Discrete Derivative2'\n//  '<S481>' : 'FLIGHT_hexacopter/SMC/Discrete Derivative3'\n//  '<S482>' : 'FLIGHT_hexacopter/SMC/MATLAB Function'\n//  '<S483>' : 'FLIGHT_hexacopter/SMC/MATLAB Function1'\n//  '<S484>' : 'FLIGHT_hexacopter/SMC/MATLAB Function2'\n//  '<S485>' : 'FLIGHT_hexacopter/SMC/MATLAB Function3'\n//  '<S486>' : 'FLIGHT_hexacopter/SMC/MATLAB Function4'\n//  '<S487>' : 'FLIGHT_hexacopter/SMC/Omega_phi'\n//  '<S488>' : 'FLIGHT_hexacopter/Subsystem/Compare To Constant'\n//  '<S489>' : 'FLIGHT_hexacopter/Subsystem/MATLAB Function'\n//  '<S490>' : 'FLIGHT_hexacopter/actuator_controls/PX4 ULog'\n//  '<S491>' : 'FLIGHT_hexacopter/actuator_controls/PX4 ULog/PX4 uORB Message'\n//  '<S492>' : 'FLIGHT_hexacopter/actuator_controls/PX4 ULog/PX4_log_write'\n//  '<S493>' : 'FLIGHT_hexacopter/actuator_outputs_motors/Normalize_pwm6'\n//  '<S494>' : 'FLIGHT_hexacopter/actuator_outputs_motors/PX4 ULog'\n//  '<S495>' : 'FLIGHT_hexacopter/actuator_outputs_motors/PX4 ULog/PX4 uORB Message'\n//  '<S496>' : 'FLIGHT_hexacopter/actuator_outputs_motors/PX4 ULog/PX4_log_write'\n//  '<S497>' : 'FLIGHT_hexacopter/sub_vehicle_angular_velocity/PX4 uORB Read1'\n//  '<S498>' : 'FLIGHT_hexacopter/sub_vehicle_angular_velocity/PX4 uORB Read1/Enabled Subsystem'\n//  '<S499>' : 'FLIGHT_hexacopter/sub_vehicle_status/MATLAB Function'\n//  '<S500>' : 'FLIGHT_hexacopter/sub_vehicle_status/PX4 uORB Read'\n//  '<S501>' : 'FLIGHT_hexacopter/sub_vehicle_status/PX4 uORB Read1'\n//  '<S502>' : 'FLIGHT_hexacopter/sub_vehicle_status/PX4 uORB Read/Enabled Subsystem'\n//  '<S503>' : 'FLIGHT_hexacopter/sub_vehicle_status/PX4 uORB Read1/Enabled Subsystem'\n//  '<S504>' : 'FLIGHT_hexacopter/vehicle_attitude_setpoint/PX4 ULog'\n//  '<S505>' : 'FLIGHT_hexacopter/vehicle_attitude_setpoint/Rotation Angles to Quaternions'\n//  '<S506>' : 'FLIGHT_hexacopter/vehicle_attitude_setpoint/PX4 ULog/PX4 uORB Message'\n//  '<S507>' : 'FLIGHT_hexacopter/vehicle_attitude_setpoint/PX4 ULog/PX4_log_write'\n//  '<S508>' : 'FLIGHT_hexacopter/vehicle_local_position_setpoint/PX4 uORB Message'\n//  '<S509>' : 'FLIGHT_hexacopter/vehicle_local_position_setpoint/PX4 uORB Write'\n//  '<S510>' : 'FLIGHT_hexacopter/vehicle_rate_setpoint/PX4 ULog'\n//  '<S511>' : 'FLIGHT_hexacopter/vehicle_rate_setpoint/PX4 ULog/PX4 uORB Message'\n//  '<S512>' : 'FLIGHT_hexacopter/vehicle_rate_setpoint/PX4 ULog/PX4_log_write'\n\n#endif                                 // FLIGHT_hexacopter_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"FLIGHT_hexacopter_private.h","type":"header","group":"model","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: FLIGHT_hexacopter_private.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.248\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu May 22 21:41:20 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef FLIGHT_hexacopter_private_h_\n#define FLIGHT_hexacopter_private_h_\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n#include \"FLIGHT_hexacopter.h\"\n#include \"FLIGHT_hexacopter_types.h\"\n\n// Private macros used by the generated code to access rtModel\n#ifndef rtmSetTFinal\n#define rtmSetTFinal(rtm, val)         ((rtm)->Timing.tFinal = (val))\n#endif\n\nextern real32_T rt_roundf_snf(real32_T u);\nextern real32_T rt_atan2f_snf(real32_T u0, real32_T u1);\nextern void FLIGHT_he_PX4Timestamp_Init(DW_PX4Timestamp_FLIGHT_hexaco_T *localDW);\nextern void FLIGHT_hexacop_PX4Timestamp(B_PX4Timestamp_FLIGHT_hexacop_T *localB);\nextern void FLIGHT__PX4Timestamp_b_Init(DW_PX4Timestamp_FLIGHT_hexa_b_T *localDW);\nextern void FLIGHT_hexac_PX4Timestamp_o(B_PX4Timestamp_FLIGHT_hexac_l_T *localB);\nextern void FLIGHT__PX4Timestamp_m_Init(DW_PX4Timestamp_FLIGHT_hexa_f_T *localDW);\nextern void FLIGHT_hexac_PX4Timestamp_n(B_PX4Timestamp_FLIGHT_hexac_h_T *localB);\nextern void FLIGHT_he_PX4Timestamp_Term(DW_PX4Timestamp_FLIGHT_hexaco_T *localDW);\nextern void FLIGHT__PX4Timestamp_o_Term(DW_PX4Timestamp_FLIGHT_hexa_b_T *localDW);\nextern void FLIGHT__PX4Timestamp_k_Term(DW_PX4Timestamp_FLIGHT_hexa_f_T *localDW);\n\n#endif                                 // FLIGHT_hexacopter_private_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"FLIGHT_hexacopter_types.h","type":"header","group":"model","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: FLIGHT_hexacopter_types.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.248\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu May 22 21:41:20 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef FLIGHT_hexacopter_types_h_\n#define FLIGHT_hexacopter_types_h_\n#include \"rtwtypes.h\"\n#include \"MW_Parameter.h\"\n#include <uORB/topics/vehicle_local_position.h>\n#include <uORB/topics/vehicle_odometry.h>\n#include <uORB/topics/input_rc.h>\n#include <uORB/topics/actuator_controls_status.h>\n#include <uORB/topics/actuator_motors.h>\n#include <uORB/topics/vehicle_angular_velocity.h>\n#include <uORB/topics/actuator_armed.h>\n#include <uORB/topics/vehicle_status.h>\n#include <uORB/topics/vehicle_attitude_setpoint.h>\n#include <uORB/topics/vehicle_local_position_setpoint.h>\n#include <uORB/topics/vehicle_rates_setpoint.h>\n#ifndef struct_e_px4_internal_block_SampleTi_T\n#define struct_e_px4_internal_block_SampleTi_T\n\nstruct e_px4_internal_block_SampleTi_T\n{\n  int32_T __dummy;\n};\n\n#endif                                // struct_e_px4_internal_block_SampleTi_T\n\n#ifndef struct_px4_internal_block_getPX4Abso_T\n#define struct_px4_internal_block_getPX4Abso_T\n\nstruct px4_internal_block_getPX4Abso_T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  e_px4_internal_block_SampleTi_T SampleTimeHandler;\n};\n\n#endif                                // struct_px4_internal_block_getPX4Abso_T\n\n// Custom Type definition for MATLABSystem: '<S11>/Read Parameter4'\n#include \"MW_Parameter.h\"\n#ifndef struct_px4_internal_block_ParameterU_T\n#define struct_px4_internal_block_ParameterU_T\n\nstruct px4_internal_block_ParameterU_T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  real_T SampleTime;\n  MW_Param_Handle MW_PARAMHANDLE;\n};\n\n#endif                                // struct_px4_internal_block_ParameterU_T\n\n#ifndef struct_px4_internal_block_PWM_FLIGHT_T\n#define struct_px4_internal_block_PWM_FLIGHT_T\n\nstruct px4_internal_block_PWM_FLIGHT_T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  unsigned int servoCount;\n  int channelMask;\n  boolean_T isMain;\n  orb_advert_t armAdvertiseObj;\n  orb_advert_t actuatorAdvertiseObj;\n  boolean_T isArmed;\n};\n\n#endif                                // struct_px4_internal_block_PWM_FLIGHT_T\n\n#ifndef struct_px4_internal_block_Publisher__T\n#define struct_px4_internal_block_Publisher__T\n\nstruct px4_internal_block_Publisher__T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  orb_advert_t orbAdvertiseObj;\n  orb_metadata_t * orbMetadataObj;\n};\n\n#endif                                // struct_px4_internal_block_Publisher__T\n\n#ifndef struct_px4_internal_block_Subscriber_T\n#define struct_px4_internal_block_Subscriber_T\n\nstruct px4_internal_block_Subscriber_T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  e_px4_internal_block_SampleTi_T SampleTimeHandler;\n  pollfd_t eventStructObj;\n  orb_metadata_t * orbMetadataObj;\n};\n\n#endif                                // struct_px4_internal_block_Subscriber_T\n\n// Parameters (default storage)\ntypedef struct P_FLIGHT_hexacopter_T_ P_FLIGHT_hexacopter_T;\n\n// Forward declaration for rtModel\ntypedef struct tag_RTM_FLIGHT_hexacopter_T RT_MODEL_FLIGHT_hexacopter_T;\n\n#endif                                 // FLIGHT_hexacopter_types_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"FLIGHT_hexacopter_data.cpp","type":"source","group":"data","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Data files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: FLIGHT_hexacopter_data.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.248\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu May 22 21:41:20 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include \"FLIGHT_hexacopter.h\"\n\n// Block parameters (default storage)\nP_FLIGHT_hexacopter_T FLIGHT_hexacopter_P = {\n  // Variable: SampleTime\n  //  Referenced by:\n  //    '<S1>/Read Parameter1'\n  //    '<S1>/Read Parameter2'\n  //    '<S1>/Read Parameter3'\n  //    '<S1>/Read Parameter4'\n  //    '<S2>/Read Parameter'\n  //    '<S2>/Read Parameter1'\n  //    '<S2>/Read Parameter10'\n  //    '<S2>/Read Parameter9'\n  //    '<S3>/Read Parameter'\n  //    '<S3>/Read Parameter1'\n  //    '<S3>/Read Parameter2'\n  //    '<S11>/Read Parameter'\n  //    '<S11>/Read Parameter1'\n  //    '<S11>/Read Parameter2'\n  //    '<S11>/Read Parameter3'\n  //    '<S11>/Read Parameter4'\n  //    '<S194>/Read Parameter'\n  //    '<S195>/Read Parameter'\n\n  0.004,\n\n  // Variable: SampleTime_SAS\n  //  Referenced by:\n  //    '<S4>/Read Parameter1'\n  //    '<S4>/Read Parameter13'\n  //    '<S4>/Read Parameter2'\n  //    '<S4>/Read Parameter3'\n  //    '<S4>/Read Parameter4'\n  //    '<S4>/Read Parameter5'\n  //    '<S10>/Read Parameter1'\n  //    '<S10>/Read Parameter10'\n  //    '<S10>/Read Parameter2'\n  //    '<S10>/Read Parameter3'\n  //    '<S10>/Read Parameter4'\n  //    '<S10>/Read Parameter5'\n  //    '<S10>/Read Parameter6'\n  //    '<S10>/Read Parameter7'\n  //    '<S10>/Read Parameter8'\n  //    '<S10>/Read Parameter9'\n  //    '<S10>/read_mc_rollrate_p'\n\n  0.001,\n\n  // Variable: Jxx\n  //  Referenced by: '<S477>/Constant'\n\n  0.0211F,\n\n  // Variable: Jyy\n  //  Referenced by: '<S477>/Constant1'\n\n  0.0219F,\n\n  // Variable: Jzz\n  //  Referenced by: '<S477>/Constant2'\n\n  0.0366F,\n\n  // Variable: MAX_CONTROL_ANGLE_PITCH\n  //  Referenced by:\n  //    '<S12>/Gain5'\n  //    '<S22>/Gain2'\n\n  0.52359879F,\n\n  // Variable: MAX_CONTROL_ANGLE_RATE_Y\n  //  Referenced by:\n  //    '<S12>/Gain6'\n  //    '<S22>/Gain3'\n  //    '<S192>/Gain3'\n\n  2.09439516F,\n\n  // Variable: MAX_CONTROL_ANGLE_ROLL\n  //  Referenced by:\n  //    '<S12>/Gain4'\n  //    '<S22>/Gain1'\n\n  0.52359879F,\n\n  // Variable: MAX_CONTROL_VELOCITY_XY\n  //  Referenced by: '<S192>/Gain1'\n\n  1.5F,\n\n  // Mask Parameter: DiscreteDerivative2_ICPrevScale\n  //  Referenced by: '<S312>/UD'\n\n  0.0F,\n\n  // Mask Parameter: DiscreteDerivative2_ICPrevSca_n\n  //  Referenced by: '<S367>/UD'\n\n  0.0F,\n\n  // Mask Parameter: DiscreteDerivative2_ICPrevSca_o\n  //  Referenced by: '<S422>/UD'\n\n  0.0F,\n\n  // Mask Parameter: DiscreteDerivative2_ICPrevSca_a\n  //  Referenced by: '<S480>/UD'\n\n  0.0F,\n\n  // Mask Parameter: DiscreteDerivative_ICPrevScaled\n  //  Referenced by: '<S478>/UD'\n\n  0.0F,\n\n  // Mask Parameter: DiscreteDerivative1_ICPrevScale\n  //  Referenced by: '<S479>/UD'\n\n  0.0F,\n\n  // Mask Parameter: DiscreteDerivative3_ICPrevScale\n  //  Referenced by: '<S481>/UD'\n\n  0.0F,\n\n  // Mask Parameter: PIDController_InitialConditionF\n  //  Referenced by: '<S55>/Filter'\n\n  0.0F,\n\n  // Mask Parameter: pid_ctrl_rollrate_InitialCondit\n  //  Referenced by: '<S350>/Integrator'\n\n  0.0F,\n\n  // Mask Parameter: pid_ctrl_rollrate_InitialCond_j\n  //  Referenced by: '<S405>/Integrator'\n\n  0.0F,\n\n  // Mask Parameter: pid_ctrl_rollrate_InitialCond_p\n  //  Referenced by: '<S460>/Integrator'\n\n  0.0F,\n\n  // Mask Parameter: PIDController_InitialConditio_a\n  //  Referenced by: '<S60>/Integrator'\n\n  0.0F,\n\n  // Mask Parameter: PIDController_LowerIntegratorSa\n  //  Referenced by: '<S60>/Integrator'\n\n  -0.3F,\n\n  // Mask Parameter: PIDController_LowerSaturationLi\n  //  Referenced by:\n  //    '<S67>/Saturation'\n  //    '<S52>/DeadZone'\n\n  0.0F,\n\n  // Mask Parameter: PIDController_UpperIntegratorSa\n  //  Referenced by: '<S60>/Integrator'\n\n  0.3F,\n\n  // Mask Parameter: PIDController_UpperSaturationLi\n  //  Referenced by:\n  //    '<S67>/Saturation'\n  //    '<S52>/DeadZone'\n\n  1.0F,\n\n  // Mask Parameter: CompareToConstant2_const\n  //  Referenced by: '<S193>/Constant'\n\n  1800U,\n\n  // Mask Parameter: CompareToConstant_const\n  //  Referenced by: '<S488>/Constant'\n\n  1800U,\n\n  // Mask Parameter: CompareToConstant_const_g\n  //  Referenced by: '<S185>/Constant'\n\n  1400U,\n\n  // Mask Parameter: CompareToConstant1_const\n  //  Referenced by: '<S23>/Constant'\n\n  1400U,\n\n  // Mask Parameter: CompareToConstant1_const_e\n  //  Referenced by: '<S183>/Constant'\n\n  1800U,\n\n  // Computed Parameter: Out1_Y0\n  //  Referenced by: '<S303>/Out1'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n    (0ULL),                            // ref_timestamp\n    0.0,                               // ref_lat\n    0.0,                               // ref_lon\n    0.0F,                              // x\n    0.0F,                              // y\n    0.0F,                              // z\n\n    {\n      0.0F, 0.0F }\n    ,                                  // delta_xy\n    0.0F,                              // delta_z\n    0.0F,                              // vx\n    0.0F,                              // vy\n    0.0F,                              // vz\n    0.0F,                              // z_deriv\n\n    {\n      0.0F, 0.0F }\n    ,                                  // delta_vxy\n    0.0F,                              // delta_vz\n    0.0F,                              // ax\n    0.0F,                              // ay\n    0.0F,                              // az\n    0.0F,                              // heading\n    0.0F,                              // delta_heading\n    0.0F,                              // ref_alt\n    0.0F,                              // dist_bottom\n    0.0F,                              // eph\n    0.0F,                              // epv\n    0.0F,                              // evh\n    0.0F,                              // evv\n    0.0F,                              // vxy_max\n    0.0F,                              // vz_max\n    0.0F,                              // hagl_min\n    0.0F,                              // hagl_max\n    false,                             // xy_valid\n    false,                             // z_valid\n    false,                             // v_xy_valid\n    false,                             // v_z_valid\n    0U,                                // xy_reset_counter\n    0U,                                // z_reset_counter\n    0U,                                // vxy_reset_counter\n    0U,                                // vz_reset_counter\n    0U,                                // heading_reset_counter\n    false,                             // heading_good_for_control\n    false,                             // xy_global\n    false,                             // z_global\n    false,                             // dist_bottom_valid\n    0U,                                // dist_bottom_sensor_bitfield\n    false,                             // dead_reckoning\n    0U                                 // _padding0\n  },\n\n  // Computed Parameter: Constant_Value\n  //  Referenced by: '<S301>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n    (0ULL),                            // ref_timestamp\n    0.0,                               // ref_lat\n    0.0,                               // ref_lon\n    0.0F,                              // x\n    0.0F,                              // y\n    0.0F,                              // z\n\n    {\n      0.0F, 0.0F }\n    ,                                  // delta_xy\n    0.0F,                              // delta_z\n    0.0F,                              // vx\n    0.0F,                              // vy\n    0.0F,                              // vz\n    0.0F,                              // z_deriv\n\n    {\n      0.0F, 0.0F }\n    ,                                  // delta_vxy\n    0.0F,                              // delta_vz\n    0.0F,                              // ax\n    0.0F,                              // ay\n    0.0F,                              // az\n    0.0F,                              // heading\n    0.0F,                              // delta_heading\n    0.0F,                              // ref_alt\n    0.0F,                              // dist_bottom\n    0.0F,                              // eph\n    0.0F,                              // epv\n    0.0F,                              // evh\n    0.0F,                              // evv\n    0.0F,                              // vxy_max\n    0.0F,                              // vz_max\n    0.0F,                              // hagl_min\n    0.0F,                              // hagl_max\n    false,                             // xy_valid\n    false,                             // z_valid\n    false,                             // v_xy_valid\n    false,                             // v_z_valid\n    0U,                                // xy_reset_counter\n    0U,                                // z_reset_counter\n    0U,                                // vxy_reset_counter\n    0U,                                // vz_reset_counter\n    0U,                                // heading_reset_counter\n    false,                             // heading_good_for_control\n    false,                             // xy_global\n    false,                             // z_global\n    false,                             // dist_bottom_valid\n    0U,                                // dist_bottom_sensor_bitfield\n    false,                             // dead_reckoning\n    0U                                 // _padding0\n  },\n\n  // Computed Parameter: Out1_Y0_d\n  //  Referenced by: '<S305>/Out1'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // position\n\n    {\n      0.0F, 0.0F, 0.0F, 0.0F }\n    ,                                  // q\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // velocity\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // angular_velocity\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // position_variance\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // orientation_variance\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // velocity_variance\n    0U,                                // pose_frame\n    0U,                                // velocity_frame\n    0U,                                // reset_counter\n    0,                                 // quality\n\n    {\n      0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_g\n  //  Referenced by: '<S304>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // position\n\n    {\n      0.0F, 0.0F, 0.0F, 0.0F }\n    ,                                  // q\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // velocity\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // angular_velocity\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // position_variance\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // orientation_variance\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // velocity_variance\n    0U,                                // pose_frame\n    0U,                                // velocity_frame\n    0U,                                // reset_counter\n    0,                                 // quality\n\n    {\n      0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_m\n  //  Referenced by: '<S495>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n\n    {\n      0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F }\n    ,                                  // control\n    0U,                                // reversible_flags\n\n    {\n      0U, 0U, 0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Out1_Y0_o\n  //  Referenced by: '<S307>/Out1'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_last_signal\n    0,                                 // rssi\n    0.0F,                              // rssi_dbm\n    0U,                                // rc_lost_frame_count\n    0U,                                // rc_total_frame_count\n    0U,                                // rc_ppm_frame_length\n\n    {\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U }\n    ,                                  // values\n    0U,                                // channel_count\n    false,                             // rc_failsafe\n    false,                             // rc_lost\n    0U,                                // input_source\n    0,                                 // link_quality\n    0U                                 // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_m1\n  //  Referenced by: '<S306>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_last_signal\n    0,                                 // rssi\n    0.0F,                              // rssi_dbm\n    0U,                                // rc_lost_frame_count\n    0U,                                // rc_total_frame_count\n    0U,                                // rc_ppm_frame_length\n\n    {\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U }\n    ,                                  // values\n    0U,                                // channel_count\n    false,                             // rc_failsafe\n    false,                             // rc_lost\n    0U,                                // input_source\n    0,                                 // link_quality\n    0U                                 // _padding0\n  },\n\n  // Computed Parameter: Out1_Y0_a\n  //  Referenced by: '<S503>/Out1'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // armed_time\n    (0ULL),                            // takeoff_time\n    (0ULL),                            // nav_state_timestamp\n    0U,                                // failure_detector_status\n    0U,                                // arming_state\n    0U,                                // latest_arming_reason\n    0U,                                // latest_disarming_reason\n    0U,                                // nav_state_user_intention\n    0U,                                // nav_state\n    0U,                                // hil_state\n    0U,                                // vehicle_type\n    false,                             // failsafe\n    false,                             // failsafe_and_user_took_over\n    false,                             // gcs_connection_lost\n    0U,                                // gcs_connection_lost_counter\n    false,                             // high_latency_data_link_lost\n    false,                             // is_vtol\n    false,                             // is_vtol_tailsitter\n    false,                             // in_transition_mode\n    false,                             // in_transition_to_fw\n    0U,                                // system_type\n    0U,                                // system_id\n    0U,                                // component_id\n    false,                             // safety_button_available\n    false,                             // safety_off\n    false,                             // power_input_valid\n    false,                             // usb_connected\n    false,                             // open_drone_id_system_present\n    false,                             // open_drone_id_system_healthy\n    false,                             // parachute_system_present\n    false,                             // parachute_system_healthy\n    false,                             // avoidance_system_required\n    false,                             // avoidance_system_valid\n    false,                             // rc_calibration_in_progress\n    false,                             // calibration_enabled\n    false,                             // pre_flight_checks_pass\n\n    {\n      0U, 0U, 0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_o\n  //  Referenced by: '<S501>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // armed_time\n    (0ULL),                            // takeoff_time\n    (0ULL),                            // nav_state_timestamp\n    0U,                                // failure_detector_status\n    0U,                                // arming_state\n    0U,                                // latest_arming_reason\n    0U,                                // latest_disarming_reason\n    0U,                                // nav_state_user_intention\n    0U,                                // nav_state\n    0U,                                // hil_state\n    0U,                                // vehicle_type\n    false,                             // failsafe\n    false,                             // failsafe_and_user_took_over\n    false,                             // gcs_connection_lost\n    0U,                                // gcs_connection_lost_counter\n    false,                             // high_latency_data_link_lost\n    false,                             // is_vtol\n    false,                             // is_vtol_tailsitter\n    false,                             // in_transition_mode\n    false,                             // in_transition_to_fw\n    0U,                                // system_type\n    0U,                                // system_id\n    0U,                                // component_id\n    false,                             // safety_button_available\n    false,                             // safety_off\n    false,                             // power_input_valid\n    false,                             // usb_connected\n    false,                             // open_drone_id_system_present\n    false,                             // open_drone_id_system_healthy\n    false,                             // parachute_system_present\n    false,                             // parachute_system_healthy\n    false,                             // avoidance_system_required\n    false,                             // avoidance_system_valid\n    false,                             // rc_calibration_in_progress\n    false,                             // calibration_enabled\n    false,                             // pre_flight_checks_pass\n\n    {\n      0U, 0U, 0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_n\n  //  Referenced by: '<S508>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    0.0F,                              // x\n    0.0F,                              // y\n    0.0F,                              // z\n    0.0F,                              // vx\n    0.0F,                              // vy\n    0.0F,                              // vz\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // acceleration\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // thrust\n    0.0F,                              // yaw\n    0.0F                               // yawspeed\n  },\n\n  // Computed Parameter: Constant_Value_l\n  //  Referenced by: '<S506>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    0.0F,                              // roll_body\n    0.0F,                              // pitch_body\n    0.0F,                              // yaw_body\n    0.0F,                              // yaw_sp_move_rate\n\n    {\n      0.0F, 0.0F, 0.0F, 0.0F }\n    ,                                  // q_d\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // thrust_body\n    false,                             // reset_integral\n    false,                             // fw_control_yaw_wheel\n\n    {\n      0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Out1_Y0_p\n  //  Referenced by: '<S498>/Out1'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // xyz\n\n    {\n      0.0F, 0.0F, 0.0F }\n    // xyz_derivative\n  },\n\n  // Computed Parameter: Constant_Value_gk\n  //  Referenced by: '<S497>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // xyz\n\n    {\n      0.0F, 0.0F, 0.0F }\n    // xyz_derivative\n  },\n\n  // Computed Parameter: Constant_Value_ni\n  //  Referenced by: '<S511>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    0.0F,                              // roll\n    0.0F,                              // pitch\n    0.0F,                              // yaw\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // thrust_body\n    false,                             // reset_integral\n\n    {\n      0U, 0U, 0U, 0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_a\n  //  Referenced by: '<S491>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // control_power\n\n    {\n      0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Out1_Y0_h\n  //  Referenced by: '<S502>/Out1'\n\n  {\n    (0ULL),                            // timestamp\n    false,                             // armed\n    false,                             // prearmed\n    false,                             // ready_to_arm\n    false,                             // lockdown\n    false,                             // manual_lockdown\n    false,                             // force_failsafe\n    false,                             // in_esc_calibration_mode\n    0U                                 // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_m3\n  //  Referenced by: '<S500>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    false,                             // armed\n    false,                             // prearmed\n    false,                             // ready_to_arm\n    false,                             // lockdown\n    false,                             // manual_lockdown\n    false,                             // force_failsafe\n    false,                             // in_esc_calibration_mode\n    0U                                 // _padding0\n  },\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant1'\n\n  100.0,\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant2'\n\n  100.0,\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant3'\n\n  100.0,\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant4'\n\n  100.0,\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant5'\n\n  100.0,\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant'\n\n  100.0,\n\n  // Expression: 1094\n  //  Referenced by: '<S12>/Constant'\n\n  1094.0,\n\n  // Expression: 1/800\n  //  Referenced by: '<S12>/Gain'\n\n  0.00125,\n\n  // Expression: 0.01\n  //  Referenced by: '<S186>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S186>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S186>/Saturation'\n\n  0.0,\n\n  // Expression: 0.01\n  //  Referenced by: '<S187>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S187>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S187>/Saturation'\n\n  0.0,\n\n  // Expression: 0.01\n  //  Referenced by: '<S188>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S188>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S188>/Saturation'\n\n  0.0,\n\n  // Expression: 0.01\n  //  Referenced by: '<S189>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S189>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S189>/Saturation'\n\n  0.0,\n\n  // Expression: 0.01\n  //  Referenced by: '<S190>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S190>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S190>/Saturation'\n\n  0.0,\n\n  // Expression: 0.01\n  //  Referenced by: '<S191>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S191>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S191>/Saturation'\n\n  0.0,\n\n  // Computed Parameter: Gain1_Gain\n  //  Referenced by: '<S2>/Gain1'\n\n  -1.0F,\n\n  // Computed Parameter: Gain_Gain_m3\n  //  Referenced by: '<S2>/Gain'\n\n  -1.0F,\n\n  // Computed Parameter: des_p_Y0\n  //  Referenced by: '<S2>/des_p'\n\n  0.0F,\n\n  // Computed Parameter: des_q_Y0\n  //  Referenced by: '<S2>/des_q'\n\n  0.0F,\n\n  // Computed Parameter: Gain1_Gain_g\n  //  Referenced by: '<S77>/Gain1'\n\n  0.0174532924F,\n\n  // Computed Parameter: Gain1_Gain_c\n  //  Referenced by: '<S78>/Gain1'\n\n  0.0174532924F,\n\n  // Computed Parameter: Gain_Gain_a\n  //  Referenced by: '<S249>/Gain'\n\n  -1.0F,\n\n  // Computed Parameter: DiscreteTimeIntegrator_gainval\n  //  Referenced by: '<S5>/Discrete-Time Integrator'\n\n  0.004F,\n\n  // Computed Parameter: DiscreteTimeIntegrator_UpperSat\n  //  Referenced by: '<S5>/Discrete-Time Integrator'\n\n  10.0F,\n\n  // Computed Parameter: DiscreteTimeIntegrator_LowerSat\n  //  Referenced by: '<S5>/Discrete-Time Integrator'\n\n  -50.0F,\n\n  // Computed Parameter: DiscreteTimeIntegrator1_gainval\n  //  Referenced by: '<S5>/Discrete-Time Integrator1'\n\n  0.004F,\n\n  // Computed Parameter: DiscreteTimeIntegrator1_UpperSa\n  //  Referenced by: '<S5>/Discrete-Time Integrator1'\n\n  10.0F,\n\n  // Computed Parameter: DiscreteTimeIntegrator1_LowerSa\n  //  Referenced by: '<S5>/Discrete-Time Integrator1'\n\n  -50.0F,\n\n  // Computed Parameter: Saturation_UpperSat_e\n  //  Referenced by: '<S195>/Saturation'\n\n  0.610865235F,\n\n  // Computed Parameter: Saturation_LowerSat_a\n  //  Referenced by: '<S195>/Saturation'\n\n  -0.610865235F,\n\n  // Computed Parameter: Gain1_Gain_i\n  //  Referenced by: '<S195>/Gain1'\n\n  -1.0F,\n\n  // Computed Parameter: DeadZone3_Start\n  //  Referenced by: '<S192>/Dead Zone3'\n\n  -0.1F,\n\n  // Computed Parameter: DeadZone3_End\n  //  Referenced by: '<S192>/Dead Zone3'\n\n  0.1F,\n\n  // Computed Parameter: Saturation9_UpperSat\n  //  Referenced by: '<S192>/Saturation9'\n\n  1.0F,\n\n  // Computed Parameter: Saturation9_LowerSat\n  //  Referenced by: '<S192>/Saturation9'\n\n  -1.0F,\n\n  // Computed Parameter: DeadZone1_Start\n  //  Referenced by: '<S192>/Dead Zone1'\n\n  -0.1F,\n\n  // Computed Parameter: DeadZone1_End\n  //  Referenced by: '<S192>/Dead Zone1'\n\n  0.1F,\n\n  // Computed Parameter: Saturation1_UpperSat\n  //  Referenced by: '<S192>/Saturation1'\n\n  1.0F,\n\n  // Computed Parameter: Saturation1_LowerSat\n  //  Referenced by: '<S192>/Saturation1'\n\n  -1.0F,\n\n  // Computed Parameter: Gain2_Gain\n  //  Referenced by: '<S192>/Gain2'\n\n  -1.5F,\n\n  // Computed Parameter: DeadZone2_Start\n  //  Referenced by: '<S192>/Dead Zone2'\n\n  -0.1F,\n\n  // Computed Parameter: DeadZone2_End\n  //  Referenced by: '<S192>/Dead Zone2'\n\n  0.1F,\n\n  // Computed Parameter: Saturation3_UpperSat\n  //  Referenced by: '<S192>/Saturation3'\n\n  1.0F,\n\n  // Computed Parameter: Saturation3_LowerSat\n  //  Referenced by: '<S192>/Saturation3'\n\n  -1.0F,\n\n  // Computed Parameter: DeadZone4_Start\n  //  Referenced by: '<S192>/Dead Zone4'\n\n  -0.1F,\n\n  // Computed Parameter: DeadZone4_End\n  //  Referenced by: '<S192>/Dead Zone4'\n\n  0.1F,\n\n  // Computed Parameter: Saturation10_UpperSat\n  //  Referenced by: '<S192>/Saturation10'\n\n  1.0F,\n\n  // Computed Parameter: Saturation10_LowerSat\n  //  Referenced by: '<S192>/Saturation10'\n\n  -1.0F,\n\n  // Computed Parameter: Gain_Gain_o\n  //  Referenced by: '<S192>/Gain'\n\n  -1.0F,\n\n  // Computed Parameter: tau_roll_Y0\n  //  Referenced by: '<S10>/tau_roll'\n\n  0.0F,\n\n  // Computed Parameter: tau_pitch_Y0\n  //  Referenced by: '<S10>/tau_pitch'\n\n  0.0F,\n\n  // Computed Parameter: tau_yaw_Y0\n  //  Referenced by: '<S10>/tau_yaw'\n\n  0.0F,\n\n  // Computed Parameter: tau_Gain\n  //  Referenced by: '<S315>/tau'\n\n  0.0005F,\n\n  // Computed Parameter: Bias1_Bias\n  //  Referenced by: '<S316>/Bias1'\n\n  1.0F,\n\n  // Computed Parameter: Bias_Bias\n  //  Referenced by: '<S316>/Bias'\n\n  1.0F,\n\n  // Computed Parameter: Gain_Gain_i\n  //  Referenced by: '<S316>/Gain'\n\n  1.41421354F,\n\n  // Computed Parameter: UnitDelay1_InitialCondition\n  //  Referenced by: '<S315>/Unit Delay1'\n\n  0.0F,\n\n  // Computed Parameter: Gain1_Gain_j\n  //  Referenced by: '<S315>/Gain1'\n\n  2.0F,\n\n  // Computed Parameter: UnitDelay2_InitialCondition\n  //  Referenced by: '<S315>/Unit Delay2'\n\n  0.0F,\n\n  // Computed Parameter: TSamp_WtEt\n  //  Referenced by: '<S312>/TSamp'\n\n  1000.0F,\n\n  // Computed Parameter: Integrator_gainval\n  //  Referenced by: '<S350>/Integrator'\n\n  0.001F,\n\n  // Computed Parameter: tau_Gain_n\n  //  Referenced by: '<S370>/tau'\n\n  0.0005F,\n\n  // Computed Parameter: Bias1_Bias_n\n  //  Referenced by: '<S371>/Bias1'\n\n  1.0F,\n\n  // Computed Parameter: Bias_Bias_b\n  //  Referenced by: '<S371>/Bias'\n\n  1.0F,\n\n  // Computed Parameter: Gain_Gain_e\n  //  Referenced by: '<S371>/Gain'\n\n  1.41421354F,\n\n  // Computed Parameter: UnitDelay1_InitialCondition_p\n  //  Referenced by: '<S370>/Unit Delay1'\n\n  0.0F,\n\n  // Computed Parameter: Gain1_Gain_e\n  //  Referenced by: '<S370>/Gain1'\n\n  2.0F,\n\n  // Computed Parameter: UnitDelay2_InitialCondition_e\n  //  Referenced by: '<S370>/Unit Delay2'\n\n  0.0F,\n\n  // Computed Parameter: TSamp_WtEt_m\n  //  Referenced by: '<S367>/TSamp'\n\n  1000.0F,\n\n  // Computed Parameter: Integrator_gainval_b\n  //  Referenced by: '<S405>/Integrator'\n\n  0.001F,\n\n  // Computed Parameter: tau_Gain_c\n  //  Referenced by: '<S425>/tau'\n\n  0.0005F,\n\n  // Computed Parameter: Bias1_Bias_i\n  //  Referenced by: '<S426>/Bias1'\n\n  1.0F,\n\n  // Computed Parameter: Bias_Bias_c\n  //  Referenced by: '<S426>/Bias'\n\n  1.0F,\n\n  // Computed Parameter: Gain_Gain_b\n  //  Referenced by: '<S426>/Gain'\n\n  1.41421354F,\n\n  // Computed Parameter: UnitDelay1_InitialCondition_e\n  //  Referenced by: '<S425>/Unit Delay1'\n\n  0.0F,\n\n  // Computed Parameter: Gain1_Gain_iw\n  //  Referenced by: '<S425>/Gain1'\n\n  2.0F,\n\n  // Computed Parameter: UnitDelay2_InitialCondition_m\n  //  Referenced by: '<S425>/Unit Delay2'\n\n  0.0F,\n\n  // Computed Parameter: TSamp_WtEt_p\n  //  Referenced by: '<S422>/TSamp'\n\n  1000.0F,\n\n  // Computed Parameter: Integrator_gainval_p\n  //  Referenced by: '<S460>/Integrator'\n\n  0.001F,\n\n  // Computed Parameter: Constant2_Value_i\n  //  Referenced by: '<S12>/Constant2'\n\n  1514.0F,\n\n  // Computed Parameter: Gain1_Gain_m\n  //  Referenced by: '<S12>/Gain1'\n\n  0.0025F,\n\n  // Computed Parameter: DeadZone1_Start_c\n  //  Referenced by: '<S12>/Dead Zone1'\n\n  -0.005F,\n\n  // Computed Parameter: DeadZone1_End_m\n  //  Referenced by: '<S12>/Dead Zone1'\n\n  0.005F,\n\n  // Computed Parameter: Saturation2_UpperSat\n  //  Referenced by: '<S12>/Saturation2'\n\n  1.0F,\n\n  // Computed Parameter: Saturation2_LowerSat\n  //  Referenced by: '<S12>/Saturation2'\n\n  -1.0F,\n\n  // Computed Parameter: Constant1_Value_l\n  //  Referenced by: '<S12>/Constant1'\n\n  1514.0F,\n\n  // Computed Parameter: Gain2_Gain_a\n  //  Referenced by: '<S12>/Gain2'\n\n  0.0025F,\n\n  // Computed Parameter: DeadZone2_Start_o\n  //  Referenced by: '<S12>/Dead Zone2'\n\n  -0.005F,\n\n  // Computed Parameter: DeadZone2_End_e\n  //  Referenced by: '<S12>/Dead Zone2'\n\n  0.005F,\n\n  // Computed Parameter: Saturation1_UpperSat_l\n  //  Referenced by: '<S12>/Saturation1'\n\n  1.0F,\n\n  // Computed Parameter: Saturation1_LowerSat_i\n  //  Referenced by: '<S12>/Saturation1'\n\n  -1.0F,\n\n  // Computed Parameter: DeadZone3_Start_p\n  //  Referenced by: '<S12>/Dead Zone3'\n\n  -0.05F,\n\n  // Computed Parameter: DeadZone3_End_l\n  //  Referenced by: '<S12>/Dead Zone3'\n\n  0.05F,\n\n  // Computed Parameter: Saturation_UpperSat_o\n  //  Referenced by: '<S12>/Saturation'\n\n  0.9F,\n\n  // Computed Parameter: Saturation_LowerSat_el\n  //  Referenced by: '<S12>/Saturation'\n\n  0.0F,\n\n  // Computed Parameter: Constant3_Value_e\n  //  Referenced by: '<S12>/Constant3'\n\n  1514.0F,\n\n  // Computed Parameter: Gain3_Gain\n  //  Referenced by: '<S12>/Gain3'\n\n  0.0025F,\n\n  // Computed Parameter: DeadZone_Start\n  //  Referenced by: '<S12>/Dead Zone'\n\n  -0.005F,\n\n  // Computed Parameter: DeadZone_End\n  //  Referenced by: '<S12>/Dead Zone'\n\n  0.005F,\n\n  // Computed Parameter: Saturation3_UpperSat_b\n  //  Referenced by: '<S12>/Saturation3'\n\n  1.0F,\n\n  // Computed Parameter: Saturation3_LowerSat_j\n  //  Referenced by: '<S12>/Saturation3'\n\n  -1.0F,\n\n  // Computed Parameter: Constant1_Value_g\n  //  Referenced by: '<S50>/Constant1'\n\n  0.0F,\n\n  // Computed Parameter: rate_transition_des_p_InitialCo\n  //  Referenced by: '<Root>/rate_transition_des_p'\n\n  0.0F,\n\n  // Computed Parameter: rate_transition_des_q_InitialCo\n  //  Referenced by: '<Root>/rate_transition_des_q'\n\n  0.0F,\n\n  // Computed Parameter: rate_transition_des_r_InitialCo\n  //  Referenced by: '<Root>/rate_transition_des_r'\n\n  0.0F,\n\n  // Computed Parameter: RateTransition1_InitialConditio\n  //  Referenced by: '<Root>/Rate Transition1'\n\n  0.0F,\n\n  // Computed Parameter: rate_transition_throttle_Initia\n  //  Referenced by: '<Root>/rate_transition_throttle'\n\n  0.0F,\n\n  // Computed Parameter: Constant1_Value_i\n  //  Referenced by: '<S15>/Constant1'\n\n  { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F },\n\n  // Computed Parameter: Saturation_UpperSat_ep\n  //  Referenced by: '<S493>/Saturation'\n\n  2000.0F,\n\n  // Computed Parameter: Saturation_LowerSat_p\n  //  Referenced by: '<S493>/Saturation'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_e\n  //  Referenced by: '<S493>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Gain_Gain_mg\n  //  Referenced by: '<S493>/Gain'\n\n  0.001F,\n\n  // Computed Parameter: Constant_Value_k\n  //  Referenced by: '<S186>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_ms\n  //  Referenced by: '<S187>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_i\n  //  Referenced by: '<S188>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_j\n  //  Referenced by: '<S189>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_lw\n  //  Referenced by: '<S190>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_ox\n  //  Referenced by: '<S191>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: DeadZone3_Start_l\n  //  Referenced by: '<S22>/Dead Zone3'\n\n  -0.003F,\n\n  // Computed Parameter: DeadZone3_End_n\n  //  Referenced by: '<S22>/Dead Zone3'\n\n  0.003F,\n\n  // Computed Parameter: Saturation9_UpperSat_c\n  //  Referenced by: '<S22>/Saturation9'\n\n  1.0F,\n\n  // Computed Parameter: Saturation9_LowerSat_i\n  //  Referenced by: '<S22>/Saturation9'\n\n  -1.0F,\n\n  // Computed Parameter: DeadZone1_Start_n\n  //  Referenced by: '<S22>/Dead Zone1'\n\n  -0.001F,\n\n  // Computed Parameter: DeadZone1_End_mj\n  //  Referenced by: '<S22>/Dead Zone1'\n\n  0.001F,\n\n  // Computed Parameter: Saturation1_UpperSat_d\n  //  Referenced by: '<S22>/Saturation1'\n\n  1.0F,\n\n  // Computed Parameter: Saturation1_LowerSat_b\n  //  Referenced by: '<S22>/Saturation1'\n\n  -1.0F,\n\n  // Computed Parameter: DeadZone2_Start_m\n  //  Referenced by: '<S22>/Dead Zone2'\n\n  -0.005F,\n\n  // Computed Parameter: DeadZone2_End_b\n  //  Referenced by: '<S22>/Dead Zone2'\n\n  0.005F,\n\n  // Computed Parameter: Saturation3_UpperSat_d\n  //  Referenced by: '<S22>/Saturation3'\n\n  1.0F,\n\n  // Computed Parameter: Saturation3_LowerSat_n\n  //  Referenced by: '<S22>/Saturation3'\n\n  -1.0F,\n\n  // Computed Parameter: DeadZone4_Start_o\n  //  Referenced by: '<S22>/Dead Zone4'\n\n  -0.1F,\n\n  // Computed Parameter: DeadZone4_End_a\n  //  Referenced by: '<S22>/Dead Zone4'\n\n  0.1F,\n\n  // Computed Parameter: Saturation10_UpperSat_g\n  //  Referenced by: '<S22>/Saturation10'\n\n  1.0F,\n\n  // Computed Parameter: Saturation10_LowerSat_f\n  //  Referenced by: '<S22>/Saturation10'\n\n  -1.0F,\n\n  // Computed Parameter: Gain_Gain_er\n  //  Referenced by: '<S22>/Gain'\n\n  -1.0F,\n\n  // Computed Parameter: Gain_Gain_ob\n  //  Referenced by: '<S1>/Gain'\n\n  -1.0F,\n\n  // Computed Parameter: Integrator_gainval_h\n  //  Referenced by: '<S60>/Integrator'\n\n  0.004F,\n\n  // Computed Parameter: Filter_gainval\n  //  Referenced by: '<S55>/Filter'\n\n  0.004F,\n\n  // Computed Parameter: Constant_Value_gx\n  //  Referenced by: '<S1>/Constant'\n\n  50.0F,\n\n  // Computed Parameter: Saturation1_UpperSat_lr\n  //  Referenced by: '<S1>/Saturation1'\n\n  1.0F,\n\n  // Computed Parameter: Saturation1_LowerSat_e\n  //  Referenced by: '<S1>/Saturation1'\n\n  0.0F,\n\n  // Computed Parameter: TSamp_WtEt_k\n  //  Referenced by: '<S480>/TSamp'\n\n  250.0F,\n\n  // Computed Parameter: TSamp_WtEt_c\n  //  Referenced by: '<S478>/TSamp'\n\n  250.0F,\n\n  // Computed Parameter: TSamp_WtEt_b\n  //  Referenced by: '<S479>/TSamp'\n\n  250.0F,\n\n  // Computed Parameter: TSamp_WtEt_py\n  //  Referenced by: '<S481>/TSamp'\n\n  250.0F,\n\n  // Computed Parameter: DiscreteTimeIntegrator_gainva_c\n  //  Referenced by: '<S11>/Discrete-Time Integrator'\n\n  0.004F,\n\n  // Computed Parameter: DiscreteTimeIntegrator_IC\n  //  Referenced by: '<S11>/Discrete-Time Integrator'\n\n  0.0F,\n\n  // Computed Parameter: Saturation2_UpperSat_i\n  //  Referenced by: '<S11>/Saturation2'\n\n  1.0F,\n\n  // Computed Parameter: Saturation2_LowerSat_k\n  //  Referenced by: '<S11>/Saturation2'\n\n  -1.0F,\n\n  // Computed Parameter: Constant_Value_ll\n  //  Referenced by: '<S21>/Constant'\n\n  0.0F,\n\n  // Computed Parameter: Constant_Value_a5\n  //  Referenced by: '<Root>/Constant'\n\n  0.0F,\n\n  // Computed Parameter: Clamping_zero_Value\n  //  Referenced by: '<S50>/Clamping_zero'\n\n  0.0F,\n\n  // Computed Parameter: PWM_Y0\n  //  Referenced by: '<S7>/PWM'\n\n  0U,\n\n  // Computed Parameter: Output_Limits1_UpperSat\n  //  Referenced by: '<S7>/Output_Limits1'\n\n  2000U,\n\n  // Computed Parameter: Output_Limits1_LowerSat\n  //  Referenced by: '<S7>/Output_Limits1'\n\n  1000U,\n\n  // Computed Parameter: rate_transition_ctrl_sw_Initial\n  //  Referenced by: '<Root>/rate_transition_ctrl_sw'\n\n  0U,\n\n  // Computed Parameter: RateTransition4_InitialConditio\n  //  Referenced by: '<Root>/Rate Transition4'\n\n  0U,\n\n  // Computed Parameter: rate_transition_arm_InitialCond\n  //  Referenced by: '<Root>/rate_transition_arm'\n\n  false,\n\n  // Computed Parameter: RateTransition7_InitialConditio\n  //  Referenced by: '<Root>/Rate Transition7'\n\n  false,\n\n  // Computed Parameter: Constant_Value_ko\n  //  Referenced by: '<S50>/Constant'\n\n  1,\n\n  // Computed Parameter: Constant2_Value_e\n  //  Referenced by: '<S50>/Constant2'\n\n  -1,\n\n  // Computed Parameter: Constant3_Value_i\n  //  Referenced by: '<S50>/Constant3'\n\n  1,\n\n  // Computed Parameter: Constant4_Value_d\n  //  Referenced by: '<S50>/Constant4'\n\n  -1\n};\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: multiword_types.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.248\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu May 22 21:41:20 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n\n#ifndef MULTIWORD_TYPES_H\n#define MULTIWORD_TYPES_H\n#include \"rtwtypes.h\"\n\n//\n//  Definitions supporting external data access\ntypedef int64_T chunk_T;\ntypedef uint64_T uchunk_T;\n\n#endif                                 // MULTIWORD_TYPES_H\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtGetInf.cpp","type":"source","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtGetInf.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.248\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu May 22 21:41:20 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  //\n  // Initialize rtInf needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  real_T rtGetInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T inf = 0.0;\n    if (bitsPerReal == 32U) {\n      inf = rtGetInfF();\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.bitVal.words.wordH = 0x7FF00000U;\n      tmpVal.bitVal.words.wordL = 0x00000000U;\n      inf = tmpVal.fltVal;\n    }\n\n    return inf;\n  }\n\n  //\n  // Initialize rtInfF needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  real32_T rtGetInfF(void)\n  {\n    IEEESingle infF;\n    infF.wordL.wordLuint = 0x7F800000U;\n    return infF.wordL.wordLreal;\n  }\n\n  //\n  // Initialize rtMinusInf needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  real_T rtGetMinusInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T minf = 0.0;\n    if (bitsPerReal == 32U) {\n      minf = rtGetMinusInfF();\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.bitVal.words.wordH = 0xFFF00000U;\n      tmpVal.bitVal.words.wordL = 0x00000000U;\n      minf = tmpVal.fltVal;\n    }\n\n    return minf;\n  }\n\n  //\n  // Initialize rtMinusInfF needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  real32_T rtGetMinusInfF(void)\n  {\n    IEEESingle minfF;\n    minfF.wordL.wordLuint = 0xFF800000U;\n    return minfF.wordL.wordLreal;\n  }\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtGetInf.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.248\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu May 22 21:41:20 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef rtGetInf_h_\n#define rtGetInf_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetInf(void);\n  extern real32_T rtGetInfF(void);\n  extern real_T rtGetMinusInf(void);\n  extern real32_T rtGetMinusInfF(void);\n\n#ifdef __cplusplus\n\n}                                      // extern \"C\"\n\n#endif\n#endif                                 // rtGetInf_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtGetNaN.cpp","type":"source","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtGetNaN.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.248\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu May 22 21:41:20 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  //\n  // Initialize rtNaN needed by the generated code.\n  // NaN is initialized as non-signaling. Assumes IEEE.\n  //\n  real_T rtGetNaN(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T nan = 0.0;\n    if (bitsPerReal == 32U) {\n      nan = rtGetNaNF();\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.bitVal.words.wordH = 0xFFF80000U;\n      tmpVal.bitVal.words.wordL = 0x00000000U;\n      nan = tmpVal.fltVal;\n    }\n\n    return nan;\n  }\n\n  //\n  // Initialize rtNaNF needed by the generated code.\n  // NaN is initialized as non-signaling. Assumes IEEE.\n  //\n  real32_T rtGetNaNF(void)\n  {\n    IEEESingle nanF = { { 0.0F } };\n\n    nanF.wordL.wordLuint = 0xFFC00000U;\n    return nanF.wordL.wordLreal;\n  }\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtGetNaN.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.248\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu May 22 21:41:20 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef rtGetNaN_h_\n#define rtGetNaN_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetNaN(void);\n  extern real32_T rtGetNaNF(void);\n\n#ifdef __cplusplus\n\n}                                      // extern \"C\"\n\n#endif\n#endif                                 // rtGetNaN_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rt_defines.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.248\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu May 22 21:41:20 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef rt_defines_h_\n#define rt_defines_h_\n\n//===========*\n//  Constants *\n// ===========\n#define RT_PI                          3.14159265358979323846\n#define RT_PIF                         3.1415927F\n#define RT_LN_10                       2.30258509299404568402\n#define RT_LN_10F                      2.3025851F\n#define RT_LOG10E                      0.43429448190325182765\n#define RT_LOG10EF                     0.43429449F\n#define RT_E                           2.7182818284590452354\n#define RT_EF                          2.7182817F\n\n//\n//  UNUSED_PARAMETER(x)\n//    Used to specify that a function parameter (argument) is required but not\n//    accessed by the function body.\n\n#ifndef UNUSED_PARAMETER\n#if defined(__LCC__)\n#define UNUSED_PARAMETER(x)                                      // do nothing\n#else\n\n//\n//  This is the semi-ANSI standard way of indicating that an\n//  unused function parameter is required.\n\n#define UNUSED_PARAMETER(x)            (void) (x)\n#endif\n#endif\n#endif                                 // rt_defines_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rt_nonfinite.cpp","type":"source","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rt_nonfinite.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.248\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu May 22 21:41:20 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  real_T rtInf;\n  real_T rtMinusInf;\n  real_T rtNaN;\n  real32_T rtInfF;\n  real32_T rtMinusInfF;\n  real32_T rtNaNF;\n}\n\nextern \"C\"\n{\n  //\n  // Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n  // generated code. NaN is initialized as non-signaling. Assumes IEEE.\n  //\n  void rt_InitInfAndNaN(size_t realSize)\n  {\n    (void) (realSize);\n    rtNaN = rtGetNaN();\n    rtNaNF = rtGetNaNF();\n    rtInf = rtGetInf();\n    rtInfF = rtGetInfF();\n    rtMinusInf = rtGetMinusInf();\n    rtMinusInfF = rtGetMinusInfF();\n  }\n\n  // Test if value is infinite\n  boolean_T rtIsInf(real_T value)\n  {\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n  }\n\n  // Test if single-precision value is infinite\n  boolean_T rtIsInfF(real32_T value)\n  {\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n  }\n\n  // Test if value is not a number\n  boolean_T rtIsNaN(real_T value)\n  {\n    boolean_T result = (boolean_T) 0;\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    if (bitsPerReal == 32U) {\n      result = rtIsNaNF((real32_T)value);\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.fltVal = value;\n      result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                           0x7FF00000 &&\n                           ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                            (tmpVal.bitVal.words.wordL != 0) ));\n    }\n\n    return result;\n  }\n\n  // Test if single-precision value is not a number\n  boolean_T rtIsNaNF(real32_T value)\n  {\n    IEEESingle tmp;\n    tmp.wordL.wordLreal = value;\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n  }\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rt_nonfinite.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.248\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu May 22 21:41:20 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef rt_nonfinite_h_\n#define rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#define NOT_USING_NONFINITE_LITERALS   1\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtInf;\n  extern real_T rtMinusInf;\n  extern real_T rtNaN;\n  extern real32_T rtInfF;\n  extern real32_T rtMinusInfF;\n  extern real32_T rtNaNF;\n  extern void rt_InitInfAndNaN(size_t realSize);\n  extern boolean_T rtIsInf(real_T value);\n  extern boolean_T rtIsInfF(real32_T value);\n  extern boolean_T rtIsNaN(real_T value);\n  extern boolean_T rtIsNaNF(real32_T value);\n  struct BigEndianIEEEDouble {\n    struct {\n      uint32_T wordH;\n      uint32_T wordL;\n    } words;\n  };\n\n  struct LittleEndianIEEEDouble {\n    struct {\n      uint32_T wordL;\n      uint32_T wordH;\n    } words;\n  };\n\n  struct IEEESingle {\n    union {\n      real32_T wordLreal;\n      uint32_T wordLuint;\n    } wordL;\n  };\n\n#ifdef __cplusplus\n\n}                                      // extern \"C\"\n\n#endif\n#endif                                 // rt_nonfinite_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtwtypes.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.248\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu May 22 21:41:20 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n\n// Logical type definitions\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n//=======================================================================*\n//  Target hardware information\n//    Device type: ARM Compatible->ARM Cortex\n//    Number of bits:     char:   8    short:   16    int:  32\n//                        long:  32    long long:  64\n//                        native word size:  32\n//    Byte ordering: LittleEndian\n//    Signed integer division rounds to: Zero\n//    Shift right on a signed integer as arithmetic shift: on\n// =======================================================================\n\n//=======================================================================*\n//  Fixed width word size data types:                                     *\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n//    real32_T, real64_T           - 32 and 64 bit floating point numbers *\n// =======================================================================\ntypedef signed char int8_T;\ntypedef unsigned char uint8_T;\ntypedef short int16_T;\ntypedef unsigned short uint16_T;\ntypedef int int32_T;\ntypedef unsigned int uint32_T;\ntypedef long long int64_T;\ntypedef unsigned long long uint64_T;\ntypedef float real32_T;\ntypedef double real64_T;\n\n//===========================================================================*\n//  Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n//                            real_T, time_T, ulong_T, ulonglong_T.           *\n// ===========================================================================\ntypedef double real_T;\ntypedef double time_T;\ntypedef unsigned char boolean_T;\ntypedef int int_T;\ntypedef unsigned int uint_T;\ntypedef unsigned long ulong_T;\ntypedef unsigned long long ulonglong_T;\ntypedef char char_T;\ntypedef unsigned char uchar_T;\ntypedef char_T byte_T;\n\n//===========================================================================*\n//  Complex number type definitions                                           *\n// ===========================================================================\n#define CREAL_T\n\ntypedef struct {\n  real32_T re;\n  real32_T im;\n} creal32_T;\n\ntypedef struct {\n  real64_T re;\n  real64_T im;\n} creal64_T;\n\ntypedef struct {\n  real_T re;\n  real_T im;\n} creal_T;\n\n#define CINT8_T\n\ntypedef struct {\n  int8_T re;\n  int8_T im;\n} cint8_T;\n\n#define CUINT8_T\n\ntypedef struct {\n  uint8_T re;\n  uint8_T im;\n} cuint8_T;\n\n#define CINT16_T\n\ntypedef struct {\n  int16_T re;\n  int16_T im;\n} cint16_T;\n\n#define CUINT16_T\n\ntypedef struct {\n  uint16_T re;\n  uint16_T im;\n} cuint16_T;\n\n#define CINT32_T\n\ntypedef struct {\n  int32_T re;\n  int32_T im;\n} cint32_T;\n\n#define CUINT32_T\n\ntypedef struct {\n  uint32_T re;\n  uint32_T im;\n} cuint32_T;\n\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n//=======================================================================*\n//  Min and Max:                                                          *\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n// =======================================================================\n#define MAX_int8_T                     ((int8_T)(127))\n#define MIN_int8_T                     ((int8_T)(-128))\n#define MAX_uint8_T                    ((uint8_T)(255U))\n#define MAX_int16_T                    ((int16_T)(32767))\n#define MIN_int16_T                    ((int16_T)(-32768))\n#define MAX_uint16_T                   ((uint16_T)(65535U))\n#define MAX_int32_T                    ((int32_T)(2147483647))\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\n\n// Block D-Work pointer type\ntypedef void * pointer_T;\n\n#endif                                 // RTWTYPES_H\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"ext_mode_types.h","type":"header","group":"interface","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Interface files","code":"//\n//  ext_mode_types.h\n//\n//  Academic License - for use in teaching, academic research, and meeting\n//  course requirements at degree granting institutions only.  Not for\n//  government, commercial, or other organizational use.\n//\n//  Code generation for model \"FLIGHT_hexacopter\".\n//\n//  Model version              : 1.248\n//  Simulink Coder version : 24.1 (R2024a) 19-Nov-2023\n//  C++ source code generated on : Thu May 22 21:41:20 2025\n//\n//  Target selection: ert.tlc\n//  Embedded hardware selection: ARM Compatible->ARM Cortex\n//  Code generation objectives: Unspecified\n//  Validation result: Not run\n\n\n#ifndef EXT_MODE_TYPES_H\n#define EXT_MODE_TYPES_H\n#include \"rtwtypes.h\"\n\n//* External Mode Event ID\ntypedef uint16_T extmodeEventId_T;\n\n//* External Mode real time, measured using the target's clock\ntypedef uint32_T extmodeRealTime_T;\n\n//* External Mode simulation time\ntypedef time_T extmodeSimulationTime_T;\n\n//* External Mode double data type\ntypedef real_T extmodeDouble_T;\n\n//* External Mode classic trigger signal\ntypedef real_T extmodeClassicTriggerSignal_T;\n\n//* Run the simulation forever (infinite simulation end time)\n#define EXTMODE_SIMULATION_RUN_FOREVER ((extmodeSimulationTime_T) -1)\n\n// Define max value of 32-bit unsigned type\n#define XCP_UINT32_MAX                 0xFFFFFFFFU\n\n//* External Mode Base rate event id\n#define EXTMODE_BASE_RATE_EVENT_ID     0\n\n//* External Mode Max Event Id\n#define EXTMODE_MAX_EVENT_ID           0xFF\n#endif                                 // EXT_MODE_TYPES_H\n\n// [EOF] ext_mode_types.h\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Interface files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtmodel.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.248\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu May 22 21:41:20 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef rtmodel_h_\n#define rtmodel_h_\n#include \"FLIGHT_hexacopter.h\"\n#endif                                 // rtmodel_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"MW_PX4_PWM.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2024 The MathWorks, Inc. */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"MW_PX4_PWM.h\"\n#include \"MW_Parameter.h\"\n#include <uORB/Publication.hpp>\n\n#define DEBUG 0\n\nstatic constexpr uint16_t PWM_SIM_DISARMED = 900;\nstatic constexpr uint16_t PWM_SIM_FAILSAFE = 600;\nstatic constexpr uint16_t PWM_SIM_PWM_MIN = 1000;\nstatic constexpr uint16_t PWM_SIM_PWM_MAX = 2000;\n#if USE_ACTUATOR_TEST\nuORB::Publication<actuator_test_s> actuator_test_pub{ORB_ID(actuator_test)};\n#endif\n\nvoid pwm_open(orb_advert_t* actuatorObj, orb_advert_t* armObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"*     actuatorObj: %d * \", actuatorObj);\n    PX4_INFO(\"*     armObj: %d *\\n\", armObj);\n#endif\n\n#if USE_ACTUATOR_TEST\n    getMainDAPWMValues(mainDAPWMValue);\n    getAUXDAPWMValues(auxDAPWMValue);\n    getMainMinValues(mainMinPWMValue);\n    getAUXMinValues(auxMinPWMValue);\n    getMainMaxValues(mainMaxPWMValue);\n    getAUXMaxValues(auxMaxPWMValue);\n#else\n    /* advertise actuator_outputs topic */\n    struct actuator_outputs_s outputs;\n    memset(&outputs, 0, sizeof(outputs));\n    *actuatorObj = orb_advertise_queue(ORB_ID(actuator_outputs_sim), &outputs, 1);\n\n    /* advertise actuator_armed topic */\n    struct actuator_armed_s armPWM;\n    memset(&armPWM, 0, sizeof(armPWM));\n    *armObj = orb_advertise_queue(ORB_ID(actuator_armed), &armPWM, 1);\n#endif\n}\n\nvoid pwm_arm(orb_advert_t* armObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_arm: *isArmed (status = %d)* \", *isArmed);\n    PX4_INFO(\"*     armObj: %d *\\n\", armObj);\n#endif\n\n#if USE_ACTUATOR_TEST\n\n#else\n    struct actuator_armed_s armPWM;\n    memset(&armPWM, 0, sizeof(armPWM));\n    armPWM.armed = true;\n    orb_publish(ORB_ID(actuator_armed), *armObj, &armPWM);\n#endif\n}\n\nvoid pwm_disarm(orb_advert_t* armObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_disarm: *isArmed (status = %d)* \", *isArmed);\n    PX4_INFO(\"*     armObj: %d *\\n\", armObj);\n#endif\n\n#if USE_ACTUATOR_TEST\n#else\n    struct actuator_armed_s armPWM;\n    memset(&armPWM, 0, sizeof(armPWM));\n    armPWM.armed = false;\n    orb_publish(ORB_ID(actuator_armed), *armObj, &armPWM);\n\n#if defined(MW_PX4_POSIX_BUILD)\n    struct vehicle_status_s arm_vehicle_stat;\n    /* Subscribe to current vehicle_status*/\n    int vehicle_status_fd = orb_subscribe(ORB_ID(vehicle_status));\n    orb_copy(ORB_ID(vehicle_status), vehicle_status_fd, &arm_vehicle_stat);\n    /* Arm vehicle status to ARMING_STATE_SHUTDOWN = 4*/\n    arm_vehicle_stat.arming_state = 4;\n    static bool isAdvertised_disarm = false;\n    static orb_advert_t vehicle_status_pub;\n    if (!isAdvertised_disarm) {\n        isAdvertised_disarm = true;\n        vehicle_status_pub = orb_advertise_queue(ORB_ID(vehicle_status), &arm_vehicle_stat, 1);\n    }\n    orb_publish(ORB_ID(vehicle_status), vehicle_status_pub, &arm_vehicle_stat);\n\n    orb_unsubscribe(vehicle_status_fd);\n#endif\n\n#endif\n}\n\nvoid pwm_forceFailsafe(orb_advert_t* armObj) {\n\n    pwm_disarm(armObj);\n}\n\nvoid pwm_setServo(unsigned servo_count,\n                  int channelMask,\n                  uint16_t* pwm_value,\n                  boolean_T isMain,\n                  orb_advert_t* actuatorObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_setServo: servo_count %d* \", servo_count);\n    PX4_INFO(\"*     isMain %d* \", isMain);\n    PX4_INFO(\"*     actuatorObj %d* \\n\", actuatorObj);\n    uint32_T iPWM;\n    printf(\"* pwm_setServo: PWM values :\");\n    for (iPWM = 0; iPWM < 8; iPWM++) {\n        printf(\"[%d]\", pwm_value[iPWM]);\n    }\n    printf(\"\\n\");\n#endif\n#if USE_ACTUATOR_TEST\n    float output = 0;\n    if (isMain) {\n        for (unsigned i = 0; i < servo_count; ++i) {\n            output = (float)pwm_value[i];\n            output = (output - mainMinPWMValue[i]) / (mainMaxPWMValue[i] - mainMinPWMValue[i]);\n            send_actuator_test_output(actuator_test_s::FUNCTION_MOTOR1 + i, output, false);\n        }\n    } else {\n        for (unsigned i = 0; i < servo_count; ++i) {\n            output = (float)pwm_value[i];\n            output = (output - ((auxMaxPWMValue[i] + auxMinPWMValue[i]) / 2)) /\n                     ((auxMaxPWMValue[i] - auxMinPWMValue[i]) / 2);\n            send_actuator_test_output(actuator_test_s::FUNCTION_SERVO1 + i, output, false);\n        }\n    }\n#else\n    if (isMain) {\n        struct actuator_outputs_s outputs;\n        memset(&outputs, 0, sizeof(outputs));\n        outputs.noutputs = servo_count;\n        outputs.timestamp = hrt_absolute_time();\n        for (unsigned i = 0; i < servo_count; i++) {\n\n            if (pwm_value[i] != PWM_SIM_DISARMED && channelMask & 1 << i) {\n\n                float output = (float)pwm_value[i];\n                /* Scale the motors that are non - reversible to[0, 1]*/\n                outputs.output[i] =\n                    (output - PWM_SIM_PWM_MIN) / (PWM_SIM_PWM_MAX - PWM_SIM_PWM_MIN);\n            }\n        }\n        orb_publish(ORB_ID(actuator_outputs_sim), *actuatorObj, &outputs);\n\n#if defined(MW_PX4_POSIX_BUILD)\n        /*Only for Host target vehicle_status needs to be armed, not for HITL*/\n        struct vehicle_status_s arm_vehicle_stat;\n        /* Subscribe to current vehicle_status*/\n        int vehicle_status_fd = orb_subscribe(ORB_ID(vehicle_status));\n        orb_copy(ORB_ID(vehicle_status), vehicle_status_fd, &arm_vehicle_stat);\n        /* Arm vehicle status to ARMING_STATE_ARMED = 2*/\n        arm_vehicle_stat.arming_state = 2;\n        orb_advert_t vehicle_status_pub =\n            orb_advertise_queue(ORB_ID(vehicle_status), &arm_vehicle_stat, 1);\n        orb_publish(ORB_ID(vehicle_status), vehicle_status_pub, &arm_vehicle_stat);\n        orb_unsubscribe(vehicle_status_fd);\n#endif\n    }\n#endif\n}\n\nvoid pwm_resetServo(unsigned servo_count, boolean_T isMain, orb_advert_t* actuatorObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_setServo: servo_count %d* \", servo_count);\n    PX4_INFO(\"*     isMain %d* \", isMain);\n    PX4_INFO(\"*     actuatorObj %d* \\n\", actuatorObj);\n#endif\n\n#if USE_ACTUATOR_TEST\n    if (isMain) {\n        for (unsigned i = 0; i < servo_count; ++i) {\n            send_actuator_test_output(actuator_test_s::FUNCTION_MOTOR1 + i, 0, true);\n        }\n    } else {\n        for (unsigned i = 0; i < servo_count; ++i) {\n            send_actuator_test_output(actuator_test_s::FUNCTION_SERVO1 + i, 0, true);\n        }\n    }\n#else\n    if (isMain) {\n        struct actuator_outputs_s outputs;\n        memset(&outputs, 0, sizeof(outputs));\n        outputs.noutputs = servo_count;\n        outputs.timestamp = hrt_absolute_time();\n        orb_publish(ORB_ID(actuator_outputs_sim), *actuatorObj, &outputs);\n    }\n\n#endif\n}\n\nvoid pwm_close(unsigned servo_count, orb_advert_t* actuatorObj, orb_advert_t* armObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_close: armObj %d* \", armObj);\n    PX4_INFO(\"*     actuatorObj %d*\\n\", actuatorObj);\n#endif\n\n#if USE_ACTUATOR_TEST\n    for (unsigned i = 0; i < servo_count; ++i) {\n        send_actuator_test_output(actuator_test_s::FUNCTION_MOTOR1 + i, 0, true);\n    }\n\n    for (unsigned i = 0; i < servo_count; ++i) {\n        send_actuator_test_output(actuator_test_s::FUNCTION_SERVO1 + i, 0, true);\n    }\n#else\n    orb_unadvertise(*actuatorObj);\n    orb_unadvertise(*armObj);\n#endif\n}\n\nvoid send_actuator_test_output(int motorNum, float value, bool isArmed) {\n#if USE_ACTUATOR_TEST\n    actuator_test_s actuator_test{};\n    actuator_test.timestamp = hrt_absolute_time();\n    actuator_test.function = motorNum;\n    actuator_test.value = value;\n    actuator_test.action =\n        isArmed ? actuator_test_s::ACTION_RELEASE_CONTROL : actuator_test_s::ACTION_DO_CONTROL;\n    actuator_test.timeout_ms = 0;\n    actuator_test_pub.publish(actuator_test);\n#endif\n}\n\nvoid getMainDAPWMValues(int32_t* daPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS1\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS2\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS3\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS4\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS5\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS6\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS7\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS8\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        }\n    }\n}\n\nvoid getAUXDAPWMValues(int32_t* daPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS1\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS2\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS3\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS4\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS5\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS6\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS7\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS8\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        }\n    }\n}\n\nvoid getMainMinValues(int32_t* minPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN1\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN2\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN3\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN4\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN5\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN6\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN7\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN8\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        }\n    }\n}\n\nvoid getAUXMinValues(int32_t* minPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN1\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN2\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN3\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN4\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN5\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN6\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN7\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN8\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        }\n    }\n}\n\nvoid getMainMaxValues(int32_t* maxPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX1\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX2\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX3\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX4\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX5\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX6\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX7\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX8\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        }\n    }\n}\n\nvoid getAUXMaxValues(int32_t* maxPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX1\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX2\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX3\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX4\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX5\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX6\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX7\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX8\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        }\n    }\n}\n\nbool getSingleParamValue(const char* parameterName, float* paramValue_float) {\n\n    bool success = false;\n    MW_Param_Handle param_handle = PARAM_INVALID;\n    param_handle = param_find(parameterName);\n\n#if DEBUG\n    printf(\"Parameter name = %s.\\n\", parameterName);\n    if (param_handle != PARAM_INVALID) {\n        printf(\"Valid Parameter Handle = %u.\\n\", param_handle);\n    } else {\n        printf(\"Invalid Parameter Handle. \\n\");\n    }\n#endif\n\n    if (param_handle != PARAM_INVALID) {\n        if (!param_get(param_handle, paramValue_float)) {\n            success = true;\n#if DEBUG\n            printf(\"MW_SINGLE. Value = %4.4f\\n\", *paramValue_float);\n#endif\n        }\n    }\n\n    return success;\n}\n\nbool getIntegerParamValue(const char* parameterName, int32_t* paramValue_int) {\n\n    bool success = false;\n    MW_Param_Handle param_handle = PARAM_INVALID;\n    param_handle = param_find(parameterName);\n\n#if DEBUG\n    printf(\"Parameter name = %s.\\n\", parameterName);\n    if (param_handle != PARAM_INVALID) {\n        printf(\"Valid Parameter Handle = %u.\\n\", param_handle);\n    } else {\n        printf(\"Invalid Parameter Handle. \\n\");\n    }\n#endif\n\n    if (param_handle != PARAM_INVALID) {\n        if (!param_get(param_handle, paramValue_int)) {\n            success = true;\n#if DEBUG\n            printf(\"Value = %ld\\n\", *paramValue_int);\n#endif\n        }\n    }\n\n    return success;\n}\n"},{"name":"MW_PX4_TaskControl.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2018-2023 The MathWorks, Inc.\n *\n * File: MW_PX4_TaskControl.c\n *\n * Abstract:\n *  This file contains the main application for Simulink that is launched\n *  by PX4 stack at boot up. The main function spawns a new task and assigns\n *  the main function in ert_main.c as callback.\n *\n */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n/*Simulink model generated code specific headers*/\n\n#define MW_StringifyDefine(x) MW_StringifyDefineExpanded(x)\n#define MW_StringifyDefineExpanded(x) #x\n\n#define MW_StringifyDefineFunction(x, y) MW_StringifyDefineExpandedFunction(x, y)\n#define MW_StringifyDefineExpandedFunction(x, y) x##y\n\n#define MW_StringifyDefineX(x) MW_StringifyDefineExpandedX(x)\n#define MW_StringifyDefineExpandedX(x) x.##h\n\n#define MW_StringifyDefineTypesX(x) MW_StringifyDefineExpandedTypesX(x)\n#define MW_StringifyDefineExpandedTypesX(x) x##_types.h\n\n#define MW_StringifyDefinePrivateX(x) MW_StringifyDefineExpandedPrivateX(x)\n#define MW_StringifyDefineExpandedPrivateX(x) x##_private.h\n\n#include MW_StringifyDefine(MODEL.h)\n#include MW_StringifyDefine(MW_StringifyDefineTypesX(MODEL))\n#include MW_StringifyDefine(MW_StringifyDefinePrivateX(MODEL))\n\n#ifndef MW_PX4_DISABLE_MAVLINK\n#include \"mavlink_main.h\"\n#endif\n\n#define DEBUG 0\n\n#ifdef PIL\nextern int errorOccurred;\n#endif\n\nextern \"C\" __EXPORT int px4_simulink_app_main(int argc,\n                                              char* argv[]); /* sbcheck:ok:extern_c needed */\n\nextern struct hrt_call\n    BaseRate_HRT; /* Base-rate HRT-callback is used to post base-rate semaphore */\nextern int terminatingmodel;\nextern int baserate_sem_copy; /* used for checking HRT semaphore water-mark*/\nstatic bool g_baseRateLife =\n    false;                        /* global storage to contain the status of the px4_simulink_app */\nstatic int px4_simulink_app_task; /* Handle of daemon thread */\nchar mavlink_shell_started = 0;\n\n/* Print the correct usage. */\nvoid px4_app_usage(const char* reason) {\n    if (reason) {\n        PX4_INFO(\"px4_simulink_app : %s\\n\", reason);\n    }\n    errx(1, \"usage: px4_simulink_app {start|stop|status} [-p <additional params>]\\n\\n\");\n}\n\n#if defined(MW_PX4_DISABLE_MAVLINK)\nuint8_t buffer[100];\nMavlinkShell shell;\nvoid shellWait(MavlinkShell* shell_ptr, uint8_t buf[]) {\n    /*The shell wait here is to be used for commands which are expected to\n      return a few characters (a max. of 100 characters.)*/\n    int read = 0, readTotal = 0;\n    for (int i = 0; i < 100; i++) {\n        buf[i] = 0;\n    }\n    while (strstr((char*)buf, \"nsh>\") == NULL) {\n        read = shell_ptr->read(buf + readTotal, 100 - readTotal);\n        readTotal = readTotal + read;\n    }\n}\n#endif\n\nvoid px4_simulink_app_control_MAVLink() {\n    if (mavlink_shell_started == 0) {\n#ifdef MW_PX4_DISABLE_MAVLINK\n        shell.start();\n        shellWait(&shell, buffer);\n#endif\n    }\n\n#ifdef MW_PX4_DISABLE_MAVLINK\n    shell.write((uint8_t*)\"mavlink stop-all\\n\", sizeof(\"mavlink stop-all\\n\"));\n    usleep(100000);\n#endif\n}\n\nint px4_simulink_app_main(int argc, char* argv[]) {\n    if (argc < 2) {\n        px4_app_usage(\"missing command\");\n    }\n\n    if (!strcmp(argv[1], \"start\")) {\n        if (g_baseRateLife == false) {\n            /* Start the Simulink Tasks here */\n#if DEBUG\n            printf(\"px4_simulink_app : Starting the Simulink model\\n\");\n            fflush(stdout);\n#endif\n\n            /* Reset semaphore */\n            g_baseRateLife = true;\n            terminatingmodel =\n                0; // reset global variable. For more info on the rational behind this, please see:\n            // http://nuttx.org/doku.php?id=wiki:nxinternal:tasks-vs-processes#nuttx_flat-build_behavior\n\n            px4_simulink_app_task = px4_task_spawn_cmd(\n                \"px4_simulink_app_task\", /* Definition of px4_task_spawn_cmd :\n                                            C:\\px4\\Firmware\\src\\platforms\\nuttx\\px4_layer\\px4_nuttx_tasks.c\n                                          */\n                SCHED_DEFAULT,           /* For STM32 F4, NuttX has SCHED_DEFAULT as SCHED_RR */\n                SCHED_PRIORITY_MAX - 15, /* SCHED_PRIORITY_MAX: 255 */\n                2048, px4_simulink_app_task_main, (char* const*)NULL);\n\n        } else {\n            warnx(\"px4_simulink_app : Simulink model is already running\\n\");\n            fflush(stdout);\n        }\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    if (!strcmp(argv[1], \"stop\")) {\n        if (g_baseRateLife == true) {\n#ifdef PIL\n            errorOccurred = 1;\n#else\n            rtmSetErrorStatus(MW_StringifyDefineFunction(MODEL, _M), \"Module stopped by user\");\n            g_baseRateLife = false;\n            px4_sem_post(&baserateTaskSem);\n#endif\n#if DEBUG\n            PX4_INFO(\"px4_simulink_app : Exiting the Simulink model\\n\");\n#endif\n        } else {\n            warnx(\"px4_simulink_app : No Simulink model is running\\n\");\n        }\n\n        fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    if (!strcmp(argv[1], \"status\")) {\n        if (g_baseRateLife) {\n            PX4_INFO(\"px4_simulink_app : model is running\\n\");\n        } else {\n            PX4_INFO(\"px4_simulink_app : model is not started\\n\");\n        }\n        fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    px4_app_usage(\"unrecognized command\");\n#if defined(MW_PX4_NUTTX_BUILD)\n    exit(1);\n#else\n    return 1;\n#endif\n}\n\nvoid MW_PX4_Terminate() {\n    hrt_cancel(&BaseRate_HRT);\n    g_baseRateLife = false; // set status of PX4 Simulink App to stop\n\n#if defined(MW_HRT_CONSTRAINT) && (1 == MW_HRT_CONSTRAINT)\n    if (baserate_sem_copy > MW_SEM_WATERMARK) {\n        PX4_INFO(\"Hard real-time constraint violated, shutting down. Updating log file. \\n\");\n        FILE* fp_taskover_run = NULL;\n        char msg_watermark[100] = {0};\n        char msg_timestamp[50] = {0};\n        struct tm* sTm;\n        time_t now = time(NULL);\n        sTm = gmtime(&now);\n        sprintf(msg_watermark,\n                \"Base-rate semaphore exceeded water-mark value %d. Model base-rate = %.3f sec.\",\n                MW_SEM_WATERMARK, (float)MW_BASERATE_PERIOD);\n        strftime(msg_timestamp, sizeof(msg_timestamp), \"%Y-%m-%d %H:%M:%S\", sTm);\n        fp_taskover_run = fopen(\"/fs/microsd/log/task_overrun_log.txt\", \"a+\");\n        fprintf(fp_taskover_run, \"%s Timestamp=%s \\n\", msg_watermark, msg_timestamp);\n        fclose(fp_taskover_run);\n    }\n#endif\n\n#if DEBUG\n    PX4_INFO(\"px4_simulink_app : Received command to end the Simulink task \\n\");\n    fflush(stdout);\n#endif\n}\n\n// LocalWords:  HRT px nsh mavlink nuttx doku nxinternal Nutt SCHED fs microsd\n// LocalWords:  dev ACM tty\n"},{"name":"MW_PX4_rtiostream_serial.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2018-2022 The MathWorks, Inc.\n *\n * File: MW_PX4_rtiostream_serial.c\n *\n * Abstract:\n *  Serial communications channel for PX4 Nuttx machine\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <limits.h>\n#include <assert.h>\n#include \"systemlib/err.h\"\n\n#include <termios.h>   /* POSIX terminal control definition*/\n#include <unistd.h>    /*UNIX standard function definitions*/\n#include <fcntl.h>     /* File control definition*/\n#include <errno.h>     /*To get a description of error */\n#include <sys/ioctl.h> /*For IOCTL Functions*/\n\n#include \"MW_target_hardware_resources.h\"\n\n#ifndef _rtiostream\nextern \"C\" { /* sbcheck:ok:extern_c needed because of C++ compatibility for rtiostream.h*/\n#include \"rtiostream.h\"\n}\n#define _rtiostream\n#endif\n\n#ifdef USE_MEXPRINTF\n#include \"mex.h\"\n#define printf mexPrintf\n#endif\n\n/***************** DEFINES ****************************************************/\n\n#define N_SERIAL_PORTS 10    /* Number of com ports allowed to open */\n#define MAX_COM_LEN 30       /* length of com port name */\n#define MAX_COM_PREFIX_LEN 7 /* Full prefix is \\\\.\\COM  */\n#define TMP_BUF_SIZ (40)\n\n#ifndef MIN\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n\n#define COM_PORT_PREFIX \"/dev/\"\n#define PORTNAME_DEFAULT_VAL \"/dev/ttyS0\"\n\n#define BAUD_DEFAULT_VAL 57600\n#define RTS_DTR_ENABLE_DEFAULT_VAL 0\n\n#define MW_EXTSERIALPORT_STR(x) MW_EXTSERIALPORT_STR_EXPANDED(x)\n#define MW_EXTSERIALPORT_STR_EXPANDED(x) #x\n\n/* define a set of verbosity levels:\n *\n * 0: no verbose output\n * 1: basic verbose output\n * 2: extra verbose output */\ntypedef enum { VERBOSITY_LEVEL_0 = 0, VERBOSITY_LEVEL_1, VERBOSITY_LEVEL_2 } VerbosityLevel;\n/* default verbosity */\n#define DEFAULT_VERBOSITY VERBOSITY_LEVEL_0\n\n#define READ_FILE_TIMEOUT 10000 /* 10 seconds */\n#define WRITE_FILE_TIMEOUT                  \\\n    2000 /* 2 seconds. This should be large \\\n          * enough to send 512 bytes at the \\\n          * lowest possible baud rate. See  \\\n          * comments in serialDataSet for   \\\n          * more details                    \\\n          */\n\n/***************** TYPEDEFS **************************************************/\n\ntypedef struct SerialCommsData_tag {\n    int isInUse; /* flag to indicate whether an instance is in use */\n    char port[MAX_COM_LEN];\n    int serialHandle;\n    uint32_T baud;\n    VerbosityLevel verbosity;\n    uint8_T rtsDtrEnable;\n} SerialCommsData;\n\n/**************** LOCAL DATA *************************************************/\n\n/* All local data resides in the per instance SerialCommsData structures to\n * make sure each connection is completely independent.\n *\n * The static array will be deallocated when the shared library is unloaded.\n *\n * Using an array rather than a linked list allows us to have fast direct lookup\n * of SerialCommsData from streamID during calls to rtIOStreamSend/Recv */\nstatic SerialCommsData SerialData[N_SERIAL_PORTS];\nstatic bool dataInitialised = false;\n\n/*\n * Refer to geck 700573 for resources used\n * All the parameters defined for Termios structure which\n * stores anything in relation to port attributes\n */\nstatic struct termios sTermios;\n\n/************** LOCAL FUNCTION PROTOTYPES ************************************/\n\nstatic int serialDataSet(SerialCommsData* sd, const void* src, const size_t size, size_t* sizeSent);\n\nstatic int serialDataGet(SerialCommsData* sd, char* dst, const size_t size, size_t* sizeRecvd);\n\nstatic int serialDataPending(SerialCommsData* sd, int* outPending);\n\nstatic void initSerialCommsDataStructure(void);\n\nstatic SerialCommsData* getSerialData(int streamID);\n\n/*************** LOCAL FUNCTIONS **********************************************/\n\n/* Function: initSerialCommsDataStructure ==========================================================\n * Abstract: Initializes the data\n * structures to zero.\n */\nstatic void initSerialCommsDataStructure(void) {\n    if (!dataInitialised) {\n        memset(&SerialData, 0, sizeof(SerialData));\n        dataInitialised = true;\n    }\n}\n\n/* Function: initTermios ===========================================================================\n * Abstract:\n *  Initializes the control settings for a UNIX serial communications device.\n */\nstatic int initTermios(int fd, uint32_T baud) {\n    speed_t baudC = B0;\n\n    if (tcgetattr(fd, &sTermios) != 0) { /*Get the attributes set by default*/\n        printf(\"ERROR: Failed to get existing serial port configuration\\n\");\n        return RTIOSTREAM_ERROR;\n    }\n\n    /* ---------- Serial Port Config ------- */\n    sTermios.c_cflag |= (CLOCAL     /*To not become port 'owner'*/\n                         | CREAD);  /*Allow reading of incoming data*/\n    sTermios.c_cflag &= ~(CSTOPB    /*To have one stop bit */\n                          | CSIZE); /*Mask Character size bites */\n    sTermios.c_cflag &= ~(PARENB);  /*Disable Parity Check*/\n    sTermios.c_cflag |= CS8;        /*Character size at 8 bits */\n\n    sTermios.c_lflag &= ~(ICANON     /*To have raw output*/\n                          | ECHO     /*Disable input character echo*/\n                          | ECHONL   /*Disable echoing NL character */\n                          | ISIG     /*Disable SIGINTR, SIGSUSP, SIGDSUSP, and SIGQUIT signals*/\n                          | IEXTEN); /* implementation-defined input processing */\n\n    sTermios.c_cc[VMIN] = 0;  /*To not have read operation dependent\n                               * on number of characters received*/\n    sTermios.c_cc[VTIME] = 0; /* Does not have a timeout*/\n\n    sTermios.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL |\n                          IXON); /*Disable Software Flow Control*/\n\n    sTermios.c_oflag &= ~OPOST; /*Disable Post processing of output*/\n\n    /*Determine Actual Baud Value to setup port*/\n    switch (baud) {\n    case 50:\n        baudC = B50;\n        break;\n    case 75:\n        baudC = B75;\n        break;\n    case 110:\n        baudC = B110;\n        break;\n    case 134:\n        baudC = B134;\n        break;\n    case 150:\n        baudC = B150;\n        break;\n    case 200:\n        baudC = B200;\n        break;\n    case 300:\n        baudC = B300;\n        break;\n    case 600:\n        baudC = B600;\n        break;\n    case 1200:\n        baudC = B1200;\n        break;\n    case 1800:\n        baudC = B1800;\n        break;\n    case 2400:\n        baudC = B2400;\n        break;\n    case 4800:\n        baudC = B4800;\n        break;\n    case 9600:\n        baudC = B9600;\n        break;\n    case 19200:\n        baudC = B19200;\n        break;\n    case 38400:\n        baudC = B38400;\n        break;\n    case 57600:\n        baudC = B57600;\n        break;\n    case 115200:\n        baudC = B115200;\n        break;\n    case 230400:\n        baudC = B230400;\n        break;\n    case 460800:\n        baudC = B460800;\n        break;\n    case 500000:\n        baudC = B500000;\n        break;\n    case 576000:\n        baudC = B576000;\n        break;\n    case 921600:\n        baudC = B921600;\n        break;\n    case 1000000:\n        baudC = B1000000;\n        break;\n    case 1152000:\n        baudC = B1152000;\n        break;\n    case 1500000:\n        baudC = B1500000;\n        break;\n    case 2000000:\n        baudC = B2000000;\n        break;\n    case 2500000:\n        baudC = B2500000;\n        break;\n    case 3000000:\n        baudC = B3000000;\n        break;\n    default: {\n        printf(\"ERROR: Invalid baud rate supplied (%d)\\n\", baud);\n        return RTIOSTREAM_ERROR;\n    }\n    }\n\n    if (cfsetispeed(&sTermios, baudC) != 0) { /*Set incoming Baud Rate*/\n        printf(\"ERROR: Failed to set input baud rate to %d\\n\", baud);\n        return RTIOSTREAM_ERROR;\n    }\n\n    if (cfsetospeed(&sTermios, baudC) != 0) { /*Set outgoing Baud Rate*/\n        printf(\"ERROR: Failed to set output baud rate to %d\\n\", baud);\n        return RTIOSTREAM_ERROR;\n    }\n\n    /************Didn't Find Equivalent for following***************/\n    /* Write timeout not available for UNIX*/\n    /* No equivalent for XonLim and XoffLim or EvtChar*/\n    /***************************************************************/\n\n    /* -------- Serial Port Config END---- */\n\n    if (tcsetattr(fd, TCSANOW, &sTermios) != 0) {\n        printf(\"ERROR: Failed to configure serial port\\n\");\n        return RTIOSTREAM_ERROR;\n    }\n    return RTIOSTREAM_NO_ERROR;\n}\n\n/* Function: serialDataPending =====================================================================\n * Abstract:\n *  Returns true, via the 'pending' arg, if data is pending on the comm line.\n *  Returns false otherwise.\n *\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR on failure.\n */\nstatic int serialDataPending(SerialCommsData* sd, int* outPending) {\n    int retVal = RTIOSTREAM_NO_ERROR;\n\n    int temp = 0;\n\n    assert(sd->serialHandle >= 0);\n\n    /* Find out how much data is available. */\n    temp = ioctl(sd->serialHandle, FIONREAD, (unsigned long)outPending);\n    if (temp < 0) {\n        retVal = RTIOSTREAM_ERROR;\n        *outPending = 0;\n    }\n\n    return retVal;\n} /* end serialDataPending */\n\n\n/* Function: serialDataGet =========================================================================\n * Abstract:\n *  Attempts to gets the specified number of bytes from the specified serial.\n *  The number of bytes read is returned via the 'sizeRecvd' parameter.\n *  RTIOSTREAM_NO_ERROR is returned on success, RTIOSTREAM_ERROR is returned on\n *  failure.\n *\n * NOTES:\n *  o it is not an error for 'sizeRecvd' to be returned as 0\n *  o this function waits for at most READ_FILE_TIMEOUT\n */\nstatic int serialDataGet(SerialCommsData* sd, char* dst, const size_t size, size_t* sizeRecvd) {\n    static const char* fnName = \"serialDataGet:\";\n    int retVal = RTIOSTREAM_NO_ERROR;\n    int avail = 0;\n\n    ssize_t sizeRecvdTemp = 0;\n    assert(sd->serialHandle >= 0);\n\n    *sizeRecvd = 0;\n    if (size == 0) {\n        /* return immediately if caller requested to read 0 bytes */\n        return retVal;\n    }\n    int retPoll = 1;\n#if defined(PX4_CONNECTEDIO) || defined(PIL)\n    struct pollfd fds[1] = {};\n    fds[0].fd = sd->serialHandle;\n    fds[0].events = POLLIN;\n    const int timeout = 100;// in ms\n    retPoll = poll(&fds[0], 1, timeout);\n#endif\n    if (retPoll>0) {\n        retVal = serialDataPending(sd, &avail);\n        if (retVal == RTIOSTREAM_ERROR || avail == 0) {\n            if (retVal == RTIOSTREAM_ERROR) {\n                printf(\"%s Pending returned RTIOSTREAM_ERROR\\n\", fnName);\n            }\n            return retVal;\n        }\n\n        sizeRecvdTemp = read(sd->serialHandle, dst, size);\n        if (sizeRecvdTemp < 0) /*Error Condition check*/\n    \n        {\n            printf(\"%s ReadFile returned ERROR\\n\", fnName);\n            retVal = RTIOSTREAM_ERROR;\n            return retVal;\n        }\n        \n        *sizeRecvd = (size_t)sizeRecvdTemp;\n    } else {\n        retVal = RTIOSTREAM_ERROR;\n    }\n\n    return retVal;\n} /* end serialDataGet */\n\n\n/* Function: serialDataSet =========================================================================\n * Abstract:\n *  Utility function to send data via the specified serial\n */\nstatic int serialDataSet(SerialCommsData* sd,\n                         const void* src,\n                         const size_t size,\n                         size_t* sizeSent) {\n    static const char* fnName = \"serialDataSet:\";\n    int retVal = RTIOSTREAM_NO_ERROR;\n\n    /* G861098: workaround an issue for some serial drivers (i.e.\n     * Arduino and C2000 USB based serial drivers). When the send operation\n     * times out for these drivers, they return that 0 bytes were sent.\n     * However, we know this is not true (i.e. we know they have actually\n     * sent non-zero bytes). The workaround is to limit the max size that\n     * one can send so it can be successfully sent with the\n     * WRITE_FILE_TIMEOUT of 2 seconds. The client code (PIL/ExtMode)\n     * is responsible to loop to send the whole amount of data.\n     */\n    const size_t maxAllowedTransferSize = 512; /* in bytes */\n    const size_t transferAmount = MIN(maxAllowedTransferSize, size);\n\n    ssize_t sizeSentTemp = 0;\n    *sizeSent = 0;\n\n    if (size == 0) {\n        /* return immediately if caller requested to write 0 bytes */\n        return retVal;\n    }\n\n    sizeSentTemp = write(sd->serialHandle, src, transferAmount);\n\n    /*G807280 Check the error number. If resource is \"Temporarily Unavailable\"\n     * don't error, but let caller application deal with zero data*/\n    if ((sizeSentTemp < 0) && ((errno == EAGAIN) || (errno == EWOULDBLOCK))) {\n        sizeSentTemp = 0;\n    }\n\n    if (sizeSentTemp < 0) {\n        printf(\"%s WriteFile returned ERROR\\n\", fnName);\n        retVal = RTIOSTREAM_ERROR;\n    }\n\n    *sizeSent = (size_t)sizeSentTemp;\n\n    return retVal;\n}\n\n/* Function: serialDataFlush =======================================================================\n * Abstract:\n *  Utility function to flush a port\n */\nstatic int serialDataFlush(SerialCommsData* sd) {\n    char tmpBuf[TMP_BUF_SIZ];\n    size_t numRecvd = 0;\n    int pending = 0;\n    int error;\n    static const char* fnName = \"serialDataFlush:\";\n\n    do {\n        error = serialDataPending(sd, &pending);\n        if ((pending > 0) && (error == RTIOSTREAM_NO_ERROR)) {\n            if (sd->verbosity) {\n                printf(\"serialDataFlush: pending = %d\\n\", pending);\n            }\n            error = serialDataGet(sd, tmpBuf, sizeof(tmpBuf), &numRecvd);\n            if (sd->verbosity) {\n                size_t currElement;\n                printf(\"serialDataFlush: sizeRecvd = %lu: \", (unsigned long)numRecvd);\n                for (currElement = 0; currElement < numRecvd; currElement++) {\n                    printf(\"%u \", (unsigned char)tmpBuf[currElement]);\n                }\n                putchar('\\n'); // printf(\"\\n\");\n            }\n        }\n    } while ((pending > 0) && (error == RTIOSTREAM_NO_ERROR) && numRecvd > 0);\n    if (error == RTIOSTREAM_ERROR) {\n        printf(\"%s Flushing returned RTIOSTREAM_ERROR\\n\", fnName);\n    }\n    return error;\n}\n\nstatic int serialPortOpenInitialize(SerialCommsData* sd,\n                                    const int streamID,\n                                    int argc,\n                                    void* argv[]) {\n    int errorCode = RTIOSTREAM_NO_ERROR;\n    int serialHandle = -1;\n    int closeFile = false;\n#ifndef PIL    \n    int result;\n#endif    \n    char fullPortName[MAX_COM_LEN] = \"\";\n\n    /* Setting PX4 baud rate and port */\n    sd->baud = (uint32_T)MW_PX4_EXTMODE_BAUD_RATE;\n    strcat(fullPortName, MW_PX4_EXTMODE_HWPORT);\n    strcpy(sd->port, fullPortName);\n    sd->verbosity = DEFAULT_VERBOSITY;\n    sd->rtsDtrEnable = RTS_DTR_ENABLE_DEFAULT_VAL;\n    printf(\"External mode : Serial port baud rate: %d\\n\", sd->baud);\n    printf(\"External mode : Serial port Number: %s\\n\", sd->port);\n    fflush(stdout);\n\n    if (sd->verbosity) {\n        printf(\"rtIOStreamOpen (connection id %d): port %s, baud %lu\\n\", streamID, sd->port,\n               (unsigned long)sd->baud);\n    }\n\n    PX4_INFO(\"Opening serial port '%s' at baud %lu \\n\", sd->port, (unsigned long)sd->baud);\n    int retries = 0;\n    while (retries < 15) {\n\n        serialHandle = open(sd->port, O_RDWR             /*Enable Read and Write Operations*/\n                                          | O_NOCTTY     /*Not controlling flag specified*/\n                                          | O_NONBLOCK); /*Make the port non -blocking*/\n\n        if (serialHandle != -1) {\n            break;\n        }\n        // sleep a bit and retry. There seems to be a NuttX bug\n        // that can cause ttyACM0 to not be available immediately,\n        // but a small delay can fix it\n        usleep(50000);\n        retries++;\n    }\n    PX4_INFO(\"Opened serial port '%s' RETURN:  %d \\n\", sd->port, serialHandle);\n    if (serialHandle == -1) { /*-1 returned on error by OPEN*/\n        printf(\"Failed to open serial port '%s'. The reported error is %d: %s. \", sd->port, errno,\n               strerror(errno));\n\n        printf(\n            \"Possible causes \"\n            \"are:\\n    a) The target is not powered on. \\n    \"\n            \"b) The specified port number is not correct. \\n    \"\n            \"c) The specified bit rate is not \"\n            \"supported by the host machine.\\n    d) The previous \"\n            \"connection was not closed correctly. \"\n            \"If this is the case, you may need to re-start MATLAB.\\n\");\n        fflush(stdout);\n\n        errorCode = RTIOSTREAM_ERROR;\n        goto EXIT_POINT;\n    }\n\n    sd->serialHandle = serialHandle;\n\n    errorCode = initTermios(sd->serialHandle, sd->baud);\n    if (errorCode == RTIOSTREAM_ERROR) {\n        closeFile = true;\n        goto EXIT_POINT;\n    }\n    /*UNIX has this done with setting of termios data\n     * structure in initTermios*/\n\n    /* g2099552 - to avoid PIL start packet getting flushed\n     * when MAVLink is enabled in start up and disabled in px4_simulink_app\n     * the serial open is blocked till a response from host (this need to be investigated) and hence\n     * the PIL start packet([ 1 5 0 0 0 0 0]) is getting flushed with the following code. The\n     * external mode takes more time to send the connect packet, hence not impacted */\n#ifndef PIL\n    result = serialDataFlush(sd); /* clear out old data on the port */\n\n    if (result == RTIOSTREAM_ERROR) {\n        printf(\"serialDataFlush failed\\n\");\n        errorCode = RTIOSTREAM_ERROR;\n        closeFile = true;\n        goto EXIT_POINT;\n    }\n#endif\n\n\n\nEXIT_POINT:\n    if (closeFile) {\n        close(serialHandle);\n    }\n    return errorCode;\n}\n\n/* Function: getSerialData =========================================================================\n * Abstract:\n *  Retrieves a SerialCommsData instance given its streamID.\n *\n * NOTE: An invalid streamID will lead to a NULL pointer being returned\n */\nstatic SerialCommsData* getSerialData(int streamID) {\n    /* return NULL for invalid or uninitialized streamIDs */\n    SerialCommsData* sd = NULL;\n    if ((streamID >= 0) && (streamID < N_SERIAL_PORTS)) {\n        if (SerialData[streamID].isInUse) {\n            sd = &SerialData[streamID];\n        }\n    }\n    return sd;\n}\n\n/***************** VISIBLE FUNCTIONS ******************************************/\n\n/* Function: rtIOStreamOpen ========================================================================\n * Abstract:\n *  Open the connection with the target.\n */\nint rtIOStreamOpen(int argc, void* argv[]) {\n    int streamID;\n    int errorCode;\n    SerialCommsData* sd;\n\n    initSerialCommsDataStructure();\n\n    /* Find any free ports */\n    for (streamID = 0; streamID < N_SERIAL_PORTS; streamID++) {\n        if (!SerialData[streamID].isInUse) {\n            break;\n        }\n    }\n    if (streamID == N_SERIAL_PORTS) {\n        printf(\"All %d elements of the SerialCommsData structure are already in use.\",\n               N_SERIAL_PORTS);\n        return RTIOSTREAM_ERROR;\n    }\n\n    sd = &SerialData[streamID];\n\n    errorCode = serialPortOpenInitialize(sd, streamID, argc, argv);\n\n    if (errorCode == RTIOSTREAM_NO_ERROR) {\n        /* flag instance as in use */\n        SerialData[streamID].isInUse = 1;\n        return streamID;\n    } else {\n        /* flag error */\n        return RTIOSTREAM_ERROR;\n    }\n}\n\n\n\n/* Function: rtIOStreamSend ========================================================================\n * Abstract:\n *  Sends the specified number of bytes on the comm line. Returns the number of\n *  bytes sent (if successful) or a negative value if an error occurred. As long\n *  as an error does not occur, this function is guaranteed to set the requested\n *  number of bytes; the function blocks if the TCP/IP send buffer doesn't have\n *  room for all of the data to be sent\n */\nint rtIOStreamSend(int streamID, const void* const src, size_t size, size_t* sizeSent) {\n    int retVal;\n    SerialCommsData* sd = getSerialData(streamID);\n    if (sd == NULL) {\n        retVal = RTIOSTREAM_ERROR;\n        return retVal;\n    }\n    retVal = serialDataSet(sd, src, size, sizeSent);\n    if (sd->verbosity) {\n        printf(\"rtIOStreamSend (connection id %d): size = %lu, sizeSent = %lu\", streamID,\n               (unsigned long)size, (unsigned long)*sizeSent);\n        if (sd->verbosity >= VERBOSITY_LEVEL_2) {\n            size_t currElement;\n            printf(\": \");\n            for (currElement = 0; currElement < *sizeSent; currElement++) {\n                printf(\"%u \", ((const unsigned char*)src)[currElement]);\n            }\n        }\n        putchar('\\n'); // printf(\"\\n\");\n    }\n    return retVal;\n}\n\n\n/* Function: rtIOStreamRecv ========================================================================\n * Abstract: receive data\n *\n */\nint rtIOStreamRecv(int streamID, void* const dst, size_t size, size_t* sizeRecvd) {\n    int retVal = RTIOSTREAM_NO_ERROR;\n    SerialCommsData* sd = getSerialData(streamID);\n    if (sd == NULL) {\n        retVal = RTIOSTREAM_ERROR;\n        return retVal;\n    }\n    retVal = serialDataGet(sd, (char*)dst, size, sizeRecvd);\n    if (sd->verbosity) {\n        printf(\"rtIOStreamRecv (connection id %d): size = %lu, sizeRecvd = %lu\", streamID,\n               (unsigned long)size, (unsigned long)*sizeRecvd);\n        if (sd->verbosity >= VERBOSITY_LEVEL_2) {\n            size_t currElement;\n            printf(\": \");\n            for (currElement = 0; currElement < *sizeRecvd; currElement++) {\n                printf(\"%u \", ((unsigned char*)dst)[currElement]);\n            }\n        }\n        putchar('\\n'); // printf(\"\\n\");\n    }\n    return retVal;\n}\n\n\n/* Function: rtIOStreamClose =======================================================================\n * Abstract: close the connection.\n *\n */\nint rtIOStreamClose(int streamID) {\n    int retVal = RTIOSTREAM_NO_ERROR;\n    SerialCommsData* sd = getSerialData(streamID);\n    if (sd == NULL) {\n        retVal = RTIOSTREAM_ERROR;\n        return retVal;\n    }\n    retVal = serialDataFlush(sd);\n    close(sd->serialHandle);\n    sd->serialHandle = -1;\n    /*because unlike Windows which uses a pointer it uses an\n     * int File descriptor which can be 0*/\n    /* clear in use flag */\n    sd->isInUse = 0;\n\n    if (sd->verbosity) {\n        printf(\"rtIOStreamClose (connection id %d)\\n\", streamID);\n    }\n\n    PX4_INFO(\"rtIOStreamClose (connection id %d)\\n\", streamID);\n\n\n    return retVal;\n}\n"},{"name":"MW_ParameterRead.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2020 The MathWorks, Inc. */\n/* Reads the Parameter value and outputs the same.\n\n **/\n#include \"MW_ParameterRead.h\"\n\n//Below Macro can be enabled for debugging purposes\n#define DEBUG 0\n\n/*\n ****************************************************************************************************************************************************\n * Wrapper function For Initializing and getting the parameter handle\n * Input Params\n * isString  - Denotes if the Parameter is string or numeric\n * sampleTime - Sample time of the block\n \n * Output Params\n * param_handle  - Handle to the requested parameter.\n ****************************************************************************************************************************************************\n */\nMW_Param_Handle MW_Init_Param(void * ParameterName, uint8_T isString , double sampleTime)\n{\n\n    MW_Param_Handle param_handle = PARAM_INVALID;\n    char * parameterStr;\n    /* Check parameters */\n    if (0 == isString)\n    {\n        fprintf(stderr,\"Only string as ParameterName name is supported.\\n\");\n#if defined(MW_PX4_NUTTX_BUILD)\t\n\texit(1);\n#else\n\treturn 1;\n#endif\n    }\n    else\n    {\n        parameterStr = (char*)ParameterName;\n    }\n    param_handle = param_find(parameterStr);\n#if DEBUG\n    printf(\"In MW_Init_Param. Parameter name = %s.\\n\", parameterStr);\n#endif\n    if (param_handle != PARAM_INVALID)\n    {\n#if DEBUG\n        printf(\"In MW_Init_Param. Valid Parameter Handle = %u.\\n\", param_handle);\n#endif    \n    }\n    else\n    {\n#if DEBUG\n        printf(\"In MW_Init_Param. Invalid Parameter Handle. \\n\");\n#endif\n    }\n    return param_handle;\n}\n\n/*\n ****************************************************************************************************************************************************\n * Wrapper function For reading the parameter\n * Input Params\n * param_h  - Handle to the parameter requested\n * dataType - Data Type of the Parameter Requested\n * dataPtr - Pointer to the data, into which param_get is written to\n *\n * Output Params\n * status  - 0 for a valid Parameter Handle ; 1 for a valid Parameter Handle\n ****************************************************************************************************************************************************\n */\nbool MW_Param_Step(MW_Param_Handle param_h, MW_PARAM_DATA_TYPE dataType, void * dataPtr)\n{\n    //status - 0 for a valid Parameter Handle\n    //status - 1 for an invalid Parameter Handle\n    bool status = 1;\n    if (param_h != PARAM_INVALID)\n    {\n#if DEBUG\n        printf(\"In MW_Param_Step.Parameter Handle = %u.\\n\", param_h);\n#endif\n        int32_t  ReturnTmpInt;\n        float ReturnTmpFlt;\n        switch (dataType)\n        {\n            case MW_INT32:\n                if (!param_get(param_h, &ReturnTmpInt))\n                {\n                    *(int*)dataPtr  = ReturnTmpInt;\n#if DEBUG\n                    printf(\"In MW_Param_Step MW_INT32. Value = %ld\\n\", *(int*)dataPtr);\n#endif\n                }\n                break;\n            case MW_SINGLE:\n                if (!param_get(param_h, &ReturnTmpFlt))\n                {\n                    *(float*)dataPtr  = ReturnTmpFlt;\n#if DEBUG\n                    printf(\"In MW_Param_Step MW_SINGLE. Value = %4.4f\\n\", *(float*)dataPtr);\n#endif\n                }\n                break;\n            default:\n                break;\n        }\n         status = 0;\n    }\n    return status;\n}\n\nvoid MW_Param_terminate(void) \n{\n}\n"},{"name":"MW_custom_RTOS_header.h","type":"header","group":"other","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _MW_CUSTOM_RTOS_HEADER_H_\n#define _MW_CUSTOM_RTOS_HEADER_H_\n#define MW_BASERATE_PRIORITY           250\n#define MW_BASERATE_PERIOD             0.001\n#define MW_NUMBER_SUBRATES             1\n#define MW_NUMBER_APERIODIC_TASKS      0\n#define MW_IS_CONCURRENT               0\n#define MW_NUMBER_TIMER_DRIVEN_TASKS   0\n#define MW_HAS_MULTIPLE_RATES\n\nextern void exitFcn(int sig);\nextern void *terminateTask(void *arg);\nextern void *baseRateTask(void *arg);\nextern void *subrateTask(void *arg);\n\n#define MW_NEEDS_BACKGROUND_TASK\n#define MW_BACKGROUNDTASK_PRIORITY     248\n\nextern void *backgroundTask(void *arg);\nextern pthread_t backgroundThread;\nextern pthread_t schedulerThread;\nextern pthread_t baseRateThread;\nextern pthread_t subRateThread[];\nextern px4_sem_t stopSem;\nextern px4_sem_t baserateTaskSem;\nextern px4_sem_t subrateTaskSem[];\nextern int taskId[];\nextern int subratePriority[];\n\n#endif\n\n#define MW_MAX_TASKNAME                16\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"MW_PX4_TaskControl.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE PX4 Cube Orange\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERSIZE 1024\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_MAXCONTIGSAMPLES 10\n#define MW_CONNECTIONINFO_XCPONSERIAL_BAUDRATE codertarget.pixhawk.internal.getExternalModeBaudrate(hCS);\n#define MW_CONNECTIONINFO_XCPONSERIAL_COMPORT codertarget.pixhawk.internal.getExternalSerialPortName(hCS);\n#define MW_CONNECTIONINFO_XCPONSERIAL_VERBOSE 1\n#define MW_EXTMODE_CONFIGURATION XCP on Serial\n#define MW_EXTMODE_RUNNING on\n#define MW_RTOS NuttX\n#define MW_RTOSBASERATETASKPRIORITY 250\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_CMAKECONFIG cubepilot_cubeorange_multicopter\n#define MW_CHANGECMAKECONFIG 48\n#define MW_AUTOMATIC_SERIAL_SCAN 1\n#define MW_COM_UPLOAD_STORAGE \n#define MW_NUTTX_SERIAL_PORT \n#define MW_ENABLE_HITL 0\n#define MW_SIMULATOR 0\n#define MW_CONNECTEDIOSERIALPORT /dev/ttyACM0\n#define MW_CONNECTEDIOSERIALPORT_CHECKBOX 1\n#define MW_CONNECTEDIOHOSTCOMPORT \n#define MW_SIMULINKIO_MODELTRANSPORTDATAFCN px4.internal.ConnectedIO.getConfigsetInfo\n#define MW_SIMULINKIO_SERVERDEPLOYFCN px4.internal.ConnectedIO.buildAndDeployPX4IOServer\n#define MW_CLOCKING_CPUCLOCKRATEMHZ 400\n#define MW_EXTSERIALPORT 3\n#define MW_EXTMODESERIALPORT_CHECKBOX 1\n#define MW_EXTMODEHOSTCOMPORT \n#define MW_PILSERIALPORT /dev/ttyACM0\n#define MW_PILSERIALPORT_CHECKBOX 1\n#define MW_PILHOSTCOMPORT \n#define MW_I2C_BUS1SPEEDKHZ_INDEX 0\n#define MW_I2C_BUS2SPEEDKHZ_INDEX 0\n#define MW_I2C_BUS1SPEEDKHZ 100\n#define MW_I2C_BUS2SPEEDKHZ 100\n#define MW_CAN_PORTINDEX 0\n#define MW_CAN_BAUDRATE_INDEX 2\n#define MW_CAN_BAUDRATE 500000\n#define MW_CAN_TESTMODE 0\n#define MW_ENABLEMAVLINKCHECKBOX 1\n#define MW_TTYACM0_BAUDRATE 27\n#define MW_TTYACM0_PARITY 0\n#define MW_TTYACM0_STOPBIT 0\n#define MW_TTYACM0_PORTMAP 48\n#define MW_TTYS0_BAUDRATE 27\n#define MW_TTYS0_PARITY 0\n#define MW_TTYS0_STOPBIT 0\n#define MW_TTYS0_PORTMAP 48\n#define MW_TTYS0HWFLOWCONTROL_CHECKBOX 0\n#define MW_TTYS1_BAUDRATE 27\n#define MW_TTYS1_PARITY 0\n#define MW_TTYS1_STOPBIT 0\n#define MW_TTYS1_PORTMAP 48\n#define MW_TTYS1HWFLOWCONTROL_CHECKBOX 0\n#define MW_TTYS2_BAUDRATE 27\n#define MW_TTYS2_PARITY 0\n#define MW_TTYS2_STOPBIT 0\n#define MW_TTYS2_PORTMAP 48\n#define MW_TTYS2HWFLOWCONTROL_CHECKBOX 0\n#define MW_TTYS5_BAUDRATE 27\n#define MW_TTYS5_PARITY 0\n#define MW_TTYS5_STOPBIT 0\n#define MW_TTYS5_PORTMAP 48\n#define MW_HRT_CONSTRAINT 0\n#define MW_SEM_WATERMARK 20\n#define MW_IOBLOCKSMODE deployed\n#define MW_DATAVERSION 2016.02\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"MW_uORB_Read.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2020 The MathWorks, Inc. */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"MW_uORB_Read.h\"\n\n#define DEBUG 0\n\nvoid uORB_read_initialize(orb_metadata_t* orbData, pollfd_t* eventStructObj) {\n    int fd = orb_subscribe(orbData);\n    eventStructObj->fd = fd;\n    eventStructObj->events = POLLIN;\n#if DEBUG\n    PX4_INFO(\"* Subscribed to topic: %s (fd = %d)*\\n\", orbData->o_name, fd);\n#endif\n}\n\nboolean_T uORB_read_step(orb_metadata_t* orbData,\n                         pollfd_t* eventStructObj,\n                         void* busData,\n                         boolean_T blockingMode,\n                         double blockingTimeout) {\n    boolean_T updated = 0;\n    bool isUpdated = false;\n    if (blockingMode) {\n#if defined(MW_PX4_NUTTX_BUILD)\n        int poll_ret = px4_poll(eventStructObj, 1, blockingTimeout);\n        static int error_counter = 0;\n        if (poll_ret == 0) {\n#if DEBUG\n            PX4_ERR(\"Got no data within %.9lf second\", blockingTimeout / 1000.0);\n#endif\n        } else if (poll_ret < 0) {\n            if (error_counter < 10 || error_counter % 500 == 0) {\n                /* use a counter to prevent flooding and slowing the system down */\n#if DEBUG\n                PX4_ERR(\"ERROR return value from poll(): %d\", poll_ret);\n#endif\n            }\n            error_counter++;\n\n        } else {\n            if (eventStructObj->revents & POLLIN) {\n                orb_copy(orbData, eventStructObj->fd, busData);\n                updated = 1;\n            }\n        }\n#elif defined(MW_PX4_POSIX_BUILD)\n        double count = 0;\n        /* The blocking timeout mentioned in the block mask is seconds but\n         * system object converts it to milliseconds*/\n        while (count < blockingTimeout) {\n            // Sleep for 1 ms and then again check if\n            // uORB topic is updated\n            usleep(1000);\n            orb_check(eventStructObj->fd, &isUpdated);\n            if (isUpdated) {\n                orb_copy(orbData, eventStructObj->fd, busData);\n                break;\n            }\n            count++;\n        }\n\n        updated = isUpdated ? 1 : 0;\n#endif\n    } else {\n        orb_check(eventStructObj->fd, &isUpdated);\n        if (isUpdated) {\n            orb_copy(orbData, eventStructObj->fd, busData);\n        }\n        updated = isUpdated ? 1 : 0;\n    }\n\n    return updated;\n}\n\nvoid uORB_read_terminate(const pollfd_t* eventStructObj) {\n    orb_unsubscribe(eventStructObj->fd);\n}\n"},{"name":"MW_uORB_Write.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018 The MathWorks, Inc. */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"MW_uORB_Write.h\"\n\n#define DEBUG 0\n\nvoid uORB_write_initialize(orb_metadata_t* orbData,\n                          orb_advert_t* orbAdvertObj,\n                          void* busData,\n                          int queueLen) {\n    *orbAdvertObj = orb_advertise_queue(orbData, busData, queueLen);    \n#if DEBUG\n    PX4_INFO(\"Started advertising topic: %s \\n\",  orbData->o_name);\n#endif    \n}\n\nvoid uORB_write_step(orb_metadata_t* orbData,\n                    orb_advert_t* orbAdvertObj,\n                    void* busData) {\n    orb_publish(orbData, *orbAdvertObj, busData);\n}\n\nvoid uORB_write_terminate(const orb_advert_t* orbAdvertObj) {\n    orb_unadvertise(*orbAdvertObj);\n}\n"},{"name":"MW_uORB_busstruct_conversion.h","type":"header","group":"other","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _MW_UORB_BUSSTRUCT_CONVERSION_H_\n#define _MW_UORB_BUSSTRUCT_CONVERSION_H_\n\n#include <uORB/topics/actuator_armed.h>\n#include <uORB/topics/actuator_controls_status.h>\n#include <uORB/topics/actuator_motors.h>\n#include <uORB/topics/input_rc.h>\n#include <uORB/topics/vehicle_angular_velocity.h>\n#include <uORB/topics/vehicle_attitude_setpoint.h>\n#include <uORB/topics/vehicle_local_position.h>\n#include <uORB/topics/vehicle_local_position_setpoint.h>\n#include <uORB/topics/vehicle_odometry.h>\n#include <uORB/topics/vehicle_rates_setpoint.h>\n#include <uORB/topics/vehicle_status.h>\n\ntypedef struct actuator_armed_s  px4_Bus_actuator_armed ;\ntypedef struct actuator_controls_status_s  px4_Bus_actuator_controls_status ;\ntypedef struct actuator_motors_s  px4_Bus_actuator_motors ;\ntypedef struct input_rc_s  px4_Bus_input_rc ;\ntypedef struct vehicle_angular_velocity_s  px4_Bus_vehicle_angular_velocity ;\ntypedef struct vehicle_attitude_setpoint_s  px4_Bus_vehicle_attitude_setpoint ;\ntypedef struct vehicle_local_position_s  px4_Bus_vehicle_local_position ;\ntypedef struct vehicle_local_position_setpoint_s  px4_Bus_vehicle_local_position_setpoint ;\ntypedef struct vehicle_odometry_s  px4_Bus_vehicle_odometry ;\ntypedef struct vehicle_rates_setpoint_s  px4_Bus_vehicle_rates_setpoint ;\ntypedef struct vehicle_status_s  px4_Bus_vehicle_status ;\n\n#endif\n"},{"name":"nuttxinitialize.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/PX4Controller/FLIGHT_hexacopter_ert_rtw/../../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2018-2022 The MathWorks, Inc.\n *\n * File: nuttxinitialize.c\n *\n * Abstract:\n *  This file contains RTOS thread creation functions\n *\n */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n\n/***********************************************\n * Added for Simulink Threads\n ************************************************/\npthread_attr_t attr;\nstatic baseRateInfo_t g_info;\nstruct sched_param g_sp;\n// extern volatile boolean_T runModel ;\n\n/***********************************************\n * Added for HRT\n ************************************************/\nstruct hrt_call BaseRate_HRT;\nint baserate_sem_copy;\n\n\n#define MW_RTOS_DEBUG 0\n\nbaseRateInfo_t EXT_sig_info;\nbaseRateInfo_t SDCard_sig_info;\nextern pthread_t backgroundThread;\nextern pthread_t loggingThread;\nextern void exitFcn(int sig);\n\nvoid setTaskPeriod(double periodInSeconds, int sigNo) {\n    timer_t timerId;\n    struct sigevent sev;\n    struct itimerspec its;\n    long stNanoSec;\n    int status;\n\n    /* Create a timer */\n    sev.sigev_notify = SIGEV_SIGNAL;\n    sev.sigev_signo = sigNo;\n    sev.sigev_value.sival_ptr = &timerId;\n    status = timer_create(CLOCK_REALTIME, &sev, &timerId);\n    CHECK_STATUS(status, 0, \"timer_create\");\n\n    /* Arm real-time scheduling timer */\n    stNanoSec = (long)(periodInSeconds * 1e9);\n    its.it_value.tv_sec = stNanoSec / 1000000000;\n    its.it_value.tv_nsec = stNanoSec % 1000000000;\n    its.it_interval.tv_sec = its.it_value.tv_sec;\n    its.it_interval.tv_nsec = its.it_value.tv_nsec;\n    status = timer_settime(timerId, 0, &its, NULL);\n    CHECK_STATUS(status, 0, \"timer_settime\");\n}\n\nvoid print_sem_value() {\n    PX4_WARN(\"Sem value = %d\", baserate_sem_copy);\n}\n\nstatic void Base_HRT_Callback(void* arg) {\n#ifndef PX4_CONNECTEDIO\n    int sem_value_check;\n\n    px4_sem_getvalue(&baserateTaskSem, &sem_value_check);\n    px4_sem_post(&baserateTaskSem);\n    baserate_sem_copy = sem_value_check;\n\n#endif\n}\n\n/* ---------------------------- */\n/* Externally visible functions */\n/* ---------------------------- */\nvoid myWaitForThisEvent(int sigNo) {\n    sigset_t sigMask;\n\n    sigemptyset(&sigMask);\n    sigaddset(&sigMask, sigNo);\n    sigwaitinfo(&sigMask, NULL);\n    //\tCHECK_STATUS_NOT(status, -1, \"sigwaitinfo\");\n}\n\nvoid MW_PX4_WaitForThisEvent(void* arg) {\n#ifdef EXT_MODE\n    /*pace External mode thread at 10 Hz*/\n    usleep(100000);\n\n    /*Signaling is causing issue when sample time is greater than 0.1\n     and model runs for more than 60 seconds. In this case model stop is not\n     stopping External mode. Using usleep for now to sleep the External Mode thread.*/\n\n    // baseRateInfo_t ext_info = *((baseRateInfo_t *)arg);\n    // static boolean_T isTaskPeriodSet = false;\n    // boolean_T rtmStopReq = rtmGetStopRequested(MW_StringifyDefineFunction(MODEL, _M));\n\n    // if (!isTaskPeriodSet) {\n    //     setTaskPeriod(ext_info.period, ext_info.sigNo);\n    //     isTaskPeriodSet = true;\n    // }\n\n    // if (!rtmStopReq) {\n    //     myWaitForThisEvent(ext_info.sigNo);\n    // }\n\n#endif\n}\n\nvoid myAddBlockForThisEvent(int sigNo) {\n    int status;\n    sigset_t sigMask;\n\n    sigemptyset(&sigMask);\n    sigaddset(&sigMask, sigNo);\n    status = pthread_sigmask(SIG_BLOCK, &sigMask, NULL);\n    CHECK_STATUS(status, 0, \"pthread_sigmask\");\n}\n\nvoid nuttxRTOSInit(double baseRatePeriod, int numSubrates) {\n    /* This is because in Daren's original Task callback ,a sleep was added before creating the\n     * threads*/\n    sleep(1);\n\n    int status;\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    size_t stackSize;\n    int baseRatePriority = MW_BASERATE_PRIORITY;\n#endif\n\n#ifdef MW_HAS_MULTIPLE_RATES\n    int i;\n    // char taskName[20];\n#endif\n#if defined(MW_PX4_NUTTX_BUILD)\n    sched_lock();\n#endif\n    // status = px4_sem_init(&termSem, 0, 0); PX4 PSP Dev: termSem no longer needed\n    // CHECK_STATUS(status, 0,\"px4_sem_init:termSem\");\n    status = px4_sem_init(&stopSem, 0, 0);\n    CHECK_STATUS(status, 0, \"px4_sem_init:stopSem\");\n    status = px4_sem_init(&baserateTaskSem, 0, 0);\n    CHECK_STATUS(status, 0, \"px4_sem_init:baserateTaskSem\");\n\n    // or you can use/check: _POSIX_PRIORITY_SCHEDULING\n    // _POSIX_THREAD_PRIORITY_SCHEDULING\n#if !defined(_POSIX_PRIORITY_SCHEDULING)\n    PX4_INFO(\"Priority scheduling is NOT supported by your system.\");\n    PX4_INFO(\"The generated code will not run correctly because your\");\n    PX4_INFO(\"model contains multiple rates and uses multi-tasking\");\n    PX4_INFO(\"code generation mode. You can only run the generated code\");\n    PX4_INFO(\"in single-tasking mode in your system. Open\");\n    PX4_INFO(\"Simulation -> Configuration Parameters -> Solver dialog\");\n    PX4_INFO(\"and set \\\"Tasking mode for periodic sample times\\\" parameter to SingleTasking.\");\n    PX4_INFO(\n        \"Re-build the Simulink model with the new settings and try executing the generated code \"\n        \"again.\");\n    fflush(stdout);\n    exit(-1);\n#endif\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    /* Set scheduling policy of the main thread to SCHED_FIFO */\n    g_sp.sched_priority = sched_get_priority_max(SCHED_FIFO) - 50;\n    status = sched_setscheduler(0, SCHED_FIFO, &g_sp);\n    CHECK_STATUS(status, 0, \"sched_setscheduler\");\n\n    /*Added init attribute and scheduler policy */\n    pthread_attr_init(&attr);\n    status = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n    CHECK_STATUS(status, 0, \"pthread_attr_setinheritsched\");\n    status = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedpolicy\");\n    // status = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n    // CHECK_STATUS(status, 0, \"pthread_attr_setdetachstate\");\n\n    /* PTHREAD_STACK_MIN is the minimum stack size required to start a thread */\n    stackSize = 8192 + PTHREAD_STACK_MIN;\n\n    /*added stack attribute back in */\n    status = pthread_attr_setstacksize(&attr, stackSize);\n    CHECK_STATUS(status, 0, \"pthread_attr_setstacksize\");\n#endif\n    /* set up info structure */\n    g_info.period = baseRatePeriod;\n    g_info.sigNo = BASERATE_TIMER_SIGNAL; // SIGRTMIN;\n\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"   stackSize = %d sched_priority = %d\", stackSize, g_sp.sched_priority);\n    PX4_INFO(\"   MW_BASERATE_PERIOD = %8.5f MW_BASERATE_PRIORITY = %d SIGRTMIN = 0x%08X\",\n             (double)baseRatePeriod, (int)baseRatePriority, SIGRTMIN);\n    PX4_INFO(\"   Init info.period = %8.5f sigNo = 0x%04X\", g_info.period, g_info.sigNo);\n    PX4_INFO(\"**creating the Base Rate thread before calling pthread_create**\");\n    fflush(stdout);\n#endif\n\n    /* Create the Base Rate Task here */\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = baseRatePriority;\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&baseRateThread, &attr, &baseRateTask, (void*)&g_info);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&baseRateThread, nullptr, &baseRateTask, (void*)&g_info);\n#endif\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"** Base Rate Task ID = %d with Priority = %d\\n\", baseRateThread, g_sp.sched_priority);\n    fflush(stdout);\n#endif\n\n/* Create sub-rate Tasks here */\n#ifdef MW_HAS_MULTIPLE_RATES\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"Creating sub-rate task threads\\n\");\n    PX4_INFO(\"Number of sub rate tasks: %d \\n\", MW_NUMBER_SUBRATES);\n    fflush(stdout);\n#endif\n\n    for (i = 0; i < MW_NUMBER_SUBRATES; i++) {\n        taskId[i] = i;\n        status = px4_sem_init(&subrateTaskSem[i], 0, 0);\n        CHECK_STATUS(status, 0, \"px4_sem_init: subrateTaskSem\");\n        // g_sp.sched_priority = MW_BASERATE_PRIORITY -40 + subratePriority[i] - 1;\n        g_sp.sched_priority = subratePriority[i];\n#if MW_RTOS_DEBUG\n        PX4_INFO(\"MW_SUBRATE_PRIORITY = %d \", (int)g_sp.sched_priority);\n#endif\n\n#if defined(MW_PX4_NUTTX_BUILD)\n        status = pthread_attr_setschedparam(&attr, &g_sp);\n        CHECK_STATUS(status, 0, \"pthread_attr_setschedparam\");\n        status = pthread_create(&subRateThread[i], &attr, &subrateTask, (void*)&taskId[i]);\n#elif defined(MW_PX4_POSIX_BUILD)\n        status = pthread_create(&subRateThread[i], nullptr, &subrateTask, (void*)&taskId[i]);\n#endif\n        CHECK_STATUS(status, 0, \"pthread_create\");\n\n#if MW_RTOS_DEBUG\n        PX4_INFO(\"** Sub Rate Task ID = %d \", subRateThread[i]);\n        fflush(stdout);\n#endif\n    }\n#endif // End of \"If Multiple Rates\" check\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = baseRatePriority;\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n#endif\n\n    /* Create the Scheduler Task here */\n    long stMicroSec;\n    stMicroSec = (long)(g_info.period * 1e6);\n    hrt_call_every(&BaseRate_HRT, stMicroSec, stMicroSec, Base_HRT_Callback,\n                   NULL); // timing callback to post base-rate semaphore\n\n/* Create the External Mode Task here */\n#ifdef EXT_MODE\n    /*---------- Creating EXT-mode Background Task ------------------*/\n    /* Setup signal info to block for EXT Mode */\n    EXT_sig_info.period = 0.1; // Sample rate at which we want Simulink to update w/ ext mode\n    EXT_sig_info.sigNo = SIGRTMIN;\n    /* Signaling the thread not working for low sample frequency*/\n    // sigemptyset(&EXT_sig_info.sigMask);\n    // sigaddset(&EXT_sig_info.sigMask, EXT_sig_info.sigNo);\n    // myAddBlockForThisEvent(EXT_sig_info.sigNo);\n\n    /* Setup thread for Custom Task */\n    fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = 40; // default is 100\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&backgroundThread, &attr, &backgroundTask, (void*)&EXT_sig_info);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&backgroundThread, nullptr, &backgroundTask, (void*)&EXT_sig_info);\n#endif\n    CHECK_STATUS(status, 0, \"EXT Mode Background pthread_create\");\n/*---------------------------------------------------------*/\n#endif\n\n/* Create the SD Card Task here */\n#if MAT_FILE\n    /*---------- Creating SD Card Background Task ------------------*/\n    fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = 40; // default is 100\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&loggingThread, &attr, &loggingThreadFcn, NULL);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&loggingThread, nullptr, &loggingThreadFcn, NULL);\n#endif\n    CHECK_STATUS(status, 0, \"SD Card Background pthread_create\");\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"** SD Card Background ID = %d \", loggingThread);\n    fflush(stdout);\n#endif\n\n/*---------------------------------------------------------*/\n#endif\n\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"px4_simulink_app : Created Simulink task threads successfully\\n\");\n    fflush(stdout);\n#endif\n#if defined(MW_PX4_NUTTX_BUILD)\n    sched_unlock();\n#endif\n}\n\n/*---------- Following function is added as a workaround for uavcan module build failure -------------\n  Original definition of the function is in the file <px4dir>\\Firmware\\Boards\\px4\\fmu-v5\\src\\can.c*/\n#if defined(MW_PX4_NUTTX_BUILD) && defined(CONFIG_CAN) && defined(UAVCAN_NUM_IFACES_RUNTIME)\n__EXPORT\nuint16_t board_get_can_interfaces(void)\n{\n\tuint16_t enabled_interfaces = 0x7;\n\n\tif (!PX4_MFT_HW_SUPPORTED(PX4_MFT_CAN2)) {\n\t\tenabled_interfaces &= ~(1 << 1);\n\t}\n\n\tif (!PX4_MFT_HW_SUPPORTED(PX4_MFT_CAN3)) {\n\t\tenabled_interfaces &= ~(1 << 2);\n\t}\n\n\treturn enabled_interfaces;\n }\n#endif\n/*---------------------------------------------------------*/\n"},{"name":"xcp.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2024a/toolbox/coder/xcp/src/target/server/protocol/src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2023 The MathWorks, Inc.\n*\n* File: xcp.c\n*\n* Abstract:\n*  Implementation of XCP Protocol Layer\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_internal.h\"\n#include \"xcp_transport_internal.h\"\n#include \"xcp_cfg.h\"\n#include \"xcp_types.h\"\n#include \"xcp_standard.h\"\n#include \"xcp_daq.h\"\n#include \"xcp_calibration.h\"\n#include \"xcp_mem.h\"\n\n\n/*****************************************************************************\n    Internal Global variables\n******************************************************************************/\n/* Initialization status */\nstatic boolean_T initialized = false;\n\n/** Current Status of the XCP Server according to the Protocol Layer */\nstatic XcpStatus xcpStatus = XCP_DISCONNECTED;\n\n/** Current Session Status of the XCP Server according to the Protocol Layer\n(see XCP Session Status bit masks) */\nstatic uint8_T xcpSessionStatus = 0;\n\n/** XCP Server Resource Protection Status (see XCP Resource bit masks) */\nstatic uint8_T xcpResourceProtectionStatus = 0;\n\n/** XCP Session configuration Id\n@note xcpSessionConfigurationId has to be set with an XCP SET_REQUEST\n      before a STORE_DAQ_REQ set. This allows the client device to verify that\n      automatically started DAQ lists contain the expected data transfer\n      configuration.\n      However the (optional) SET_REQUEST command is not supported at the\n      moment, so this value is hard-coded to 0 and never changed. */\nstatic uint16_T xcpSessionConfigurationId = 0;\n\n/** This table contains the list of XcpPacketLookupFunction to be used\n    (for each packets group) to get access to the corresponding\n    Packet Input and Output handlers */\nstatic XcpPacketLookupFunction groupPacketLookup[XCP_PACKETS_GROUP_NUMBER];\n\n/*****************************************************************************\n    Internal Functions\n******************************************************************************/\n/** Free the msgBuffer and allocate a new buffer to host a XCP packet of newPacketSize */\nstatic XcpErrorCode msgBufferRealloc(void **msgBuffer, size_t *msgBufferSize, size_t *packetOffset, size_t newPacketSize)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    xcpPoolId_T reservedPoolId = xcpTransportCtoReservedMemPoolId();\n\n    /* Free the original buffer */\n    xcpMemFree(*msgBuffer);\n\n    /* Allocate a new buffer with the proper size */\n    *msgBufferSize = xcpTransportMsgBufferSize(newPacketSize, XCP_CTO);\n    *packetOffset = xcpTransportPacketOffset();\n\n    if (*msgBufferSize > 0) {\n        /* Using a reserved memory pool, to guarantee that the reply\n           gets always delivered to the XCP Client */\n        *msgBuffer = xcpMemAllocFromPool(reservedPoolId, *msgBufferSize);\n        if (*msgBuffer == NULL) {\n            errorCode = XCP_NO_MEMORY;\n        }\n    }\n    else {\n        errorCode = XCP_INV_SIZE;\n    }\n\n    return errorCode;\n}\n\n/** Input Packet Handler to be used for packets that need to be discarded */\nstatic XcpProtoErrorCode discardInputPacketHandler(void   *msgBuffer,\n                                                   size_t  xcpPacketOffset,\n                                                   size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"Detected attempt to send packet ID %xH when the XCP connection has not been established\\n\", \n               *((uint8_T *) msgBuffer + xcpPacketOffset));\n\n    if (msgBuffer != NULL) {\n        xcpMemFree(msgBuffer);\n    }\n\n    *outputPacketSize = 0;\n\n    return XCP_PROTO_SUCCESS;\n}\n\n/** Input Packet Handler to be used for unknown commands */\nstatic XcpProtoErrorCode unknownInputPacketHandler(void   *msgBuffer,\n                                                   size_t  xcpPacketOffset,\n                                                   size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"Packet ID  %xH is not supported at the moment\\n\",\n    *((uint8_T *) msgBuffer + xcpPacketOffset));\n\n    *outputPacketSize = XCP_ERROR_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_CMD_UNKNOWN;\n}\n\n/** The function returns the Group Id corresponding to a given Packet ID */\nstatic XcpPacketsGroupIdType xcpGetPacketGroupID(uint8_T pid, uint8_T level1Code)\n{\n    XcpPacketsGroupIdType groupId = XCP_UNKNOWN_PACKET_GROUP_ID;\n\n    if ((pid >= XCP_STANDARD_PACKETS_ID_MIN) /* && (pid <= XCP_STANDARD_PACKETS_ID_MAX) */) {\n        groupId = XCP_STANDARD_PACKETS_ID;\n    }\n    else if ((pid >= XCP_CALIBRATION_PACKETS_ID_MIN) && (pid <= XCP_CALIBRATION_PACKETS_ID_MAX)) {\n        groupId = XCP_CALIBRATION_PACKETS_ID;\n    }\n    else if (((pid >= XCP_DAQ_PACKETS_ID_MIN) && (pid <= XCP_DAQ_PACKETS_ID_MAX)) ||\n             ((pid == XCP_PID_LEVEL1_COMMAND) && \n             (level1Code >= XCP_DAQ_LEVEL1_CODE_MIN) && (level1Code <= XCP_DAQ_LEVEL1_CODE_MAX))) {\n        groupId = XCP_DAQ_PACKETS_ID;\n    }\n    else if ((pid >= XCP_PROGRAM_PACKETS_ID_MIN) && (pid <= XCP_PROGRAM_PACKETS_ID_MAX)) {\n        groupId = XCP_PROGRAM_PACKETS_ID;\n    }\n\n    return groupId;\n}\n\n/** Identify the internal packet handler functions responsible for processing a specific XCP packet.\n    @note If the status is XCP_DISCONNECTED, no packets are accepted except XCP_PID_CONNECT\n          If the command is not supported, the XCP server has to reply with a ERR response packet\n          and ERR_CMD_UNKNOWN error code */\nstatic void xcpGetPacketHandlers(const uint8_T *packet,\n                                 size_t packetSize,\n                                 XcpInputPacketHandler  *inputHandler,\n                                 XcpOutputPacketHandler *outputHandler)\n{\n    /* uint8_T gets promoted to a higher data-type. On C2000, it is \n     * unsigned int. Since data is packed, a non-zero MSB in packet[0]\n     * can then make PID an invalid identifier. Explicitly mask to\n     * remove the upper byte if any.\n     */\n     const XcpLevel1CommandPacketFrame* command = (const XcpLevel1CommandPacketFrame*) packet;\n\n    uint8_T PID = command->PID; /* Retrieve Packet ID */\n    uint8_T level1CommandCode = 0;\n    if ((PID == XCP_PID_LEVEL1_COMMAND) && (packetSize > 1)) {\n        level1CommandCode = command->level1Code;\n    }\n\n    if (xcpStatus != XCP_DISCONNECTED) {\n        /* Check if the received XCP packet is supported and\n           retrieve the corresponding handler */\n        XcpPacketsGroupIdType groupId = xcpGetPacketGroupID(PID, level1CommandCode);\n        boolean_T found = false;\n\n        if (groupId != XCP_UNKNOWN_PACKET_GROUP_ID) {\n            XcpPacketLookupFunction getPacket = groupPacketLookup[groupId];\n            const XcpPacketHandlers *packetInfo = NULL;\n\n            if (getPacket != NULL) {\n                packetInfo = getPacket(PID);\n                found = (packetInfo != NULL);\n                if (found) {\n                    *inputHandler = packetInfo->inputHandler;\n                    *outputHandler = packetInfo->outputHandler;\n                }\n            }\n        }\n\n        if (!found) {\n            /* Packet is not supported*/\n            *inputHandler = unknownInputPacketHandler;\n            *outputHandler = genericOutputPacketHandler;\n        }\n    }\n    else {\n        /* If the XCP Server is in the XCP_DISCONNECTED status,\n        * no other XCP packets are accepted except XCP_PID_CONNECT */\n        if (PID == XCP_PID_CONNECT) {\n            XcpPacketLookupFunction getPacket = groupPacketLookup[XCP_STANDARD_PACKETS_ID];\n\n            *inputHandler = NULL;\n            *outputHandler = NULL;\n\n            if (getPacket != NULL) {\n                const XcpPacketHandlers *connect = getPacket(XCP_PID_CONNECT);\n                if (connect != NULL) {\n                    /* Note: if the Protocol layer is correctly configured,\n                       the CONNECT command should be always implemented */\n                    *inputHandler = connect->inputHandler;\n                    *outputHandler = connect->outputHandler;\n                }\n            }\n        }\n        else {\n            /* Input packet must be ignored and discarded */\n            *inputHandler = discardInputPacketHandler;\n            *outputHandler = NULL;\n        }\n    }\n}\n\n/*****************************************************************************\n    Public Functions (shared across different XCP commands)\n******************************************************************************/\nXcpStatus xcpStatusGet(void)\n{\n    return xcpStatus;\n}\n\nvoid xcpStatusSet(XcpStatus status)\n{\n    xcpStatus = status;\n}\n\nuint8_T xcpSessionStatusGet(void)\n{\n    return xcpSessionStatus;\n}\n\nvoid xcpSessionStatusSet(uint8_T status)\n{\n    xcpSessionStatus = status;\n}\n\nvoid xcpSessionStatusSetMask(uint8_T mask)\n{\n    XCP_SET_MASK(xcpSessionStatus, mask);\n}\n\nvoid xcpSessionStatusClearMask(uint8_T mask)\n{\n    XCP_CLEAR_MASK(xcpSessionStatus, mask);\n}\n\nuint8_T xcpResourceProtectionStatusGet(void)\n{\n    return xcpResourceProtectionStatus;\n}\n\nvoid xcpResourceProtectionStatusSet(uint8_T status)\n{\n    xcpResourceProtectionStatus = status;\n}\n\nvoid xcpResourceProtectionSetMask(uint8_T mask)\n{\n    XCP_SET_MASK(xcpResourceProtectionStatus, mask);\n}\n\nvoid xcpResourceProtectionClearMask(uint8_T mask)\n{\n    XCP_CLEAR_MASK(xcpResourceProtectionStatus, mask);\n}\n\nuint16_T xcpSessionConfigurationIdGet(void)\n{\n    return xcpSessionConfigurationId;\n}\n\nvoid xcpSessionConfigurationIdSet(uint16_T id)\n{\n    xcpSessionConfigurationId = id;\n}\n\nvoid genericOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    XCP_UNUSED_PARAM(packetSize);\n\n    if (inputCode == XCP_PROTO_SUCCESS) {\n        /* Send back a generic RES packet */\n        XcpGenericResPacketFrame *frame = (XcpGenericResPacketFrame *)packet;\n        frame->PID = XCP_PID_RES;\n    }\n    else {\n        XcpErrorPacketFrame *frame = (XcpErrorPacketFrame *)packet;\n        frame->PID = XCP_PID_ERR;\n\n        switch (inputCode) {\n        case XCP_PROTO_MEMORY_OVERFLOW:\n            frame->errorCode = XCP_ERR_MEMORY_OVERFLOW;\n            break;\n        case XCP_PROTO_SEQUENCE_ERROR:\n            frame->errorCode = XCP_ERR_SEQUENCE;\n            break;\n        case XCP_PROTO_OUT_OF_RANGE:\n            frame->errorCode = XCP_ERR_OUT_OF_RANGE;\n            break;\n        case XCP_PROTO_CMD_UNKNOWN:\n            frame->errorCode = XCP_ERR_CMD_UNKNOWN;\n            break;\n        case XCP_PROTO_SYNCH:\n            frame->errorCode = XCP_ERR_CMD_SYNC;\n            break;\n        case XCP_PROTO_WRITE_PROTECTED:\n            frame->errorCode = XCP_ERR_WRITE_PROTECTED;\n            break;\n        case XCP_PROTO_CMD_SYNTAX:\n            frame->errorCode = XCP_ERR_CMD_SYNTAX;\n            break;\n        case XCP_PROTO_DAQ_ACTIVE:\n            frame->errorCode = XCP_ERR_DAQ_ACTIVE;\n            break;\n        case XCP_PROTO_MODE_NOT_VALID:\n            frame->errorCode = XCP_ERR_MODE_NOT_VALID;\n            break;\n        case XCP_PROTO_DAQ_CONFIG_ERROR:\n            frame->errorCode = XCP_ERR_DAQ_CONFIG;\n            break;\n        case XCP_PROTO_BUSY:\n            frame->errorCode = XCP_ERR_CMD_BUSY;\n            break;\n        case XCP_PROTO_ACCESS_DENIED:\n            frame->errorCode = XCP_ERR_ACCESS_DENIED;\n            break;\n        case XCP_PROTO_SEGMENT_UNKNOWN:\n            frame->errorCode = XCP_ERR_SEGMENT_NOT_VALID;\n            break;\n        case XCP_PROTO_PAGE_UNKNOWN:\n            frame->errorCode = XCP_ERR_PAGE_NOT_VALID;\n            break;\n        case XCP_PROTO_GENERIC_ERROR:\n            frame->errorCode = XCP_ERR_GENERIC;\n            break;\n        case XCP_PROTO_RESOURCE_NOT_ACCESSIBLE:\n            frame->errorCode = XCP_ERR_RESOURCE_NOT_ACCESSIBLE;\n            break;\n        default:\n            /* This should never happen */\n            XCP_PRINTF(\"genericOutputPacketHandler error: %d input code is not supported\", inputCode);\n            frame->errorCode = XCP_ERR_CMD_UNKNOWN;\n        }\n    }\n}\n\n\nconst XcpPacketHandlers* xcpFindPacket(XcpRxPidCode pid, const XcpPacketHandlers* packets, size_t packetsNumber)\n{\n    const XcpPacketHandlers* packet = NULL;\n\n    if (packets != NULL) {\n        size_t i = 0;\n        for (i = 0; (i < packetsNumber) && (packet == NULL); i++) {\n            if (pid == packets[i].PID) {\n                packet = &packets[i];\n            }\n        }\n    }\n\n    return packet;\n}\n\n/*****************************************************************************\n    Public Functions (implementing the Protocol Layer interface)\n******************************************************************************/\nXcpErrorCode xcpInit(\n    int   argc,   /**< [in] number of init parameters              */\n    void *argv[]  /**< [in] array of parameters values (C strings) */\n    )\n{\n    XCP_UNUSED_PARAM(argc);\n    XCP_UNUSED_PARAM(argv);\n\n    XCP_ERROR_IF(initialized, XCP_ERROR, \"xcpInit: protocol layer already initialized\\n\");\n\n    /* Initialize Standard Commands support */\n    xcpStandardInit();\n    groupPacketLookup[XCP_STANDARD_PACKETS_ID] = xcpStandardGetPacketLookup();\n\n    /* Initialize DAQ lists (and STIM) support */\n    xcpDaqInit();\n    groupPacketLookup[XCP_DAQ_PACKETS_ID] = xcpDaqGetPacketLookup();\n\n    /* Initialize Calibration support */\n    xcpCalibrationInit();\n    groupPacketLookup[XCP_CALIBRATION_PACKETS_ID] = xcpCalibrationGetPacketLookup();\n\n    initialized = true;\n\n    return XCP_SUCCESS;\n}\n\nXcpErrorCode xcpRun(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *msgBuffer = NULL;\n    size_t   msgBufferSize = 0;\n    size_t   packetOffset = 0;\n    size_t   packetSize = 0;\n    size_t   outputPacketSize = 0;\n    uint8_T *packet = NULL;\n    XcpInputPacketHandler  inputHandler  = NULL;\n    XcpOutputPacketHandler outputHandler = NULL;\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpRun: protocol layer not initialized\\n\");\n\n    /* Extract a packet from the transport layer */\n    errorCode = xcpTransportRxPacketGet(XCP_TRANSPORT_RX_DEFAULT_QUEUE,\n                                       (void**)&msgBuffer, &msgBufferSize,\n                                       &packetOffset, &packetSize);\n    if ((errorCode != XCP_SUCCESS) &&\n        (errorCode != XCP_PKT_OUT_OF_SEQUENCE) && /* If a wrong packet counter is detected,       */\n        (errorCode != XCP_PKT_LOST)) {            /* the packet content is still considered valid */\n        goto error;\n    }\n\n    /* Check buffer sizes and retrieve the pointer to the XCP packet area */\n    if ((msgBuffer == NULL) || ((packetOffset + XCP_IN_HW_AG(packetSize)) > msgBufferSize)) { \n        errorCode = XCP_INV_SIZE;\n        goto error;\n    }\n\n    /* Identify the handler suitable for processing the given XCP packet */\n    packet = msgBuffer + packetOffset;\n    xcpGetPacketHandlers(packet, packetSize, &inputHandler, &outputHandler);\n\n    /* An input handler needs to be always present */\n    if (inputHandler == NULL) {\n        XCP_PRINTF(\"xcpRun: missing input handler for packet ID %xH\", packet[0]);\n        errorCode = XCP_ERROR;\n        goto error;\n    }\n\n    /* Process input packet */\n    protoErrorCode = inputHandler(msgBuffer, packetOffset, &outputPacketSize);\n\n    if ((outputHandler != NULL) && (outputPacketSize > 0)) {\n        errorCode = XCP_SUCCESS;\n\n        /* An Output Packet needs to be generated -> check if current message buffer is big enough for the response packet */\n        if (packetSize < outputPacketSize) {\n            errorCode = msgBufferRealloc((void **)&msgBuffer, &msgBufferSize, &packetOffset, outputPacketSize);\n        }\n\n        XCP_MEMSET(packet, 0, XCP_IN_HW_AG(packetSize));\n\n        if (errorCode == XCP_SUCCESS) {\n            /* Fill the response packet */\n            packet = msgBuffer + packetOffset;\n            outputHandler(protoErrorCode, packet, outputPacketSize);\n\n            /* Send the response back to the Transport Layer\n               @note to guarantee the maximum responsiveness even when the TX traffic\n                     is maxed out, the highest priority queue is used */\n            errorCode = xcpTransportTxPacketSet(XCP_TRANSPORT_TX_HIGHEST_PRIO_QUEUE,\n                                                XCP_TRANSPORT_NOT_A_DAQ,\n                                                msgBuffer, msgBufferSize,\n                                                packetOffset, outputPacketSize);\n            if (errorCode != XCP_SUCCESS) {\n                goto error;\n            }\n        }\n    }\n\n    return errorCode;\n\nerror:\n    if (msgBuffer != NULL) {\n        xcpMemFree(msgBuffer);\n    }\n\n    return errorCode;\n}\n\nXcpErrorCode xcpEvent(XcpEventIdType eventId)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    uint32_T timestamp = 0;\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpEvent: protocol layer not initialized\\n\");\n\n    timestamp = (uint32_T)XCP_TIMESTAMP_GET();\n    \n    /* Process DAQ Lists associated to the event */\n    errorCode = xcpDaqEvent(eventId, timestamp, false);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpEventExternalTimestamp(XcpEventIdType eventId, uint32_T timestamp)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpEvent: protocol layer not initialized\\n\");\n\n    /* Process DAQ Lists associated to the event */\n    errorCode = xcpDaqEvent(eventId, timestamp, false);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpEventNotificationReq(XcpEventCode eventCode, const void *eventData, size_t eventDataSize)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t packetOffset = xcpTransportPacketOffset();\n    size_t maxEventDataSize = xcpTransportMaxCtoSize() - XCP_EVENT_PACKET_SIZE_IN_BYTES;\n    size_t packetSize = 0;\n    uint8_T *msgBuffer = NULL;\n    size_t msgBufferSize = 0;\n\n    /* Validate input parameters */\n    XCP_ERROR_IF((eventDataSize > 0) && (eventData == NULL), XCP_INV_ARG, \"xcpEventNotificationReq: invalid eventData buffer\\n\");\n    XCP_ERROR_IF(eventDataSize > maxEventDataSize, XCP_INV_ARG, \"xcpEventNotificationReq: invalid eventDataSize\\n\");\n\n    /* Calculate the required message buffer size */\n    packetSize = eventDataSize + XCP_EVENT_PACKET_SIZE_IN_BYTES;\n\n    /* Allocate the message buffer */\n    msgBufferSize = xcpTransportMsgBufferSize(packetSize, XCP_CTO);\n    msgBuffer = (uint8_T *)xcpMemAlloc(msgBufferSize);\n\n    if (msgBuffer != NULL) {\n        XcpEventPacketFrame *frame = (XcpEventPacketFrame *) (msgBuffer + packetOffset);\n\n        /* Fill the EV packet information */\n        frame->PID = XCP_PID_EV;\n        frame->eventCode = eventCode;\n\n        if (eventDataSize > 0) {\n            uint8_T *packetEventData = msgBuffer + packetOffset + XCP_IN_HW_AG(XCP_EVENT_PACKET_SIZE_IN_BYTES);\n\n            /* Copy the optional event data */\n            XCP_MEMCPY(packetEventData, eventData, XCP_IN_HW_AG(eventDataSize));\n        }\n\n        /* Send the EV packet to the Transport Layer\n           @note to guarantee that this packet gets delivered as soon as possible\n                 to the XCP Client, the highest priority queue is used */\n        errorCode = xcpTransportTxPacketSet(XCP_TRANSPORT_TX_HIGHEST_PRIO_QUEUE,\n                                            XCP_TRANSPORT_NOT_A_DAQ,\n                                            msgBuffer, msgBufferSize,\n                                            packetOffset, packetSize);\n        if (errorCode != XCP_SUCCESS) {\n            xcpMemFree(msgBuffer);\n        }\n    }\n    else\n    {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    return errorCode;\n}\n\nXcpErrorCode xcpRemoteServiceReq(XcpReqServiceCode serviceReqCode, const void *serviceReqData, size_t serviceReqDataSize)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t packetOffset = xcpTransportPacketOffset();\n    size_t maxServiceReqDataSize = xcpTransportMaxCtoSize() - XCP_SERVICE_REQ_PACKET_SIZE_IN_BYTES;\n    size_t packetSize = 0;\n    uint8_T *msgBuffer = NULL;\n    size_t msgBufferSize = 0;\n\n    /* Validate input parameters */\n    XCP_ERROR_IF((serviceReqDataSize > 0) && (serviceReqData == NULL), XCP_INV_ARG, \"xcpRemoteServiceReq: invalid serviceReqData buffer\\n\");\n    XCP_ERROR_IF(serviceReqDataSize > maxServiceReqDataSize, XCP_INV_ARG, \"xcpRemoteServiceReq: invalid serviceReqDataSize\\n\");\n\n    /* Calculate the required message buffer size */\n    packetSize = serviceReqDataSize + XCP_SERVICE_REQ_PACKET_SIZE_IN_BYTES;\n\n    /* Allocate the message buffer */\n    msgBufferSize = xcpTransportMsgBufferSize(packetSize, XCP_CTO);\n    msgBuffer = (uint8_T *)xcpMemAlloc(msgBufferSize);\n\n    if (msgBuffer != NULL) {\n        XcpServiceReqPacketFrame *frame = (XcpServiceReqPacketFrame *) (msgBuffer + packetOffset);\n\n        /* Fill the SERV packet information */\n        frame->PID = XCP_PID_SERV;\n        frame->serviceReqCode = serviceReqCode;\n\n        if (serviceReqDataSize > 0) {\n            uint8_T *packetServiceReqData = msgBuffer + packetOffset + XCP_IN_HW_AG(XCP_SERVICE_REQ_PACKET_SIZE_IN_BYTES);\n\n            /* Copy the optional event data */\n            XCP_MEMCPY(packetServiceReqData, serviceReqData, XCP_IN_HW_AG(serviceReqDataSize));\n        }\n\n        /* Send the SERV packet to the Transport Layer\n           @note to guarantee that this packet gets delivered as soon as possible\n                 to the XCP Client, the highest priority queue is used */\n        errorCode = xcpTransportTxPacketSet(XCP_TRANSPORT_TX_HIGHEST_PRIO_QUEUE,\n                                            XCP_TRANSPORT_NOT_A_DAQ,\n                                            msgBuffer, msgBufferSize,\n                                            packetOffset, packetSize);\n        if (errorCode != XCP_SUCCESS) {\n            xcpMemFree(msgBuffer);\n        }\n    }\n    else\n    {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    return errorCode;\n}\n\nXcpStatus xcpGetStatus(void)\n{\n    return xcpStatus;\n}\n\nXcpErrorCode xcpReset(void)\n{\n    if (!initialized) {\n        XCP_PRINTF(\"xcpReset: protocol layer already reset\\n\");\n        /* Nothing to do: just printing out a warning message*/\n    }\n\n    /* Reset Calibration support */\n    xcpCalibrationReset();\n\n    /* Reset DAQ lists (and STIM) support */\n    xcpDaqReset();\n\n    /* Reset Standard Commands support */\n    xcpStandardReset();\n\n    XCP_MEMSET((void*)groupPacketLookup, 0, sizeof(groupPacketLookup));\n\n    initialized = false;\n\n    return XCP_SUCCESS;\n}\n\nXcpErrorCode xcpSetCustomPoolMemoryManager(XcpEventIdType eventId, XcpCustomAllocHandler allocHandler, XcpCustomFreeHandler freeHandler)\n{\n    XcpErrorCode errorCode;\n\n    /* Forward registration to DAQ list */\n    errorCode = xcpDaqSetCustomPoolMemoryManager(eventId, allocHandler, freeHandler);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpGetCustomPoolMemoryManager(XcpEventIdType *eventId, XcpCustomAllocHandler *allocHandler, XcpCustomFreeHandler *freeHandler)\n{\n    XcpErrorCode errorCode;\n\n    /* Forward query to DAQ list */\n    errorCode = xcpDaqGetCustomPoolMemoryManager(eventId, allocHandler, freeHandler);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpPackedModeEventsFlush(uint32_T timestamp)\n{\n    XcpErrorCode errorCode;\n\n    errorCode = xcpDaqEventsFlush(timestamp);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpPackedModeEventReset(XcpEventIdType eventId)\n{\n    XcpErrorCode errorCode;\n    boolean_T resetSamples = true;\n\n    /* Reset the status of pending packed DAQ lists,\n       discarding incomplete packets. */\n    errorCode = xcpDaqEvent(eventId, 0, resetSamples);\n\n    return errorCode;\n}\n\n#ifdef XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT\n\nXcpErrorCode xcpGetDaqOdtEntries(XcpEventIdType eventId,\n                                 XcpOdtEntry* entries,\n                                 size_t* entriesNumber,\n                                 size_t maxEntriesNumber)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    errorCode = xcpDaqGetOdtEntries(eventId, XCP_DIRECTION_DAQ,\n                                 entries, entriesNumber,\n                                 maxEntriesNumber);\n    return errorCode;\n}\n\n#endif /* XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT */\n\n\n#ifndef XCP_DAQ_SUPPORT\n\nvoid xcpDaqInit(void) {}\nXcpPacketLookupFunction xcpDaqGetPacketLookup(void) {return NULL;}\nvoid xcpDaqSetPacketLookup(XcpPacketLookupFunction getPacket) {XCP_UNUSED_PARAM(getPacket);}\nXcpErrorCode xcpDaqEvent(XcpEventIdType eventId, uint32_T timestamp, boolean_T resetSamples) {XCP_UNUSED_PARAM(eventId); XCP_UNUSED_PARAM(timestamp); XCP_UNUSED_PARAM(resetSamples); return XCP_SUCCESS;}\nboolean_T xcpResetDaqListStatus(void) {return true;}\nXcpErrorCode xcpDaqEventsFlush(uint32_T timestamp) {XCP_UNUSED_PARAM(timestamp); return XCP_SUCCESS;}\nboolean_T xcpDaqLock(void) {return true;}\nvoid xcpDaqUnlock(void) {}\nvoid xcpDaqReset(void) {}\nXcpErrorCode xcpDaqSetCustomPoolMemoryManager(XcpEventIdType eventId, XcpCustomAllocHandler allocHandler, XcpCustomFreeHandler freeHandler) {\n    XCP_UNUSED_PARAM(eventId); XCP_UNUSED_PARAM(allocHandler); XCP_UNUSED_PARAM(freeHandler); return XCP_SUCCESS;}\nXcpErrorCode xcpDaqGetCustomPoolMemoryManager(XcpEventIdType *eventId, XcpCustomAllocHandler *allocHandler, XcpCustomFreeHandler *freeHandler) {\n    XCP_UNUSED_PARAM(eventId); XCP_UNUSED_PARAM(allocHandler); XCP_UNUSED_PARAM(freeHandler); return XCP_SUCCESS;}\n\n#ifdef XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT\nXcpErrorCode xcpGetDaqOdtEntries(XcpEventIdType eventId, XcpOdtEntry* entries, size_t* entriesNumber, size_t maxEntriesNumber){\n    XCP_UNUSED_PARAM(eventId); XCP_UNUSED_PARAM(entries); XCP_UNUSED_PARAM(entriesNumber); XCP_UNUSED_PARAM(maxEntriesNumber); return XCP_SUCCESS;}\n#endif /* XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT */\n\n#endif\n\n\n#ifndef XCP_CALIBRATION_SUPPORT\n\nvoid xcpCalibrationInit(void) {}\nXcpPacketLookupFunction xcpCalibrationGetPacketLookup(void) {return NULL;}\nvoid xcpCalibrationSetPacketLookup(XcpPacketLookupFunction getPacket) {XCP_UNUSED_PARAM(getPacket);}\nvoid xcpCalibrationReset(void) {}\n\n#endif\n"},{"name":"xcp_calibration.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2024a/toolbox/coder/xcp/src/target/server/protocol/src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2017-2020 The MathWorks, Inc.\n*\n* File: xcp_calibration.c\n*\n* Abstract:\n*  Implementation of XCP Protocol Layer Calibration support\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_cfg.h\"\n#include \"xcp_calibration.h\"\n\n#ifdef XCP_CALIBRATION_SUPPORT\n\n#ifdef XCP_CALIBRATION_EXTENDED_SUPPORT\n#include \"xcp_calibration_ext.h\"\n#endif\n\n#include \"xcp_types.h\"\n#include \"xcp_calibration_types.h\"\n#include \"xcp_standard.h\"\n#include \"xcp_transport_internal.h\"\n\n/*****************************************************************************\n    Internal Functions specific to Calibration support\n******************************************************************************/\nstatic boolean_T isValidShortDownloadSize(uint8_T size)\n{\n    size_t addressGranularity = XCP_ADDRESS_GRANULARITY_BYTES_NUMBER;\n    size_t maxCtoSize = xcpTransportMaxCtoSize();\n\n    return (size <= ((maxCtoSize - 8) / addressGranularity));\n}\n\n#if XCP_SET_MTA_ENABLE == 1\n    static boolean_T isValidDownloadSize(uint8_T size)\n    {\n        size_t addressGranularity = XCP_ADDRESS_GRANULARITY_BYTES_NUMBER;\n        size_t maxCtoSize = xcpTransportMaxCtoSize();\n        \n        return ( (size >= 1)  && (size <= (maxCtoSize-2) / addressGranularity ) );\n    }\n#endif  /* XCP_SET_MTA_ENABLE == 1 */\n\n/** memcpy function used to copy data from packet to MTA address */\nstatic void xcpMemcpyToMTA(uint8_T *packet, uint8_T size)\n{\n    /* Retrieve memory address */\n    uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n\n    XCP_PRINTF(\"writing at address %p\\n\", xcpMTARawPointer);\n\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n{\n    uint32_T address;\n    uint8_T addressExtension;\n    uint8_T dstOffsetBytes;\n    xcpStandardGetMta(&address, &addressExtension);\n    dstOffsetBytes = XCP_BYTE_OFFSET_GET(address);\n    xcpMemcpyByte(xcpMTARawPointer, dstOffsetBytes, packet, 0, size);\n}\n#else\n    XCP_MEMCPY(xcpMTARawPointer, packet, size);\n#endif\n}\n\n/*****************************************************************************\n    XCP DOWNLOAD\n******************************************************************************/\n#if XCP_SET_MTA_ENABLE == 1\n    static XcpProtoErrorCode downloadInputPacketHandler(void   *msgBuffer,\n        size_t  xcpPacketOffset,\n        size_t *outputPacketSize)\n    {\n        XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n        uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n        XcpDownloadCmdPacketFrame *frame = (XcpDownloadCmdPacketFrame *)packet;\n        boolean_T ok = false;\n        uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n\n        /* Check if the number of data elements is valid */\n        ok = isValidDownloadSize((uint8_T)frame->size);\n        XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n            (\"DOWNLOAD: invalid number of data elements (%d)\\n\", frame->size));\n            \n        /* Check if a valid MTA address is available */\n        XCP_INPUT_PKT_ERROR_IF((xcpMTARawPointer == 0) || (xcpMTARawPointer == NULL), \n            XCP_PROTO_ACCESS_DENIED, (\"DOWNLOAD: invalid address\\n\"));\n\n        XCP_PRINTF(\"DOWNLOAD: \");\n    \n        /* Update the value of the parameter with the data element content */\n        xcpMemcpyToMTA(packet + sizeof(XcpDownloadCmdPacketFrame), (uint8_T)frame->size);\n    \n        /* Post-increment MTA by the frame size in address granularity units */\n        xcpStandardIncrementMta((uint8_T)frame->size);\n        \n        *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n        return protoErrorCode;\n    }\n#endif  /* XCP_SET_MTA_ENABLE == 1 */\n\n/*****************************************************************************\n    XCP SHORT_DOWNLOAD\n******************************************************************************/\nstatic XcpProtoErrorCode shortDownloadInputPacketHandler(void   *msgBuffer,\n    size_t  xcpPacketOffset,\n    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpShortDownloadCmdPacketFrame *frame = (XcpShortDownloadCmdPacketFrame *)packet;\n    boolean_T ok = false;\n\n    /* Check if the number of data elements is valid */\n    ok = isValidShortDownloadSize((uint8_T)frame->size);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"SHORT_DOWNLOAD: invalid number of data elements (%d)\\n\", frame->size));\n\n    /* Check if the memory address is valid and set the MTA pointer */\n    ok = xcpStandardSetMta(frame->address, (uint8_T)frame->addressExtension);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_ACCESS_DENIED, (\"SHORT_DOWNLOAD: invalid address\\n\"));\n\n    XCP_PRINTF(\"SHORT_DOWNLOAD: \");\n\n    /* Update the value of the parameter with the data element content */\n    xcpMemcpyToMTA(packet + sizeof(XcpShortDownloadCmdPacketFrame), (uint8_T)frame->size);\n\n    /* Post-increment MTA by the frame size in address granularity units */\n    xcpStandardIncrementMta((uint8_T)frame->size);\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n\n/** This table contains the list of supported Rx packets and the corresponding handlers */\nstatic const XcpPacketHandlers calibrationSupportedRxPacket[] =\n{\n#if XCP_SET_MTA_ENABLE == 1\n    { XCP_PID_DOWNLOAD,       downloadInputPacketHandler,     genericOutputPacketHandler },\n#endif\n    { XCP_PID_SHORT_DOWNLOAD, shortDownloadInputPacketHandler, genericOutputPacketHandler }\n};\n\n\n/*****************************************************************************\n    XCP Packet Lookup Function for basic calibration commands\n******************************************************************************/\n\n/* Default Calibration Packet Lookup function, supporting only basic commands\n   listed in the table above */\nstatic const XcpPacketHandlers* getPacket(XcpRxPidCode pid)\n{\n    return xcpFindPacket(pid, calibrationSupportedRxPacket,\n                         XCP_ELEMENTS_NUMBER(calibrationSupportedRxPacket));\n}\n\nstatic XcpPacketLookupFunction packetLookup = NULL;\n\n\n\n/*****************************************************************************\n    Public Functions (invoked within the Protocol Layer)\n******************************************************************************/\nvoid xcpCalibrationInit(void)\n{\n    /* Initialize the packet lookup function to support only basic\n       calibration commands */\n    xcpCalibrationSetPacketLookup(getPacket);\n\n#ifdef XCP_CALIBRATION_EXTENDED_SUPPORT\n    /* Initialize support for the extended list of calibration commands */\n    xcpCalibrationExtendedInit();\n#endif\n}\n\n\nXcpPacketLookupFunction xcpCalibrationGetPacketLookup(void)\n{\n    return packetLookup;\n}\n\n\nvoid xcpCalibrationSetPacketLookup(XcpPacketLookupFunction getPacketFcn)\n{\n    packetLookup = getPacketFcn;\n}\n\nvoid xcpCalibrationReset(void)\n{\n#ifdef XCP_CALIBRATION_EXTENDED_SUPPORT\n    /* Reset support for the extended list of calibration commands */\n    xcpCalibrationExtendedReset();\n#endif\n}\n\n#endif\n"},{"name":"xcp_daq.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2024a/toolbox/coder/xcp/src/target/server/protocol/src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2023 The MathWorks, Inc.\n*\n* File: xcp_daq.c\n*\n* Abstract:\n*  Implementation of XCP Protocol Layer DAQ Lists (and STIM) support\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_internal.h\"\n#include \"xcp_cfg.h\"\n#include \"xcp_daq.h\"\n\n#ifdef XCP_DAQ_SUPPORT\n#include \"xcp_daq_ext.h\"\n#include \"xcp_transport_internal.h\"\n#include \"xcp_types.h\"\n#include \"xcp_daq_types.h\"\n#include \"xcp_mem.h\"\n\n/*****************************************************************************\n    Internal Global variables specific to DAQ support\n******************************************************************************/\n\n/** Dynamic DAQ Lists data structures */\nstatic XcpDaqLists xcpDynamicDaqLists;\n\n/** Number of event threads currently in execution */\nstatic size_t xcpRunningEventCounter = 0;\n\n/** ID of the selected DAQ List on START_STOP_DAQ_LIST command */\n#define XCP_INVALID_DAQ_LIST_ID -1\nstatic int32_T startStopDaqListId = XCP_INVALID_DAQ_LIST_ID;\n\n/** Pointer to current ODT entry */\nstatic XcpDaqPtr   xcpCurrentDaq = { 0xFFFF, 0xFF, 0xFF };\n\nstatic XcpEventCustomMemoryManager xcpEventCustomMemoryManager = {XCP_DAQ_CUSTOM_MEMORY_INVALID_EVENT_ID, NULL, NULL};\n\n#ifndef XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n/* XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT is typically enabled\n   for multi-core applications, where it is critical to limit\n   the interference between threads streaming data.\n   For this reason, by default we enable the independent lock\n   of the DAQ list data structures between events */\n#define XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK 1\n#else\n/* XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT is typically disabled\n   for single-core bare-metal applications, where it is critical\n   to limit the memory footprint of the target executable.\n   For this reason, by default we disable the independent lock\n   of the DAQ list data structures between events and use a single\n   mutex to protect the DAQ lists data structures */\n#define XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK 0\n#endif\n\n#endif\n\n\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n/* Mutex protecting against the concurrent access to DAQ Lists data structures */\nstatic XCP_MUTEX_DEFINE(daqLock);\n\nstatic boolean_T xcpDaqWriteLock(XcpEventIdType eventId)\n{\n    boolean_T locked = false;\n    XCP_UNUSED_PARAM(eventId);\n    XCP_WRITE_TRY_LOCK(daqLock, xcpRunningEventCounter, locked);\n\n    return locked;\n}\n\nstatic void xcpDaqWriteUnlock(XcpEventIdType eventId)\n{\n    XCP_UNUSED_PARAM(eventId);\n    XCP_WRITE_UNLOCK(daqLock);\n}\n\nstatic void xcpDaqReadLock(XcpEventIdType eventId)\n{\n    XCP_UNUSED_PARAM(eventId);\n    XCP_READ_LOCK(daqLock, xcpRunningEventCounter);\n}\n\nstatic void xcpDaqReadUnlock(XcpEventIdType eventId)\n{\n    XCP_UNUSED_PARAM(eventId);\n    XCP_READ_UNLOCK(daqLock, xcpRunningEventCounter);\n}\n\n#else\n/* Each XCP event has an independent mutex to protect the read/write access\n   to the DAQ list data structures */\n#ifndef XCP_MAX_EVENT_DATA_NUMBER\n#define XCP_MAX_EVENT_DATA_NUMBER XCP_MAX_EVENT_CHANNEL\n#endif\n\ntypedef struct XcpEventData {\n    XCP_MUTEX_DEFINE(lock);\n} XcpEventData;\n\n/** Array of event-specific data */\nstatic XcpEventData xcpEventData[XCP_MAX_EVENT_DATA_NUMBER];\n\nstatic boolean_T xcpDaqWriteLock(XcpEventIdType eventId)\n{\n    XCP_MUTEX_LOCK(xcpEventData[eventId].lock);\n    return true;\n}\n\nstatic void xcpDaqWriteUnlock(XcpEventIdType eventId)\n{\n    XCP_MUTEX_UNLOCK(xcpEventData[eventId].lock);\n}\n\nstatic void xcpDaqReadLock(XcpEventIdType eventId)\n{\n    XCP_MUTEX_LOCK(xcpEventData[eventId].lock);\n}\n\nstatic void xcpDaqReadUnlock(XcpEventIdType eventId)\n{\n    XCP_MUTEX_UNLOCK(xcpEventData[eventId].lock);\n}\n\n#endif\n\n#ifndef XCP_MIN_EVENT_NO_RESERVED_POOL\n#define XCP_MIN_EVENT_NO_RESERVED_POOL 0xFFFF\n#endif\n\n/*****************************************************************************\n    Internal Functions specific to DAQ support\n******************************************************************************/\n\n/* When enabled, timestamp is required for first ODT in the DAQ list */\n#if XCP_TIMESTAMP_FIXED == 0\n#define IS_TIMESTAMP_REQUIRED(mode, odtNumber) ((odtNumber == 0) && \\\n            XCP_READ_BIT_VALUE(mode, XCP_DAQ_MODE_TIMESTAMP_MASK))\n#else\n#define IS_TIMESTAMP_REQUIRED(mode, odtNumber) (odtNumber == 0)\n#endif\n\n/* Incrementing pointer. byteOffset argument will have a valid value only when\n   we are emulating as a BYTE addressable target. Otherwise, it is 0. */\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n#define XCP_HW_PTR_INCREMENT(ptr, incr, byteOffset) (uint8_T *)(byteOffset ? (ptr + XCP_IN_HW_AG(incr - 1)) : (ptr + XCP_IN_HW_AG(incr)))\n#else\n#define XCP_HW_PTR_INCREMENT(ptr, incr, byteOffset) (uint8_T *)(ptr + incr)\n#endif\n\n/* Update byteOffset when emulating as a BYTE addressable target */\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n#define XCP_HW_BYTE_OFFSET_UPDATE(offset, size) ((offset + size) % XCP_HARDWARE_ADDRESS_GRANULARITY_BYTES_NUMBER)\n#else\n#define XCP_HW_BYTE_OFFSET_UPDATE(offset, size) 0\n#endif\n\n#define IS_USING_CUSTOM_POOL(x) (x == xcpEventCustomMemoryManager.eventId)\n\nstatic boolean_T isActiveDaqList(uint16_T daqListId)\n{\n    return (xcpDynamicDaqLists.daq[daqListId].status == XCP_DAQ_SELECTED) ||\n           (xcpDynamicDaqLists.daq[daqListId].status == XCP_DAQ_STARTED);\n}\n\nstatic boolean_T noActiveDaqLists(void)\n{\n    boolean_T found = 0;\n    uint16_T i = 0;\n\n    for (i = 0; (i < xcpDynamicDaqLists.daqCount) && !found; i++) {\n        found = isActiveDaqList(i);\n    }\n\n    return !found;\n}\n\nstatic boolean_T isValidDaqPtr(uint16_T daqListId, uint8_T odtId, uint8_T odtEntryId)\n{\n    boolean_T ret = (xcpDynamicDaqLists.daq != NULL) &&\n                    (daqListId < xcpDynamicDaqLists.daqCount) &&\n                    (xcpDynamicDaqLists.daq[daqListId].odt != NULL) &&\n                    (odtId < xcpDynamicDaqLists.daq[daqListId].odtCount) &&\n                    (xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry != NULL) &&\n                    (odtEntryId < xcpDynamicDaqLists.daq[daqListId].odt[odtId].entriesCount);\n\n    return ret;\n}\n\nstatic boolean_T isValidDaqEntry(uint8_T bitOffset, uint8_T size, uint32_T address)\n{\n    boolean_T ret = false;\n    uint16_T  entrySize = size;     /* cast to 16-bit avoids -Werror=type-limits */\n\n    if (bitOffset == 0xFF) {\n        /* \"Normal\" (non-bitwise) access has been selected */\n        if ( (entrySize <= XCP_MAX_ODT_ENTRY_SIZE) &&\n             (entrySize % (XCP_ODT_ENTRY_SIZE_GRANULARITY/XCP_ADDRESS_GRANULARITY_BYTES_NUMBER) == 0) &&\n             (  address % (XCP_ODT_ENTRY_SIZE_GRANULARITY/XCP_ADDRESS_GRANULARITY_BYTES_NUMBER) == 0) ) {\n            ret = true;\n        }\n    }\n    else {\n        /* Bitwise access has been selected */\n        if ((bitOffset <= 0x1F) && (address % XCP_ODT_ENTRY_SIZE_GRANULARITY) &&\n            (entrySize == XCP_ODT_ENTRY_SIZE_GRANULARITY)) {\n            ret = true;\n        }\n    }\n\n    return ret;\n}\n\n/** The current supported mode includes:\n- alternating = 0\n- direction = 0 (DAQ only)\n- timestamp = 1 or 0\n- PID OFF = 0\n*/\nstatic boolean_T isSupportedDaqListMode(uint8_T mode)\n{\n    #if XCP_TIMESTAMP_FIXED == 0\n        return ( (mode & ~XCP_DAQ_MODE_TIMESTAMP_MASK) == 0 );\n    #else\n        return (mode == XCP_DAQ_MODE_TIMESTAMP_MASK);\n    #endif\n}\n\nstatic boolean_T isValidStartStopMode(uint8_T mode)\n{\n    boolean_T ret = false;\n\n    if ((mode == XCP_DAQ_LIST_STOP) ||\n        (mode == XCP_DAQ_LIST_START) ||\n        (mode == XCP_DAQ_LIST_SELECT))\n        ret = true;\n\n    return ret;\n}\n\nstatic boolean_T isValidStartStopSynchMode(uint8_T mode)\n{\n    boolean_T ret = false;\n\n    if ((mode == XCP_DAQ_LIST_STOP_ALL) ||\n        (mode == XCP_DAQ_LIST_START_SELECTED) ||\n        (mode == XCP_DAQ_LIST_STOP_SELECTED))\n        ret = true;\n\n    return ret;\n}\n\nstatic boolean_T absoluteOdtNumberIdentification(void)\n{\n    return (XCP_ID_FIELD_TYPE == XCP_ID_ABSOLUTE_ODT_NUMBER);\n}\n\nstatic boolean_T isDaqPackedModeEnabled(uint16_T daqListId)\n{\n    /* DAQ Packed Mode is only supported for event-grouped packing and \n       reserved memory pool */\n\n    boolean_T isEnabled = (xcpDynamicDaqLists.daq[daqListId].packedMode == XCP_DAQ_EVENT_GROUPED_PACKING) &&\n                          !IS_USING_CUSTOM_POOL(xcpDynamicDaqLists.daq[daqListId].eventId);\n    \n#if XCP_MEM_DAQ_RESERVED_POOLS_NUMBER > 0\n    isEnabled = isEnabled && (daqListId < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER);\n#endif\n\n    return isEnabled;\n}\n\n/* Return size of packet associated with the odt at the protocol layer */\nstatic size_t odtPacketSize(XcpDaq *daq, uint8_T odtNumber) {\n    XcpOdt *odt = &daq->odt[odtNumber];\n    size_t packetSize = XCP_IN_BYTES(odt->size * daq->sampleCount + XCP_IN_AG(XCP_ID_FIELD_SIZE));\n\n    if (IS_TIMESTAMP_REQUIRED(daq->mode, odtNumber)) {\n        packetSize += XCP_TIMESTAMP_SIZE;\n    }\n\n    return packetSize;\n}\n\n/* Try to allocate a reserved memory pool dedicated to the packets in the DAQ list.\n   @note depending on the configuration of the memory allocator, this may fail\n         so we just set daq->poolId to XCP_INVALID_POOL_ID in that case */\nstatic XcpErrorCode createDaqReservedPool(XcpDaq *daq)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t poolBlockSize = 0;\n    uint8_T i = 0;\n\n    /* Calculate the max size for the ODT packets in the given DAQ list */\n    for (i = 0; i < daq->odtCount; i++) {\n        /* Calculate the required message buffer size */\n        size_t packetSize = odtPacketSize(daq, i);\n        size_t msgBufferSize = 0;\n\n        msgBufferSize = xcpTransportMsgBufferSize(packetSize, XCP_DTO);\n\n        if (msgBufferSize > poolBlockSize) {\n            poolBlockSize = msgBufferSize;\n        }\n    }\n\n    /* Try the allocation of the dedicate pool */\n    errorCode = xcpMemReservedPoolCreate(poolBlockSize,\n        (size_t)XCP_MEM_DAQ_RESERVED_POOL_BLOCKS_NUMBER * daq->odtCount,\n        &daq->poolId);\n    if (errorCode != XCP_SUCCESS) {\n        daq->poolId = XCP_INVALID_POOL_ID;\n    }\n\n    #ifdef XCP_DEBUG_SUPPORT\n    xcpMemPrintDiagnostics();\n    #endif\n\n    return errorCode;\n}\n\nstatic void destroyDaqReservedPool(XcpDaq *daq)\n{\n    if (daq->poolId != XCP_INVALID_POOL_ID) {\n        xcpMemReservedPoolDestroy(daq->poolId);\n    }\n\n    daq->poolId = XCP_INVALID_POOL_ID;\n}\n\n\n/*****************************************************************************\n    XCP SET DAQ PTR\n******************************************************************************/\nstatic XcpProtoErrorCode setDaqPtrInputPacketHandler(void   *msgBuffer,\n                                                     size_t  xcpPacketOffset,\n                                                     size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpSetDaqPtrCmdPacketFrame *frame = (XcpSetDaqPtrCmdPacketFrame *) packet;\n    uint16_T daqListId  = (uint16_T)frame->daqListId;\n    uint8_T  odtId      = (uint8_T)frame->odtId;\n    uint8_T  odtEntryId = (uint8_T)frame->odtEntryId;\n    boolean_T ok = false;\n\n    /* Check if the selected ODT Entry is available */\n    ok = isValidDaqPtr(daqListId, odtId, odtEntryId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"SET_DAQ_PTR: ODT entry not available (DAQ %d, ODT %d, Entry %d)\\n\", daqListId, odtId, odtEntryId));\n\n    /* Check if the DAQ list is currently active */\n    ok = !isActiveDaqList(daqListId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_ACTIVE, (\"SET_DAQ_PTR: DAQ list %d is currently active\\n\", daqListId));\n\n    /* Everything is fine -> proceed and update the current ODT entry pointer */\n    XCP_PRINTF(\"SET_DAQ_PTR: updating current ODT entry pointer to DAQ %d, ODT %d, Entry %d\\n\",\n               daqListId, odtId, odtEntryId);\n\n    xcpCurrentDaq.daqListId  = daqListId;\n    xcpCurrentDaq.odtId      = odtId;\n    xcpCurrentDaq.odtEntryId = odtEntryId;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP WRITE DAQ\n******************************************************************************/\nstatic XcpProtoErrorCode writeDaqInputPacketHandler(void   *msgBuffer,\n                                                    size_t  xcpPacketOffset,\n                                                    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpWriteDaqCmdPacketFrame *frame = (XcpWriteDaqCmdPacketFrame *)packet;\n    uint16_T daqListId = xcpCurrentDaq.daqListId;\n    uint8_T  odtId = xcpCurrentDaq.odtId;\n    uint8_T  odtEntryId = xcpCurrentDaq.odtEntryId;\n    XcpOdtEntry *entry = NULL;\n    boolean_T ok = false;\n\n    /* Check if the selected ODT Entry is available */\n    ok = isValidDaqPtr(daqListId, odtId, odtEntryId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_WRITE_PROTECTED,\n        (\"WRITE_DAQ: current ODT entry not available for write operations (DAQ %d, ODT %d, Entry %d)\\n\", daqListId, odtId, odtEntryId));\n\n    /* Check if the DAQ list is currently active */\n    ok = !isActiveDaqList(daqListId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_ACTIVE, (\"XCP_WRITE_DAQ: DAQ list %d is currently active\\n\", daqListId));\n\n    /* Check if the Entry values are valid */\n    ok = isValidDaqEntry((uint8_T)frame->bitOffset, (uint8_T)frame->size, (uint32_T)frame->address);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"XCP_WRITE_DAQ: invalid DAQ %d ODT %d Entry %d value: bitOffset = %xH size = %d addressExtension = %dH address = %xH\\n\",\n         daqListId, odtId, odtEntryId, frame->bitOffset, frame->size, frame->addressExtension, frame->address));\n\n    /* Everything is fine -> proceed and write the entry */\n    XCP_PRINTF(\"XCP_WRITE_DAQ: writing DAQ %d ODT %d Entry %d: bitOffset = %xH size = %d addressExtension = %dH address = %xH\\n\",\n               daqListId, odtId, odtEntryId, frame->bitOffset, frame->size, frame->addressExtension, frame->address);\n\n    entry = &(xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry[odtEntryId]);\n\n    entry->bitOffset        = (uint8_T)frame->bitOffset;\n    entry->size             = (uint8_T)frame->size;\n    entry->addressExtension = (uint8_T)frame->addressExtension;\n    entry->address          = (uint32_T)frame->address;\n\n    /* After a successful WRITE_DAQ, the xcpDaqPtr odtEntryId needs to be post incremented */\n    xcpCurrentDaq.odtEntryId++;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP SET DAQ LIST MODE\n******************************************************************************/\nstatic XcpProtoErrorCode setDaqListModeInputPacketHandler(void   *msgBuffer,\n                                                          size_t  xcpPacketOffset,\n                                                          size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpSetDaqListModeCmdPacketFrame *frame = (XcpSetDaqListModeCmdPacketFrame *)packet;\n    XcpDaq *daqList = NULL;\n    boolean_T ok = false;\n\n    /* Check if the DAQ List is available */\n    ok = (xcpDynamicDaqLists.daq != NULL) && (frame->daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE, (\"SET_DAQ_LIST_MODE: DAQ list %d not available\\n\", frame->daqListId));\n\n    daqList = &(xcpDynamicDaqLists.daq[frame->daqListId]);\n\n    /* Check if the DAQ list is currently active */\n    ok = !isActiveDaqList((uint16_T)frame->daqListId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_ACTIVE, (\"SET_DAQ_LIST_MODE: DAQ list %d is currently active\\n\", frame->daqListId));\n\n    /* Check if the Event Id is valid */\n    ok = (frame->eventId < XCP_MAX_EVENT_CHANNEL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE, (\"SET_DAQ_LIST_MODE: invalid event channel Id %d\\n\", frame->eventId));\n\n    /* Check DAQ list priority */\n    ok = (frame->priority == 0);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE, (\"SET_DAQ_LIST_MODE: priority not supported, must be zero\\n\"));\n\n    /* Check if DAQ list mode is supported */\n    ok = isSupportedDaqListMode((uint8_T)frame->mode);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID, (\"SET_DAQ_LIST_MODE: DAQ list mode not supported %xH\\n\", frame->mode));\n\n    /* Everything is fine -> proceed and set the DAQ list mode */\n    XCP_PRINTF(\"SET_DAQ_LIST_MODE: setting DAQ list %d: mode = %xH, eventId = %d, prescaler = %d, priority = %d\\n\",\n        frame->daqListId, frame->mode, frame->eventId, frame->prescaler, frame->priority);\n\n    daqList->mode       = (uint8_T)frame->mode;\n    daqList->eventId    = (uint16_T)frame->eventId;\n    daqList->prescaler  = (uint8_T)frame->prescaler;\n    daqList->priority   = (uint8_T)frame->priority;\n\n    /* Assuming that prescaler = 0 means value that you are not interested in using it */\n    if (daqList->prescaler <= 1)\n        daqList->prescaler = 1;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP START_STOP_DAQ_LIST\n******************************************************************************/\nstatic XcpProtoErrorCode startStopDaqListInputPacketHandler(void   *msgBuffer,\n                                                            size_t  xcpPacketOffset,\n                                                            size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpStartStopDaqListCmdPacketFrame *frame = (XcpStartStopDaqListCmdPacketFrame *)packet;\n    XcpDaq *daqList = NULL;\n    int32_T daqListId = frame->daqListId;\n    boolean_T ok = false;\n    boolean_T locked = false;\n\n    /* Check if the DAQ List is available */\n    ok = (xcpDynamicDaqLists.daq != NULL) && (daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"START_STOP_DAQ_LIST: DAQ list %d not available\\n\", daqListId));\n\n    startStopDaqListId = daqListId;\n    daqList = &(xcpDynamicDaqLists.daq[daqListId]);\n\n    /* Check if requested mode is valid */\n    ok = isValidStartStopMode((uint8_T)frame->mode);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"START_STOP_DAQ_LIST: invalid mode %d selected \\n\", frame->mode));\n\n    /* Assign the Absolute ODT number */\n    if (absoluteOdtNumberIdentification()) {\n        if (daqList->status == XCP_DAQ_INIT) {\n            /* The DAQ list has never been started/stopped/selected before\n            -> PIDs for the ODTs needs to be reserved */\n            if (XCP_READ_BIT_VALUE(daqList->mode, XCP_DAQ_MODE_DIRECTION_MASK)) {\n                /* STIM */\n                ok = (daqList->odt != NULL) &&\n                       ((xcpDynamicDaqLists.firstAvailableStimPid +\n                        daqList->odtCount) <= XCP_MAX_STIM_ODT_NUMBER);\n\n                if (ok) {\n                    daqList->firstPid = xcpDynamicDaqLists.firstAvailableStimPid;\n                    xcpDynamicDaqLists.firstAvailableStimPid += daqList->odtCount;\n                }\n            }\n            else {\n                /* DAQ */\n                ok = (daqList->odt != NULL) &&\n                       ((xcpDynamicDaqLists.firstAvailableDaqPid +\n                        daqList->odtCount) <= XCP_MAX_DAQ_ODT_NUMBER);\n\n                if (ok) {\n                    daqList->firstPid = xcpDynamicDaqLists.firstAvailableDaqPid;\n                    xcpDynamicDaqLists.firstAvailableDaqPid += daqList->odtCount;\n                }\n            }\n\n            XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_CONFIG_ERROR,\n                (\"START_STOP_DAQ_LIST: cannot assign PIDs for DAQ list %d \\n\", daqListId));\n        }\n    }\n\n    /* Check the ODT configuration and also if the ODT sizes fits the Max DTO size */\n    if ((frame->mode == XCP_DAQ_LIST_START) || (frame->mode == XCP_DAQ_LIST_SELECT)) {\n        int i = 0;\n\n        ok = true;\n        for (i = 0; (i < daqList->odtCount) && ok; i++) {\n            int j = 0;\n            size_t odtSize = 0;\n\n            /* Calculate the resulting ODT size */\n            for (j = 0; j < daqList->odt[i].entriesCount; j++) {\n                odtSize += daqList->odt[i].entry[j].size;\n            }\n\n            /* Check that the resulting ODT size is valid */\n            if (IS_TIMESTAMP_REQUIRED(daqList->mode, i)){\n                ok = (XCP_IN_BYTES(odtSize * daqList->sampleCount + XCP_IN_AG(XCP_ID_FIELD_SIZE)) + XCP_TIMESTAMP_SIZE) <= xcpTransportMaxDtoSize();\n            }\n            else{\n                ok = (XCP_IN_BYTES(odtSize * daqList->sampleCount + XCP_IN_AG(XCP_ID_FIELD_SIZE))) <= xcpTransportMaxDtoSize();\n            }\n            XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_CONFIG_ERROR,\n                (\"START_STOP_DAQ_LIST: in DAQ list %d the ODT entries size is larger than Max DTO size for ODT %d \\n\", daqListId, i));\n\n            /* Update the ODT size */\n            daqList->odt[i].size = odtSize;\n        }\n    }\n\n    /* Everything is fine -> proceed and change the DAQ list status */\n    locked = xcpDaqWriteLock(daqList->eventId);\n\n    if (locked) {\n        XcpErrorCode createPoolError = XCP_SUCCESS;\n\n        switch (frame->mode) {\n        case XCP_DAQ_LIST_STOP:\n            XCP_PRINTF(\"START_STOP_DAQ_LIST: stopping DAQ list %d\\n\", daqListId);\n            daqList->status = XCP_DAQ_STOPPED;\n            if (noActiveDaqLists()) {\n                /* update status if this was the only active DAQ list */\n                xcpStatusSet(XCP_CONNECTED);\n                xcpSessionStatusClearMask(XCP_SESSION_DAQ_RUNNING_MASK);\n            }\n            break;\n\n        case XCP_DAQ_LIST_START:\n            XCP_PRINTF(\"START_STOP_DAQ_LIST: starting DAQ list %d\\n\", daqListId);\n\n            /* daqList->poolId is initialized with XCP_INVALID_POOL_ID in\n               allocDaqInputPacketHandler.\n\n               Allocate a reserved memory pool for the DAQ list, if needed. */\n            if (daqList->poolId == XCP_INVALID_POOL_ID) {\n                if (IS_USING_CUSTOM_POOL(daqList->eventId)) {\n                    /* Forward custom memory information to the memory manager */\n                    createPoolError = xcpMemCustomPoolCreate(\n                                          xcpEventCustomMemoryManager.allocHandler, \n                                          xcpEventCustomMemoryManager.freeHandler,\n                                          &daqList->poolId);\n                } else if (daqListId < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER\n                    && daqList->eventId < XCP_MIN_EVENT_NO_RESERVED_POOL) {\n                    /* Create a reserved memory pool, if not already created */\n                    createPoolError = createDaqReservedPool(daqList);\n                    daqList->currentSample = 0;\n                }\n            }\n\n            if (createPoolError == XCP_SUCCESS) {\n                daqList->status = XCP_DAQ_STARTED;\n                xcpStatusSet(XCP_SYNC_DATA_TRANSFER);\n                xcpSessionStatusSetMask(XCP_SESSION_DAQ_RUNNING_MASK);\n            }\n            break;\n\n        case XCP_DAQ_LIST_SELECT:\n            XCP_PRINTF(\"START_STOP_DAQ_LIST: selected DAQ list %d\\n\", frame->daqListId);\n            daqList->status = XCP_DAQ_SELECTED;\n            break;\n        }\n\n        xcpDaqWriteUnlock(daqList->eventId);\n\n        *outputPacketSize = XCP_START_STOP_DAQ_LIST_RES_PACKET_SIZE_IN_BYTES;\n        XCP_INPUT_PKT_ERROR_IF(createPoolError != XCP_SUCCESS, XCP_PROTO_MEMORY_OVERFLOW,\n                (\"START_STOP_DAQ_LIST: cannot allocate reserved memory pool for the DAQ list\\n\"));\n    }\n\n    /* Error if the command cannot be executed as the processing of\n       at least one event was in progress */\n    XCP_INPUT_PKT_ERROR_IF(!locked, XCP_PROTO_BUSY,\n        (\"START_STOP_DAQ_LIST: cannot be carried out as an event was processed\\n\"));\n\n    return protoErrorCode;\n}\n\nstatic void startStopDaqListOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    if (inputCode == XCP_PROTO_SUCCESS) {\n        XcpStartStopDaqListResPacketFrame *frame = (XcpStartStopDaqListResPacketFrame *)packet;\n\n        /* Fill the response */\n        frame->PID      = XCP_PID_RES;\n        frame->firstPid = xcpDynamicDaqLists.daq[startStopDaqListId].firstPid;\n    }\n    else {\n        genericOutputPacketHandler(inputCode, packet, packetSize);\n    }\n}\n\n/*****************************************************************************\n    XCP START_STOP_SYNCH\n******************************************************************************/\nstatic XcpProtoErrorCode startStopSynchInputPacketHandler(void   *msgBuffer,\n                                                          size_t  xcpPacketOffset,\n                                                          size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpStartStopSynchCmdPacketFrame *frame = (XcpStartStopSynchCmdPacketFrame *)packet;\n    boolean_T ok = false;\n    boolean_T locked = false;\n    int32_T i = 0;\n\n    /* Check if requested mode is valid */\n    ok = isValidStartStopSynchMode((uint8_T)frame->mode);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"START_STOP_SYNCH: invalid mode %d selected \\n\", frame->mode));\n\n    /* Check if the DAQ Lists are available */\n    ok = (xcpDynamicDaqLists.daq != NULL) && (xcpDynamicDaqLists.daqCount > 0);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"START_STOP_SYNCH: DAQ lists not available\\n\"));\n\n    /* Everything is fine -> proceed and try to change the DAQ list status */\n\n    /* Need to get the lock to guarantee that they are all done in the same cycle */\n    locked = xcpDaqLock();\n\n    if (locked) {\n        XcpErrorCode createPoolError = XCP_SUCCESS;\n        uint16_T daqListId = 0;\n\n        switch (frame->mode) {\n        case XCP_DAQ_LIST_STOP_ALL:\n            for (i = 0; i < xcpDynamicDaqLists.daqCount; i++) {\n                if (xcpDynamicDaqLists.daq[i].status != XCP_DAQ_INIT) {\n                    XCP_PRINTF(\"START_STOP_SYNCH: stopping DAQ list %d\\n\", i);\n                    xcpDynamicDaqLists.daq[i].status = XCP_DAQ_STOPPED;\n                }\n            }\n\n            /* update status as there are no more active DAQ list */\n            xcpStatusSet(XCP_CONNECTED);\n            xcpSessionStatusClearMask(XCP_SESSION_DAQ_RUNNING_MASK);\n            break;\n\n        case XCP_DAQ_LIST_START_SELECTED:\n            /* xcpDynamicDaqLists.daq[i].poolId is initialized with\n               XCP_INVALID_POOL_ID in allocDaqInputPacketHandler.\n\n               Allocate a reserved memory pool for the DAQ list, if needed. */\n            for (i = 0; (i < xcpDynamicDaqLists.daqCount) && (createPoolError == XCP_SUCCESS); i++) {\n                if ((xcpDynamicDaqLists.daq[i].status == XCP_DAQ_SELECTED) && \n                    (xcpDynamicDaqLists.daq[i].poolId == XCP_INVALID_POOL_ID)) {\n                    if (IS_USING_CUSTOM_POOL(xcpDynamicDaqLists.daq[i].eventId)) {\n                        /* Allocate custom pool if custom memory functions are\n                           provided for this eventId */\n                        createPoolError = xcpMemCustomPoolCreate(\n                                              xcpEventCustomMemoryManager.allocHandler,\n                                              xcpEventCustomMemoryManager.freeHandler,\n                                              &xcpDynamicDaqLists.daq[i].poolId);\n                    } else if (i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER\n                        && xcpDynamicDaqLists.daq[i].eventId < XCP_MIN_EVENT_NO_RESERVED_POOL) {\n                        /* Create a reserved memory pool, if not already created */\n                        createPoolError = createDaqReservedPool(&xcpDynamicDaqLists.daq[i]);\n                        xcpDynamicDaqLists.daq[i].currentSample = 0;\n                        daqListId = (uint16_T) i;\n                    }\n                }\n            }\n\n            if (createPoolError == XCP_SUCCESS) {\n                /* If the allocation went well for all the DAQ lists, start them */\n                for (i = 0; (i < xcpDynamicDaqLists.daqCount); i++) {\n                    if (xcpDynamicDaqLists.daq[i].status == XCP_DAQ_SELECTED) {\n                        XCP_PRINTF(\"START_STOP_SYNCH: starting DAQ list %d\\n\", i);\n\n                        xcpDynamicDaqLists.daq[i].status = XCP_DAQ_STARTED;\n                        xcpStatusSet(XCP_SYNC_DATA_TRANSFER);\n                        xcpSessionStatusSetMask(XCP_SESSION_DAQ_RUNNING_MASK);\n                    }\n                }\n            }\n            break;\n\n        case XCP_DAQ_LIST_STOP_SELECTED:\n            for (i = 0; i < xcpDynamicDaqLists.daqCount; i++) {\n                if (xcpDynamicDaqLists.daq[i].status == XCP_DAQ_SELECTED) {\n                    XCP_PRINTF(\"START_STOP_SYNCH: stopping DAQ list %d\\n\", i);\n                    xcpDynamicDaqLists.daq[i].status = XCP_DAQ_STOPPED;\n                }\n            }\n\n            if (noActiveDaqLists()) {\n                /* update status if this was the only active DAQ list */\n                xcpStatusSet(XCP_CONNECTED);\n                xcpSessionStatusClearMask(XCP_SESSION_DAQ_RUNNING_MASK);\n            }\n            break;\n        }\n\n        /* Unlock all the events */\n        xcpDaqUnlock();\n\n        (void)daqListId; /* to suppress unused-but-set-variable when XCP_PRINTF is empty */\n        XCP_INPUT_PKT_ERROR_IF(createPoolError != XCP_SUCCESS, XCP_PROTO_MEMORY_OVERFLOW,\n                (\"START_STOP_SYNCH: cannot allocate reserved memory pool for the DAQ list %d\\n\", daqListId));\n\n        *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n    }\n\n    /* Error if the command cannot be executed as the processing of\n       at least one event was in progress */\n    XCP_INPUT_PKT_ERROR_IF(!locked, XCP_PROTO_BUSY,\n        (\"START_STOP_SYNCH: cannot be carried out as an event was processed\\n\"));\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP GET DAQ PROCESSOR INFO\n******************************************************************************/\nstatic XcpProtoErrorCode getDaqProcessorInfoInputPacketHandler(void   *msgBuffer,\n                                                               size_t  xcpPacketOffset,\n                                                               size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"GET DAQ PROCESSOR INFO\\n\");\n\n    *outputPacketSize =  XCP_GET_DAQ_PROCESSOR_INFO_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SUCCESS;\n}\n\nstatic void getDaqProcessorInfoOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    XcpGetDaqProcessorInfoResPacketFrame *frame = (XcpGetDaqProcessorInfoResPacketFrame *)packet;\n\n    XCP_UNUSED_PARAM(inputCode);\n    XCP_UNUSED_PARAM(packetSize);\n\n    /* Fill Get Daq Processor Info response */\n    XCP_MEMSET(frame, 0, sizeof(*frame));\n\n    frame->PID = XCP_PID_RES;\n    frame->daqProperties = XCP_DAQ_PROPERTIES_VALUE;\n    frame->maxDaq = XCP_MAX_DAQ;\n    frame->maxEventChannel = XCP_MAX_EVENT_CHANNEL;\n    frame->minDaq = XCP_MIN_DAQ;\n    frame->daqKeyByte = XCP_DAQ_KEY_VALUE;\n\n    XCP_PRINTF(\"* DAQ Properties:    %xH\\n\", frame->daqProperties);\n    XCP_PRINTF(\"* MAX_DAQ:           %d\\n\", frame->maxDaq);\n    XCP_PRINTF(\"* MAX_EVENT_CHANNEL: %d\\n\", frame->maxEventChannel);\n    XCP_PRINTF(\"* MIN_DAQ:           %d\\n\", frame->minDaq);\n    XCP_PRINTF(\"* Daq Key Byte:      %xH\\n\", frame->daqKeyByte);\n}\n\n/*****************************************************************************\n    XCP GET DAQ RESOLUTION INFO\n******************************************************************************/\nstatic XcpProtoErrorCode getDaqResolutionInfoInputPacketHandler(void   *msgBuffer,\n    size_t  xcpPacketOffset,\n    size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"GET DAQ RESOLUTION INFO\\n\");\n\n    *outputPacketSize = XCP_GET_DAQ_RESOLUTION_INFO_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SUCCESS;\n}\n\nstatic void getDaqResolutionInfoOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    XcpGetDaqResolutionInfoResPacketFrame *frame = (XcpGetDaqResolutionInfoResPacketFrame *)packet;\n\n    XCP_UNUSED_PARAM(inputCode);\n    XCP_UNUSED_PARAM(packetSize);\n\n    /* Fill Get Daq Resolution Info response */\n    XCP_MEMSET(frame, 0, sizeof(*frame));\n\n    frame->PID = XCP_PID_RES;\n\n    /* @note in the current version the same limits apply for DAQ and STIM */\n    frame->daqOdtEntrySizeGranularity = XCP_ODT_ENTRY_SIZE_GRANULARITY;\n    frame->maxDaqOdtEntrySize = XCP_MAX_ODT_ENTRY_SIZE;\n    frame->stimOdtEntrySizeGranularity = XCP_ODT_ENTRY_SIZE_GRANULARITY;\n    frame->maxStimOdtEntrySize = XCP_MAX_ODT_ENTRY_SIZE;\n    frame->timestampMode = XCP_TIMESTAMP_MODE_VALUE;\n    frame->timestampTicks = XCP_TIMESTAMP_TICKS;\n\n    XCP_PRINTF(\"* DAQ ODT Entry size granularity:   %d\\n\",  frame->daqOdtEntrySizeGranularity);\n    XCP_PRINTF(\"* Max DAQ ODT Entry size:           %d\\n\",  frame->maxDaqOdtEntrySize);\n    XCP_PRINTF(\"* STIM ODT Entry size granularity:  %d\\n\",  frame->stimOdtEntrySizeGranularity);\n    XCP_PRINTF(\"* Max STIM ODT Entry size:          %d\\n\",  frame->maxStimOdtEntrySize);\n    XCP_PRINTF(\"* Timestamp Mode =                  %xH\\n\", frame->timestampMode);\n    XCP_PRINTF(\"* Timestamp Ticks =                 %d\\n\",  frame->timestampTicks);\n}\n\n/*****************************************************************************\n    XCP FREE_DAQ\n******************************************************************************/\nstatic XcpProtoErrorCode freeDaqInputPacketHandler(void   *msgBuffer,\n                                                   size_t  xcpPacketOffset,\n                                                   size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    boolean_T ok = false;\n\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"FREE_DAQ: clearing existing dynamic DAQ lists\\n\");\n    ok = xcpResetDaqListStatus();\n\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_BUSY,\n        (\"FREE_DAQ: cannot be carried out as an event was processed\\n\"));\n\n    /* No DAQ lists are running -> XCP_SYNC_DATA_TRANSFER cannot be active anymore */\n    xcpStatusSet(XCP_CONNECTED);\n\n    /* Everything is fine -> send positive response */\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP ALLOC_DAQ\n******************************************************************************/\nstatic XcpProtoErrorCode allocDaqInputPacketHandler(void   *msgBuffer,\n                                                    size_t  xcpPacketOffset,\n                                                    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpAllocDaqCmdPacketFrame *frame = (XcpAllocDaqCmdPacketFrame *) packet;\n    int32_T daqCount = (uint16_T)frame->daqCount;\n    XcpDaq *daq = NULL;\n    boolean_T ok = false;\n    int i = 0;\n\n    /* Check if DAQ lists have already been allocated */\n    ok = xcpDynamicDaqLists.daq == NULL;\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_DAQ: sequence error detected, DAQ lists already allocated\\n\"));\n\n    /* Check if the number of DAQ lists requested is supported */\n    ok = (daqCount > 0) && (daqCount <= (XCP_MAX_DAQ - XCP_MIN_DAQ));\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_DAQ: invalid number of DAQ lists (%d)\\n\", daqCount));\n\n    XCP_PRINTF(\"ALLOC_DAQ: allocating %d DAQ lists (%lu B)\\n\", daqCount, (unsigned long) ((size_t)daqCount * sizeof(XcpDaq)));\n\n    /* Proceed and allocate the DAQ lists */\n    daq = (XcpDaq *)xcpMemAlloc((size_t) daqCount * sizeof(XcpDaq));\n    XCP_INPUT_PKT_ERROR_IF(daq == NULL, XCP_PROTO_MEMORY_OVERFLOW,\n        (\"ALLOC_DAQ: not enough memory to allocate %d DAQ lists\\n\", daqCount));\n\n    XCP_MEMSET(daq, 0, (size_t)daqCount * sizeof(XcpDaq));\n\n    /* Make sure that the DAQ lists are available for use */\n    xcpDynamicDaqLists.daq = daq;\n    xcpDynamicDaqLists.daqCount = (uint16_T) daqCount;\n\n    for (i = 0; i < daqCount; i++) {\n        daq[i].poolId        = XCP_INVALID_POOL_ID;\n        daq[i].packedMode    = XCP_DAQ_DATA_NOT_PACKED;\n        daq[i].timestampMode = XCP_DAQ_SINGLE_TIMESTAMP_FIRST_SAMPLE;\n        daq[i].sampleCount   = 1;\n        daq[i].currentSample = 0;\n    }\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP ALLOC_ODT\n******************************************************************************/\nstatic XcpProtoErrorCode allocOdtInputPacketHandler(void   *msgBuffer,\n                                                    size_t  xcpPacketOffset,\n                                                    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpAllocOdtCmdPacketFrame *frame = (XcpAllocOdtCmdPacketFrame *)packet;\n    uint16_T daqListId = (uint16_T)frame->daqListId;\n    uint8_T  odtCount  = (uint8_T)frame->odtCount;\n    boolean_T ok = false;\n\n    /* Check if DAQ lists have already been allocated */\n    ok = (xcpDynamicDaqLists.daq != NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT: sequence error detected, DAQ lists not allocated\\n\"));\n\n    /* Check if the DAQ List Id is valid */\n    ok = (daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT: DAQ list id %d is out of range\\n\", daqListId));\n\n    /* Check if the number of ODTs is valid */\n    ok = (odtCount > 0) && (odtCount <= XCP_MAX_DAQ_ODT_NUMBER);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT: invalid number of ODT (%d) for DAQ list id %d\\n\", odtCount, daqListId));\n\n    /* Check if the ODTs have already been allocated */\n    ok = (xcpDynamicDaqLists.daq[daqListId].odt == NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT: sequence error detected, ODT already allocated\\n\"));\n\n    XCP_PRINTF(\"ALLOC_ODT: allocating %d ODTs in DAQ list %d (%lu B)\\n\",\n        odtCount, daqListId, (unsigned long)(odtCount * sizeof(XcpOdt)));\n\n    /* Everything is fine -> proceed and allocate the ODTs */\n    xcpDynamicDaqLists.daq[daqListId].odt = (XcpOdt *)xcpMemAlloc(odtCount * sizeof(XcpOdt));\n    XCP_INPUT_PKT_ERROR_IF(xcpDynamicDaqLists.daq[daqListId].odt == NULL, XCP_PROTO_MEMORY_OVERFLOW,\n        (\"ALLOC_ODT: not enough memory to allocate %d ODT in DAQ list %d\\n\", odtCount, daqListId));\n\n    XCP_MEMSET(xcpDynamicDaqLists.daq[daqListId].odt, 0, odtCount * sizeof(XcpOdt));\n\n    xcpDynamicDaqLists.daq[daqListId].odtCount = odtCount;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP ALLOC_ODT_ENTRY\n******************************************************************************/\nstatic XcpProtoErrorCode allocOdtEntryInputPacketHandler(void   *msgBuffer,\n    size_t  xcpPacketOffset,\n    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpAllocOdtEntryCmdPacketFrame *frame = (XcpAllocOdtEntryCmdPacketFrame *)packet;\n    uint16_T daqListId       = (uint16_T)frame->daqListId;\n    uint8_T  odtId           = (uint8_T)frame->odtId;\n    uint8_T  odtEntriesCount = (uint8_T)frame->odtEntriesCount;\n    boolean_T ok = false;\n\n    /* Check if the DAQ lists have already been allocated */\n    ok = (xcpDynamicDaqLists.daq != NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT_ENTRY: sequence error detected, DAQ lists not allocated\\n\"));\n\n    /* Check if the DAQ List Id is valid */\n    ok = (daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT_ENTRY: DAQ list id %d is out of range\\n\", daqListId));\n\n    /* Check if the ODTs have already been allocated */\n    ok = (xcpDynamicDaqLists.daq[daqListId].odt != NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT_ENTRY: sequence error detected, ODTs not allocated\\n\"));\n\n    /* Check if the ODT Id is valid */\n    ok = (odtId < xcpDynamicDaqLists.daq[daqListId].odtCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT_ENTRY: ODT id %d is out of range\\n\", odtId));\n\n    /* Check if the ODT entries have already been allocated */\n    ok = (xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry == NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"ALLOC_ODT_ENTRY: sequence error detected, ODT Entries already allocated\\n\"));\n\n    /* Check if the number of ODT Entries is valid */\n    ok = (odtEntriesCount > 0);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"ALLOC_ODT_ENTRY: invalid number of ODT entries (%d) for ODT %d in DAQ list %d\\n\", odtEntriesCount, odtId, daqListId));\n\n    XCP_PRINTF(\"ALLOC_ODT_ENTRY: allocating %d ODT Entries in DAQ list %d ODT %d (%lu B)\\n\", \n        odtEntriesCount, daqListId, odtId, (unsigned long)(odtEntriesCount * sizeof(XcpOdtEntry)));\n\n    /* Everything is fine -> proceed and allocate the ODT entries */\n    xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry = (XcpOdtEntry *)xcpMemAlloc(odtEntriesCount * sizeof(XcpOdtEntry));\n\n    XCP_INPUT_PKT_ERROR_IF(xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry == NULL, XCP_PROTO_MEMORY_OVERFLOW,\n        (\"ALLOC_ODT_ENTRY: not enough memory to allocate %d ODT in DAQ list %d ODT %d\\n\", odtEntriesCount, daqListId, odtId));\n\n    XCP_MEMSET(xcpDynamicDaqLists.daq[daqListId].odt[odtId].entry, 0, odtEntriesCount * sizeof(XcpOdtEntry));\n\n    xcpDynamicDaqLists.daq[daqListId].odt[odtId].entriesCount = odtEntriesCount;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\n/*****************************************************************************\n    XCP GET DAQ CLOCK\n******************************************************************************/\n\nstatic XcpProtoErrorCode getDaqClockInputPacketHandler(void *msgBuffer,\n                                                       size_t xcpPacketOffset,\n                                                       size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n    *outputPacketSize = XCP_ERROR_PACKET_SIZE_IN_BYTES;\n    return XCP_PROTO_RESOURCE_NOT_ACCESSIBLE;\n}\n\n/*****************************************************************************\n    XCP LEVEL1 COMMAND\n******************************************************************************/\n\n/* The only supported Level 1 command is SET DAQ PACKED MODE */\nstatic XcpProtoErrorCode setDaqPackedModeInputPacketHandler(void   *msgBuffer,\n                                                            size_t  xcpPacketOffset,\n                                                            size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpSetDaqPackedModeCmdPacketFrame *frame = (XcpSetDaqPackedModeCmdPacketFrame *)packet;\n    uint16_T daqListId        = (uint16_T) frame->daqListId;\n    uint8_T  daqPackedMode    = (uint8_T)  frame->daqPackedMode;\n    uint8_T  dpmTimestampMode = (uint8_T)  frame->dpmTimestampMode;\n    uint16_T dpmSampleCount   = (uint16_T) frame->dpmSampleCount;\n    boolean_T ok = true;\n\n    /* Check if the DAQ lists have already been allocated */\n    ok = (xcpDynamicDaqLists.daq != NULL);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_SEQUENCE_ERROR,\n        (\"SET_DAQ_PACKED_MODE: sequence error detected, DAQ lists not allocated\\n\"));\n\n    /* Check if the DAQ List Id is valid */\n    ok = (daqListId < xcpDynamicDaqLists.daqCount);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"SET_DAQ_PACKED_MODE: DAQ list id %d is out of range\\n\", daqListId));\n\n#if XCP_MEM_DAQ_RESERVED_POOLS_NUMBER > 0\n    /* DAQ Packed Mode is only supported for DAQ lists with a reserved memory pool */\n    ok = (daqListId < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"SET_DAQ_PACKED_MODE: packed mode is not supported for DAQ list id %d, with no reserved memory pool\\n\", daqListId));\n#else\n    ok = false;\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"SET_DAQ_PACKED_MODE: packed mode is not supported for DAQ list id %d, with no reserved memory pool\\n\", daqListId));\n#endif\n\n    /* Check if the selected DAQ packed mode is valid. \n       Currently we only support event-grouped data packing */\n    ok = ((daqPackedMode == XCP_DAQ_DATA_NOT_PACKED) || \n          (daqPackedMode == XCP_DAQ_EVENT_GROUPED_PACKING));\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"SET_DAQ_PACKED_MODE: DAQ Packed mode %d is not supported\\n\", daqPackedMode));\n\n    /* Check if the selected DAQ Timestamp mode is valid. \n       Currently we only support single timestamp of the first sample */\n    ok = (dpmTimestampMode == XCP_DAQ_SINGLE_TIMESTAMP_FIRST_SAMPLE);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"SET_DAQ_PACKED_MODE: DAQ Packed timestamp mode %d is not supported\\n\", dpmTimestampMode));\n\n    /* Check if the selected DAQ Packed sample count is valid. */\n    ok = ((daqPackedMode == XCP_DAQ_DATA_NOT_PACKED && (dpmSampleCount == 1)) ||\n         ((daqPackedMode != XCP_DAQ_DATA_NOT_PACKED) && (dpmSampleCount >= XCP_DAQ_PACKED_SAMPLE_COUNT_MIN)));\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_MODE_NOT_VALID,\n        (\"SET_DAQ_PACKED_MODE: DAQ Packed sample count %d is not supported.\\n\", dpmSampleCount));\n\n    /* Check that the DAQ list is not already running */\n    ok = !isActiveDaqList(daqListId);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_DAQ_ACTIVE,\n        (\"SET_DAQ_PACKED_MODE: packed mode configuration cannot be changed if the DAQ is running.\\n\"));\n\n    /* Finally: select the new configuration */\n    XCP_PRINTF(\"SET_DAQ_PACKED_MODE: setting packed mode %d timestamp mode %d sample count %d\\n\", \n               daqPackedMode, dpmTimestampMode, dpmSampleCount);\n\n    xcpDynamicDaqLists.daq[daqListId].packedMode    = daqPackedMode;\n    xcpDynamicDaqLists.daq[daqListId].timestampMode = dpmTimestampMode;\n    xcpDynamicDaqLists.daq[daqListId].sampleCount   = dpmSampleCount;\n    xcpDynamicDaqLists.daq[daqListId].currentSample = 0;\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\nstatic XcpProtoErrorCode level1CommandInputPacketHandler(void  *msgBuffer,\n                                                        size_t  xcpPacketOffset,\n                                                        size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    XcpLevel1CommandPacketFrame* command = (XcpLevel1CommandPacketFrame*) ((uint8_T *)msgBuffer + xcpPacketOffset);\n    boolean_T ok = (command->level1Code == XCP_DAQ_LEVEL1_CODE_SET_DAQ_PACKED_MODE);\n\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_CMD_UNKNOWN,\n        (\"DAQ LEVEL1 COMMAND: command code %d is not supported\\n\", command->level1Code));\n\n    /* The only supported Level 1 command is SET_DAQ_PACKED_MODE */\n    protoErrorCode = setDaqPackedModeInputPacketHandler(msgBuffer, xcpPacketOffset, outputPacketSize);\n\n    return protoErrorCode;\n}\n\n\n/** This table contains the list of supported Rx packets and the corresponding handlers */\nstatic const XcpPacketHandlers daqSupportedRxPacket[] =\n{\n    { XCP_PID_START_STOP_DAQ_LIST,     startStopDaqListInputPacketHandler,     startStopDaqListOutputPacketHandler },\n    { XCP_PID_START_STOP_SYNCH,        startStopSynchInputPacketHandler,       genericOutputPacketHandler },\n    { XCP_PID_GET_DAQ_PROCESSOR_INFO,  getDaqProcessorInfoInputPacketHandler,  getDaqProcessorInfoOutputPacketHandler},\n    { XCP_PID_GET_DAQ_RESOLUTION_INFO, getDaqResolutionInfoInputPacketHandler, getDaqResolutionInfoOutputPacketHandler },\n    { XCP_PID_SET_DAQ_PTR,             setDaqPtrInputPacketHandler,            genericOutputPacketHandler },\n    { XCP_PID_WRITE_DAQ,               writeDaqInputPacketHandler,             genericOutputPacketHandler },\n    { XCP_PID_SET_DAQ_LIST_MODE,       setDaqListModeInputPacketHandler,       genericOutputPacketHandler },\n    { XCP_PID_FREE_DAQ,                freeDaqInputPacketHandler,              genericOutputPacketHandler },\n    { XCP_PID_ALLOC_DAQ,               allocDaqInputPacketHandler,             genericOutputPacketHandler },\n    { XCP_PID_ALLOC_ODT,               allocOdtInputPacketHandler,             genericOutputPacketHandler },\n    { XCP_PID_ALLOC_ODT_ENTRY,         allocOdtEntryInputPacketHandler,        genericOutputPacketHandler },\n    { XCP_PID_GET_DAQ_CLOCK,           getDaqClockInputPacketHandler,          genericOutputPacketHandler },\n    { XCP_PID_LEVEL1_COMMAND,          level1CommandInputPacketHandler,        genericOutputPacketHandler }\n};\n\n\n\n/*****************************************************************************\n    XCP Packet Lookup Function for basic DAQ commands\n******************************************************************************/\n\n/* Default DAQ Packet Lookup function, supporting only basic commands\n   listed in the table above */\nstatic const XcpPacketHandlers* getPacket(XcpRxPidCode pid)\n{\n    return xcpFindPacket(pid, daqSupportedRxPacket,\n                         XCP_ELEMENTS_NUMBER(daqSupportedRxPacket));\n}\n\nstatic XcpPacketLookupFunction packetLookup = NULL;\n\n\n\n/*****************************************************************************\n    Public Functions (invoked within the Protocol Layer)\n******************************************************************************/\nvoid xcpDaqInit(void)\n{\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n    XCP_MUTEX_INIT(daqLock);\n#else\n    uint16_T i = 0;\n\n    /* Initialize Event locks */\n    for (i = 0; i < XCP_MAX_EVENT_DATA_NUMBER; i++) {\n        XCP_MUTEX_INIT(xcpEventData[i].lock);\n    }\n#endif\n\n    xcpRunningEventCounter = 0;\n    XCP_MEMSET(&xcpDynamicDaqLists, 0, sizeof(xcpDynamicDaqLists));\n\n    /* Initialize the packet lookup function to support only basic\n       DAQ commands */\n    xcpDaqSetPacketLookup(getPacket);\n\n    /* Initialize support for the extended list of DAQ commands\n       @note this may override the default Packet lookup function\n             by adding support for more (optional) commands */\n    xcpDaqExtendedInit();\n}\n\n\nXcpPacketLookupFunction xcpDaqGetPacketLookup(void)\n{\n    return packetLookup;\n}\n\n\nvoid xcpDaqSetPacketLookup(XcpPacketLookupFunction getPacketFcn)\n{\n    packetLookup = getPacketFcn;\n}\n\n/**\n Reset a DAQ list, deleting any partial packet associated with it. This can only happen if the DAQ\n list is using packed mode.\n*/\nstatic XcpErrorCode xcpResetDaq(uint16_T daqIndex) {\n    int i = 0;\n    XcpDaq *daq = NULL;\n\n    XCP_ERROR_IF(\n        xcpDynamicDaqLists.daq == NULL || xcpDynamicDaqLists.daqCount <= daqIndex,\n        XCP_INV_ARG,\n        \"xcpProcessDaq: invalid daqIndex\");\n\n    daq = &xcpDynamicDaqLists.daq[daqIndex];\n\n    /* Resetting only needs to do something if a DAQ list is using packed mode and has started\n        writing the packet */\n    if (!isDaqPackedModeEnabled(daqIndex) || daq->currentSample == 0) {\n        return XCP_SUCCESS;\n    }\n\n    for (i = 0; i < daq->odtCount; ++i) {\n        xcpMemFree(daq->odt[i].msgBuffer);\n    }\n\n    daq->currentSample = 0;\n\n    return XCP_SUCCESS;\n}\n\n/**\n Writes xcp data needed at the beginning of an XCP packet for the given ODT. `currentValuePtr` and\n `offsetBytes` are updated accordingly.\n @note The current implementation only supports absolute ODT number.\n*/\nstatic void daqWriteXCPDataForOdt(XcpDaq* daq, uint8_T odtNumber, uint32_T timestamp) {\n    XcpOdt *odt = &daq->odt[odtNumber];\n    uint8_T *packet = odt->currentValuePtr;\n\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n    odt->offsetBytes = (XCP_IN_AG(XCP_ID_FIELD_SIZE)) % XCP_HARDWARE_ADDRESS_GRANULARITY_BYTES_NUMBER;\n#else\n    /* Dummy variable used when we are not emulating as BYTE addressable target */\n    odt->offsetBytes = 0;\n#endif\n\n    /* Fill the Identification Field first\n    @note this is hard-coded to support absolute ODT number at the moment */\n    *packet = (uint8_T)(daq->firstPid + odtNumber);\n    packet = XCP_HW_PTR_INCREMENT(packet, XCP_IN_AG(XCP_ID_FIELD_SIZE), odt->offsetBytes);\n\n    /* Add the timestamp for the first DTO\n    @note this is hard-coded to support timestamp size of 4 bytes */\n    if (IS_TIMESTAMP_REQUIRED(daq->mode, odtNumber)) {\n    #ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n        size_t srcOffsetBytes = 0;\n        xcpMemcpyByte(packet, odt->offsetBytes, &timestamp, srcOffsetBytes, XCP_IN_HW_BYTES(sizeof(timestamp)));\n    #else\n        XCP_MEMCPY(packet, &timestamp, sizeof(timestamp));\n    #endif\n\n        packet = XCP_HW_PTR_INCREMENT(packet, XCP_IN_AG(XCP_TIMESTAMP_SIZE + odt->offsetBytes), odt->offsetBytes);\n        odt->offsetBytes = XCP_HW_BYTE_OFFSET_UPDATE(odt->offsetBytes, XCP_IN_AG(XCP_TIMESTAMP_SIZE));\n    }\n    odt->currentValuePtr = packet;\n}\n\n/**\n Writes the value of the entries for the given ODT, at the memory pointed by `currentValuePtr` and\n `offsetBytes`, which are updated accordingly.\n*/\nstatic void odtWriteEntries(XcpOdt *odt) {\n    uint8_T entryIndex = 0;\n    uint8_T *packet = odt->currentValuePtr;\n\n    for (entryIndex = 0; entryIndex < odt->entriesCount; ++entryIndex) {\n        XcpOdtEntry *entry = &(odt->entry[entryIndex]);\n        uint8_T const* address = XCP_ADDRESS_GET_READ(entry->addressExtension, entry->address);\n\n        if (entry->bitOffset != 0xFF) {\n            /* Bitwise access has been selected */\n        #ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n            uint32_T dword;\n            uint8_T bitValue;\n            size_t srcOffsetBytes = XCP_BYTE_OFFSET_GET(entry->address);\n            xcpMemcpyByte(&dword, 0, address, srcOffsetBytes, 4);\n            bitValue = (uint8_T) ((dword & ((uint32_T)(1 << entry->bitOffset))) != 0);\n            xcpMemcpyByte(packet, odt->offsetBytes, &bitValue, 0, entry->size);\n        #else\n            uint32_T const* dword = (uint32_T const*)address;\n            *packet = (uint8_T) ((*dword & ((uint32_T)(1 << entry->bitOffset))) != 0);\n        #endif\n        }\n        else {\n            /* 'Normal' (non-bitwise) access has been selected */\n        #ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n            size_t srcOffsetBytes = XCP_BYTE_OFFSET_GET(entry->address);\n            xcpMemcpyByte(packet, odt->offsetBytes, address, srcOffsetBytes, entry->size);\n        #else\n            XCP_MEMCPY(packet, address, entry->size);\n        #endif\n        }\n\n        packet = XCP_HW_PTR_INCREMENT(packet, entry->size + odt->offsetBytes, odt->offsetBytes);\n        odt->offsetBytes = XCP_HW_BYTE_OFFSET_UPDATE(odt->offsetBytes, entry->size);\n    }\n\n    odt->currentValuePtr = packet;\n}\n\n/**\n Process a DAQ, allocate memory, write pid and timestamp if needed, and copies variables values in\n the XCP packet.\n */\nstatic XcpErrorCode xcpProcessDaq(uint16_T daqIndex, uint32_T timestamp, XcpTransportQueueType_T txQueue) {\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    boolean_T error = false;\n    XcpDaq *daq = NULL;\n    uint8_T odtIndex = 0;\n    boolean_T daqPackedModeEnabled = false;\n    boolean_T transmitRequest = false;\n\n    XCP_ERROR_IF(\n        xcpDynamicDaqLists.daq == NULL || xcpDynamicDaqLists.daqCount <= daqIndex,\n        XCP_INV_ARG,\n        \"xcpProcessDaq: invalid daqIndex\");\n\n    daq = &xcpDynamicDaqLists.daq[daqIndex];\n\n    daqPackedModeEnabled = isDaqPackedModeEnabled(daqIndex);\n    /* In packed Mode we only want to transmit when the expected number of \n        samples has been reached */\n    transmitRequest = !daqPackedModeEnabled ||\n                                ((daq->currentSample + 1) == daq->sampleCount);\n\n    /* @note prescaler is not supported at the moment */\n    for (odtIndex = 0; (odtIndex < daq->odtCount) && !error; odtIndex++) {\n        XcpOdt *odt = &daq->odt[odtIndex];\n        size_t packetOffset = xcpTransportPacketOffset();\n        size_t msgBufferSize = 0;\n\n        /* when packed mode is active the allocation occurs at the first sample */\n        boolean_T requestNewMessageBuffer = !daqPackedModeEnabled || (daq->currentSample == 0);\n\n        if (requestNewMessageBuffer) {\n            /* Calculate the required XCP packet size */\n            odt->packetSize = odtPacketSize(daq, odtIndex);\n\n            /* Calculate the overall message buffer */\n            msgBufferSize = xcpTransportMsgBufferSize(odt->packetSize, XCP_DTO);\n\n            if (daq->poolId != XCP_INVALID_POOL_ID) {\n                /* A dedicated memory pool is available */\n                odt->msgBuffer = (uint8_T *)xcpMemAllocFromPool(daq->poolId, msgBufferSize);\n            } else {\n                /* No memory pool available, use the Main memory instead */\n                odt->msgBuffer = (uint8_T *)xcpMemAlloc(msgBufferSize);\n            }\n\n            if (odt->msgBuffer != NULL) {\n                /* Allocation went well, set current pointer to the beginning of the XCP packet */\n                odt->currentValuePtr = odt->msgBuffer + packetOffset;\n\n                /* let's fill the PID and timestamp field if required */\n                daqWriteXCPDataForOdt(daq, odtIndex, timestamp);\n\n            } else {\n                /* An issue occurred during the memory allocation */\n                error = true;\n                errorCode = XCP_NO_MEMORY;\n            }\n        }\n\n        if (!error && (odt->msgBuffer != NULL)) {\n            if (!IS_USING_CUSTOM_POOL(daq->eventId)) {\n                odtWriteEntries(odt);\n            }\n\n            if (transmitRequest) {\n                /* Send the response back to the Transport Layer */\n                /* Calculate the overall message buffer */\n                msgBufferSize = xcpTransportMsgBufferSize(odt->packetSize, XCP_DTO);\n\n                errorCode = xcpTransportTxPacketSet(txQueue,\n                                                    daqIndex,\n                                                    odt->msgBuffer, msgBufferSize,\n                                                    packetOffset, odt->packetSize);\n                if (errorCode != XCP_SUCCESS) {\n                    xcpMemFree(odt->msgBuffer);\n                }\n            }\n        }\n    }\n\n    daq->currentSample = (daq->currentSample + 1) % daq->sampleCount;\n\n    return errorCode;\n}\n\nXcpErrorCode xcpDaqEvent(XcpEventIdType eventId, uint32_T timestamp, boolean_T resetSamples)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    /* The lock is used to protect against the concurrent execution of XCP commands\n    (within xcpRun()) that can modify the DAQ list data structures */\n    xcpDaqReadLock(eventId);\n\n    if ((xcpDynamicDaqLists.daq != NULL) && (xcpDynamicDaqLists.daqCount > 0)) {\n        uint16_T i = 0;\n        XcpDaq *daq = xcpDynamicDaqLists.daq;\n\n        for (i = 0; (i < xcpDynamicDaqLists.daqCount) && errorCode == XCP_SUCCESS; i++) {\n            if (!XCP_READ_BIT_VALUE(daq[i].mode, XCP_DAQ_MODE_DIRECTION_MASK) && /* it's a DAQ list */\n                (daq[i].status == XCP_DAQ_STARTED) &&                            /* it's running */\n                (daq[i].eventId == eventId)) {                                   /* and associated to this event */\n\n                boolean_T txReady = xcpTransportTxReady(XCP_TRANSPORT_TX_DEFAULT_QUEUE, i);\n                XcpTransportQueueType_T txQueue = txReady ? XCP_TRANSPORT_TX_DEFAULT_QUEUE :\n                                                            XCP_TRANSPORT_DEFERRED_TX_QUEUE;\n\n            #ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n                if (txReady &&\n                    (daq[i].poolId != XCP_INVALID_POOL_ID)) {\n                    /* If the Tx queue is ready, it is safe to flush the free memory,\n                        so that the deferred free blocks become available for subsequent allocations */\n                    xcpMemReservedPoolFlushFreeMem(daq[i].poolId);\n                }\n            #endif\n\n                if (resetSamples) {\n                    errorCode = xcpResetDaq(i);\n                } else {\n                    errorCode = xcpProcessDaq(i, timestamp, txQueue);\n                }\n\n                if (txReady) {\n                /* Trigger the transmission of the packets that have been enqueued\n                    for this DAQ list */\n                    xcpTransportTxTrigger(XCP_TRANSPORT_TX_DEFAULT_QUEUE, i);\n                }\n\n            }\n        }\n    }\n\n    xcpDaqReadUnlock(eventId);\n\n    return errorCode;\n}\n\nXcpErrorCode xcpDaqEventsFlush(uint32_T timestamp)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_UNUSED_PARAM(timestamp);\n\n    if (xcpDynamicDaqLists.daq != NULL) {\n        boolean_T locked = xcpDaqLock();\n\n        if (locked) {\n            XcpDaq  *daq = xcpDynamicDaqLists.daq;\n            int32_T  daqCount = xcpDynamicDaqLists.daqCount;\n            uint16_T i = 0;\n\n            for (i = 0; i < daqCount; i++) {\n                boolean_T daqPackedModeEnabled = isDaqPackedModeEnabled(i);\n\n                if (daqPackedModeEnabled &&\n                    (daq[i].status == XCP_DAQ_STARTED) &&\n                    (daq[i].currentSample > 0)) {\n                    \n                    boolean_T txReady = xcpTransportTxReady(XCP_TRANSPORT_TX_DEFAULT_QUEUE, i);\n                    XcpTransportQueueType_T txQueue = txReady ? XCP_TRANSPORT_TX_DEFAULT_QUEUE :\n                                                            XCP_TRANSPORT_DEFERRED_TX_QUEUE;\n                    uint16_T j = 0;\n\n                    for (j = 0; j < daq[i].odtCount; j++) {\n                        if (daq[i].odt[j].msgBuffer != NULL) {\n                            size_t msgBufferSize = xcpTransportMsgBufferSize(daq[i].odt[j].packetSize, XCP_DTO);\n                            size_t packetOffset = xcpTransportPacketOffset();\n                            uint8_T *packet = daq[i].odt[j].msgBuffer + packetOffset;\n                            size_t notInitializedDataSize = XCP_IN_HW_AG(daq[i].odt[j].packetSize) - \n                                                             ((size_t) (daq[i].odt[j].currentValuePtr - packet));\n\n                            XCP_MEMSET(daq[i].odt[j].currentValuePtr, 0, notInitializedDataSize);\n\n                            errorCode = xcpTransportTxPacketSet(txQueue,\n                                                                i,\n                                                                daq[i].odt[j].msgBuffer, msgBufferSize,\n                                                                packetOffset, daq[i].odt[j].packetSize);\n                            if (errorCode != XCP_SUCCESS) {\n                                xcpMemFree(daq[i].odt[j].msgBuffer);\n                            }\n\n                        }\n                    }\n\n                    daq[i].currentSample = 0;\n                }\n            }\n\n            xcpDaqUnlock();\n        } else {\n            errorCode = XCP_BUSY;\n        }\n    }\n\n    return errorCode;\n}\n\n\n\nboolean_T xcpDaqLock(void)\n{\n    boolean_T locked = true;\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n    locked = xcpDaqWriteLock(0);\n#else\n    XcpEventIdType i = 0;\n\n    for(i = 0; i < XCP_MAX_EVENT_DATA_NUMBER; i++) {\n        xcpDaqWriteLock(i);\n    }\n#endif\n    return locked;\n}\n\n\n/* Unlock DAQ list transmission */\nvoid xcpDaqUnlock(void)\n{\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n    xcpDaqWriteUnlock(0);\n#else\n    XcpEventIdType i = 0;\n\n    for(i = 0; i < XCP_MAX_EVENT_DATA_NUMBER; i++) {\n        /* Unlock in reverse order, to prevent deadlock */\n    \txcpDaqWriteUnlock(XCP_MAX_EVENT_DATA_NUMBER - 1 - i);\n    }\n#endif\n}\n\n\nboolean_T xcpResetDaqListStatus(void)\n{\n    boolean_T locked = true;\n\n    if (xcpDynamicDaqLists.daq != NULL) {\n        XcpDaq *daq = xcpDynamicDaqLists.daq;\n        int32_T  daqCount = xcpDynamicDaqLists.daqCount;\n\n        locked = xcpDaqLock();\n\n        if (locked) {\n            /* No events were processed, it's safe to remove the DAQ lists */\n            int32_T i = 0;\n            int32_T j = 0;\n\n            /* No events are currently running,\n               it's safe to remove the DAQ lists */\n            xcpDynamicDaqLists.daq = NULL;\n            xcpDynamicDaqLists.daqCount = 0;\n            xcpDynamicDaqLists.firstAvailableDaqPid = 0;\n            xcpDynamicDaqLists.firstAvailableStimPid = 0;\n            \n            /* Reset ID of the DAQ List selected by START_STOP_DAQ_LIST command */\n            startStopDaqListId = XCP_INVALID_DAQ_LIST_ID;\n\n            /* Let's release the locks */\n            xcpDaqUnlock();\n\n            /* Prepare the Transport Layer for subsequent connections\n               (by resetting the Frame Handler counters and deleting the\n               existing packets in TX/RX fifos) */\n            xcpTransportRestart();\n\n            /* Delete all the Dynamic DAQ data structures and\n               reserved  memory pools */\n            for (i = 0; i < daqCount; i++) {\n                if (IS_USING_CUSTOM_POOL(daq[i].eventId)) {\n                    xcpMemCustomPoolDestroy(daq[i].poolId);\n                } else if (i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER\n                 && daq[i].eventId < XCP_MIN_EVENT_NO_RESERVED_POOL) {\n                    destroyDaqReservedPool(&daq[i]);\n                }\n\n                if (daq[i].odt != NULL) {\n                    for (j = 0; j < daq[i].odtCount; j++) {\n                        if (daq[i].odt[j].entry != NULL) {\n                            xcpMemFree(daq[i].odt[j].entry);\n                        }\n                    }\n\n                    xcpMemFree(daq[i].odt);\n                }\n            }\n\n            xcpMemFree(daq);\n\n            xcpSessionStatusClearMask(XCP_SESSION_DAQ_RUNNING_MASK);\n        }\n    }\n\n    return locked;\n}\n\n\nvoid xcpDaqReset(void)\n{\n    xcpResetDaqListStatus();\n\n    /* reset support for the extended list of DAQ commands */\n    xcpDaqExtendedReset();\n\n    /* Restore the original value for the lookup function */\n    xcpDaqSetPacketLookup(NULL);\n\n#if !defined(XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK) || (XCP_DAQ_LIST_INDEPENDENT_EVENT_LOCK == 0)\n    XCP_MUTEX_INIT(daqLock);\n#else\n    {\n        uint16_T i = 0;\n\n        for (i = 0; i < XCP_MAX_EVENT_DATA_NUMBER; i++) {\n            XCP_MUTEX_INIT(xcpEventData[i].lock);\n        }\n    }\n#endif\n}\n\n\nXcpErrorCode xcpDaqSetCustomPoolMemoryManager(XcpEventIdType eventId, \n                                              XcpCustomAllocHandler allocHandler, \n                                              XcpCustomFreeHandler freeHandler)\n{\n    if (allocHandler == NULL || freeHandler == NULL) {\n        return XCP_INV_ARG;\n    }\n\n    xcpEventCustomMemoryManager.eventId = eventId;\n    xcpEventCustomMemoryManager.allocHandler = allocHandler;\n    xcpEventCustomMemoryManager.freeHandler = freeHandler;\n\n    return XCP_SUCCESS;\n}\n\n\nXcpErrorCode xcpDaqGetCustomPoolMemoryManager(XcpEventIdType *eventId,\n                                              XcpCustomAllocHandler *allocHandler,\n                                              XcpCustomFreeHandler *freeHandler)\n{\n    if (xcpEventCustomMemoryManager.eventId == XCP_DAQ_CUSTOM_MEMORY_INVALID_EVENT_ID) {\n        return XCP_NOT_INITIALIZED;\n    }\n    if (allocHandler == NULL || freeHandler == NULL) {\n        return XCP_INV_ARG;\n    }\n\n    *eventId = xcpEventCustomMemoryManager.eventId;\n    *allocHandler = xcpEventCustomMemoryManager.allocHandler;\n    *freeHandler = xcpEventCustomMemoryManager.freeHandler;\n\n    return XCP_SUCCESS;\n}\n\n\n#ifdef XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT\n\nXcpErrorCode xcpDaqGetOdtEntries(XcpEventIdType eventId, \n                                 XcpDaqDirection direction, \n                                 XcpOdtEntry* entries,\n                                 size_t* entriesNumber,\n                                 size_t maxEntriesNumber)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    XcpOdtEntry* currentEntry = entries;\n    size_t entriesCount = 0;\n    boolean_T memOverflow = false;\n\n    XCP_ERROR_IF(eventId >= XCP_MAX_EVENT_CHANNEL, XCP_INV_ARG, \"xcpDaqGetOdtEntries: invalid eventId\\n\");\n    XCP_ERROR_IF(direction != XCP_DIRECTION_DAQ, XCP_NOT_SUPPORTED, \"xcpDaqGetOdtEntries: direction not supported\\n\");\n    XCP_ERROR_IF(entries == NULL, XCP_INV_ARG, \"xcpDaqGetOdtEntries: invalid entries\\n\");\n    XCP_ERROR_IF(entriesNumber == NULL, XCP_INV_ARG, \"xcpDaqGetOdtEntries: invalid entriesNumber\\n\");\n    XCP_ERROR_IF(maxEntriesNumber == 0, XCP_INV_ARG, \"xcpDaqGetOdtEntries: invalid maxEntriesNumber\\n\");\n\n    /* Extract the ODT entries by navigating the whole DAQ List hierarchy */\n    if (xcpDynamicDaqLists.daq != NULL) {\n        uint16_T daqId = 0;\n        for (daqId = 0; (daqId < xcpDynamicDaqLists.daqCount) && !memOverflow; daqId++) {\n            XcpDaq *daq = &xcpDynamicDaqLists.daq[daqId];\n\n            if ((daq->eventId == eventId) &&\n                ((direction == XCP_DIRECTION_DAQ) &&\n                 !XCP_READ_BIT_VALUE(daq[daqId].mode, XCP_DAQ_MODE_DIRECTION_MASK)) &&\n                 isActiveDaqList(daqId)) {\n                /* only active DAQ lists are considered */\n                if (daq->odt != NULL) {\n                    uint8_T odtId = 0;\n\n                    for (odtId = 0; (odtId < daq->odtCount) && !memOverflow; odtId++) {\n                        XcpOdt *odt = &daq->odt[odtId];\n  \n                        if (odt->entry != NULL) {\n                            uint8_T entryId = 0;\n\n                            for (entryId = 0; (entryId < odt->entriesCount) && !memOverflow; entryId++) {\n                                XcpOdtEntry *odtEntry = &odt->entry[entryId];\n                                \n                                if (entriesCount < maxEntriesNumber) {\n                                    XCP_MEMCPY(currentEntry, odtEntry, sizeof(XcpOdtEntry));\n                                    currentEntry++;\n                                    entriesCount++;\n                                } else {\n                                    memOverflow = true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    /* update number of entries copied and error code */\n    *entriesNumber = entriesCount;\n    if (memOverflow) {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    return errorCode;\n}\n\n#endif /* XCP_INTERNAL_DAQ_CONFIG_ACCESS_SUPPORT */\n\n\n#ifndef XCP_DAQ_EXTENDED_SUPPORT\n\nvoid xcpDaqExtendedInit(void) {}\nvoid xcpDaqExtendedReset(void) {}\n\n#endif\n\n#endif\n"},{"name":"xcp_drv_rtiostream.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2024a/toolbox/coder/xcp/src/target/server/platform/default","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2023 The MathWorks, Inc.\n*\n* File: xcp_drv_rtiostream.c\n*\n* Abstract:\n*  Implementation of XCP driver based on rtIOStream\n*/\n\n#include \"rtiostream.h\"\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_drv.h\"\n\n#define INVALID_DRV_ID  -1\n\n/* Timeout expected for the reception of a packet, once the reception has started */\nstatic const uint32_T XCP_RECEIVE_PACKET_TIMEOUT_IN_MICROSECONDS  = 1000000L;  /* 1s */\n\n/* Delay before attempting the reception of new data */\nstatic const uint32_T XCP_RECEIVE_RETRY_TIME_IN_MICROSECONDS = 10L;  /* 10us */\n\n/* Timeout expected for the transmission of a packet, once the transmission has started */\nstatic const uint32_T XCP_SEND_PACKET_TIMEOUT_IN_MICROSECONDS = 2000000L;   /* 2s */\n\n/* Delay before attempting the transmission of new data */\nstatic const uint32_T XCP_SEND_RETRY_TIME_IN_MICROSECONDS = 10L;  /* 10us */\n\n\n/* According to the XCP standard, the XCP server only supports the connection\n   with one XCP Client at a time. The active connection is identified by\n   a specific drvID */\nstatic int drvID = INVALID_DRV_ID;\n\n\n/* If set to true, force the xcpDrvSend and xcpDrvRecv APIs to be blocking */\nstatic boolean_T  forceBlocking = false;\n\n\nXcpErrorCode xcpDrvOpen(\n    int   argc,\n    void *argv[]\n    )\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if (drvID != INVALID_DRV_ID) {\n        XCP_PRINTF(\"xcpDrvOpen: XCP driver already initialized\\n\");\n        return XCP_ERROR;\n    }\n\n    /* Open the actual communication channel */\n    drvID = rtIOStreamOpen(argc, argv);\n    if (drvID < 0) {\n        XCP_PRINTF(\"xcpDrvOpen: unable to open communication channel\\n\");\n        drvID = INVALID_DRV_ID;\n        errorCode = XCP_ERROR;\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvIoctl(XcpDrvIoctlCommand cmd)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_ERROR_IF((cmd != XCP_DRV_RESTORE_DEFAULT_BLOCKING_SETUP) &&\n                 (cmd != XCP_DRV_FORCE_BLOCKING), XCP_INV_ARG,\n                 \"xcpDrvIoctl: invalid command\\n\");\n\n    forceBlocking = (cmd == XCP_DRV_FORCE_BLOCKING);\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvSend(const void *src, size_t size)\n{\n    int ret = RTIOSTREAM_NO_ERROR;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t   sent = 0;\n    size_t sentBytesCounter = 0;\n    uint32_T elapsedTime = 0;\n    const uint8_T *dataPtr = NULL;\n    boolean_T done = false;\n\n    XCP_ERROR_IF(src == NULL, XCP_INV_ARG, \"xcpDrvSend: invalid src buffer\\n\");\n    XCP_ERROR_IF(size == 0, XCP_INV_ARG, \"xcpDrvSend: invalid size\\n\");\n    XCP_ERROR_IF(drvID == INVALID_DRV_ID, XCP_NOT_INITIALIZED, \"xcpDrvSend: XCP driver not initialized\\n\");\n\n    while (!done) {\n        dataPtr = (const uint8_T *)src + sentBytesCounter;\n        ret = rtIOStreamSend(drvID, dataPtr, (size - sentBytesCounter), &sent);\n\n        if (ret == RTIOSTREAM_NO_ERROR) {\n            if ((sent == 0) && (sentBytesCounter == 0) && !forceBlocking) {\n                /* This will only happen if the rtIOStreamSend function\n                   is non-blocking and we haven't started sending data yet */\n                errorCode = XCP_BUSY;\n            } else {\n                /* Send packet in progress, we need to complete it */\n                sentBytesCounter += sent;\n\n                done = (sentBytesCounter >= size) ;\n\n                if (!done) {\n                    if (elapsedTime >= XCP_SEND_PACKET_TIMEOUT_IN_MICROSECONDS) {\n                        errorCode = XCP_PKT_TX_TIMEOUT_ERROR;\n                    } else {\n                        XCP_SLEEP(0, XCP_SEND_RETRY_TIME_IN_MICROSECONDS);\n                        elapsedTime += XCP_SEND_RETRY_TIME_IN_MICROSECONDS;\n                    }\n                }\n            }\n        } else {\n            errorCode = XCP_ERROR;\n        }\n\n        done = done || (errorCode == XCP_BUSY) || (errorCode == XCP_ERROR) ||\n               (errorCode == XCP_PKT_TX_TIMEOUT_ERROR);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvRecv(void *dst, size_t size)\n{\n    int ret = RTIOSTREAM_NO_ERROR;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t receivedBytesCounter = 0;\n    size_t received = 0;\n    uint32_T elapsedTime = 0;\n    uint8_T *dataPtr = NULL;\n    boolean_T done = false;\n\n    XCP_ERROR_IF(dst == NULL, XCP_INV_ARG, \"xcpDrvRecv: invalid src buffer\\n\");\n    XCP_ERROR_IF(size == 0, XCP_INV_ARG, \"xcpDrvRecv: invalid size\\n\");\n    XCP_ERROR_IF(drvID == INVALID_DRV_ID, XCP_NOT_INITIALIZED, \"xcpDrvRecv: XCP driver not initialized\\n\");\n\n    while (!done) {\n        dataPtr = (uint8_T *)dst + receivedBytesCounter;\n\n        ret = rtIOStreamRecv(drvID, dataPtr, (size - receivedBytesCounter), &received);\n        if (ret == RTIOSTREAM_NO_ERROR) {\n            if ((received == 0) && (receivedBytesCounter == 0) && !forceBlocking) {\n                /* This will only happen if the rtIOStreamRecv function\n                   is non-blocking and we haven't started receiving data yet */\n                errorCode = XCP_EMPTY;\n            } else {\n                /* Receive packet in progress, we need to complete it */\n                receivedBytesCounter += received;\n                done = (receivedBytesCounter >= size);\n\n                if (!done) {\n                    if (elapsedTime >= XCP_RECEIVE_PACKET_TIMEOUT_IN_MICROSECONDS) {\n                        errorCode = XCP_PKT_RX_TIMEOUT_ERROR;\n                    } else {\n                        XCP_SLEEP(0, XCP_RECEIVE_RETRY_TIME_IN_MICROSECONDS);\n                        elapsedTime += XCP_RECEIVE_RETRY_TIME_IN_MICROSECONDS;\n                    }\n                }\n            }\n        }\n        else {\n            errorCode = XCP_ERROR;\n        }\n        \n        done = done || (errorCode == XCP_EMPTY) || (errorCode == XCP_ERROR) ||\n               (errorCode ==  XCP_PKT_RX_TIMEOUT_ERROR);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvRecvUnknownSize(void *dst, size_t *size, size_t maxSize)\n{\n    int ret = RTIOSTREAM_NO_ERROR;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t receivedBytes = 0;\n    uint8_T *dataPtr = NULL;\n\n    XCP_ERROR_IF(dst == NULL, XCP_INV_ARG, \"xcpDrvRecvUnknownSize: invalid dst buffer\\n\");\n    XCP_ERROR_IF(size == NULL, XCP_INV_ARG, \"xcpDrvRecvUnknownSize: invalid size pointer\\n\");\n    XCP_ERROR_IF(maxSize == 0, XCP_INV_ARG, \"xcpDrvRecvUnknownSize: invalid maxSize\\n\");\n    XCP_ERROR_IF(drvID == INVALID_DRV_ID, XCP_NOT_INITIALIZED, \"xcpDrvRecvUnknownSize: XCP driver not initialized\\n\");\n\n    dataPtr = (uint8_T *)dst;\n\n    ret = rtIOStreamRecv(drvID, dataPtr, maxSize, &receivedBytes);\n    if (ret == RTIOSTREAM_NO_ERROR) {\n        if (receivedBytes == 0) {\n            /* This will only happen if we haven't yet started receiving data */\n            errorCode = XCP_EMPTY;\n        }\n        else if (receivedBytes <= maxSize) {\n            /* Packet received. Hence, update the actual size */\n            *size = receivedBytes;\n            errorCode = XCP_SUCCESS;\n        }\n        else {\n            errorCode = XCP_ERROR;\n        }\n    }\n    else {\n        errorCode = XCP_ERROR;\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpDrvClose(void)\n{\n    int ret = RTIOSTREAM_NO_ERROR;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if (drvID == INVALID_DRV_ID) {\n        XCP_PRINTF(\"xcpDrvClose: XCP driver already closed\\n\");\n        return XCP_SUCCESS; /* Nothing to do: just printing out a warning message*/\n    }\n\n    ret = rtIOStreamClose(drvID);\n\n    if (ret == RTIOSTREAM_NO_ERROR) {\n        drvID = INVALID_DRV_ID;\n        errorCode = XCP_SUCCESS;\n    }\n    else {\n        errorCode = XCP_ERROR;\n    }\n\n    return errorCode;\n}\n\n"},{"name":"xcp_ext_classic_trigger.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2024a/toolbox/coder/xcp/src/target/ext_mode/src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2020-2023 The MathWorks, Inc.\n *\n * File: xcp_ext_classic_trigger.c\n *\n * Abstract:\n *  This file contains the implementation of the External Mode\n *  \"Classic Trigger\" logic.\n *\n */\n\n#include \"xcp_ext_classic_trigger.h\"\n#include \"xcp_ext_common.h\"\n\n#define EXTMODE_TRIG_BASE_RATE_EVENT_ID EXTMODE_BASE_RATE_EVENT_ID\n\n#define DEFAULT_XCP_CLASSIC_TRIGGER_DURATION 1000\n\n\n/* Global variables directly accessible by the XCP Client */\nextmodeEventId_T volatile xcpClassicTriggerEventId = 0;\n\nuint32_T volatile xcpClassicTriggerSignalAddress = 0;\nuint8_T volatile  xcpClassicTriggerSignalAddressExtension = 0;\n\nextmodeClassicTriggerSignal_T volatile xcpClassicTriggerLevel = 0;\n\nuint32_T volatile xcpClassicTriggerDuration = DEFAULT_XCP_CLASSIC_TRIGGER_DURATION;\nuint32_T volatile xcpClassicTriggerHoldOff  = 0;\nint32_T  volatile xcpClassicTriggerDelay    = 0;\n\nXcpClassicTriggerDirection volatile xcpClassicTriggerDirection = XCP_EXTMODE_TRIGGER_RISING;\n\n#if defined(EXTMODE_TRIG_ARMED_ON_START) && EXTMODE_TRIG_ARMED_ON_START == 0\nboolean_T volatile xcpClassicTriggerArmRequest = false;\n#else\n/* Classic Trigger is armed by default */\nboolean_T volatile xcpClassicTriggerArmRequest = true;\n#endif\n\nboolean_T volatile xcpClassicTriggerCancelRequest = false;\n\nXcpClassicTriggerSource volatile xcpClassicTriggerSource = XCP_EXTMODE_TRIGGER_MANUAL;\n\nXcpClassicTriggerMode volatile xcpClassicTriggerMode = XCP_EXTMODE_TRIGGER_NORMAL;\n\nXcpClassicTriggerStatus volatile xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n\n\nXCP_STATIC extmodeClassicTriggerSignal_T xcpOldSignalValue = 0;\nXCP_STATIC boolean_T                     xcpOldSignalValueAvailable = false;\n\nXCP_STATIC XcpClassicTriggerSource       xcpOldClassicTriggerSource = XCP_EXTMODE_TRIGGER_MANUAL;\n\nXCP_STATIC boolean_T                     xcpTriggerEnabled = false;\nXCP_STATIC boolean_T                     xcpSignalTriggerFired = false;\nXCP_STATIC uint32_T                      xcpTriggerCount = 0;\n\nXCP_STATIC boolean_T                     xcpForcedTriggerEnabled = false;\nXCP_STATIC boolean_T                     xcpForceTriggerEnableRequest = false;\n\n/** The function is responsible for sampling the signal trigger value\n    and setting the xcpSignalTriggerFired boolean to true if\n    the trigger signal has the expected transition across the xcpClassicTriggerLevel.\n    The boolean will always be restored back to false by the base rate\n    when the event is acknowledged and the state transition completed.\n    The function is also setting xcpTriggerEnabled to true if no Delay is required. */\nstatic void sampleSignalTrigger(void)\n{\n    extmodeClassicTriggerSignal_T const* signal = (extmodeClassicTriggerSignal_T const*)\n                                            XCP_ADDRESS_GET_READ(xcpClassicTriggerSignalAddressExtension,\n                                                            xcpClassicTriggerSignalAddress);\n    if ((signal != NULL) &&\n       ((xcpClassicTriggerSignalAddressExtension != 0) ||\n        (xcpClassicTriggerSignalAddress != 0))) {\n        if ((xcpClassicTriggerStatus ==\tXCP_EXTMODE_TRIGGER_ARMED) &&\n            !xcpSignalTriggerFired) {\n            /* Read the new signal value */\n            extmodeClassicTriggerSignal_T signalValue = *signal;\n\n            if (xcpOldSignalValueAvailable) {\n                /* If the trigger is armed and not already fired,\n                   check for the expected transition */\n                boolean_T checkForRising =  (xcpClassicTriggerDirection == XCP_EXTMODE_TRIGGER_RISING) ||\n                                            (xcpClassicTriggerDirection == XCP_EXTMODE_TRIGGER_RISING_OR_FALLING);\n\n                boolean_T checkForFalling = (xcpClassicTriggerDirection == XCP_EXTMODE_TRIGGER_FALLING) ||\n                                            (xcpClassicTriggerDirection == XCP_EXTMODE_TRIGGER_RISING_OR_FALLING);\n\n                if (checkForRising &&\n                   (((signalValue >= xcpClassicTriggerLevel) && (xcpOldSignalValue <  xcpClassicTriggerLevel)) ||\n                    ((signalValue >  xcpClassicTriggerLevel) && (xcpOldSignalValue == xcpClassicTriggerLevel)))) {\n\n                    if (xcpClassicTriggerDelay == 0) {\n                        /* fire the event immediately if needed no Delay is required */\n                        xcpTriggerEnabled = true;\n                    }\n                    xcpSignalTriggerFired   = true; /* the transition from ARMED to FIRING is updated in base rate */\n                }\n                if (checkForFalling &&\n                   (((signalValue < xcpClassicTriggerLevel)  && (xcpOldSignalValue >= xcpClassicTriggerLevel)) ||\n                    ((signalValue == xcpClassicTriggerLevel) && (xcpOldSignalValue >  xcpClassicTriggerLevel)))) {\n\n                    if (xcpClassicTriggerDelay == 0) {\n                        /* fire the event immediately if needed no Delay is required */\n                        xcpTriggerEnabled = true;\n                    }\n                    xcpSignalTriggerFired   = true; /* the transition from ARMED to FIRING is updated in base rate */\n                }\n            }\n\n            /* Update the old signal value. Note: if we just fired, the sampling will start\n               next time the trigger is armed and therefore we reset xcpOldSignalValueAvailable */\n            xcpOldSignalValueAvailable = !xcpSignalTriggerFired;\n            xcpOldSignalValue = signalValue;\n        }\n    }\n}\n\n\n/** The function is executed in the base rate and it is responsible\n    for the handling of the triggering status transitions */\nstatic void updateTriggerStatus(void)\n{\n    /* Process user Arm/Cancel requests common to all states\n       and update the triggerFired variable (depending on the\n       active triggering source) */\n    boolean_T triggerFired = false;\n\n    if (xcpClassicTriggerStatus == XCP_EXTMODE_TRIGGER_UNARMED) {\n        /* This case deserves a separate handling\n           because we would like the transition to the ARMED status\n           to occur in the same cycle.\n           Since we are already UNARMED, any request to cancel \n           the trigger can be ignored */\n        xcpClassicTriggerCancelRequest = false;\n        xcpSignalTriggerFired = false;\n\n        if (xcpClassicTriggerArmRequest) {\n            /* Process arm request */\n            xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n            xcpClassicTriggerArmRequest = false;\n\n            /* If we are using MANUAL trigger, we want to start \n               firing the trigger event straightaway, e.g.\n               when the user selects ExtModeArmWhenConnect */\n            if (xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_MANUAL) {\n                triggerFired = true;\n            }\n        }\n    } else {\n        /* We are already armed, ignore any request to arm the trigger */\n        xcpClassicTriggerArmRequest = false;\n\n        if (xcpClassicTriggerCancelRequest) {\n            /* No matter what the Status is, a cancel request should\n               always bring the status to UNARMED.\n               We implement the transition here, to avoid code\n               duplication in the states. */\n            xcpTriggerEnabled = false;\n            xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n            xcpClassicTriggerCancelRequest = false;\n        } else {\n            if (xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_MANUAL) {\n                /* when manual triggering is selected, we assume that\n                   the trigger event has always been fired when armed */\n                triggerFired = true;\n            } else {\n                /* when signal triggering is selected, we check the status\n                   of the xcpSignalTriggerFired (updated by the\n                   sampleSignalTrigger() logic */\n                triggerFired = xcpSignalTriggerFired;\n                xcpSignalTriggerFired = false;\n            }\n        }\n    }\n\n    /* Handle the remaining state transitions */\n    switch (xcpClassicTriggerStatus) {\n    case XCP_EXTMODE_TRIGGER_UNARMED:\n        if (xcpClassicTriggerArmRequest) {\n            /* Process arm request */\n            xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n            xcpClassicTriggerArmRequest = false;\n        }\n        break;\n\n    case XCP_EXTMODE_TRIGGER_ARMED:\n        if (triggerFired) {\n            if ((xcpClassicTriggerDelay > 0) &&\n                (xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_SIGNAL)) {\n                /* We need to postpone the enabling of the trigger\n                   by xcpClassicTriggerDelay base periods */\n                xcpTriggerCount = (uint32_T) xcpClassicTriggerDelay;\n                xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_DELAYED;\n            } else {\n                /* Negative xcpClassicTriggerDelay are ignored.\n                   The parameter is also ignored if the xcpClassicTriggerSource\n                   is XCP_EXTMODE_TRIGGER_MANUAL\n                   If xcpClassicTriggerDelay is 0 we enable the trigger straight away */\n                if (xcpClassicTriggerDuration > 0) {\n                    xcpTriggerEnabled = true;\n                    xcpTriggerCount = xcpClassicTriggerDuration;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_FIRING;\n                } else {\n                    /* If duration is 0, we would never be able to send any data.\n                       This situation should be prevented on the host,\n                       we just handle it gracefully here, in case it happens */\n                    XCP_PRINTF(\"Invalid duration value (0) detected.\\n\");\n                    xcpTriggerEnabled = false;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n                }\n            }\n        }\n        break;\n\n    case XCP_EXTMODE_TRIGGER_FIRING:\n        /* Update the base rate counter */\n        if (xcpTriggerCount > 0) {\n            xcpTriggerCount--;\n        }\n\n        if (xcpTriggerCount == 0) {\n            /* Duration has expired */\n            if (xcpClassicTriggerMode == XCP_EXTMODE_TRIGGER_ONESHOT) {\n                /* In the one-shot scenario we just disable the trigger */\n                xcpTriggerEnabled = false;\n                xcpClassicTriggerStatus  = XCP_EXTMODE_TRIGGER_UNARMED;\n            } else {\n                /* In normal mode, we might have to handle the HoldOff and\n                   pause the triggering  */\n                if (xcpClassicTriggerHoldOff > 0) {\n                    xcpTriggerEnabled = false;\n                    xcpTriggerCount = xcpClassicTriggerHoldOff;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_HOLDING_OFF;\n                } else {\n                    if (triggerFired) {\n                        /* If the trigger has been fired, we start another duration\n                           straight away */\n                        xcpTriggerCount = xcpClassicTriggerDuration;\n                        xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_FIRING;\n                    } else {\n                        /* We wait for the next trigger to be fired */\n                        xcpTriggerEnabled = false;\n                        xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n                    }\n                }\n            }\n        }\n        break;\n\n    case XCP_EXTMODE_TRIGGER_DELAYED:\n        /* Update the base rate counter */\n        if (xcpTriggerCount > 0) {\n            xcpTriggerCount--;\n        }\n\n        if (xcpTriggerCount == 0) {\n            /* Delay is over, we can enable the trigger now */\n            if (xcpClassicTriggerDuration > 0) {\n                xcpTriggerEnabled = true;\n                xcpTriggerCount = xcpClassicTriggerDuration;\n                xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_FIRING;\n            } else {\n                /* If duration is 0, we would never be able to send any data.\n                   This situation should be prevented on the host,\n                   we just handle it gracefully here, in case it happens */\n                XCP_PRINTF(\"Invalid duration value (0) detected.\\n\");\n                xcpTriggerEnabled = false;\n                xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n            }\n        }\n        break;\n\n    case XCP_EXTMODE_TRIGGER_HOLDING_OFF:\n        /* Update the base rate counter */\n        if (xcpTriggerCount > 0) {\n            xcpTriggerCount--;\n        }\n\n        if (xcpTriggerCount == 0) {\n            /* HoldOff time has expired */\n            if (triggerFired) {\n                /* If the trigger has been fired, we start another duration\n                   straight away */\n                if (xcpClassicTriggerDuration > 0) {\n                    xcpTriggerEnabled = true;\n                    xcpTriggerCount = xcpClassicTriggerDuration;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_FIRING;\n                } else {\n                    /* If duration is 0, we would never be able to send any data.\n                       This situation should be prevented on the host,\n                       we just handle it gracefully here, in case it happens */\n                    XCP_PRINTF(\"Invalid duration value (0) detected.\\n\");\n                    xcpTriggerEnabled = false;\n                    xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n                }\n            } else {\n                /* We wait for the next trigger to be fired */\n                xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n            }\n        }\n        break;\n\n    default:\n        XCP_PRINTF(\"Invalid Trigger Status %u detected\\n\", xcpClassicTriggerStatus);\n        xcpTriggerEnabled = false;\n        xcpSignalTriggerFired = false;\n        xcpClassicTriggerCancelRequest = false;\n        xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_UNARMED;\n    }\n}\n\n\n\nXcpErrorCode xcpExtModeClassicTriggerInit(void)\n{\n    xcpOldSignalValue = 0;\n    xcpOldSignalValueAvailable = false;\n\n    xcpOldClassicTriggerSource = xcpClassicTriggerSource;\n\n    xcpTriggerEnabled = false;\n    xcpSignalTriggerFired = false;\n    xcpTriggerCount = 0;\n\n    xcpClassicTriggerStatus  = XCP_EXTMODE_TRIGGER_UNARMED;\n\n    return XCP_SUCCESS;\n}\n\n\n/** The function returns true if the external mode event must be triggered */\nboolean_T xcpExtModeClassicTriggerEnabled(extmodeEventId_T eventId)\n{\n    if (eventId == EXTMODE_TRIG_BASE_RATE_EVENT_ID) {\n        /* Whenever a change of the xcpClassicTriggerSource is detected\n           the xcpClassicTriggerStatus is reset */\n        boolean_T triggerSrcChangeDetected = (xcpClassicTriggerSource != xcpOldClassicTriggerSource);\n        xcpOldClassicTriggerSource = xcpClassicTriggerSource;\n\n        if (triggerSrcChangeDetected) {\n            xcpTriggerEnabled     = false;\n            xcpSignalTriggerFired = false;\n            xcpTriggerCount       = 0;\n\n            xcpClassicTriggerStatus  = XCP_EXTMODE_TRIGGER_UNARMED;\n        }\n\n        /* If XCP_EXTMODE_TRIGGER_SIGNAL is selected we want to start\n           processing the Arm request (or the Hold-off expiration) \n           straightaway and carry out the state transition before \n           sampling for the first time */\n        if ((xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_SIGNAL)  &&\n            (((xcpClassicTriggerStatus == XCP_EXTMODE_TRIGGER_UNARMED) &&\n               xcpClassicTriggerArmRequest) ||\n             ((xcpClassicTriggerStatus == XCP_EXTMODE_TRIGGER_HOLDING_OFF) &&\n              (xcpTriggerCount == 1)))) {\n               xcpTriggerCount = 0;\n               xcpClassicTriggerArmRequest = false;\n               xcpClassicTriggerStatus = XCP_EXTMODE_TRIGGER_ARMED;\n        }\n    }\n\n    if ((xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_SIGNAL) &&\n        (eventId == xcpClassicTriggerEventId))  {\n        /* Since we are running at the correct eventID, sample the\n           trigger signal value to determine if the trigger signal\n           needs to be enabled.\n           Note: this will update the boolean straight away and request\n           the state transition (updated at the next base rate) */\n        sampleSignalTrigger();\n    }\n\n    if (eventId == EXTMODE_TRIG_BASE_RATE_EVENT_ID) {\n        /* update trigger status to fulfill user requests */\n        updateTriggerStatus();\n\n        /* If the base rate task has run, then reset the\n         * xcpForceTriggerEnableRequest flag.  The state machine\n         * is up to date. */\n        xcpForceTriggerEnableRequest = false;\n    } else if (xcpForceTriggerEnableRequest) {\n        return xcpForcedTriggerEnabled;\n    }\n\n    return xcpTriggerEnabled;\n}\n\n\n/** Reset External Mode classic triggering logic, by restoring the default status */\nXcpErrorCode xcpExtModeClassicTriggerReset(void)\n{\n    xcpOldSignalValue = 0;\n    xcpOldSignalValueAvailable = false;\n\n    xcpClassicTriggerStatus  = XCP_EXTMODE_TRIGGER_UNARMED;\n    xcpOldClassicTriggerSource = XCP_EXTMODE_TRIGGER_MANUAL;\n    xcpClassicTriggerEventId = 0;\n    xcpTriggerEnabled = false;\n    xcpSignalTriggerFired = false;\n    xcpTriggerCount = 0;\n    xcpForcedTriggerEnabled = false;\n    xcpForceTriggerEnableRequest = false;\n\n    xcpClassicTriggerSignalAddress = 0;\n    xcpClassicTriggerSignalAddressExtension = 0;\n\n    xcpClassicTriggerLevel    = 0;\n    xcpClassicTriggerDuration = DEFAULT_XCP_CLASSIC_TRIGGER_DURATION;\n    xcpClassicTriggerHoldOff  = 0;\n    xcpClassicTriggerDelay    = 0;\n\n    xcpClassicTriggerDirection = XCP_EXTMODE_TRIGGER_RISING;\n\n#if defined(EXTMODE_TRIG_ARMED_ON_START) && EXTMODE_TRIG_ARMED_ON_START == 0\n    xcpClassicTriggerArmRequest = false;\n#else\n/* Classic Trigger is armed by default */\n    xcpClassicTriggerArmRequest = true;\n#endif\n\n    xcpClassicTriggerCancelRequest = false;\n\n    xcpClassicTriggerSource = XCP_EXTMODE_TRIGGER_MANUAL;\n    xcpClassicTriggerMode = XCP_EXTMODE_TRIGGER_NORMAL;\n\n    return XCP_SUCCESS;\n}\n\n\n/** When Manual triggering is enabled, force output of xcpExtModeClassicTriggerEnabled to\n *  match pending Arm or Cancel request for all non-base rate events until requests are \n *  processed at the next base rate event.\n * \n *  In the concurrent execution workflow, it is used to avoid omission\n *  of logging data points if a non-base rate task completes\n *  before the base rate at t = 0.\n * \n *  This is a NO-OP when XCP_EXTMODE_TRIGGER_SIGNAL is active.\n */\nvoid xcpExtModeClassicTriggerForceEnableStatusUpdate(void) {\n    if (xcpClassicTriggerSource == XCP_EXTMODE_TRIGGER_MANUAL) {\n        if (xcpClassicTriggerArmRequest && !xcpClassicTriggerCancelRequest) {\n            /* Force xcpExtModeClassicTriggerEnabled to return true\n            * until the next base rate event. */\n            xcpForcedTriggerEnabled = true;\n            xcpForceTriggerEnableRequest = true;\n        } else if (xcpClassicTriggerCancelRequest & !xcpClassicTriggerArmRequest) {\n            xcpForcedTriggerEnabled = false;\n            xcpForceTriggerEnableRequest = true;\n        } else {\n            xcpForceTriggerEnableRequest = false;\n        }\n    }\n}\n"},{"name":"xcp_ext_common.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2024a/toolbox/coder/xcp/src/target/ext_mode/src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2018-2023 The MathWorks, Inc.\n *\n * File: xcp_ext_common.c\n *\n * Abstract:\n *  This file contains the implementation of the common functionalities\n *  used within the XCP External Mode Platform Abstraction layer.\n *\n *  This includes the handling of absolute simulation time and the global\n *  variables to control the execution of the model on the target\n *  (and accessed remotely via XCP communication protocol).\n */\n#if !defined(INTEGER_CODE) || INTEGER_CODE == 0\n#include <float.h>         /* for DBL_EPSILON */\n#include <math.h>\n#endif\n\n#include \"xcp_ext_common.h\"\n#include \"xcp_ext_param.h\"\n#include \"xcp.h\"\n#include \"xcp_internal.h\"\n#include \"xcp_transport.h\"\n#include \"xcp_cfg.h\"\n\n#include \"rtw_extmode.h\"\n\n#ifdef XCP_CUSTOM_ADDRESS_TRANSLATION\nvoid xcpInitCustomAddressGet(void);\n#endif\n\n#ifndef EXTMODE_FLUSH_ALL_DATA_DELAY_TIME_IN_MICROSECONDS\n/* Dummy delay, that forces the background task to pause the execution\n   and reduces the packets transmission rate. \n   This is useful for host-based targets to prevent the saturation\n   of transmission buffers */\n#define EXTMODE_FLUSH_ALL_DATA_DELAY_TIME_IN_MICROSECONDS  10L  /* 10us */\n#endif\n\n\n/* XCP Client can 'directly' access these global variables, in order to control\n   the model state machine */\n\n#if defined(ON_TARGET_WAIT_FOR_START) && ON_TARGET_WAIT_FOR_START == 1\nboolean_T volatile xcpModelStartRequest = false;\n#else\nboolean_T volatile xcpModelStartRequest = true;\n#endif\nboolean_T volatile xcpModelStopRequest = false;\nXcpExtModeStatus volatile xcpModelStatus = XCP_EXTMODE_STATUS_RESET;\n\nuint32_T volatile xcpModelChecksum0   = 0;\nuint32_T volatile xcpModelChecksum1   = 0;\nuint32_T volatile xcpModelChecksum2   = 0;\nuint32_T volatile xcpModelChecksum3   = 0;\nuint32_T volatile xcpModelIntegerCode = 0;\n\n/* Global variable defined when a non-BYTE addressable target is\n   being emulated as a BYTE addressable target. Currently defined \n   only for WORD addressable targets (Eg.:C2000). But, can be\n   extended to DWORD addressable targets */\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\nuint8_T volatile xcpEmulateWordTargetAsByteTarget = 1;\n#endif\n\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\nextmodeSimulationTime_T volatile xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_RUN_FOREVER;\n#else\nextmodeSimulationTime_T volatile xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_TIME_NOT_INITIALIZED;\n#endif\n\nboolean_T               volatile xcpExtmodeSimulationComplete  = false;\n\n#if !defined(INTEGER_CODE) || INTEGER_CODE == 0\n/* Dummy double variable, required to obtain the size of double data type on the target \n   using the symbols parser. */\nextmodeDouble_T volatile xcpDummyDoubleVariable = (extmodeDouble_T) 0;\n#endif\n\n/* Definition of a dummy printf function */\nvoid xcp_void_printf(const char_T *fmt,...){UNUSED_PARAMETER(fmt);}\n\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n\n/* The mutex is used to protect against the concurrent access to the global\n   variables (related to the simulation time) when xcpExtModeUpdateTime()\n   is executed by different threads.\n   In particular it guarantees that the state of the variables is updated\n   atomically and it is always consistent when the function is executed */\nstatic XCP_MUTEX_DEFINE(xcpExtModeLock);\n\n\nuint32_T xcpCurrentSimulationTimeInTicks[2] = {0};\n\n/* The variable contains the last value of model simulation time \n   received via extmodeEvent() for the Base Rate thread.\n   In particular, the extmodeSimulationTime_T represents absolute time \n   (in baserate ticks)\n   Note: xcpBaseRateSimulationTime is assumed to be monotonically increasing, \n         but a counter overflow could occur */\nXCP_STATIC extmodeSimulationTime_T xcpBaseRateSimulationTime = 0;\n\n/* When LifeSpan is short, the xcpBaseRateSimulationTime variable could \n  \"overflow earlier than expected\", as the generated code may use only \n  a 16bit counter to store the baserate ticks.\n\n  The purpose of xcpTicksCounterL is to convert the xcpBaseRateSimulationTime \n  into a \"normal\" 32bit variable (and it relies on the EXTMODE_MAX_BASE_RATE_SIMULATION_TIME\n  value to understand when the overflow is supposed to occur).\n\n  xcpTicksCounterL and xcpTicksCounterH are then used to obtain \n  the xcpCurrentSimulationTimeInTicks global tick counter */\nXCP_STATIC uint32_T xcpTicksCounterL = 0;\nXCP_STATIC uint32_T xcpTicksCounterH = 0;\n\n/* The variable contains the last value of simulation time converted into a 32 bit\n   value with XCP_TIMESTAMP_UNIT resolution. This variable is only updated when\n   base rate is executed */\nXCP_STATIC uint32_T xcpBaseRateSimulationTimestamp = 0;\n\n#else /* INTEGER_CODE == 0 */\n\nuint32_T xcpCurrentSimulationTimeInMs[2] = {0};\nXCP_STATIC extmodeSimulationTime_T xcpBaseRateSimulationTime = 0;\n\n#endif\n\n#ifndef XCP_BIG_ENDIAN\n\nXCP_STATIC void xcpCopyTimeValue(volatile uint32_T *dst, uint32_T lsb, uint32_T msb)\n{\n    dst[0] = lsb;\n    dst[1] = msb;\n}\n\n#else /* BIG ENDIAN*/\n\n#define XCP_BYTES_SWAP(value)    ((((value) >> 24) & 0x000000ff)| \\\n                                  (((value) >> 8)  & 0x0000ff00)| \\\n                                  (((value) << 8)  & 0x00ff0000)| \\\n                                  (((value) << 24) & 0xff000000))\n\nXCP_STATIC void xcpCopyTimeValue(volatile uint32_T *dst, uint32_T lsb, uint32_T msb)\n{\n    dst[0] = XCP_BYTES_SWAP(lsb);\n    dst[1] = XCP_BYTES_SWAP(msb);\n}\n\n#endif /* BIG ENDIAN*/\n\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n\n/* Define the XCP_TIMESTAMP_UNITS_PER_MICROSECOND value based on the\n   selected XCP_TIMESTAMP_UNIT */\n#if (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1US)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     1\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10US)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     10\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100US)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     100\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1MS)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     1000\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10MS)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     10000\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100MS)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     100000\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1S)\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND     1000000\n#else\n#error \"Invalid XCP_TIMESTAMP_UNIT value. When Purely Integer code is selected, it must be greater than or equal to XCP_TIMESTAMP_UNIT_1US.\"\n#endif\n\n\nstatic extmodeSimulationTime_T xcpExtModeMaxBaseRateSimulationTime = EXTMODE_MAX_BASE_RATE_SIMULATION_TIME;\n\n\n/* Internal function that updates absolute simulation time variables:\n   - xcpCurrentSimulationTimeInTicks \n   - xcpBaseRateSimulationTime\n   - xcpBaseRateSimulationTimestamp\n   and detect if the simulation is actually complete\n   (by updating xcpExtmodeSimulationComplete variable)\n \n   The function returns the 32bit XCP Timestamp counter value \n   (in XCP_TIMESTAMP_UNITs) corresponding to the given newTime\n \n   Note: the newTime input represents the model simulation time in base rate ticks */\nstatic uint32_T updateTime(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    uint32_T timestamp = 0;\n\n    XCP_MUTEX_LOCK(xcpExtModeLock);\n    \n    if (eventId == EXTMODE_BASE_RATE_EVENT_ID) {\n        /* Absolute time variables are only updated when \n           base rate thread is executed */\n        extmodeSimulationTime_T ticksIncrement;\n        extmodeSimulationTime_T newCounterTicks;\n\n        /* Detect increment (in ticks) */\n        if (newTime >= xcpBaseRateSimulationTime) {\n            ticksIncrement = newTime - xcpBaseRateSimulationTime;\n        } else {\n            ticksIncrement = newTime + EXTMODE_MAX_BASE_RATE_SIMULATION_TIME - xcpBaseRateSimulationTime + 1;\n        }\n    \n        /* Update xcpTicksCounterL and xcpTicksCounterH tick counters */\n        newCounterTicks = xcpTicksCounterL + ticksIncrement;\n    \n        if (newCounterTicks < xcpTicksCounterL) {\n            xcpTicksCounterH++;\n        }\n        xcpTicksCounterL = newCounterTicks;\n\n        /* Update absolute simulation time values */\n        xcpCopyTimeValue(xcpCurrentSimulationTimeInTicks, xcpTicksCounterL, xcpTicksCounterH);\n\n        /* Save last received base rate simulation time */\n        xcpBaseRateSimulationTime = newTime;\n    \n        /* Update the 32bit XCP Timestamp counter for the base rate, using 32bit unsigned integer arithmetic */\n        xcpBaseRateSimulationTimestamp += ticksIncrement * EXTMODE_STEP_SIZE_IN_MICROSECONDS * XCP_TIMESTAMP_UNITS_PER_MICROSECOND;\n\n        timestamp = xcpBaseRateSimulationTimestamp;\n        \n        /* Check if simulation is complete */\n        if ((xcpExtmodeFinalSimulationTime != EXTMODE_SIMULATION_RUN_FOREVER) &&\n            (xcpExtmodeFinalSimulationTime != EXTMODE_SIMULATION_TIME_NOT_INITIALIZED)) {\n            /* By default, assuming EXTMODE_SIMULATION_RUN_FOREVER */\n            xcpExtmodeSimulationComplete = (xcpTicksCounterL >= xcpExtmodeFinalSimulationTime);\n        }\n    } else {\n        /* For threads different from the base rate, if the execution is\n           really concurrent, the simulationTime value might be different \n           from xcpBaseRateSimulationTime (ahead or behind).\n           The resulting timestamp value is calculated starting from \n           xcpBaseRateSimulationTimestamp and adding/subtracting the \n           difference */\n        extmodeSimulationTime_T ticksIncrement = 0;\n        extmodeSimulationTime_T ticksDecrement = 0;\n        \n        if (xcpExtModeMaxBaseRateSimulationTime < MAX_extmodeSimulationTime_T) {\n            /* If the size of extmodeSimulationTime_T data type allows\n               the representation of numbers bigger than EXTMODE_MAX_BASE_RATE_SIMULATION_TIME\n               then the newTime value needs to be \"converted\" to just use the same\n               amount of bits as the Base Rate (ClockTick0)\n               Note: this happens for example when ClockTicks are uint16_T and\n               extmodeSimulationTime_T is uint32_T. If the first subrate is half\n               of the base rate then\n                   newTime = ClockTick1 * 2\n               and this time would end up being bigger than EXTMODE_MAX_BASE_RATE_SIMULATION_TIME */\n            newTime = newTime % (xcpExtModeMaxBaseRateSimulationTime + 1);\n        }\n\n        if (newTime >= xcpBaseRateSimulationTime) {\n            /* We need to identify one of the two cases:\n               - newTime is ahead of xcpBaseRateSimulationTime\n               - newTime is behind but an overflow occurred\n             */\n            ticksIncrement = newTime - xcpBaseRateSimulationTime;\n            ticksDecrement = xcpBaseRateSimulationTime + EXTMODE_MAX_BASE_RATE_SIMULATION_TIME - newTime + 1;\n\n            if (ticksDecrement <= ticksIncrement) {\n                /* Assuming that newTime is behind and an overflow has occurred */\n                ticksIncrement = 0;\n            } else {\n            \t/* assuming that newTime is ahead */\n                ticksDecrement = 0;\n            }\n        } else {\n            /* We need to identify one of the two cases:\n               - newTime is behind of xcpBaseRateSimulationTime\n               - newTime is ahead but an overflow occurred\n             */\n            ticksIncrement = newTime + EXTMODE_MAX_BASE_RATE_SIMULATION_TIME - xcpBaseRateSimulationTime + 1;\n            ticksDecrement = xcpBaseRateSimulationTime - newTime;\n\n            if (ticksDecrement <= ticksIncrement) {\n                /* Assuming that newTime is behind, as more likely */\n                ticksIncrement = 0;\n            } else {\n            \t/* assuming that newTime is ahead and an overflow has occurred */\n                ticksDecrement = 0;\n            }\n        }\n\n        if (ticksIncrement > 0) {\n            timestamp = xcpBaseRateSimulationTimestamp +\n                        (ticksIncrement * EXTMODE_STEP_SIZE_IN_MICROSECONDS * XCP_TIMESTAMP_UNITS_PER_MICROSECOND);\n        } else {\n            timestamp = xcpBaseRateSimulationTimestamp -\n                        (ticksDecrement * EXTMODE_STEP_SIZE_IN_MICROSECONDS * XCP_TIMESTAMP_UNITS_PER_MICROSECOND);\n        }\n    }\n\n    XCP_MUTEX_UNLOCK(xcpExtModeLock);\n    \n    return timestamp;\n}\n\n/* Update absolute simulation time variables\n   and detect if the simulation is actually complete\n\n   Note: the newTime input represents the current model simulation time */\nvoid xcpExtModeUpdateTime(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    updateTime(newTime, eventId);\n}\n\n/* In addition to updating absolute simulation time variables\n   and detecting if the simulation is actually complete, \n   the function returns the 32bit XCP Timestamp counter value\n   (in XCP_TIMESTAMP_UNITs) corresponding to the given newTime\n\n   Note: the newTime input represents the model simulation time */\nuint32_T xcpExtModeGetUpdatedTimestamp(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    return updateTime(newTime, eventId);\n}\n\n\n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n\n/* Return value in XCP_TIMESTAMP_UNITs, based on the current model simulation time */\nuint32_T xcpGetTimestamp(void)\n{\n    uint32_T timestamp;\n\n    /* @note: theoretically the base thread could pre-preempt any thread during the\n       read operation. Since the read of a 32bit value may not be atomic\n       in some architectures we have to protect it with a mutex.\n       We may be able to remove this lock if we extend the Platform Abstraction Layer\n       to include atomic read operations */\n    XCP_MUTEX_LOCK(xcpExtModeLock);\n\n    timestamp = xcpBaseRateSimulationTimestamp;\n\n    XCP_MUTEX_UNLOCK(xcpExtModeLock);\n\n    return timestamp;\n}\n\n#endif /* XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME */\n\n#else /* INTEGER_CODE == 0 */\n\n/* Define the XCP_TIMESTAMP_UNITS_PER_SECOND value based on the\n   selected XCP_TIMESTAMP_UNIT */\n#if (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e9\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e8\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e7\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e6\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e5\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e4\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e3\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e2\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e1\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1S)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND            1\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e12\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e11\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e10\n#else\n#error \"invalid XCP_TIMESTAMP_UNIT value\"\n#endif\n\n\n/* Update absolute simulation time variable xcpCurrentSimulationTimeInMs\n   and detect if the simulation is actually complete\n   (by updating xcpExtmodeSimulationComplete variable)\n\n   The function returns the 32bit XCP Timestamp counter value\n   (in XCP_TIMESTAMP_UNITs) corresponding to the given newTime\n\n   Note: the newTime input represents the model simulation time in seconds */\nvoid xcpExtModeUpdateTime(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    if (eventId == EXTMODE_BASE_RATE_EVENT_ID) {\n        /* Absolute time variables are only updated when base rate\n           thread is executed, no need to use any lock */\n        real_T   timeInMs = newTime * 1000.0;\n        uint32_T timeInMsL = (uint32_T)fmod(timeInMs, (extmodeSimulationTime_T) XCP_UINT32_MAX + 1);\n        uint32_T timeInMsH = 0;\n\n        if (timeInMs > XCP_UINT32_MAX) {\n            /* cast truncates, rounding to zero */\n            timeInMsH = (uint32_T)(timeInMs / XCP_UINT32_MAX);\n        }\n\n        /* Update absolute simulation time variables */\n        xcpCopyTimeValue(xcpCurrentSimulationTimeInMs, timeInMsL, timeInMsH);\n\n        /* Check if simulation is complete */\n        if ((xcpExtmodeFinalSimulationTime != EXTMODE_SIMULATION_RUN_FOREVER) &&\n            (xcpExtmodeFinalSimulationTime != EXTMODE_SIMULATION_TIME_NOT_INITIALIZED)) {\n            /* By default, assuming EXTMODE_SIMULATION_RUN_FOREVER */\n           xcpExtmodeSimulationComplete = (xcpExtmodeFinalSimulationTime - newTime) <\n                                          (newTime * (DBL_EPSILON));\n        }\n\n        /* Update the current simulation time */\n        xcpBaseRateSimulationTime = newTime;\n    }\n}\n\n/* In addition to updating absolute simulation time variables\n   and detecting if the simulation is actually complete, \n   the function returns the 32bit XCP Timestamp counter value\n   (in XCP_TIMESTAMP_UNITs) corresponding to the given newTime\n\n   Note: the newTime input represents the model simulation time */\nuint32_T xcpExtModeGetUpdatedTimestamp(extmodeSimulationTime_T newTime, extmodeEventId_T eventId)\n{\n    uint32_T timestamp = 0;\n\n    xcpExtModeUpdateTime(newTime, eventId);\n\n    /* Convert the newTime into the 32 bits XCP Timestamp counter, based on XCP configuration */\n    timestamp = (uint32_T)fmod(newTime * (extmodeSimulationTime_T) XCP_TIMESTAMP_UNITS_PER_SECOND + 0.5, \n                              (extmodeSimulationTime_T)XCP_UINT32_MAX + 1);\n\n    return timestamp;\n}\n\n\n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n\n/* This function is supposed to return the value of the XCP Timestamp in XCP_TIMESTAMP_UNITs.\n   Specifically it is invoked within the xcpEvent().\n   When XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME is defined, both extmodeEvent() and \n   rtExtModeUpload() use xcpEventExternalTimestamp() instead, so we should never hit this function.\n   However we need to provide a dummy implementation as the function is required by the \n   Platform Abstraction Layer. */\nuint32_T xcpGetTimestamp(void)\n{\n    return 0;\n}\n\n#endif /* XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME */\n\n#endif /* INTEGER_CODE == 1 */\n\n\nuint32_T xcpExtModeGetSimulationTime(void)\n{  \n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n    /* Even if not thread-safe, this implementation has been added for backward compatibility \n       as Code Execution Profiling was invoking the xcpEvent() API directly */\n    return xcpExtModeGetUpdatedTimestamp(xcpBaseRateSimulationTime, EXTMODE_BASE_RATE_EVENT_ID);\n#else\n    return 0;\n#endif\n}\n\n\nXcpErrorCode xcpExtModeInit(void)\n{\n    int_T parNumber = 0;\n    void **parList = NULL;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    \n#if !defined(INTEGER_CODE) || INTEGER_CODE == 0\n    /* Use dummy variable to prevent optimization in some compilers */\n    xcpDummyDoubleVariable = (extmodeDouble_T) 0;\n#endif\n\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\n    XCP_MUTEX_INIT(xcpExtModeLock);\n#endif\n\n#ifdef XCP_CUSTOM_ADDRESS_TRANSLATION\n    xcpInitCustomAddressGet();\n#endif\n\n    /* Retrieve XCP Transport Layer initialization parameters */\n    xcpTransportGetInitParameters(&parNumber, &parList);\n\n    /* Initialize XCP Transport Layer */\n    errorCode = xcpTransportInit(parNumber, parList);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpExtModeInit: xcpTransportInit error\\n\");\n        return errorCode;\n    }\n\n    /* Retrieve XCP Protocol Layer initialization parameters */\n    xcpGetInitParameters(&parNumber, &parList);\n\n    /* Initialize XCP Protocol layer */\n    errorCode = xcpInit(parNumber, parList);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpExtModeInit: xcpInit error: code %d\\n\", errorCode);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpExtModeRunBackground(boolean_T flushAllData)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    boolean_T done = false;\n\n    /* Add a dummy delay, that forces the task to pause the execution\n       (leaving the 'running' state). This gives Simulink the opportunity\n       to run when connecting to host-based targets in External Mode */\n    XCP_SLEEP(0, 0);\n\n    do {\n        boolean_T dataAvailable = false;\n\n        /* Retrieve a new Rx packet from interface */\n        errorCode = xcpTransportRx();\n\n        if ((errorCode != XCP_SUCCESS) && (errorCode != XCP_EMPTY)) {\n            XCP_PRINTF(\"xcpExtModeRunBackground: xcpTransportRx error, code %d\\n\", errorCode);\n            done = true;\n        } else {\n            dataAvailable = dataAvailable || (errorCode != XCP_EMPTY);\n        }\n\n        if (!done) {\n            /* Process it within the protocol layer.\n               By checking the return code value, diagnostic info on\n               XCP packet processing can be collected.\n               Every run corresponds to the processing of one single XCP packet */\n            errorCode = xcpRun();\n\n            if ((errorCode != XCP_SUCCESS) && (errorCode != XCP_EMPTY)) {\n                XCP_PRINTF(\"xcpExtModeRunBackground: xcpRun error, code %d\\n\", errorCode);\n                done = true;\n            } else {\n                dataAvailable = dataAvailable || (errorCode != XCP_EMPTY);\n            }\n        }\n\n        if (!done) {\n            /* Send one of the pending Tx packets over the network */\n            errorCode = xcpTransportTx();\n            if ((errorCode != XCP_SUCCESS) && (errorCode != XCP_EMPTY)) {\n                XCP_PRINTF(\"xcpExtModeRunBackground: xcpTransportTx error, code %d\\n\", errorCode);\n                done = true;\n            } else {\n                dataAvailable = dataAvailable || (errorCode != XCP_EMPTY);\n            }\n        }\n\n        if (flushAllData) {\n#if EXTMODE_FLUSH_ALL_DATA_DELAY_TIME_IN_MICROSECONDS > 0\n            /* Dummy delay, that forces the background task to pause the execution\n               and reduces the packets transmission rate, for host-based targets. */\n            XCP_SLEEP(0, EXTMODE_FLUSH_ALL_DATA_DELAY_TIME_IN_MICROSECONDS);\n#endif\n            /* The xcpExtModeRunBackground will continue to process packets until\n               the TX and RX queues are empty or an error occurred. */\n            done = done || !dataAvailable;\n        } else {\n            /* The xcpExtModeRunBackground will only carry out one iteration and then return.\n               The remaining packets will be processed at the next round. */\n            done = true;\n        }\n    } while (!done);\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpExtModeReset(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    extmodeRealTime_T elapsedTime;\n    XcpStatus status;\n\n    if (xcpExtmodeSimulationComplete) {\n        /* When DAQ Packed Mode is enabled, if we reached the nominal end of the\n           simulation we trigger the transmission of a packet containing the samples \n           received so far. The trailing '0's will be removed and not displayed\n           in the output of the simulation */\n        xcpPackedModeEventsFlush(0);\n    }\n\n    /* Wait for the XCP client to complete the clean disconnection procedure */\n    status = xcpGetStatus();\n\n    elapsedTime = 0;\n    while ((elapsedTime < EXTMODE_SHUTDOWN_TIMEOUT_IN_MICROSECONDS) &&\n           (status != XCP_DISCONNECTED)) {\n\n        XCP_SLEEP(0, EXTMODE_RETRY_TIME_IN_MICROSECONDS);\n        elapsedTime += EXTMODE_RETRY_TIME_IN_MICROSECONDS;\n\n        /* Run the XCP Stack to keep the communication 'alive',\n           forcing the flush of all data */\n        xcpExtModeRunBackground(true);\n\n        /* Check the XCP stack status again */\n        status = xcpGetStatus();\n    }\n\n    /* Reset XCP Protocol Layer */\n    errorCode = xcpReset();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpReset error: code %d\\n\", errorCode);\n    }\n\n    /* Reset XCP Transport Layer */\n    errorCode = xcpTransportReset();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportReset error: code %d\\n\", errorCode);\n    }\n\n    /* Restore the global variables to the default value */\n#if defined(ON_TARGET_WAIT_FOR_START) && ON_TARGET_WAIT_FOR_START == 1\n    xcpModelStartRequest = false;\n#else\n    xcpModelStartRequest = true;\n#endif\n\n    xcpModelStopRequest = false;\n\n    xcpModelChecksum0   = 0;\n    xcpModelChecksum1   = 0;\n    xcpModelChecksum2   = 0;\n    xcpModelChecksum3   = 0;\n    xcpModelIntegerCode = 0;\n\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\n    xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_RUN_FOREVER;\n\n    xcpBaseRateSimulationTime = 0;\n\n    xcpTicksCounterL = 0;\n    xcpTicksCounterH = 0;\n\n    xcpBaseRateSimulationTimestamp = 0;\n#else\n    xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_TIME_NOT_INITIALIZED;\n#endif\n\n    xcpExtmodeSimulationComplete  = false;\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n    XCP_MEMSET(xcpCurrentSimulationTimeInTicks, 0, sizeof(xcpCurrentSimulationTimeInTicks));\n\n    xcpBaseRateSimulationTime = 0;\n\n    xcpTicksCounterL = 0;\n    xcpTicksCounterH = 0;\n\n    xcpBaseRateSimulationTimestamp = 0;\n#else\n    XCP_MEMSET(xcpCurrentSimulationTimeInMs, 0, sizeof(xcpCurrentSimulationTimeInMs));\n    xcpBaseRateSimulationTime = 0;\n#endif\n\n    return errorCode;\n}\n"},{"name":"xcp_ext_mode.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2024a/toolbox/coder/xcp/src/target/ext_mode/src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2017-2023 The MathWorks, Inc.\n *\n * File: xcp_ext_mode.c\n *\n * Abstract:\n *  The file provides the implementation of the ext_mode.h interface\n *  based on XCP communication protocol\n */\n\n#if !defined(EXTMODE_DISABLE_ARGS_PROCESSING)\n#include <stdio.h>\n#endif\n\n#include <string.h>        /* optional for strcmp */\n\n#include \"xcp_ext_common.h\"\n#include \"xcp_ext_param.h\"\n#include \"xcp_internal.h\"\n#include \"ext_mode.h\"\n\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n\n#include \"xcp_ext_classic_trigger.h\"\n\n#ifndef EXTMODE_XCP_MAX_TRIGGER_NUMBER\n#if defined(XCP_MEM_DAQ_RESERVED_POOLS_NUMBER) && (XCP_MEM_DAQ_RESERVED_POOLS_NUMBER > 0)\n/* If XCP_MEM_DAQ_RESERVED_POOLS_NUMBER is defined, the value of this macro should be at least\n   equal to the number of sample times in the model. This can be one more than the number of DAQ\n   lists that use reserved pools if Tid 0 and 1 are mapped to the same DAQ list. */\n#define EXTMODE_XCP_MAX_TRIGGER_NUMBER XCP_MEM_DAQ_RESERVED_POOLS_NUMBER + 1\n#else\n#define EXTMODE_XCP_MAX_TRIGGER_NUMBER EXTMODE_MAX_EVENT_ID\n#endif\n#endif /* EXTMODE_XCP_MAX_TRIGGER_NUMBER */\n\n#if (EXTMODE_XCP_MAX_TRIGGER_NUMBER > EXTMODE_MAX_EVENT_ID) || (EXTMODE_XCP_MAX_TRIGGER_NUMBER < 1)\n#error Invalid EXTMODE_XCP_MAX_TRIGGER_NUMBER value.\n#endif\n\nstatic extmodeEventTriggerEnable xcpCustomTriggerFunction[EXTMODE_XCP_MAX_TRIGGER_NUMBER];\n\n#endif\n\n\nextmodeErrorCode_T extmodeParseArgs(int_T   argc,\n                                    const char_T *argv[])\n{\n    extmodeErrorCode_T errorCode = EXTMODE_SUCCESS;\n\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    /* Some targets do not support command line args */\n    UNUSED_PARAMETER(argc);\n    UNUSED_PARAMETER(argv);\n#else\n    boolean_T  parseError = false;\n    int_T  count = 1;\n\n    if (argc < 0) {\n        XCP_PRINTF(\"extmodeParseArgs: argc must be a positive number\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    if ((argc > 0) && (argv == NULL)) {\n        XCP_PRINTF(\"extmodeParseArgs: invalid argv value\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    /*\n     * Parse the External Mode Platform-independent Abstraction Layer parameters.\n     * Let all unrecognized parameters pass through to the XCP External Mode \n     * Platform-specific Abstraction Layer.\n     * NULL out all args handled so that they can ignored by the lower layer.\n     */\n    while (count < argc) {\n        const char_T *option = argv[count++];\n\n        if (option != NULL) {\n            /* final time */\n            if ((strcmp(option, \"-tf\") == 0) && (count != argc)) {\n                const char_T *timeValueString = argv[count++];\n                extmodeSimulationTime_T  timeValue = 0;\n                char_T        stringBuffer[201];\n\n                XCP_MEMSET(stringBuffer, 0, sizeof(stringBuffer));\n\n                sscanf(timeValueString, \"%200s\", stringBuffer);\n                if (strcmp(stringBuffer, \"inf\") == 0) {\n                    timeValue = EXTMODE_SIMULATION_RUN_FOREVER;\n                }\n                else {\n                    char_T tmpString[2];\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n                    int tmpValue;\n\n                    if ((sscanf(stringBuffer, \"%d%1s\", &tmpValue, tmpString) != 1) ||\n                        (tmpValue < 0)) {\n                        XCP_PRINTF(\"External mode final simulation time must be a positive, integer value or inf\\n\");\n                        parseError = true;\n                        break;\n                    }\n                    timeValue = (extmodeSimulationTime_T) tmpValue;\n#else\n                    if ((sscanf(stringBuffer, \"%lf%1s\", &timeValue, tmpString) != 1) ||\n                        (timeValue < (extmodeSimulationTime_T)0)) {\n                        XCP_PRINTF(\"External mode final simulation time must be a positive, real value or inf\\n\");\n                        parseError = true;\n                        break;\n                    }\n#endif\n                }\n                xcpExtmodeFinalSimulationTime = timeValue;\n\n                argv[count - 2] = NULL;\n                argv[count - 1] = NULL;\n            }\n            /* -w (wait for packet from host) option */\n            else if (strcmp(option, \"-w\") == 0) {\n                xcpModelStartRequest = false;\n                argv[count - 1] = NULL;\n            }\n        }\n    }\n\n    if (parseError) {\n        XCP_PRINTF(\"\\nUsage: model_name -option1 val1 -option2 val2 -option3 \"\n            \"...\\n\\n\");\n\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1) || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n        XCP_PRINTF(\"\\t-tf 20 - sets final time to 20 ticks\\n\");\n#else\n        XCP_PRINTF(\"\\t-tf 20 - sets final time to 20 seconds\\n\");\n#endif\n\n        return EXTMODE_INV_ARG;\n    }\n\n    /* Extract XCP specific initialization parameters, by invoking the \n       XCP External Mode Platform-specific Abstraction Layer API */\n    xcpExtModeParseArgs(argc, argv);\n\n    /*\n     * Check for unprocessed (\"unhandled\") args.\n     */\n    {\n        int i;\n        for (i = 1; i<argc; i++) {\n            if (argv[i] != NULL) {\n                XCP_PRINTF(\"Unexpected command line argument: %s\\n\", argv[i]);\n                return EXTMODE_INV_ARG;\n            }\n        }\n    }\n\n#endif /* EXTMODE_DISABLE_ARGS_PROCESSING */\n\n    return errorCode;\n}\n\n\nextmodeErrorCode_T extmodeInit(RTWExtModeInfo *extmodeInfo, extmodeSimulationTime_T *finalTime)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if (extmodeInfo == NULL) {\n        XCP_PRINTF(\"extmodeInit: invalid extmodeInfo\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    if (finalTime == NULL) {\n        XCP_PRINTF(\"extmodeInit: invalid finalTime variable\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    if (xcpExtmodeFinalSimulationTime == EXTMODE_SIMULATION_TIME_NOT_INITIALIZED) {\n#if (defined(INTEGER_CODE) && INTEGER_CODE == 1)  || defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS)\n        /* If the model final simulation time in External Mode has NOT been initialized,\n           then EXTMODE_SIMULATION_RUN_FOREVER is assumed, as the Real-time Model\n           structure doesn't contain any final time information when PurelyIntegerCode\n           is selected */\n        xcpExtmodeFinalSimulationTime = EXTMODE_SIMULATION_RUN_FOREVER;\n#else\n        /* If the model final simulation time in External Mode has NOT been initialized,\n           then the finalTime argument is considered an INPUT */\n        xcpExtmodeFinalSimulationTime = *finalTime;\n#endif\n    }\n    else {\n        /* If the model final simulation time in External Mode has been initialized\n           (e.g.via '-tf ' parameter detected by extmodeParseArgs() or\n            via explicit call of extmodeSetFinalSimulationTime())\n           then the finalTime argument is considered an OUTPUT */\n        *finalTime = xcpExtmodeFinalSimulationTime;\n    }\n\n    if (xcpExtmodeFinalSimulationTime == EXTMODE_SIMULATION_RUN_FOREVER) {\n        XCP_PRINTF(\"\\n**warning: the simulation will run with no stop time due \"\n            \"to external mode infinite final simulation time.\\n\");\n    }\n\n    /* Initialize the model checksum information */\n    xcpModelChecksum0 = rteiGetChecksum0(extmodeInfo);\n    xcpModelChecksum1 = rteiGetChecksum1(extmodeInfo);\n    xcpModelChecksum2 = rteiGetChecksum2(extmodeInfo);\n    xcpModelChecksum3 = rteiGetChecksum3(extmodeInfo);\n\n#if defined(INTEGER_CODE) && INTEGER_CODE == 1\n    xcpModelIntegerCode = 1;\n#else\n    xcpModelIntegerCode = 0;\n#endif\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n    xcpExtModeClassicTriggerInit();\n\n    /* By default, use Classic Triggering */\n    {\n        unsigned i = 0;\n        for (i = 0; i < EXTMODE_XCP_MAX_TRIGGER_NUMBER; i++) {\n            xcpCustomTriggerFunction[i] = xcpExtModeClassicTriggerEnabled;\n        }\n    }\n#endif\n\n    /* Initialize the platform abstraction layer common services */\n    errorCode = xcpExtModeInit();\n    \n    if (errorCode == XCP_SUCCESS) {\n        xcpModelStatus = XCP_EXTMODE_STATUS_INITIALIZED;\n    }\n\n    return XCP_TO_EXTMODE_ERROR_CODE(errorCode);\n}\n\n\nextmodeErrorCode_T extmodeWaitForHostRequest(extmodeRealTime_T timeoutInMicroseconds)\n{\n    extmodeErrorCode_T errorCode = EXTMODE_SUCCESS;\n    extmodeRealTime_T elapsedTime = 0;\n    boolean_T timeoutExpired = false;\n    boolean_T waitForHostRequest = !xcpModelStartRequest;\n    xcpModelStatus = XCP_EXTMODE_STATUS_WAITING_TO_START;\n\n    timeoutExpired = (timeoutInMicroseconds == 0) && !xcpModelStartRequest && !xcpModelStopRequest;\n\n    /*\n     * Pause until the XCP client modifies the xcpModelStartRequest value\n     * or a stop request has been issued\n     */\n    while (!xcpModelStartRequest && !xcpModelStopRequest && !timeoutExpired) {\n        XCP_SLEEP(0L, EXTMODE_RETRY_TIME_IN_MICROSECONDS);\n        elapsedTime += EXTMODE_RETRY_TIME_IN_MICROSECONDS;\n\n        timeoutExpired = (timeoutInMicroseconds != EXTMODE_WAIT_FOREVER) &&\n                         (elapsedTime > timeoutInMicroseconds);\n\n        xcpExtModeRunBackground(DEFAULT_XCP_EXTMODE_RUN_BACKGROUND_FLUSH);\n    }\n\n    xcpModelStatus = XCP_EXTMODE_STATUS_READY_TO_RUN;\n\n    if (timeoutExpired) {\n        errorCode = EXTMODE_TIMEOUT_ERROR;\n    }\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n    /* Avoid missing logged data points at t = 0 in concurrent execution workflows. */\n    if (waitForHostRequest) {\n        xcpExtModeClassicTriggerForceEnableStatusUpdate();\n    }\n#endif\n    return errorCode;\n}\n\n\nextmodeErrorCode_T extmodeEvent(extmodeEventId_T eventId, extmodeSimulationTime_T simulationTime)\n{\n    XcpErrorCode errorCode  = XCP_SUCCESS;\n    boolean_T triggerEnable = true;\n\n#if (!defined(INTEGER_CODE) || (INTEGER_CODE == 0)) && (!defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS))\n    if (simulationTime < 0) {\n        XCP_PRINTF(\"extmodeEvent error: invalid simulationTime, must be non-negative\\n\");\n        return EXTMODE_INV_ARG;\n    }\n#endif\n\n    if (eventId > EXTMODE_MAX_EVENT_ID) {\n        XCP_PRINTF(\"extmodeEvent error: invalid eventId (%d), must be less than %d\\n\", eventId, EXTMODE_MAX_EVENT_ID);\n        return EXTMODE_INV_ARG;\n    }\n    \n    if ((xcpModelStatus == XCP_EXTMODE_STATUS_READY_TO_RUN) ||\n        (xcpModelStatus == XCP_EXTMODE_STATUS_INITIALIZED)) {\n        /* Update model status, as soon as the extmodeEvent() gets invoked */\n        xcpModelStatus = XCP_EXTMODE_STATUS_RUNNING;\n    }\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n    if ((eventId < EXTMODE_XCP_MAX_TRIGGER_NUMBER) &&\n        (xcpCustomTriggerFunction[eventId] != NULL)) {\n        /* Trigger logic should be applied only when the synchronous\n           data transfer is active */\n        XcpStatus xcpStatus = xcpGetStatus();\n        if (xcpStatus == XCP_SYNC_DATA_TRANSFER) {\n            triggerEnable = xcpCustomTriggerFunction[eventId](eventId);\n        }\n    }\n#endif\n    {\n        XcpEventIdType xcpEventId = (XcpEventIdType) eventId;\n\n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n        /* Update local absolute time variables*/\n        uint32_T timestampBasedOnSimTime = xcpExtModeGetUpdatedTimestamp(simulationTime, eventId);\n#else\n        /* Update local absolute time variables*/\n        xcpExtModeUpdateTime(simulationTime, eventId);\n#endif\n\n        if (triggerEnable) {\n#ifdef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n            /* Notify XCP Stack about the eventId */\n            errorCode = xcpEventExternalTimestamp(xcpEventId, timestampBasedOnSimTime);\n#else\n            /* Notify XCP Stack about the eventId, using the timestamp read\n               from the HW timer supported by XCP Platform Abstraction layer */\n            errorCode = xcpEvent(xcpEventId);\n#endif\n        } else {\n            /* reset pending packed DAQ lists if the trigger did not fire so that we do not send\n               packets with non-consecutive samples */\n            xcpPackedModeEventReset(xcpEventId);\n        }\n    }\n\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"extmodeEvent error: code %d\\n\", errorCode);\n    }\n\n    return XCP_TO_EXTMODE_ERROR_CODE(errorCode);\n}\n\n\nextmodeErrorCode_T extmodeBackgroundRun(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    errorCode = xcpExtModeRunBackground(DEFAULT_XCP_EXTMODE_RUN_BACKGROUND_FLUSH);\n\n    return XCP_TO_EXTMODE_ERROR_CODE(errorCode);\n}\n\n\nextmodeErrorCode_T extmodeReset(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    xcpModelStatus = XCP_EXTMODE_STATUS_RESETTING;\n    \n    errorCode = xcpExtModeReset();\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n    XCP_MEMSET(xcpCustomTriggerFunction, 0, sizeof(xcpCustomTriggerFunction));\n\n    xcpExtModeClassicTriggerReset();\n#endif\n\n    xcpModelStatus = XCP_EXTMODE_STATUS_RESET;\n    \n    return XCP_TO_EXTMODE_ERROR_CODE(errorCode);\n}\n\nboolean_T extmodeStopRequested(void)\n{\n    return xcpModelStopRequest;\n}\n\nboolean_T extmodeStartRequested(void)\n{\n    return xcpModelStartRequest;\n}\n\n\nboolean_T extmodeSimulationComplete(void)\n{\n    return xcpExtmodeSimulationComplete;\n}\n\nextmodeErrorCode_T extmodeGetFinalSimulationTime(extmodeSimulationTime_T *finalTime)\n{\n    if (finalTime == NULL) {\n        XCP_PRINTF(\"extmodeGetFinalSimulationTime: invalid finalTime variable\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    if (xcpExtmodeFinalSimulationTime == EXTMODE_SIMULATION_TIME_NOT_INITIALIZED) {\n        XCP_PRINTF(\"extmodeGetFinalSimulationTime: finalTime not initialized\\n\");\n        return EXTMODE_NOT_INITIALIZED;\n    }\n\n    *finalTime = xcpExtmodeFinalSimulationTime;\n\n    return EXTMODE_SUCCESS;\n}\n\nextmodeErrorCode_T extmodeSetFinalSimulationTime(extmodeSimulationTime_T finalTime)\n{\n#if (!defined(INTEGER_CODE) || (INTEGER_CODE == 0)) && (!defined(XCP_EXTMODE_SIMULATION_TIME_IN_TICKS))\n    if ((finalTime < 0) && (finalTime != EXTMODE_SIMULATION_RUN_FOREVER)) {\n        XCP_PRINTF(\"extmodeSetFinalSimulationTime: invalid finalTime value\\n\");\n        return EXTMODE_INV_ARG;\n    }\n#endif\n\n    xcpExtmodeFinalSimulationTime = finalTime;\n\n    return EXTMODE_SUCCESS;\n}\n\n#ifdef EXTMODE_XCP_TRIGGER_SUPPORT\n\nextmodeErrorCode_T extmodeGetEventTriggerEnable(extmodeEventId_T eventId, extmodeEventTriggerEnable *triggerEnable)\n{\n    if (eventId >= EXTMODE_XCP_MAX_TRIGGER_NUMBER) {\n        XCP_PRINTF(\"extmodeGetEventTriggerEnable: invalid eventId value\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    if (triggerEnable == NULL) {\n        XCP_PRINTF(\"extmodeGetEventTriggerEnable: invalid triggerEnabled value\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    *triggerEnable = xcpCustomTriggerFunction[eventId];\n\n    return EXTMODE_SUCCESS;\n}\n\nextmodeErrorCode_T extmodeSetEventTriggerEnable(extmodeEventId_T eventId, extmodeEventTriggerEnable triggerEnable)\n{\n    if (eventId >= EXTMODE_XCP_MAX_TRIGGER_NUMBER) {\n        XCP_PRINTF(\"extmodeSetEventTriggerEnable: invalid eventId value\\n\");\n        return EXTMODE_INV_ARG;\n    }\n\n    xcpCustomTriggerFunction[eventId] = triggerEnable;\n    return EXTMODE_SUCCESS;\n}\n\n#else\n\nextmodeErrorCode_T extmodeGetEventTriggerEnable(extmodeEventId_T eventId, extmodeEventTriggerEnable *triggerEnable)\n{\n    UNUSED_PARAMETER(eventId);\n\n    if (triggerEnable != NULL) {\n        *triggerEnable = NULL;\n    }\n\n    return EXTMODE_SUCCESS;\n}\n\nextmodeErrorCode_T extmodeSetEventTriggerEnable(extmodeEventId_T eventId, extmodeEventTriggerEnable triggerEnable)\n{\n    UNUSED_PARAMETER(eventId);\n    UNUSED_PARAMETER(triggerEnable);\n\n    return EXTMODE_SUCCESS;\n}\n\n#endif\n"},{"name":"xcp_ext_param_default_serial.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2024a/toolbox/coder/xcp/src/target/ext_mode/src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2017-2022 The MathWorks, Inc.\n *\n * File: xcp_ext_param_default_serial.c     \n *\n * Abstract:\n *  The file provides the implementation of the xcp_ext_param.h \n *  interface specific for the XCP Default Platform Abstraction Layer\n *  for the Serial transport layer.\n */\n\n#include \"rtwtypes.h\"\n\n#include \"rtw_extmode.h\"\n\n#include \"xcp_common.h\"\n#include \"xcp_ext_param.h\"\n\n#ifndef EXTMODE_DISABLE_ARGS_PROCESSING\n\n /** Transport Layer initialization parameters \n     @note the default values can be overwritten when parsing the\n           External Mode command line arguments */\nstatic const void* xcpTransportLayerParams[] =\n{\n    \"-port\", \"1\",\n    \"-baud\", \"57600\",\n    \"-verbose\", \"0\",\n};\n\n#endif /* EXTMODE_DISABLE_ARGS_PROCESSING */\n\nvoid xcpExtModeParseArgs(int_T argc, const char_T *argv[])\n{\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    /* Some targets do not support command line args */\n    UNUSED_PARAMETER(argc);\n    UNUSED_PARAMETER(argv);\n#else\n    if ((argv != NULL) && (argc > 0)) {\n        int_T optionId = 1;\n        uint_T idx;\n\n        while (optionId < argc) {\n            const char_T *option = argv[optionId];\n\n            optionId++;\n\n            if ((option != NULL) && (optionId != argc)) {\n                boolean_T isXcpOption = false;\n\n                for (idx = 0; idx < sizeof(xcpTransportLayerParams)/sizeof(xcpTransportLayerParams[0]); idx = idx + 2){\n                    if (strcmp(option, xcpTransportLayerParams[idx]) == 0) {\n                        xcpTransportLayerParams[idx+1] = argv[optionId];\n                        isXcpOption = true;\n                        break;\n                    }\n                }\n\n                if (isXcpOption) {\n                    /* Mark arguments as \"processed\" */\n                    argv[optionId - 1] = NULL;\n                    argv[optionId] = NULL;\n                }\n                \n                optionId++;\n            }\n        }\n    }\n#endif\n}\n\nvoid xcpTransportGetInitParameters(int_T *parNumber, void **parList[])\n{\n#ifdef  EXTMODE_DISABLE_ARGS_PROCESSING\n    if ((parNumber != NULL) && (parList != NULL)) {\n        /* No Transport Layer parameters defined (assuming rtiostream default) */\n        *parNumber = 0;\n        *parList = NULL;\n    }\n#else    \n    if ((parNumber != NULL) && (parList != NULL)) {\n        *parNumber = XCP_ELEMENTS_NUMBER(xcpTransportLayerParams);\n        *parList = (void **) &xcpTransportLayerParams;\n    }\n#endif\n}\n\nvoid xcpGetInitParameters(int_T *parNumber, void **parList[])\n{\n    if ((parNumber != NULL) && (parList != NULL)) {\n        /* No Protocol Layer parameters available at the moment */\n        *parNumber = 0;\n        *parList = NULL;\n    }\n}\n\n\n"},{"name":"xcp_fifo.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2024a/toolbox/coder/xcp/src/target/server/transport/src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2020 The MathWorks, Inc.\n*\n* File: xcp_fifo.c\n*\n* Abstract:\n*  Implementation of FIFO data structure based on single linked list\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp_fifo.h\"\n\n\nvoid xcpFifoInit(struct xcpFifo * fifo)\n{\n    fifo->first = NULL;\n    fifo->last = &(fifo)->first;\n}\n\n\nvoid xcpFifoEnqueue(struct xcpFifo *fifo, struct xcpFifoEntry *element)\n{\n    element->next = NULL;\n    *(fifo)->last = element;\n    fifo->last = &(element->next);\n}\n\n\nvoid xcpFifoDequeue(struct xcpFifo *fifo, struct xcpFifoEntry **element)\n{\n    *element = fifo->first;\n\n    if (fifo->first != NULL) {\n        fifo->first = fifo->first->next;\n\n        if (fifo->first == NULL)\n            fifo->last = &(fifo)->first;\n    }\n}\n\n\nvoid xcpFifoEnqueueHead(struct xcpFifo *fifo, struct xcpFifoEntry *element)\n{\n    element->next = (fifo)->first;\n\n    if ((fifo)->first == NULL) {\n        (fifo)->last = &(element->next);\n    }\n\n    (fifo)->first = element;\n}\n\n\nvoid xcpFifoSpliceHead(struct xcpFifo *dstFifo, struct xcpFifo *srcFifo)\n{\n    if (srcFifo->first != NULL) {\n        *(srcFifo->last) = dstFifo->first;\n        dstFifo->first = srcFifo->first;\n         \n        srcFifo->first = NULL;\n        srcFifo->last = &(srcFifo)->first;\n    }\n}\n\n\nboolean_T xcpFifoEmpty(struct xcpFifo *fifo)\n{\n    return ((fifo)->first == NULL);\n}\n\n\nvoid xcpFifoReset(struct xcpFifo * fifo)\n{\n    xcpFifoInit(fifo);\n}\n"},{"name":"xcp_frame_serial.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2024a/toolbox/coder/xcp/src/target/server/transport/src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2023 The MathWorks, Inc.\n*\n* File: xcp_frame_serial.c\n*\n* Abstract:\n*  XCP Frame Handler implementation for the Serial transport layer.\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_frame.h\"\n#include \"xcp_frame_serial.h\"\n#include \"xcp_drv.h\"\n#include \"xcp_mem.h\"\n#include \"xcp_types.h\"\n\n\n/* Frame Handler internal counters */\n#if XCP_SERIAL_USES_CTR\nstatic uintCTR_T txCounter = 0;\nstatic uintCTR_T rxCounter = 0;\nstatic int       firstRxCounterReceived = 0;\n#endif\n\n/* true if the Frame Handler has been successfully initialized */\nstatic boolean_T initialized = false;\n\n/* ID for of the memory pool reserved for the allocation of\n    CTO XCP Packets */\nstatic xcpPoolId_T xcpCtoReservedMemPoolId = -1;\n\n\nuint16_T xcpSxiHtons(uint16_T hostShort)\n{\n#ifndef XCP_BIG_ENDIAN\n    return hostShort;\n#else\n    return ((hostShort & 0xFF00) >> 8) | ((hostShort & 0x00FF) << 8);\n#endif\n}\n\n\nuint16_T xcpSxiNtohs(uint16_T networkShort)\n{\n    return xcpSxiHtons(networkShort);\n}\n\n#if XCP_SERIAL_USES_CS\n /*\n  * Checksum is calculated for all octets in a target memory location.\n  * length : number of target memory locations.\n  */\n#if XCP_ADDRESS_GRANULARITY == XCP_ADDRESS_GRANULARITY_BYTE\n    uintCS_T xcpSxiChecksum(const void *buffer, uintLEN_T length){\n        const uint8_T *buf = buffer;\n        uintCS_T checkSum = 0;\n        while (length-- > 0) {\n            /* buf is a uint8_T* so endian transformation is not required. */\n            checkSum += *buf++;\n        }\n        return checkSum;\n    }\n#elif XCP_ADDRESS_GRANULARITY == XCP_ADDRESS_GRANULARITY_WORD\n    uintCS_T xcpSxiChecksum(const void *buffer, uintLEN_T length){\n        const uint16_T *buf = buffer;\n        uintCS_T checkSum = 0;\n        while (length-- > 0){\n            checkSum += *buf & 0x00FF;\n            checkSum += (*buf++) >> 8;\n        }\n        return checkSum;\n    }\n#endif\n\n#endif\n\nXcpErrorCode xcpFrameInit(\n    int   argc,   /**< [in] number of init parameters              */\n    void *argv[]  /**< [in] array of parameters values (C strings) */\n    )\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_ERROR_IF(initialized, XCP_ERROR, \"xcpFrameInit: frame handler already initialized\\n\");\n\n    /* Open the XCP driver */\n    errorCode = xcpDrvOpen(argc, argv);\n    if (errorCode == XCP_SUCCESS) {\n#if XCP_SERIAL_USES_CTR\n        txCounter = 0;\n        rxCounter = 0;\n        firstRxCounterReceived = 0;\n#endif\n        initialized = true;\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpFrameMsgSend(\n    void    *msgBuffer,  /**< [in] pointer to the base address of the buffer where the message is stored */\n    size_t   msgOffset,  /**< [in] offset (from base address in AG units) where the XCP message frame is stored */\n    size_t   msgSize     /**< [in] size (in AG units) of XCP message frame */\n    )\n{\n    /* This function works properly only if the XCP_SERIAL_HEADER_FORMAT is LEN_WORD_CTR_WORD and \n     * XCP_SERIAL_TAIL_FORMAT is CHECKSUM_WORD.\n     */\n    uint8_T *bufferPtr = NULL;\n    struct XcpHeader *header = NULL;\n    uintLEN_T lengthInBytes = 0;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n#if XCP_SERIAL_USES_CS\n    uintCS_T checksum;\n    struct XcpTail *tail;\n#endif\n\n    XCP_ERROR_IF(msgBuffer == NULL, XCP_INV_ARG, \"xcpFrameMsgSend: invalid msgBuffer\\n\");\n    XCP_ERROR_IF(msgSize < sizeof(struct XcpHeader) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE), XCP_INV_ARG, \"xcpFrameMsgSend: invalid msgSize\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpFrameMsgSend: frame handler not initialized\\n\");\n\n    bufferPtr = (uint8_T *) msgBuffer + msgOffset;\n\n    header = (struct XcpHeader *) bufferPtr;\n    lengthInBytes = LenSxiNtoH(header->length);\n\n    if ( ( lengthInBytes == 0 ) ||\n         ( msgSize < ( sizeof(struct XcpHeader) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE) + XCP_IN_AG(lengthInBytes) ) )\n       ) {\n        XCP_PRINTF(\"xcpFrameMsgSend: invalid message format detected\\n\");\n        return XCP_INV_MSG_FORMAT;\n    }\n\n#if XCP_SERIAL_USES_CTR\n    /* Set the value of the transport layer txCounter immediately before\n     * sending the message so that it reflects the correct order for the\n     * sequence of frames that are sent rather than the sequence in which\n     * they are constructed (which could be different in the case where\n     * there are multiple prioritized queues). */\n    header->counter = CtrSxiHtoN(txCounter);\n#endif\n\n#if XCP_SERIAL_USES_CS\n    tail = (struct XcpTail *) ((char *) header + sizeof(struct XcpHeader) + XCP_IN_AG(lengthInBytes));\n    checksum = CsSxiHtoN(xcpSxiChecksum(header, sizeof(struct XcpHeader) + XCP_IN_AG(lengthInBytes)));\n    XCP_MEMCPY(&tail->cs, &checksum, sizeof(tail->cs));\n#endif\n\n    /* Send the XCP Frame Header\n     * If the xcpDrvSend() is blocking, the return code should be XCP_SUCCESS\n     * If the xcpDrvSend() is non-blocking, the return code could be XCP_SUCCESS or XCP_BUSY.\n     * If something went wrong we should get XCP_ERROR or XCP_PKT_TX_TIMEOUT_ERROR */\n    errorCode = xcpDrvSend(bufferPtr, XCP_SERIAL_HEADER_SIZE);\n    if(errorCode != XCP_SUCCESS){\n        return errorCode;\n    }\n    bufferPtr += XCP_IN_AG(XCP_SERIAL_HEADER_SIZE);\n\n    /* Since have already started sending the packet, we should wait until \n     * the remaining part is sent, or a XCP_PKT_TX_TIMEOUT_ERROR has occurred.\n     * For this reason we force the subsequent xcpDrvRecv to be blocking */\n    xcpDrvIoctl(XCP_DRV_FORCE_BLOCKING);\n\n    /* Send the XCP Packet */\n    errorCode = xcpDrvSend(bufferPtr, lengthInBytes);\n    if(errorCode != XCP_SUCCESS){\n        goto txError;\n    }\n    bufferPtr += XCP_IN_AG(lengthInBytes);\n\n    /* Send the XCP Frame Tail */\n    errorCode = xcpDrvSend(bufferPtr, XCP_SERIAL_TAIL_SIZE);\n    if (errorCode != XCP_SUCCESS){\n        goto txError;\n    }\n\n    /* If successfully sent, the buffer can be freed */\n    if (errorCode == XCP_SUCCESS) {\n        xcpMemFree(msgBuffer);\n    }\n\n#if XCP_SERIAL_USES_CTR\n    /* Don't increment the counter if the transfer of the packet is delayed\n       due to the transport layer being busy. */\n    if (errorCode != XCP_BUSY) {\n        txCounter++;\n    }\n#endif\n\ntxError:\n    /* The packet has been sent, or an error occurred. In any case\n     * we can restore the default blocking/non-blocking behavior */\n    xcpDrvIoctl(XCP_DRV_RESTORE_DEFAULT_BLOCKING_SETUP);\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpFrameMsgRecv(\n    void  **msgBuffer,  /**< [out] pointer to the base address of the buffer where the message is stored */\n    size_t  msgOffset,  /**< [in] offset (from base address in AG units) where the XCP message frame is stored */\n    size_t *msgSize     /**< [out] size (in AG units) of the XCP message frame that has been received */\n    )\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    struct XcpHeader rxHeader;\n    uintLEN_T lengthInBytes = 0;\n    uint8_T *buffer;\n    uint8_T *bufferPtr;\n\n    XCP_ERROR_IF(msgBuffer == NULL, XCP_INV_ARG, \"xcpFrameMsgRecv: invalid msgBuffer pointer\\n\");\n    XCP_ERROR_IF(msgSize == NULL, XCP_INV_ARG, \"xcpFrameMsgRecv: invalid msgSize pointer\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpFrameMsgRecv: frame handler not initialized\\n\");\n\n    /* Receive message header first.\n     * If the xcpDrvRecv() is blocking, the return code should be XCP_SUCCESS\n     * If the xcpDrvRecv() is non-blocking, the return code could be XCP_SUCCESS or XCP_EMPTY\n     * If something went wrong we should get XCP_ERROR or XCP_PKT_RX_TIMEOUT_ERROR */\n    errorCode = xcpDrvRecv(&rxHeader, XCP_SERIAL_HEADER_SIZE);\n    if (errorCode != XCP_SUCCESS) {\n        return errorCode;\n    }\n\n    /* Infer the number of BYTES in the XCP Packet from the received header.\n     * This may not be a multiple of XCP_ADDRESS_GRANULARITY */\n    lengthInBytes = LenSxiNtoH(rxHeader.length);\n    if (lengthInBytes == 0) {\n        XCP_PRINTF(\"xcpFrameMsgRecv: invalid message format detected\\n\");\n        errorCode = XCP_INV_MSG_FORMAT;\n        return errorCode;\n    }\n\n    /* Request to the XCP allocator the memory for the message to be received.\n     * STIM packets are not supported at the moment. For this reason\n     * the XCP Server can only receive CTOs */\n    buffer = xcpMemAllocFromPool(xcpCtoReservedMemPoolId,\n                msgOffset\n                + XCP_IN_AG(XCP_SERIAL_HEADER_SIZE)\n                + XCP_IN_AG(lengthInBytes)\n                + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE) );\n\n    if (buffer == NULL) {\n        errorCode = XCP_NO_MEMORY;\n        return errorCode;\n    }\n\n    bufferPtr = buffer;\n\n    /* Initialize the header part */\n    XCP_MEMSET(bufferPtr, 0, msgOffset);\n    bufferPtr += msgOffset;\n\n    XCP_MEMCPY(bufferPtr, &rxHeader, sizeof(rxHeader));\n    bufferPtr += sizeof(rxHeader);\n\n    /* Since have already started receiving the packet, we should wait until\n     * the remaining part is received, or a XCP_PKT_RX_TIMEOUT_ERROR has occurred.\n     * For this reason we force the subsequent xcpDrvRecv to be blocking */\n    xcpDrvIoctl(XCP_DRV_FORCE_BLOCKING);\n\n    /* Receive the XCP packet */\n    errorCode = xcpDrvRecv(bufferPtr, lengthInBytes);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpFrameMsgRecv: received XCP header, but XCP packet is not available or packet size is incorrect\\n\");\n        errorCode = XCP_INV_MSG_FORMAT;\n        goto rxError;\n    }\n\n    bufferPtr  += XCP_IN_AG(lengthInBytes);\n\n    /* Receive the XCP packet */\n    errorCode = xcpDrvRecv(bufferPtr, XCP_SERIAL_TAIL_SIZE);\n\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpFrameMsgRecv: received XCP header and XCP packet, but XCP tail is not available or packet size is incorrect\\n\");\n        errorCode = XCP_INV_MSG_FORMAT;\n        goto rxError;\n    }\n\n    /* The packet has been received, so we can restore\n     * the default blocking/non-blocking behavior */\n    xcpDrvIoctl(XCP_DRV_RESTORE_DEFAULT_BLOCKING_SETUP);\n\n    *msgBuffer = buffer;\n    *msgSize = sizeof(rxHeader) + XCP_IN_AG(lengthInBytes) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE);\n\n    return errorCode;\n\nrxError:\n    /* An error occurred while receiving a packet, so we can restore\n     * the default blocking/non-blocking behavior */\n    xcpDrvIoctl(XCP_DRV_RESTORE_DEFAULT_BLOCKING_SETUP);\n\n    *msgBuffer = NULL;\n    *msgSize = 0;\n    xcpMemFree(buffer);\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpFrameCreateMsg(\n    void        *msgFrame,           /**< [out] pointer to the buffer containing the full message frame */\n    size_t       msgFrameBufferSize, /**< [in]  max size (in AG units) of the buffer where the message frame is copied */\n    size_t      *msgFrameSize,       /**< [out] size (in AG units) of the generated msg frame */\n    size_t       xcpPacketSize       /**< [in]  size (in BYTEs) of the XCP packet. */\n    )\n{\n    struct XcpHeader *header = (struct XcpHeader *) msgFrame;\n\n    /* Input parameters validation */\n    XCP_ERROR_IF(msgFrame == NULL, XCP_INV_ARG, \"xcpFrameCreateMsg: invalid msgFrame buffer\\n\");\n    XCP_ERROR_IF(msgFrameSize == NULL, XCP_INV_ARG, \"xcpFrameCreateMsg: invalid msgFrameSize pointer\\n\");\n    XCP_ERROR_IF(xcpPacketSize == 0, XCP_INV_ARG, \"xcpFrameCreateMsg: invalid xcpPacketSize\\n\");\n    XCP_ERROR_IF(msgFrameBufferSize < (XCP_IN_AG(xcpPacketSize) + sizeof(struct XcpHeader) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE)), XCP_INV_ARG, \"xcpFrameCreateMsg: invalid msgFrameBufferSize\\n\");\n\n    /* update XCP header */\n    /* header->length = number of BYTES in the XCP Packet */\n    header->length = LenSxiHtoN((uint16_T)xcpPacketSize);\n\n    *msgFrameSize = XCP_IN_AG(xcpPacketSize) + sizeof(struct XcpHeader) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE);\n\n    return XCP_SUCCESS;\n}\n\n\nXcpErrorCode xcpFrameExtractPacket(\n    const void  *msgFrame,      /**< [in]  pointer to the buffer containing full message frame content */\n    size_t       msgFrameSize,  /**< [in]  size (in AG units) of the full message frame */\n    size_t      *xcpPacketSize  /**< [out] size (in BYTEs) of the XCP packet that has been processed */\n    )\n{\n    const struct XcpHeader *header = (const struct XcpHeader *) msgFrame;\n    uintLEN_T length = 0;\n#if XCP_SERIAL_USES_CTR\n    uintCTR_T counter = 0;\n#endif\n#if XCP_SERIAL_USES_CS\n    const struct XcpTail *tail;\n    uintCS_T checksum = 0;\n#endif\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    /* Input parameters validation */\n    XCP_ERROR_IF(msgFrame == NULL, XCP_INV_ARG, \"xcpFrameExtractPacket: invalid msgFrame\\n\");\n    XCP_ERROR_IF(xcpPacketSize == NULL, XCP_INV_ARG, \"xcpFrameExtractPacket: invalid xcpPacketSize pointer\\n\");\n    XCP_ERROR_IF(msgFrameSize <= sizeof(struct XcpHeader), XCP_INV_ARG, \"xcpFrameExtractPacket: invalid msgFrameSize\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpFrameExtractPacket: frame handler not initialized\\n\");\n\n    /* Extract info from the received message */\n    length = LenSxiNtoH(header->length);\n#if XCP_SERIAL_USES_CTR\n    counter = CtrSxiNtoH(header->counter);\n#endif\n\n    /* Check message length */\n    if (msgFrameSize != (XCP_IN_AG(length) + XCP_IN_AG(XCP_SERIAL_HEADER_SIZE) + XCP_IN_AG(XCP_SERIAL_TAIL_SIZE))) {\n        XCP_PRINTF(\"xcpFrameExtractPacket: Xcp packet has an invalid size\\n\");\n        return XCP_INV_MSG_FORMAT;\n    }\n\n#if XCP_SERIAL_USES_CTR\n    /* Check message counter */\n    if (!firstRxCounterReceived) {\n        /* No checks can be carried out the first time */\n        firstRxCounterReceived = 1;\n    }\n    else {\n        if (counter < (rxCounter + 1)) {\n            errorCode = XCP_PKT_OUT_OF_SEQUENCE;\n        }\n        else if (counter >(rxCounter + 1)) {\n            errorCode = XCP_PKT_LOST;\n        }\n    }\n    rxCounter = counter;\n#endif\n\n    /* Verify the checksum */\n#if XCP_SERIAL_USES_CS\n    tail = (const struct XcpTail *) ((const char *) msgFrame + sizeof(struct XcpHeader) + XCP_IN_AG(length));\n    XCP_MEMCPY(&checksum, &tail->cs, sizeof(checksum));\n    checksum = CsSxiNtoH(checksum);\n    XCP_ERROR_IF(checksum != xcpSxiChecksum(header, sizeof(struct XcpHeader) + XCP_IN_AG(length)), XCP_PKT_CHECKSUM_ERROR, \"xcpFrameExtractPacket: invalid checksum\\n\");\n#endif\n    *xcpPacketSize = length;\n\n    return errorCode;\n}\n\n/* Returns the number of BYTEs in an XCP Frame Header */\nsize_t xcpFrameHeaderSize(void)\n{\n    return XCP_SERIAL_HEADER_SIZE;\n}\n\n/* Returns the number of BYTEs in an XCP Tail */\nsize_t xcpFrameTailSize(void)\n{\n    return XCP_SERIAL_TAIL_SIZE;\n}\n\n\nsize_t xcpFrameMaxDtoSize(void)\n{\n    return XCP_MAX_DTO_SIZE;\n}\n\n\nsize_t xcpFrameMaxCtoSize(void)\n{\n    return XCP_MAX_CTO_SIZE;\n}\n\n\nXcpErrorCode xcpFrameRestart(void)\n{\n#if XCP_SERIAL_USES_CTR\n    txCounter = 0;\n    rxCounter = 0;\n    firstRxCounterReceived = 0;\n#endif\n\n    return XCP_SUCCESS;\n}\n\n\nvoid xcpFrameSetCtoReservedMemPoolId(xcpPoolId_T poolId)\n{\n    xcpCtoReservedMemPoolId = poolId;\n}\n\n\nXcpErrorCode xcpFrameReset(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if (!initialized) {\n        XCP_PRINTF(\"xcpFrameReset: frame handler already reset\\n\");\n        return XCP_SUCCESS; /* Nothing to do: just printing out a warning message*/\n    }\n\n    /* Close the actual communication channel */\n    errorCode = xcpDrvClose();\n    if (errorCode == XCP_SUCCESS) {\n#if XCP_SERIAL_USES_CTR\n        txCounter = 0;\n        rxCounter = 0;\n        firstRxCounterReceived = 0;\n#endif\n        initialized = false;\n    } else {\n        XCP_PRINTF(\"xcpFrameReset: xcpDrvClose error\\n\");\n    }\n\n    return errorCode;\n}\n"},{"name":"xcp_mem_default.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2024a/toolbox/coder/xcp/src/target/server/platform/default","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2023 The MathWorks, Inc.\n*\n* File: xcp_mem_default.c\n*\n* Abstract:\n*  Implementation of default XCP Server memory allocator\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp_mem.h\"\n#include \"xcp_mem_default.h\"\n#include \"xcp_utils.h\"\n\n#define PADDING (XCP_MEM_ALIGNMENT-1)\n\n/* Array of XcpMemPoolDescriptor for each block size to allow freeing and\n   allocating blocks.\n\n   @note this includes both the Main Memory area and the Reserved Pools\n         Memory Area */\nstatic XcpMemPoolDescriptor xcpMemPoolDescriptors[XCP_MEM_MAIN_RESERVED_POOL_NUMBER];\n\n/* xcpMemCustomPoolDescriptor stores the custom memory functions to allocate and\n   free memory for a specific memory pool */\nstatic XcpMemCustomPoolDescriptor xcpMemCustomPoolDescriptors[XCP_MEM_CUSTOM_POOL_MAX_NUMBER];\n\n\n/* Main memory chunk from which blocks are allocated using the xcpMemAlloc\n * This may not be aligned to XCP_MEM_ALIGNMENT depending on the compiler \n * and/or build flags.\n * Add padding bytes to the end to enable aligning blocks in xcpMemMainChunk\n * to aligned addresses if needed.\n */\nXCP_MEM_DATA_SECTION_BEGIN\nstatic uint8_T xcpMemMainChunk[XCP_MEM_MAIN_TOTAL_SIZE + PADDING];\nXCP_MEM_DATA_SECTION_END\n\n\n/* Reserved pools memory chunk from which pool blocks are allocated using the\n * xcpMemAllocFromPool()\n * Also refer to comments in xcpMemMainChunk\n */\nXCP_MEM_DATA_SECTION_BEGIN\nstatic uint8_T xcpMemReservedPoolsChunk[XCP_MEM_RESERVED_POOLS_TOTAL_SIZE + PADDING];\nXCP_MEM_DATA_SECTION_END\n\nstatic size_t  xcpMemReservedPoolsChunkUsedBytes;\n\n/* Mutex to prevent concurrent access to xcpMemPoolDescriptors, xcpMemMainChunk\n   and xcpMemReservedPoolsChunk\n   @note: the insertion/removal of blocks within each reserved pool is protected by a dedicated\n          lock, to reduce the interference between threads in multi-core applications */\nstatic XCP_MUTEX_DEFINE(xcpMemLock);\n\n\n/* Initialize pool's memory chunk, by creating the pool's memory blocks and as a linked list */\nstatic void xcpInitializePoolMemoryArea(uint8_T *memoryPtr, size_t blockSize, size_t blocksNumber)\n{\n    if (memoryPtr != NULL) {\n        XcpMemHeader *p, *prev = NULL;\n        size_t i;\n        /* Initialize memory to zero */\n        size_t totSize = XCP_MEM_BLOCK_SIZE_WITH_OVERHEAD(blockSize) * blocksNumber;\n        XCP_MEMSET(memoryPtr,  0, totSize);\n\n        for(i = 0 ; i < blocksNumber; ++i) {\n            p = (XcpMemHeader*) memoryPtr;\n            p -> next = NULL;\n            p -> poolId = XCP_FREE_POOL_ID;\n            if (prev) {\n                prev -> next = p;\n            }\n            memoryPtr += XCP_MEM_BLOCK_SIZE_WITH_OVERHEAD(blockSize);\n            prev = p;\n        }\n    }\n}\n\nXcpErrorCode xcpMemInit(void)\n{\n    uint8_T poolIdx;\n    uint8_T *memoryPtr = (uint8_T *)XCP_ALIGNED(xcpMemMainChunk);\n\n    XCP_MUTEX_INIT(xcpMemLock);\n\n\n#ifndef XCP_NO_MAIN_MEM_ALLOCATED\n    /* Sort main memory block */\n    xcpSortArray(xcpMemMainBlockSizes, xcpMemMainBlocksNumber, (size_t)XCP_MEM_MAIN_POOLS_NUMBER);\n\n    /* Initialize Main memory */\n    for(poolIdx = 0; poolIdx < XCP_MEM_MAIN_POOLS_NUMBER; ++poolIdx) {\n        size_t blocksCount = xcpMemMainBlocksNumber[poolIdx];\n        size_t blockSize = xcpMemMainBlockSizes[poolIdx];\n\n        xcpMemPoolDescriptors[poolIdx].head = (XcpMemHeader*) memoryPtr;\n        xcpMemPoolDescriptors[poolIdx].totalBlocksCount = blocksCount;\n        xcpMemPoolDescriptors[poolIdx].freeBlocksCount = blocksCount;\n        xcpMemPoolDescriptors[poolIdx].blockSize = blockSize;\n        xcpMemPoolDescriptors[poolIdx].poolSize =\n            blocksCount * XCP_MEM_BLOCK_SIZE_WITH_OVERHEAD(blockSize);\n#ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n        xcpMemPoolDescriptors[poolIdx].deferredFreeHead = NULL;\n        xcpMemPoolDescriptors[poolIdx].deferredFreeTail = NULL;\n        xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount = 0;\n#else\n        XCP_MUTEX_INIT(xcpMemPoolDescriptors[poolIdx].lock);\n#endif\n\n        xcpInitializePoolMemoryArea(memoryPtr, blockSize, blocksCount);\n        memoryPtr += xcpMemPoolDescriptors[poolIdx].poolSize;\n    }\n#else\n    (void)memoryPtr;\n#endif\n\n    /* Initialize Reserved pools memory\n       @note since the allocation of the memory pools is dynamic,\n             the creation of the blocks for each pool is deferred\n             and carried out within the xcpMemReservedPoolCreate() */\n    XCP_MEMSET(xcpMemReservedPoolsChunk, 0, sizeof(xcpMemReservedPoolsChunk));\n    xcpMemReservedPoolsChunkUsedBytes = 0;\n\n    for(poolIdx = XCP_MEM_MAIN_POOLS_NUMBER; poolIdx < XCP_MEM_MAIN_RESERVED_POOL_NUMBER; ++poolIdx) {\n        xcpMemPoolDescriptors[poolIdx].head = XCP_FREE_POOL;\n        xcpMemPoolDescriptors[poolIdx].totalBlocksCount = 0;\n        xcpMemPoolDescriptors[poolIdx].freeBlocksCount = 0;\n        xcpMemPoolDescriptors[poolIdx].blockSize = 0;\n        xcpMemPoolDescriptors[poolIdx].poolSize = 0;\n#ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n        xcpMemPoolDescriptors[poolIdx].deferredFreeHead = NULL;\n        xcpMemPoolDescriptors[poolIdx].deferredFreeTail = NULL;\n        xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount = 0;\n#else\n        XCP_MUTEX_INIT(xcpMemPoolDescriptors[poolIdx].lock);\n#endif\n    }\n\n    for(poolIdx = 0; poolIdx < XCP_MEM_CUSTOM_POOL_MAX_NUMBER; poolIdx++) {\n        xcpMemCustomPoolDescriptors[poolIdx].allocHandler = NULL;\n        xcpMemCustomPoolDescriptors[poolIdx].freeHandler = NULL;\n    }\n\n    return XCP_SUCCESS;\n}\n\n\nvoid* xcpMemAlloc(size_t size)\n{\n\n#ifndef XCP_NO_MAIN_MEM_ALLOCATED\n\n    uint8_T poolIdx;\n    size_t blockSize = 0;\n    XcpMemHeader *poolHead = NULL;\n\n    /* a size of 0 is considered an invalid argument */\n    if (size == 0) {\n        return NULL;\n    }\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    /* find the first large enough pool */\n    for(poolIdx = 0; poolIdx <  XCP_MEM_MAIN_POOLS_NUMBER; ++poolIdx) {\n        blockSize = xcpMemMainBlockSizes[poolIdx];\n        if ((size <= blockSize) && (xcpMemPoolDescriptors[poolIdx].freeBlocksCount > 0)) {\n            poolHead = xcpMemPoolDescriptors[poolIdx].head;\n            break;\n        }\n    }\n\n    if (!poolHead) { /* size is too large, or there are no more free blocks */\n       XCP_MUTEX_UNLOCK(xcpMemLock);\n       return NULL;\n    }\n\n    xcpMemPoolDescriptors[poolIdx].head = poolHead->next;\n    (xcpMemPoolDescriptors[poolIdx].freeBlocksCount)--;\n    poolHead->poolId = poolIdx;\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    /* return a pointer past just the poolId */\n    return ((uint8_T*) poolHead) + XCP_MEM_POOLID_SIZE;\n\n#else\n\n    (void)size;\n    return NULL;\n\n#endif\n\n}\n\n\nvoid xcpMemFree(void *ptr)\n{\n    if (ptr) {\n        /* the XcpMemHeader cell is 'behind' the user's pointer */\n        XcpMemHeader *hd = (XcpMemHeader*) ((uint8_T*)ptr - XCP_MEM_POOLID_SIZE);\n        uint8_T poolIdx = hd -> poolId;\n\n        if (poolIdx >= XCP_MEM_CUSTOM_POOLS_OFFSET && poolIdx < XCP_MEM_CUSTOM_POOLS_UPPER_BOUND) {\n            poolIdx = poolIdx - XCP_MEM_CUSTOM_POOLS_OFFSET;\n            if (xcpMemCustomPoolDescriptors[poolIdx].freeHandler) {\n                /* For custom memory pools, protection against concurrent\n                   exclusion must be guaranteed within the custom free method */\n                xcpMemCustomPoolDescriptors[poolIdx].freeHandler((uint8_T*)ptr - XCP_MEM_POOLID_SIZE);\n            }\n            return;\n        }\n\n        if ((poolIdx == XCP_FREE_POOL_ID) || (poolIdx >= XCP_MEM_MAIN_RESERVED_POOL_NUMBER)){\n            /* ill-formed block or already freed pointer */\n            XCP_PRINTF(\"xcpMemFree: invalid or double-freed pointer %p\\n\", ptr);\n            return;\n        }\n\n#ifndef XCP_NO_MAIN_MEM_ALLOCATED\n        /* insert the new free block in the front of the pool */\n        if (poolIdx < XCP_MEM_MAIN_POOLS_NUMBER) {\n            XCP_MUTEX_LOCK(xcpMemLock);\n\n            hd -> poolId = XCP_FREE_POOL_ID;\n            hd -> next = xcpMemPoolDescriptors[poolIdx].head;\n\n            xcpMemPoolDescriptors[poolIdx].head = hd;\n            ++(xcpMemPoolDescriptors[poolIdx].freeBlocksCount);\n\n            XCP_MUTEX_UNLOCK(xcpMemLock);\n        }\n        else\n#endif\n        {\n        #ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n            /* If lockless support is enabled, the freed memory block is\n               not immediately available for subsequent allocations,\n               until xcpMemReservedPoolFlushFreeMem is invoked */\n            hd -> poolId = XCP_FREE_POOL_ID;\n            hd -> next = xcpMemPoolDescriptors[poolIdx].deferredFreeHead;\n\n            if (xcpMemPoolDescriptors[poolIdx].deferredFreeTail == NULL) {\n                /* Let's save a reference to the first block in the pool\n                   that has been freed */\n                xcpMemPoolDescriptors[poolIdx].deferredFreeTail = hd;\n            }\n\n            xcpMemPoolDescriptors[poolIdx].deferredFreeHead = hd;\n            ++(xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount);\n        #else\n            XCP_MUTEX_LOCK(xcpMemPoolDescriptors[poolIdx].lock);\n\n            hd -> poolId = XCP_FREE_POOL_ID;\n            hd -> next = xcpMemPoolDescriptors[poolIdx].head;\n\n            xcpMemPoolDescriptors[poolIdx].head = hd;\n            ++(xcpMemPoolDescriptors[poolIdx].freeBlocksCount);\n            XCP_MUTEX_UNLOCK(xcpMemPoolDescriptors[poolIdx].lock);\n        #endif\n        }\n    }\n}\n\n\nXcpErrorCode xcpMemReservedPoolCreate(size_t blockSize, size_t blocksNumber, xcpPoolId_T* poolId)\n{\n    uint8_T poolIdx;\n    uint8_T *currentHead = (uint8_T *) XCP_ALIGNED(xcpMemReservedPoolsChunk);\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    xcpPoolId_T pool = XCP_INVALID_POOL_ID;\n    size_t requestedPoolSize;\n\n    if ((poolId == NULL) || (blockSize == 0) || (blocksNumber == 0)) {\n        XCP_PRINTF(\"xcpMemReservedPoolCreate: invalid input parameter\\n\");\n        return XCP_INV_ARG;\n    }\n\n    /* blockSize needs to be a multiple of XCP_MEM_ALIGNMENT in order to align blocks to aligned addresses.\n     * If the size is not a multiple, adjustment is done here.\n     */\n    blockSize = (size_t) XCP_ALIGNED(blockSize);\n\n    requestedPoolSize = blocksNumber * XCP_MEM_BLOCK_SIZE_WITH_OVERHEAD(blockSize);\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    for(poolIdx = XCP_MEM_MAIN_POOLS_NUMBER; poolIdx < XCP_MEM_MAIN_RESERVED_POOL_NUMBER; ++poolIdx) {\n        if (xcpMemPoolDescriptors[poolIdx].head == XCP_FREE_POOL) {\n            /* The pool is free, let's check if it is big enough */\n            if ((xcpMemPoolDescriptors[poolIdx].poolSize) == 0) {\n                /* The pool has never been allocated before, so this must be the last\n                   usable pool in the list */\n                if (requestedPoolSize <= (XCP_MEM_RESERVED_POOLS_TOTAL_SIZE - xcpMemReservedPoolsChunkUsedBytes)) {\n                    /* It is big enough, so let's mark it as allocated */\n                    xcpMemPoolDescriptors[poolIdx].head = (XcpMemHeader*) currentHead;\n                    xcpMemPoolDescriptors[poolIdx].totalBlocksCount = blocksNumber;\n                    xcpMemPoolDescriptors[poolIdx].freeBlocksCount = blocksNumber;\n                    xcpMemPoolDescriptors[poolIdx].blockSize = blockSize;\n                    xcpMemPoolDescriptors[poolIdx].poolSize = requestedPoolSize;\n                #ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeHead = NULL;\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeTail = NULL;\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount = 0;\n                #endif\n\n                    xcpInitializePoolMemoryArea(currentHead, blockSize, blocksNumber);\n                    xcpMemReservedPoolsChunkUsedBytes += requestedPoolSize;\n\n                    pool = poolIdx;\n                }\n                break; /* No more pools to process, exit from the loop */\n            } else {\n                /* The pool has already been allocated so it can't be re-sized */\n                if (requestedPoolSize <= xcpMemPoolDescriptors[poolIdx].poolSize) {\n                    /* It is big enough, so let's mark it as allocated */\n                    xcpMemPoolDescriptors[poolIdx].head = (XcpMemHeader*) currentHead;\n                    xcpMemPoolDescriptors[poolIdx].totalBlocksCount = blocksNumber;\n                    xcpMemPoolDescriptors[poolIdx].freeBlocksCount = blocksNumber;\n                    xcpMemPoolDescriptors[poolIdx].blockSize = blockSize;\n                #ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeHead = NULL;\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeTail = NULL;\n                    xcpMemPoolDescriptors[poolIdx].deferredFreeBlocksCount = 0;\n                #endif\n\n                    xcpInitializePoolMemoryArea(currentHead, blockSize, blocksNumber);\n                    pool = poolIdx;\n                    break; /* We found what we were looking for, exit from the loop */\n                }\n            }\n        }\n\n        /* Let's continue to see if there are bigger memory areas available */\n        currentHead += xcpMemPoolDescriptors[poolIdx].poolSize;\n    }\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    if (pool == XCP_INVALID_POOL_ID) {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    *poolId = pool;\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpMemReservedPoolDestroy(xcpPoolId_T poolId)\n{\n    uint8_T poolIdx;\n    boolean_T isLastPool = true;\n\n    if ((poolId < XCP_MEM_MAIN_POOLS_NUMBER) || (poolId >= XCP_MEM_MAIN_RESERVED_POOL_NUMBER)) {\n        XCP_PRINTF(\"xcpMemReservedPoolDestroy: invalid input parameter\\n\");\n        return XCP_INV_ARG;\n    }\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    /* Check if the pool is the last one (i.e. the used pool with the highest id) */\n    for(poolIdx = (XCP_MEM_MAIN_RESERVED_POOL_NUMBER - 1); poolIdx > poolId; --poolIdx) {\n        if ((xcpMemPoolDescriptors[poolIdx].head != XCP_FREE_POOL) ||\n            (xcpMemPoolDescriptors[poolIdx].poolSize != 0)) {\n            isLastPool = false;\n            break; /* the pool is not the last, exit from the loop */\n        }\n    }\n\n    xcpMemPoolDescriptors[poolId].head = XCP_FREE_POOL;\n    xcpMemPoolDescriptors[poolId].totalBlocksCount = 0;\n    xcpMemPoolDescriptors[poolId].freeBlocksCount = 0;\n    xcpMemPoolDescriptors[poolId].blockSize = 0;\n\n#ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n    xcpMemPoolDescriptors[poolId].deferredFreeHead = NULL;\n    xcpMemPoolDescriptors[poolId].deferredFreeTail = NULL;\n    xcpMemPoolDescriptors[poolId].deferredFreeBlocksCount = 0;\n#endif\n\n    if (isLastPool) {\n        /* If it's the last pool we can de-allocate the memory, taking into account this pool\n           as well as the previous ones that have already been deallocated (out of order) */\n        for(poolIdx = XCP_MEM_MAIN_POOLS_NUMBER; poolIdx < XCP_MEM_MAIN_RESERVED_POOL_NUMBER; ++poolIdx) {\n            if ((xcpMemPoolDescriptors[poolIdx].head == XCP_FREE_POOL) &&\n                (xcpMemPoolDescriptors[poolIdx].poolSize != 0)) {\n                xcpMemReservedPoolsChunkUsedBytes -= xcpMemPoolDescriptors[poolIdx].poolSize;\n                xcpMemPoolDescriptors[poolIdx].poolSize = 0;\n            }\n        }\n    }\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    return XCP_SUCCESS;\n}\n\n\nXcpErrorCode xcpMemCustomPoolCreate(XcpCustomAllocHandler allocHandler, XcpCustomFreeHandler freeHandler, xcpPoolId_T* poolId)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    uint8_T poolIdx;\n\n    xcpPoolId_T pool = XCP_INVALID_POOL_ID;\n\n    if ((poolId == NULL) || (allocHandler == NULL) || (freeHandler == NULL)) {\n        XCP_PRINTF(\"xcpMemCustomPoolCreate: invalid input parameter\\n\");\n        return XCP_INV_ARG;\n    }\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    for (poolIdx = 0; poolIdx < XCP_MEM_CUSTOM_POOL_MAX_NUMBER; poolIdx++) {\n        if (xcpMemCustomPoolDescriptors[poolIdx].allocHandler == NULL && xcpMemCustomPoolDescriptors[poolIdx].freeHandler == NULL) {\n            pool = poolIdx + XCP_MEM_CUSTOM_POOLS_OFFSET;\n            xcpMemCustomPoolDescriptors[poolIdx].allocHandler = allocHandler;\n            xcpMemCustomPoolDescriptors[poolIdx].freeHandler = freeHandler;\n            break;\n        }\n    }\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    if (pool == XCP_INVALID_POOL_ID) {\n        errorCode = XCP_NO_MEMORY;\n    }\n\n    *poolId = pool;\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpMemCustomPoolDestroy(xcpPoolId_T poolId)\n{\n    if (poolId < XCP_MEM_CUSTOM_POOLS_OFFSET || poolId >= XCP_MEM_CUSTOM_POOLS_UPPER_BOUND) {\n        XCP_PRINTF(\"xcpMemCustomPoolDestroy: invalid poolId\\n\");\n        return XCP_INV_ARG;\n    }\n\n    XCP_MUTEX_LOCK(xcpMemLock);\n\n    xcpMemCustomPoolDescriptors[poolId - XCP_MEM_CUSTOM_POOLS_OFFSET].allocHandler = NULL;\n    xcpMemCustomPoolDescriptors[poolId - XCP_MEM_CUSTOM_POOLS_OFFSET].freeHandler = NULL;\n\n    XCP_MUTEX_UNLOCK(xcpMemLock);\n\n    return XCP_SUCCESS;\n}\n\n\nvoid* xcpMemAllocFromPool(xcpPoolId_T poolId, size_t size)\n{\n    XcpMemHeader *poolHead = NULL;\n\n    /* a size of 0 is considered an invalid argument */\n    if (size == 0) {\n        return NULL;\n    }\n\n    /* Check if memory allocation is delegated to a custom handler.\n       For custom memory pools, protection against concurrent execution must be\n       implemented withing the allocation method */\n    if (poolId >= XCP_MEM_CUSTOM_POOLS_OFFSET && poolId < XCP_MEM_CUSTOM_POOLS_UPPER_BOUND) {\n        if (xcpMemCustomPoolDescriptors[poolId - XCP_MEM_CUSTOM_POOLS_OFFSET].allocHandler) {\n            /* Memory must be added explicitly to store the pool ID */\n            poolHead = (XcpMemHeader *) xcpMemCustomPoolDescriptors[poolId - XCP_MEM_CUSTOM_POOLS_OFFSET].allocHandler(size + XCP_MEM_POOLID_SIZE);\n            if (!poolHead) {\n                return NULL;\n            }\n            poolHead->poolId = (uint8_T) poolId;\n            return ((uint8_T*) poolHead) + XCP_MEM_POOLID_SIZE;\n        }\n        return NULL;\n    }\n    \n    if ((poolId < XCP_MEM_MAIN_POOLS_NUMBER) || (poolId >= XCP_MEM_MAIN_RESERVED_POOL_NUMBER) ||\n        (xcpMemPoolDescriptors[poolId].head == XCP_FREE_POOL) ||\n        (xcpMemPoolDescriptors[poolId].blockSize < size)) {\n        /* No memory block of the given size is available from this pool */\n        return NULL;\n    }\n\n#ifndef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n    XCP_MUTEX_LOCK(xcpMemPoolDescriptors[poolId].lock);\n#endif\n\n    if (xcpMemPoolDescriptors[poolId].freeBlocksCount > 0) {\n        poolHead = xcpMemPoolDescriptors[poolId].head;\n    }\n\n    if (!poolHead){ /* there are no more free blocks */\n#ifndef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n       XCP_MUTEX_UNLOCK(xcpMemPoolDescriptors[poolId].lock);\n#endif\n       return NULL;\n    }\n\n    xcpMemPoolDescriptors[poolId].head = poolHead->next;\n    (xcpMemPoolDescriptors[poolId].freeBlocksCount)--;\n    poolHead->poolId = (uint8_T) poolId;\n\n#ifndef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\n    XCP_MUTEX_UNLOCK(xcpMemPoolDescriptors[poolId].lock);\n#endif\n\n    /* return a pointer past just the poolId */\n    return ((uint8_T*) poolHead) + XCP_MEM_POOLID_SIZE;\n\n}\n\n\n#ifdef XCP_MEM_RESERVED_POOLS_LOCKLESS_SUPPORT\nvoid xcpMemReservedPoolFlushFreeMem(xcpPoolId_T poolId)\n{\n    if ((poolId >= XCP_MEM_MAIN_POOLS_NUMBER) &&\n        (poolId < XCP_MEM_MAIN_RESERVED_POOL_NUMBER) &&\n        (xcpMemPoolDescriptors[poolId].deferredFreeTail != NULL)) {\n        /* Let's move the deferred free blocks to the list of free blocks\n           available for subsequent allocations */\n        xcpMemPoolDescriptors[poolId].deferredFreeTail->next = xcpMemPoolDescriptors[poolId].head;\n        xcpMemPoolDescriptors[poolId].head = xcpMemPoolDescriptors[poolId].deferredFreeHead;\n        xcpMemPoolDescriptors[poolId].freeBlocksCount += xcpMemPoolDescriptors[poolId].deferredFreeBlocksCount;\n        xcpMemPoolDescriptors[poolId].deferredFreeBlocksCount = 0;\n        xcpMemPoolDescriptors[poolId].deferredFreeTail = NULL;\n    }\n}\n#endif\n\n\nXcpErrorCode xcpMemReset(void){\n    XCP_MEMSET(xcpMemMainChunk,          0, sizeof(xcpMemMainChunk));\n    XCP_MEMSET(xcpMemReservedPoolsChunk, 0, sizeof(xcpMemReservedPoolsChunk));\n    xcpMemReservedPoolsChunkUsedBytes = 0;\n\n    XCP_MEMSET(xcpMemPoolDescriptors,    0, sizeof(xcpMemPoolDescriptors));\n\n    XCP_MEMSET(xcpMemCustomPoolDescriptors, 0, sizeof(xcpMemCustomPoolDescriptors));\n\n    return XCP_SUCCESS;\n}\n\n#ifdef XCP_DEBUG_SUPPORT\n\nvoid xcpMemPrintDiagnostics(void)\n{\n    uint8_T poolIdx;\n    XCP_PRINTF(\"#############################\\n\");\n    XCP_PRINTF(\"             Header size: %7zu B\\n\", XCP_MEM_HEADER_SIZE);\n    XCP_PRINTF(\"             Offset size: %7zu B\\n\", XCP_MEM_POOLID_SIZE);\n    XCP_PRINTF(\"      Main System memory: %7zu B\\n\", XCP_MEM_MAIN_SYSTEM_SIZE);\n    XCP_PRINTF(\"        Main User memory: %7zu B\\n\", XCP_MEM_MAIN_USER_SIZE);\n    XCP_PRINTF(\"       Main Total memory: %7zu B\\n\", XCP_MEM_MAIN_TOTAL_SIZE);\n\n    for(poolIdx = 0 ; poolIdx < XCP_MEM_MAIN_POOLS_NUMBER ; ++poolIdx) {\n        size_t bsThisPool = xcpMemMainBlockSizes[poolIdx];\n        size_t nbBlocksThisPool = xcpMemPoolDescriptors[poolIdx].totalBlocksCount;\n        size_t nbFreeBlocksThisPool = xcpMemPoolDescriptors[poolIdx].freeBlocksCount;\n        XCP_PRINTF(\"%6zu B blocks: %4zu/%-4zu\\n\", bsThisPool, nbFreeBlocksThisPool, nbBlocksThisPool);\n    }\n    XCP_PRINTF(\"               (free)/(total)\\n\");\n    XCP_PRINTF(\"#############################\\n\");\n\n    XCP_PRINTF(\"        Res Pools Number: %7d   \\n\", XCP_MEM_RESERVED_POOLS_NUMBER);\n    XCP_PRINTF(\"  Res Pools Total memory: %7zu B\\n\", (size_t)XCP_MEM_RESERVED_POOLS_TOTAL_SIZE);\n    XCP_PRINTF(\"   Res Pools Used memory: %7zu B\\n\", xcpMemReservedPoolsChunkUsedBytes);\n\n    for(poolIdx = XCP_MEM_MAIN_POOLS_NUMBER ; poolIdx < XCP_MEM_MAIN_RESERVED_POOL_NUMBER ; ++poolIdx) {\n        size_t nbBlocksThisPool = xcpMemPoolDescriptors[poolIdx].totalBlocksCount;\n        size_t nbFreeBlocksThisPool = xcpMemPoolDescriptors[poolIdx].freeBlocksCount;\n        size_t sizeBlocksThisPool = xcpMemPoolDescriptors[poolIdx].blockSize;\n        XCP_PRINTF(\"Pool %3d blocks: %4zu/%-4zu of size %7zu\\n\", poolIdx, nbFreeBlocksThisPool, nbBlocksThisPool, sizeBlocksThisPool);\n    }\n    XCP_PRINTF(\"               (free)/(total)\\n\");\n}\n\n#endif\n\n#ifdef XCP_MEM_BYTE_COPY_SUPPORT\n/* xcpMemcpyByte() currently supports byte-wise copy on WORD (HW_AG=2) addressable targets only */\nvoid xcpMemcpyByte(void *pDst, uint8_T dstOffsetBytes, void const* pSrc, uint8_T srcOffsetBytes, size_t numOfBytes)\n{\n    uint16_T *dst = (uint16_T *)pDst;\n    uint16_T const* src = (uint16_T const*)pSrc;\n\n    if (numOfBytes >= 1) {\n        size_t numOfAGUnits = ((numOfBytes + 1) >> 1);\n        \n        if ((dstOffsetBytes == 0) && (srcOffsetBytes == 0)){\n            if (numOfBytes % 2){\n                numOfAGUnits--;\n                XCP_MEMCPY(dst, src, numOfAGUnits);\n                dst[numOfAGUnits] &= 0xff00;\n                dst[numOfAGUnits] |= (src[numOfAGUnits] & 0x00ff);\n            }\n            else {\n                XCP_MEMCPY(dst, src, numOfAGUnits);\n            }\n        }\n        else if ((dstOffsetBytes == 1) && (srcOffsetBytes == 0)){\n            uint32_T i = 0;\n            dst[0] &= 0x00ff;\n            dst[0] |= ((src[0] & 0x00ff) << 8);\n            for (i = 1; i < numOfAGUnits; i++){\n                dst[i]  = ((src[i-1] & 0xff00) >> 8);\n                dst[i] |= ((src[i] & 0x00ff) << 8);\n            }\n            if ((numOfBytes % 2) == 0){\n                dst[i] &= 0xff00;\n                dst[i] |= ((src[i-1] & 0xff00) >> 8);\n            }\n        }\n        else if ((dstOffsetBytes == 0) && (srcOffsetBytes == 1)){\n            uint32_T i = 0;\n            dst[0] = ((src[0] & 0xff00) >> 8);\n            if (numOfBytes >= 2) {\n                dst[0] |= ((src[1] & 0x00ff) << 8);\n                for (i = 1; i < numOfAGUnits-1; i++){\n                    dst[i]  = ((src[i] & 0xff00) >> 8);\n                    dst[i] |= ((src[i+1] & 0x00ff) << 8);\n                }\n                if (numOfBytes % 2){\n                    dst[i] &= 0xff00;\n                    dst[i] |= ((src[i] & 0xff00) >> 8);\n                }\n            }\n        }\n        else if ((dstOffsetBytes == 1) && (srcOffsetBytes == 1)){\n            dst[0] &= 0x00ff;\n            dst[0] |= (src[0] & 0xff00);\n            numOfBytes--;\n            numOfAGUnits--;\n            dst++;\n            src++;\n            XCP_MEMCPY(dst, src, numOfAGUnits);\n            if ((numOfBytes % 2) != 0){\n                dst[numOfAGUnits] &= 0xff00;\n                dst[numOfAGUnits] |= (src[numOfAGUnits] & 0x00ff);\n            }\n        }\n    }\n}\n\n#endif\n"},{"name":"xcp_platform_default.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2024a/toolbox/coder/xcp/src/target/server/platform/default","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2023 The MathWorks, Inc.\n*\n* File: xcp_platform_default.c\n*\n* Abstract:\n*  Implementation of default XCP Server platform services\n*/\n\n#include <stdlib.h>\n\n#include \"xcp_common.h\"\n#include \"xcp_platform_default.h\"\n#include \"xcp_cfg.h\"\n\n#if defined(__APPLE__) && defined(__MACH__)\n#include <mach-o/dyld.h>\n#endif\n\n/* Define the API to pause the execution (sleep) for a specific amount of time */\n#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)\n\n#define XCP_MICROSECONDS_PER_SECOND  1000000\n\nstatic boolean_T xcpPerfCounterAvailable      = true;\nstatic boolean_T xcpPerfCounterInitialized    = false;\nstatic uint64_t  xcpPerfCounterTicksPerSecond = 1;\n\n/* Initialize performance counters */\nstatic void xcpPerfCounterInit(void)\n{\n    if (!xcpPerfCounterInitialized) {\n        LARGE_INTEGER frequency;\n\n        if (QueryPerformanceFrequency(&frequency)) {\n            if ((frequency.u.HighPart != 0) || (frequency.u.LowPart == 0)) {\n                XCP_PRINTF(\"xcpTimestampInit: QueryPerformanceFrequency error, unexpected frequency\\n\");\n                xcpPerfCounterAvailable = false;\n            } else {\n                xcpPerfCounterTicksPerSecond = frequency.u.LowPart;\n            }\n        }\n        else {\n            XCP_PRINTF(\"xcpTimestampInit: QueryPerformanceFrequency error, performance Counter not available\\n\");\n            xcpPerfCounterAvailable = false;\n        }\n\n        xcpPerfCounterInitialized = true;\n    }\n}\n\n\n/* Convert a performance counter value (in ticks) into a value according to a specific time unit */\nstatic uint64_t xcpPerfCounterValue2TimeUnits(LARGE_INTEGER value, uint64_t timeUnitsPerSecond)\n{\n    return ((((uint64_t)value.u.HighPart) << 32) | (uint64_t)value.u.LowPart) * timeUnitsPerSecond / xcpPerfCounterTicksPerSecond;\n}\n\n\n\nvoid xcpSleep(uint32_T seconds, uint32_T microseconds)\n{\n    if ((seconds == 0) && (microseconds == 0)) {\n        /* According to MSDN, a value of zero causes the thread to relinquish\n           the remainder of its time slice to any other thread that is ready to run.\n           If there are no other threads ready to run, the function returns immediately\n           and the thread continues execution */\n        Sleep(0);\n    } else if ((seconds == 0) && (microseconds < 1000)) {\n        /* Sleep() doesn't allow to sleep for less than 1ms.\n           If a sleep time of less than 1ms is requested on Windows, a busy wait\n           based on performance counters is used instead */\n        if (!xcpPerfCounterInitialized) {\n            /* Initialize performance counters */\n            xcpPerfCounterInit();\n        }\n\n        if (xcpPerfCounterAvailable) {\n            LARGE_INTEGER current;\n            uint64_t startTime = 0;\n            uint64_t currentTime = 0;\n            uint64_t elapsedTime = 0;\n\n            QueryPerformanceCounter(&current);\n            startTime = xcpPerfCounterValue2TimeUnits(current, XCP_MICROSECONDS_PER_SECOND);\n\n            do\n            {\n                QueryPerformanceCounter(&current);\n                currentTime = xcpPerfCounterValue2TimeUnits(current, XCP_MICROSECONDS_PER_SECOND);\n\n                if (currentTime >= startTime) {\n                    elapsedTime = currentTime - startTime;\n                } else {\n                    elapsedTime = currentTime + UINT64_MAX - startTime;\n                }\n            }\n            while(elapsedTime <= microseconds);\n        }\n    } else {\n        /* Sleep for the required amount of ms */\n        Sleep((seconds) * 1000 + (((microseconds) + 1000 - 1) / 1000));\n    }\n}\n\n#elif defined(__linux__) || defined(__APPLE__) && defined(__MACH__)\n\nvoid xcpSleep(uint32_T seconds, uint32_T microseconds)\n{\n#if defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 199309L\n\t/* nanosleep() is the preferred sleep method on Linux */\n\tstruct timespec t;\n\tt.tv_sec = seconds;\n\tt.tv_nsec = microseconds * 1000;\n\n\tnanosleep(&t, NULL);\n#else\n\t/* if nanosleep() is not available, use the select() instead */\n\tstruct timeval t;\n\tt.tv_sec = seconds;\n\tt.tv_usec = (suseconds_t)microseconds; /* tv_usec is signed */\n\n\tselect(0, NULL, NULL, NULL, &t);\n#endif /* _POSIX_C_SOURCE >= 199309L */\n}\n\n#else\n\n#error \"platform not supported: a custom Platform Abstraction Layer needs to be provided.\"\n\n#endif\n\n\n#ifndef XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME\n/* @note The following section provides the default implementation\n         of the xcpGetTimestamp() API, based on the 'real' time\n         for Linux and Windows platforms.\n         If XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME is defined,\n         the same function will be implemented in the External Mode\n         abstraction layer, based on the model simulation time */\n\n/* Define the XCP_TIMESTAMP_UNITS_PER_SECOND value based on the\n   selected XCP_TIMESTAMP_UNIT */\n#if (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e9\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e8\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100NS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e7\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e6\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e5\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100US)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e4\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e3\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e2\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100MS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND          1e1\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1S)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND            1\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_1PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e12\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_10PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e11\n#elif (XCP_TIMESTAMP_UNIT == XCP_TIMESTAMP_UNIT_100PS)\n#define XCP_TIMESTAMP_UNITS_PER_SECOND         1e10\n#else\n#error \"invalid XCP_TIMESTAMP_UNIT value\"\n#endif\n\n/* Define the corresponding XCP_TIMESTAMP_UNITS_PER_MICROSECOND value */\n#define XCP_TIMESTAMP_UNITS_PER_MICROSECOND (XCP_TIMESTAMP_UNITS_PER_SECOND / 1e6)\n\nstatic boolean_T xcpTimestampInitialized = false;\nstatic uint64_t  xcpTimestampStartTime = 0;\n\n\n#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)\n\n/* Initialize timestamp based on performance counters */\nstatic void xcpTimestampInit(void)\n{\n    if (!xcpTimestampInitialized) {\n        if (!xcpPerfCounterInitialized) {\n            /* Initialize performance counters */\n            xcpPerfCounterInit();\n        }\n\n        if (xcpPerfCounterAvailable) {\n            LARGE_INTEGER current;\n\n            /* Initialize xcpTimestampStartTime based on current time */\n            QueryPerformanceCounter(&current);\n\n            xcpTimestampStartTime = xcpPerfCounterValue2TimeUnits(current, (uint64_t) XCP_TIMESTAMP_UNITS_PER_SECOND);\n        }\n\n        xcpTimestampInitialized = true;\n    }\n}\n\n/* Get timestamp value in XCP_TIMESTAMP_UNITs\n    @note in the current implementation the time starts counting from 0 on the first call */\nuint32_T xcpGetTimestamp(void)\n{\n    LARGE_INTEGER current;\n    uint64_t currentTime;\n    uint32_T ret = 0;\n\n    if (!xcpTimestampInitialized) {\n        xcpTimestampInit();\n        return ret;\n    }\n\n    if (xcpPerfCounterAvailable) {\n        QueryPerformanceCounter(&current);\n        currentTime = xcpPerfCounterValue2TimeUnits(current, (uint64_t) XCP_TIMESTAMP_UNITS_PER_SECOND);\n\n        if (currentTime >= xcpTimestampStartTime) {\n            ret = (uint32_T) (currentTime - xcpTimestampStartTime);\n        } else {\n            ret = (uint32_T) (currentTime + UINT64_MAX - xcpTimestampStartTime);\n        }\n    }\n\n    return ret;\n}\n\n#elif defined(__linux__) || defined(__APPLE__) && defined(__MACH__)\n\n/* Return value in XCP_TIMESTAMP_UNITs\n   @note in the current implementation the time starts counting from 0 on the first call */\nuint32_T xcpGetTimestamp(void)\n{\n    struct timeval timeVal;\n    uint64_t currentTime = 0;\n    uint32_T ret = 0;\n\n    gettimeofday(&timeVal, NULL);\n    currentTime = timeVal.tv_sec * XCP_TIMESTAMP_UNITS_PER_SECOND + timeVal.tv_usec * XCP_TIMESTAMP_UNITS_PER_MICROSECOND;\n\n    if (!xcpTimestampInitialized) {\n        /* Read initial time and store it in xcpTimestampStartTime variable */\n        xcpTimestampStartTime = currentTime;\n\n        xcpTimestampInitialized = true;\n    }\n\n    if (currentTime >= xcpTimestampStartTime) {\n        ret = (uint32_T) (currentTime - xcpTimestampStartTime);\n    } else {\n        ret = (uint32_T) (currentTime + UINT64_MAX - xcpTimestampStartTime);\n    }\n\n    return ret;\n}\n\n#else\n\n#error \"platform not supported: a custom Platform Abstraction Layer needs to be provided.\"\n\n#endif\n\n#endif /* XCP_TIMESTAMP_BASED_ON_SIMULATION_TIME */\n\n\n/* Define the API to convert the XCP address and extension into the corresponding\n   variable address in the target address space */\n#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)\n\n#if defined(__MINGW32__) || defined(__MINGW64__) || defined(XCP_PLATFORM_WINDOWS_NO_OFFSET_SUPPORT)\n\nuint8_T *xcpAddressGet(uint8_T addressExtension, uint32_T address)\n{\n    return (uint8_T*) ((uintptr_t) address | (((uintptr_t)addressExtension) << 32));\n}\n\n#else\n\nextern IMAGE_DOS_HEADER __ImageBase;\nuint8_T *xcpAddressGet(uint8_T addressExtension, uint32_T address)\n{\n    return (uint8_T*) (((uintptr_t) address | (((uintptr_t)addressExtension) << 32)) + \n                       (uintptr_t)&__ImageBase);\n}\n\n#endif\n\n#elif defined(__linux__)\n\nextern char __executable_start;\n\n#if defined(XCP_PLATFORM_LINUX_PIE_SUPPORT) && defined(XCP_PLATFORM_LINUX_NO_PIE_SUPPORT)\n#error \"XCP_PLATFORM_LINUX_PIE_SUPPORT and XCP_PLATFORM_LINUX_NO_PIE_SUPPORT cannot be defined at the same time.\"\n#endif\n\n#ifdef XCP_PLATFORM_LINUX_PIE_SUPPORT\n\n/* If the binary is compiled as Position Independent Executable, the address sent by the XCP Client\n   is treated as an offset from the __executable_start address */\nuint8_T *xcpAddressGet(uint8_T addressExtension, uint32_T address)\n{\n    return (uint8_T*) (((uintptr_t) address | (((uintptr_t)addressExtension) << 32)) + \n                        (uintptr_t)&__executable_start);\n}\n\n#elif defined(XCP_PLATFORM_LINUX_NO_PIE_SUPPORT)\n\n/* If the binary is NOT compiled as Position Independent Executable, the address sent by the XCP Client\n   is treated as the actual address of the variable */\nuint8_T *xcpAddressGet(uint8_T addressExtension, uint32_T address)\n{\n    return (uint8_T*) ((uintptr_t) address | (((uintptr_t)addressExtension) << 32));\n}\n\n#else\n\n/* if the code is loaded below 32 bits, the default implementation is assuming\n   that PIE is not enabled and that address represents the actual address\n   in memory where the variable is loaded.\n\n   However if we detect that the code has been loaded beyond that limit,\n   then a relocation mechanism must be enabled and therefore we apply\n   the same conversion rule as PIE */\nuint8_T *xcpAddressGet(uint8_T addressExtension, uint32_T address)\n{\n    if ((uintptr_t)&__executable_start < (uintptr_t)UINT32_MAX) {\n        return (uint8_T*) ((uintptr_t) address | (((uintptr_t)addressExtension) << 32));\n    } else {\n        return (uint8_T*) (((uintptr_t) address | (((uintptr_t)addressExtension) << 32)) +\n                            (uintptr_t)&__executable_start);\n    }\n}\n\n#endif /*  XCP_PLATFORM_LINUX_PIE_SUPPORT */\n\n#elif defined(__APPLE__) && defined(__MACH__)\n\n#define MAX_EXECUTABLE_PATH_SIZE 1024\n#define UNINITIALIZED_ADDRESS ((intptr_t) -1)\n\n/* Get the dynamic image slide of system when the executable is deployed */\nuintptr_t xcpExecutableStartAddress(void)\n{    \n    static intptr_t imgSlideValue = UNINITIALIZED_ADDRESS;\n    \n    if (imgSlideValue == UNINITIALIZED_ADDRESS) {\n        char path[MAX_EXECUTABLE_PATH_SIZE];\n        uint32_T size = sizeof(path);\n        path[MAX_EXECUTABLE_PATH_SIZE-1] = '\\0';\n        /* _NSGetExecutablePath returns 0 if the path of the main executable\n         * is successfully copied */\n        if (_NSGetExecutablePath(path, &size) == 0) {\n            uint32_T i = 0;\n            for (i = 0; (i < _dyld_image_count()) && (imgSlideValue == UNINITIALIZED_ADDRESS); i++)\n            {\n             /* If the path of the executable is the same as the indexed image\n             that means the image is the ASLR slide */\n                if (strcmp(_dyld_get_image_name(i), path) == 0)\n                    imgSlideValue = _dyld_get_image_vmaddr_slide(i);\n            }\n        }\n    }\n    return (uintptr_t)imgSlideValue;\n}\n\nuint8_T *xcpAddressGet(uint8_T addressExtension, uint32_T address)\n{\n    return (uint8_T*) (((uintptr_t) address | (((uintptr_t)addressExtension) << 32)) + \n                       xcpExecutableStartAddress());\n}\n\n#else\n\n#error \"platform not supported: a custom Platform Abstraction Layer needs to be provided.\"\n\n#endif\n\n/* LocalWords:  MSDN\n */\n"},{"name":"xcp_standard.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2024a/toolbox/coder/xcp/src/target/server/protocol/src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2022 The MathWorks, Inc.\n*\n* File: xcp_standard.c\n*\n* Abstract:\n*  Implementation of XCP Protocol Layer standard commands\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_cfg.h\"\n#include \"xcp_types.h\"\n#include \"xcp_transport_internal.h\"\n#include \"xcp_daq.h\"\n#include \"xcp_standard.h\"\n#include \"xcp_standard_ext.h\"\n#include \"xcp_standard_types.h\"\n\n\n/*****************************************************************************\n    Internal Variables\n******************************************************************************/\nstatic XcpAddress xcpMta = {0,0};   /* MTA and MTA extension in same format as in SET_MTA packet, used by (SHORT)_UPLOAD, (SHORT)_DOWNLOAD */\nstatic uint8_T xcpUploadSize = 0;\n\n\n/*****************************************************************************\n    Internal Utility Functions\n******************************************************************************/\nstatic boolean_T isValidUploadSize(uint8_T size)\n{\n    size_t addressGranularity = XCP_ADDRESS_GRANULARITY_BYTES_NUMBER;\n    size_t maxCtoSize = xcpTransportMaxCtoSize();\n\n    return (size < ((maxCtoSize) / addressGranularity));\n}\n\n/** memcpy function used to copy data from MTA address to the packet */\nstatic void xcpMemcpyFromMTA(uint8_T *pktData, uint8_T dstOffsetBytes)\n{\n    /* Retrieve memory address */\n    uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n\n    XCP_PRINTF(\"reading at address %p\\n\", xcpMTARawPointer);\n\n#ifdef XCP_EMULATE_BYTE_ADDRESSABLE_TARGET\n{\n    uint32_T address;\n    uint8_T addressExtension;\n    uint8_T srcOffsetBytes;\n    xcpStandardGetMta(&address, &addressExtension);\n    srcOffsetBytes = XCP_BYTE_OFFSET_GET(address);\n    if (dstOffsetBytes) { pktData--; }\n    xcpMemcpyByte(pktData, dstOffsetBytes, xcpMTARawPointer, srcOffsetBytes, xcpUploadSize);\n}\n#else\n    XCP_UNUSED_PARAM(dstOffsetBytes);\n    XCP_MEMCPY(pktData, xcpMTARawPointer, xcpUploadSize);\n#endif\n\n}\n\n/*****************************************************************************\n    XCP CONNECT\n******************************************************************************/\n#define XCP_NO_RESOURCES  0x00\n\nstatic const uint8_T xcpResourceValue = (\n    XCP_NO_RESOURCES\n#ifdef XCP_DAQ_SUPPORT\n    | XCP_RESOURCE_DAQ_MASK\n#endif\n#ifdef XCP_STIM_SUPPORT\n    | XCP_RESOURCE_STIM_MASK\n#endif\n#ifdef XCP_PGM_SUPPORT\n    | XCP_RESOURCE_PGM_MASK\n#endif\n#ifdef XCP_CALIBRATION_SUPPORT\n    | XCP_RESOURCE_CAL_PAG_MASK\n#endif\n    );\n\nstatic const uint8_T xcpCommModeBaseValue = (\n    (XCP_ADDRESS_GRANULARITY << XCP_COMM_MODE_ADDRESS_GRANULARITY_OFFSET)\n#if (XCP_BYTE_ORDER != 0)\n    | XCP_COMM_MODE_BYTE_ORDER_MASK\n#endif\n#ifdef XCP_BLOCK_MODE_SUPPORT\n    | XCP_COMM_MODE_SLAVE_BLOCK_MODE_MASK\n#endif\n#ifdef XCP_COMM_MODE_INFO_SUPPORT\n    | XCP_COMM_MODE_OPTIONAL_MASK\n#endif\n    );\n\nstatic XcpProtoErrorCode connectInputPacketHandler(void   *msgBuffer,\n                                                   size_t  xcpPacketOffset,\n                                                   size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpConnectCmdPacketFrame *frame = (XcpConnectCmdPacketFrame *) packet;\n    boolean_T ok = false;\n\n    /* If DAQ List support is enabled, reset the status of dynamic DAQ list data structures */\n    ok = xcpResetDaqListStatus();\n\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_BUSY,\n        (\"CONNECT: DAQ lists reset cannot be carried out, as an event was processed\\n\"));\n\n    /* Validate command inputs */\n    ok = (frame->mode == XCP_CONNECT_MODE_NORMAL) || (frame->mode == XCP_CONNECT_MODE_USER_DEFINED);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n                          (\"CONNECT: invalid mode detected %xH\\n\", frame->mode));\n\n    /* Everything is fine -> updating the Protocol Layer status */\n    XCP_PRINTF(\"CONNECT: entering XCP_CONNECTED status\\n\");\n    xcpStatusSet(XCP_CONNECTED);\n\n    protoErrorCode = XCP_PROTO_SUCCESS;\n    *outputPacketSize = XCP_CONNECT_RES_PACKET_SIZE_IN_BYTES;\n\n    return protoErrorCode;\n}\n\nstatic void connectOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    if (inputCode == XCP_PROTO_SUCCESS) {\n        /* Fill connect response */\n        XcpConnectResPacketFrame *frame = (XcpConnectResPacketFrame *)packet;\n        XCP_MEMSET(frame, 0, sizeof(*frame));\n\n        frame->PID = XCP_PID_RES;\n\n        /* Update resource field */\n        frame->resource = xcpResourceValue;\n\n        /* Update commModeBasic field */\n        frame->commModeBasic = xcpCommModeBaseValue;\n\n        /* Update Max CTO and DTO fields */\n        frame->maxCtoSize = (uint8_T)xcpTransportMaxCtoSize();\n        frame->maxDtoSize = (uint16_T)xcpTransportMaxDtoSize();\n\n        /* Update Protocol and Transport Version fields */\n        frame->xcpProtocolVersion  = XCP_MAJOR_NUMBER(XCP_PROTOCOL_LAYER_VERSION);\n        frame->xcpTransportVersion = XCP_MAJOR_NUMBER(XCP_TRANSPORT_LAYER_VERSION);\n\n        XCP_PRINTF(\"* Resource:          %xH\\n\", frame->resource);\n        XCP_PRINTF(\"* Comm Mode Basic:   %xH\\n\", frame->commModeBasic);\n        XCP_PRINTF(\"* Max CTO size:      %d\\n\",  frame->maxCtoSize);\n        XCP_PRINTF(\"* Max DTO size:      %d\\n\",  frame->maxDtoSize);\n        XCP_PRINTF(\"* Protocol Version:  %d\\n\",  frame->xcpProtocolVersion);\n        XCP_PRINTF(\"* Transport Version: %d\\n\",  frame->xcpTransportVersion);\n    }\n    else {\n        genericOutputPacketHandler(inputCode, packet, packetSize);\n    }\n}\n\n/*****************************************************************************\n    XCP DISCONNECT\n******************************************************************************/\nstatic XcpProtoErrorCode disconnectInputPacketHandler(void   *msgBuffer,\n                                                      size_t  xcpPacketOffset,\n                                                      size_t *outputPacketSize)\n{\n    boolean_T ok = true;\n\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    /* If DAQ List support is enabled, reset the status of dynamic DAQ list data structures */\n    ok = xcpResetDaqListStatus();\n\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_BUSY,\n        (\"DISCONNECT: DAQ lists reset cannot be carried out, as an event was processed\\n\"));\n\n    /* Everything is fine -> proceed with the status update */\n    XCP_PRINTF(\"DISCONNECT: entering XCP_DISCONNECTED status\\n\");\n    xcpStatusSet(XCP_DISCONNECTED);\n\n    *outputPacketSize = XCP_GENERIC_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SUCCESS;\n}\n\n/*****************************************************************************\n    XCP GET_STATUS\n******************************************************************************/\nstatic XcpProtoErrorCode getStatusInputPacketHandler(void   *msgBuffer,\n                                                     size_t  xcpPacketOffset,\n                                                     size_t *outputPacketSize)\n{\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"GET STATUS\\n\");\n\n    *outputPacketSize = XCP_GET_STATUS_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SUCCESS;\n}\n\nstatic void getStatusOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{\n    XcpGetStatusResPacketFrame *frame = (XcpGetStatusResPacketFrame *)packet;\n\n    XCP_UNUSED_PARAM(inputCode);\n    XCP_UNUSED_PARAM(packetSize);\n\n    /* Fill Get Status response */\n    XCP_MEMSET(frame, 0, sizeof(*frame));\n\n    frame->PID                      = XCP_PID_RES;\n    frame->sessionStatus            = xcpSessionStatusGet();\n    frame->resourceProtectionStatus = xcpResourceProtectionStatusGet();\n    frame->sessionConfigurationId   = xcpSessionConfigurationIdGet();\n\n    XCP_PRINTF(\"* Session Status:              %xH\\n\", frame->sessionStatus);\n    XCP_PRINTF(\"* Resource Protection Status:  %xH\\n\", frame->resourceProtectionStatus);\n    XCP_PRINTF(\"* Session Config Id:           %d\\n\", frame->sessionConfigurationId);\n}\n\n/*****************************************************************************\n    XCP SYNCH\n******************************************************************************/\n#define XCP_SYNC_RES_PACKET_SIZE_IN_BYTES 2\n\nstatic XcpProtoErrorCode synchInputPacketHandler(void   *msgBuffer,\n                                                 size_t  xcpPacketOffset,\n                                                 size_t *outputPacketSize)\n{\n    boolean_T locked = false;\n\n    XCP_UNUSED_PARAM(msgBuffer);\n    XCP_UNUSED_PARAM(xcpPacketOffset);\n\n    XCP_PRINTF(\"SYNCH\\n\");\n\n    /* Make sure that no DAQ list is currently\n       in the process of sending packets */\n    locked = xcpDaqLock();\n\n    if (locked) {\n        /* Re-synchronizing the transport layer, by flushing the TX packets currently\n           in the TX FIFO and restarting the frame handler */\n        xcpTransportResynch();\n\n        xcpDaqUnlock();\n    }\n\n    *outputPacketSize = XCP_SYNC_RES_PACKET_SIZE_IN_BYTES;\n\n    return XCP_PROTO_SYNCH;\n}\n\n\n#if XCP_SET_MTA_ENABLE == 1\n/*****************************************************************************\n    XCP SET_MTA\n******************************************************************************/\n    static XcpProtoErrorCode setMTAInputPacketHandler(void  *msgBuffer, \n        size_t  xcpPacketOffset, \n        size_t *outputPacketSize) {\n\n        XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n        uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n        XcpSetMTACmdPacketFrame *frame = (XcpSetMTACmdPacketFrame *)packet;\n        boolean_T ok = false;\n\n        /* Check if the memory address is valid and set the MTA pointer */\n        ok = xcpStandardSetMta(frame->address, (uint8_T)frame->addressExtension);\n        XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_ACCESS_DENIED, (\"SET_MTA: invalid address\\n\"));\n        \n        XCP_PRINTF(\"SET_MTA: setting MTA value to %x and extension %x\\n\", frame->address, frame->addressExtension);    \n\n        *outputPacketSize = sizeof(XcpGenericResPacketFrame);\n\n        return protoErrorCode;\n    }\n\n/*****************************************************************************\n    XCP UPLOAD\n******************************************************************************/\n    static XcpProtoErrorCode uploadInputPacketHandler(void   *msgBuffer,\n        size_t  xcpPacketOffset,\n        size_t *outputPacketSize) {\n\n        XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n        uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n        XcpUploadCmdPacketFrame *frame = (XcpUploadCmdPacketFrame *)packet;\n        boolean_T ok = false;\n        uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n\n        /* Check if the number of data elements is valid */\n        ok = isValidUploadSize((uint8_T)frame->size);\n        XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n            (\"UPLOAD: invalid number of data elements (%d)\\n\", (uint8_T)frame->size));\n        \n        /* Check if a valid MTA address is available */\n        XCP_INPUT_PKT_ERROR_IF(xcpMTARawPointer == 0, XCP_PROTO_ACCESS_DENIED,\n            (\"UPLOAD: invalid address\\n\"));\n        \n        xcpUploadSize = (uint8_T)frame->size;\n        *outputPacketSize = XCP_UPLOAD_RES_PACKET_SIZE_IN_BYTES + XCP_IN_BYTES(xcpUploadSize);\n\n        return protoErrorCode;\n    }\n\n    \n    static void uploadOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize) {\n        \n        if (inputCode == XCP_PROTO_SUCCESS) {\n\n            /* Fill Upload response */\n            uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n            XcpUploadResPacketFrame *frame = (XcpUploadResPacketFrame *)packet;\n            XCP_MEMSET(frame, 0, sizeof(*frame));\n            frame->PID = XCP_PID_RES;\n\n            if ((xcpMTARawPointer != NULL) &&\n                (packetSize == (XCP_UPLOAD_RES_PACKET_SIZE_IN_BYTES + XCP_IN_BYTES(xcpUploadSize)))\n                ) {\n                uint8_T *pktData = (uint8_T *)packet + XCP_IN_AG(XCP_UPLOAD_RES_PACKET_SIZE_IN_BYTES);\n                uint8_T dstOffsetBytes = (XCP_UPLOAD_RES_PACKET_SIZE_IN_BYTES % XCP_HARDWARE_ADDRESS_GRANULARITY_BYTES_NUMBER);\n\n                XCP_PRINTF(\"UPLOAD: \");\n                \n                /* Copy the memory content to the packet data area */\n                xcpMemcpyFromMTA(pktData, dstOffsetBytes);\n\n                /* Post-increment MTA by the frame size in address granularity units */\n                xcpStandardIncrementMta(xcpUploadSize);\n                xcpUploadSize = 0;\n            }\n            else {\n                /* This is a software error and it should never happen */\n                XCP_PRINTF(\"UPLOAD: invalid data detected\\n\");\n            }\n        }\n        else {\n            genericOutputPacketHandler(inputCode, packet, packetSize);\n        }\n    }\n#endif  /* XCP_SET_MTA_ENABLE == 1  */\n\n\n/*****************************************************************************\n    XCP SHORT_UPLOAD\n******************************************************************************/\nstatic XcpProtoErrorCode shortUploadInputPacketHandler(void   *msgBuffer,\n    size_t  xcpPacketOffset,\n    size_t *outputPacketSize)\n{\n    XcpProtoErrorCode protoErrorCode = XCP_PROTO_SUCCESS;\n    uint8_T *packet = (uint8_T *)msgBuffer + xcpPacketOffset;\n    XcpShortUploadCmdPacketFrame *frame = (XcpShortUploadCmdPacketFrame *)packet;\n    boolean_T ok = false;\n\n    /* Check if the number of data elements is valid */\n    ok = isValidUploadSize((uint8_T)frame->size);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_OUT_OF_RANGE,\n        (\"SHORT_UPLOAD: invalid number of data elements (%d)\\n\", (uint8_T)frame->size));\n\n    /* Check if the memory address is valid and set the MTA pointer */\n    ok = xcpStandardSetMta(frame->address, (uint8_T)frame->addressExtension);\n    XCP_INPUT_PKT_ERROR_IF(!ok, XCP_PROTO_ACCESS_DENIED, (\"SHORT_UPLOAD: invalid address\\n\"));\n\n    xcpUploadSize = (uint8_T)frame->size;\n\n    *outputPacketSize = XCP_SHORT_UPLOAD_RES_PACKET_SIZE_IN_BYTES + XCP_IN_BYTES(xcpUploadSize);\n\n    return protoErrorCode;\n}\n\nstatic void shortUploadOutputPacketHandler(XcpProtoErrorCode inputCode, void *packet, size_t packetSize)\n{    \n    if (inputCode == XCP_PROTO_SUCCESS) {\n\n        /* Fill Short Upload response */\n        uint8_T *xcpMTARawPointer = xcpStandardGetAddressFromMta();\n        XcpShortUploadResPacketFrame *frame = (XcpShortUploadResPacketFrame *)packet;\n        XCP_MEMSET(frame, 0, sizeof(*frame));\n\n        frame->PID = XCP_PID_RES;\n\n        if ((xcpMTARawPointer != NULL) &&\n            (packetSize == XCP_SHORT_UPLOAD_RES_PACKET_SIZE_IN_BYTES + XCP_IN_BYTES(xcpUploadSize) )\n           ) {\n            uint8_T *pktData = (uint8_T *)packet + XCP_IN_AG(XCP_SHORT_UPLOAD_RES_PACKET_SIZE_IN_BYTES);\n            uint8_T dstOffsetBytes = (XCP_SHORT_UPLOAD_RES_PACKET_SIZE_IN_BYTES % XCP_HARDWARE_ADDRESS_GRANULARITY_BYTES_NUMBER);\n\n            XCP_PRINTF(\"SHORT_UPLOAD: \");\n\n            /* Copy the memory content to the packet data area */\n            xcpMemcpyFromMTA(pktData, dstOffsetBytes);\n\n            /* Post-increment MTA by the frame size in address granularity units */\n            xcpStandardIncrementMta(xcpUploadSize);\n\n            xcpUploadSize = 0;\n        }\n        else {\n            /* This is a software error and it should never happen */\n            XCP_PRINTF(\"SHORT_UPLOAD: invalid data detected\\n\");\n        }\n    }\n    else {\n        genericOutputPacketHandler(inputCode, packet, packetSize);\n    }\n}\n\n\n/** This table contains the list of supported Rx packets and the corresponding handlers */\nstatic const XcpPacketHandlers standardSupportedRxPacket[] =\n{\n    { XCP_PID_CONNECT,      connectInputPacketHandler,     connectOutputPacketHandler },\n    { XCP_PID_DISCONNECT,   disconnectInputPacketHandler,  genericOutputPacketHandler },\n    { XCP_PID_GET_STATUS,   getStatusInputPacketHandler,   getStatusOutputPacketHandler },\n    { XCP_PID_SYNCH,        synchInputPacketHandler,       genericOutputPacketHandler },\n#if XCP_SET_MTA_ENABLE == 1  \n    { XCP_PID_SET_MTA,      setMTAInputPacketHandler,      genericOutputPacketHandler },\n    { XCP_PID_UPLOAD,       uploadInputPacketHandler,      uploadOutputPacketHandler},\n#endif\n    { XCP_PID_SHORT_UPLOAD, shortUploadInputPacketHandler, shortUploadOutputPacketHandler }\n};\n\n\n\n/*****************************************************************************\n    XCP Packet Lookup Function for basic standard commands\n******************************************************************************/\n\n/* Default Standard Packet Lookup function, supporting only basic commands\n   listed in the table above */\nstatic const XcpPacketHandlers* getPacket(XcpRxPidCode pid)\n{\n    return xcpFindPacket(pid, standardSupportedRxPacket,\n                         XCP_ELEMENTS_NUMBER(standardSupportedRxPacket));\n}\n\nstatic XcpPacketLookupFunction packetLookup = NULL;\n\n\n\n/*****************************************************************************\n    Public Functions (invoked within the Protocol Layer)\n******************************************************************************/\nvoid xcpStandardInit(void)\n{\n    /* Initialize the packet lookup function to support only basic\n       standard commands */\n    xcpStandardSetPacketLookup(getPacket);\n\n    /* Initialize support for the extended list of Standard commands\n       @note this may override the default Packet lookup function\n             by adding support for more (optional) commands */\n    xcpStandardExtendedInit();\n}\n\n\nXcpPacketLookupFunction xcpStandardGetPacketLookup(void)\n{\n    return packetLookup;\n}\n\n\nvoid xcpStandardSetPacketLookup(XcpPacketLookupFunction getPacketFcn)\n{\n    packetLookup = getPacketFcn;\n}\n\n\nvoid xcpStandardReset(void)\n{\n    /* reset support for the extended list of Standard commands */\n    xcpStandardExtendedReset();\n\n    /* Restore the original value for the lookup function */\n    xcpStandardSetPacketLookup(NULL);\n}\n\n\nuint8_T* xcpStandardGetAddressFromMta(void) {\n    return XCP_ADDRESS_GET_WRITE(xcpMta.addressExtension, xcpMta.address);\n}\n\n\nboolean_T xcpStandardSetMta(uint32_T address, uint8_T addressExtension) {\n    if ((addressExtension == 0) && (address == 0)) {\n        return false;\n    } else {\n        xcpMta.address = address;\n        xcpMta.addressExtension = addressExtension;\n        return true;\n    }\n}\n\n\nvoid xcpStandardGetMta(uint32_T *address, uint8_T *addressExtension) {\n    *address = xcpMta.address;\n    *addressExtension = xcpMta.addressExtension;\n}\n\n\nvoid xcpStandardIncrementMta(uint8_T incr) {\n    xcpMta.address += incr;\n}\n\n\n#ifndef XCP_STANDARD_EXTENDED_SUPPORT\n\nvoid xcpStandardExtendedInit(void) {}\nvoid xcpStandardExtendedReset(void) {}\n\n#endif\n"},{"name":"xcp_transport.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2024a/toolbox/coder/xcp/src/target/server/transport/src","tag":"","groupDisplay":"Other files","code":"/*\n* Copyright 2016-2021 The MathWorks, Inc.\n*\n* File: xcp_transport.c\n*\n* Abstract:\n*  Implementation of XCP Transport Layer.\n*  The file contains the common part that is responsible for the handling\n*  of Tx/Rx buffers and relies on the Xcp Driver and Xcp Frame Handler layers\n*  for sending and receiving data to/from the supported transport layer specification\n*/\n\n#include \"xcp_common.h\"\n#include \"xcp.h\"\n#include \"xcp_transport.h\"\n#include \"xcp_transport_types.h\"\n#include \"xcp_transport_internal.h\"\n#include \"xcp_frame.h\"\n#include \"xcp_fifo.h\"\n#include \"xcp_mem.h\"\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n#include \"xcp_daq_types.h\"\n#endif\n\n/** Number of supported Tx queues */\n\n#define XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER     2\n\n/** Number of supported Rx queues */\n#define XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER  1\n\n\n/* In this Transport Layer implementation, the memory buffer associated with a generic\n   XCP message has the following format:\n\n   --------------      +---->  --------------\n  | xcpFifoEntry | ----+      | xcpFifoEntry |\n   --------------              --------------\n  | XCP Header   |            | XCP Header   |\n   --------------              --------------\n  | XCP Packet   |            | XCP Packet   |\n   --------------              --------------\n\n  xcpFifoEntry is an internal data structure used to implement a FIFO through a single linked list\n*/\n\n\n\n/* Transmit FIFOs */\nstatic struct xcpFifo txFifo[XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER];\n\nstatic XCP_MUTEX_DEFINE(txLock);\n\n/* Receive FIFOs */\nstatic struct xcpFifo rxFifo[XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER];\n\nstatic XCP_MUTEX_DEFINE(rxLock);\n\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n\n#if XCP_MEM_DAQ_RESERVED_POOLS_NUMBER <= 0\n#error  \"XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT requires a XCP_MEM_DAQ_RESERVED_POOLS_NUMBER value greater than 0\"\n#endif\n\nstatic struct xcpFifo daqDeferredTxFifo[XCP_MEM_DAQ_RESERVED_POOLS_NUMBER];\nstatic struct xcpFifo daqTxFifo[XCP_MEM_DAQ_RESERVED_POOLS_NUMBER];\nstatic boolean_T      daqTxRequest[XCP_MEM_DAQ_RESERVED_POOLS_NUMBER];\nstatic uint16_T       lastDaqIdTx = 0xFFFF;\n\n#endif\n\n\n/* true if the Transport Layer has been successfully initialized */\nstatic boolean_T  initialized = false;\n\n/* ID of the memory pool reserved for the allocation of\n    CTO XCP Packets */\nstatic xcpPoolId_T xcpCtoReservedMemPoolId = -1;\n\n\n#ifdef XCP_DEBUG_SUPPORT\nstatic const char *xcpTransportDiagDataString[XCP_TRANSPORT_COUNTERS_NUMBER] = {\n    \"XCP_TRANSPORT_INIT_COUNTER               \",\n    \"XCP_TRANSPORT_TX_COUNTER                 \",\n    \"XCP_TRANSPORT_TX_PACKET_SET_COUNTER      \",\n    \"XCP_TRANSPORT_RX_PACKET_GET_COUNTER      \",\n    \"XCP_TRANSPORT_RX_COUNTER                 \",\n    \"XCP_TRANSPORT_RESTART_COUNTER            \",\n    \"XCP_TRANSPORT_RESYNCH_COUNTER            \",\n    \"XCP_TRANSPORT_RESET_COUNTER              \",\n    \"XCP_TRANSPORT_MEM_INIT_ERROR             \",\n    \"XCP_TRANSPORT_MEM_RESET_ERROR            \",\n    \"XCP_TRANSPORT_FRAME_INIT_ERROR           \",\n    \"XCP_TRANSPORT_FRAME_CREATE_MSG_ERROR     \",\n    \"XCP_TRANSPORT_FRAME_SEND_ERROR           \",\n    \"XCP_TRANSPORT_FRAME_RECV_ERROR           \",\n    \"XCP_TRANSPORT_FRAME_EXTRACT_PACKET_ERROR \",\n    \"XCP_TRANSPORT_FRAME_RESTART_ERROR        \",\n    \"XCP_TRANSPORT_FRAME_RESET_ERROR          \",\n    \"XCP_TRANSPORT_TX_PACKET_IN_COUNTER       \",\n    \"XCP_TRANSPORT_TX_PACKET_OUT_COUNTER      \",\n    \"XCP_TRANSPORT_TX_PACKET_FREED_COUNTER    \",\n    \"XCP_TRANSPORT_TX_IS_EMPTY_COUNTER        \",\n    \"XCP_TRANSPORT_RX_PACKET_IN_COUNTER       \",\n    \"XCP_TRANSPORT_RX_PACKET_OUT_COUNTER      \",\n    \"XCP_TRANSPORT_RX_PACKET_FREED_COUNTER    \",\n    \"XCP_TRANSPORT_RX_IS_EMPTY_COUNTER        \"\n};\n\nstatic XcpTransportDiagnostic xcpTransportDiagnostic;\n\n\nvoid xcpTransportDiagnosticReset(void)\n{\n    XCP_MEMSET(&xcpTransportDiagnostic, 0, sizeof(xcpTransportDiagnostic));\n}\n\n\nvoid xcpTransportDiagnosticGet(XcpTransportDiagnostic *diag)\n{\n    XCP_MEMCPY(diag, &xcpTransportDiagnostic, sizeof(xcpTransportDiagnostic));\n}\n\n\nvoid xcpTransportDiagnosticPrint(const XcpTransportDiagnostic *diag)\n{\n    if (diag != NULL) {\n        int i = 0;\n        for (i = 0; i < XCP_TRANSPORT_COUNTERS_NUMBER; i++) {\n            XCP_PRINTF(\"%s = %lu\\n\", xcpTransportDiagDataString[i], (unsigned long) xcpTransportDiagnostic.data[i]);\n        }\n    }\n}\n\n#define XCP_DIAG_UPDATE(counterId)     xcpTransportDiagnostic.data[counterId]++\n\n#else\n\n#define XCP_DIAG_UPDATE(counterId) \n\n#endif\n\n/* Empty the TX FIFO by deleting the existing packets */\nstatic void xcpTransportEmptyTxFifo(void)\n{\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    uint16_T i = 0;\n\n    XCP_MUTEX_LOCK(txLock);\n\n    for (i = 0; i < XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER; i++) {\n        do {\n            xcpFifoDequeue(&txFifo[i], &msgBufferHeader);\n\n            if (msgBufferHeader != NULL) {\n                xcpMemFree(msgBufferHeader);\n                XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_FREED_COUNTER);\n            }\n        } while (msgBufferHeader != NULL);\n    }\n\n    XCP_MUTEX_UNLOCK(txLock);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    for (i = 0; i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER; i++) {\n        do {\n            xcpFifoDequeue(&daqTxFifo[i], &msgBufferHeader);\n\n            if (msgBufferHeader != NULL) {\n                xcpMemFree(msgBufferHeader);\n                XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_FREED_COUNTER);\n            }\n        } while (msgBufferHeader != NULL);\n\n        do {\n            xcpFifoDequeue(&daqDeferredTxFifo[i], &msgBufferHeader);\n\n            if (msgBufferHeader != NULL) {\n                xcpMemFree(msgBufferHeader);\n                XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_FREED_COUNTER);\n            }\n        } while (msgBufferHeader != NULL);\n\n        daqTxRequest[i] = false;\n    }\n    lastDaqIdTx = 0xFFFF;\n#endif\n}\n\n\n/* Empty the RX FIFO by deleting the existing packets */\nstatic void xcpTransportEmptyRxFifo(void)\n{\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    XcpTransportQueueType_T i = 0;\n\n    XCP_MUTEX_LOCK(rxLock);\n\n    for (i = 0; i < XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER; i++) {\n        do {\n            xcpFifoDequeue(&rxFifo[i], &msgBufferHeader);\n\n            if (msgBufferHeader != NULL) {\n                xcpMemFree(msgBufferHeader);\n                XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_PACKET_FREED_COUNTER);\n            }\n        } while (msgBufferHeader != NULL);\n    }\n\n    XCP_MUTEX_UNLOCK(rxLock);\n}\n\n\nXcpErrorCode xcpTransportInit(int argc, void * argv[])\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    uint16_T i = 0;\n\n    XCP_ERROR_IF(initialized, XCP_ERROR, \"xcpTransportInit: transport layer already initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_INIT_COUNTER);\n\n    /* Initialize Tx and Rx data structures*/\n    for (i = 0; i < XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER; i++) {\n        xcpFifoInit(&txFifo[i]);\n    }\n    XCP_MUTEX_INIT(txLock);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    for (i = 0; i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER; i++) {\n        xcpFifoInit(&daqTxFifo[i]);\n        xcpFifoInit(&daqDeferredTxFifo[i]);\n        daqTxRequest[i] = false;\n    }\n    lastDaqIdTx = 0xFFFF;\n#endif\n\n    for (i = 0; i < XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER; i++) {\n        xcpFifoInit(&rxFifo[i]);\n    }\n    XCP_MUTEX_INIT(rxLock);\n\n    /* Initialize XCP memory allocator */\n    errorCode = xcpMemInit();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportInit: error (%d) detected during memory allocator initialization\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_MEM_INIT_ERROR);\n        return errorCode;\n    }\n\n    {\n        /* Allocate the memory pool reserved for the allocation\n           of CTO, EV and SERV XCP Packets */\n        size_t maxCtoSize = xcpTransportMaxCtoSize();\n        size_t maxBufferSize = xcpTransportMsgBufferSize(maxCtoSize, XCP_CTO);\n\n        errorCode = xcpMemReservedPoolCreate(maxBufferSize, XCP_MEM_CTO_RESERVED_POOL_BLOCKS_NUMBER,\n                                             &xcpCtoReservedMemPoolId);\n\n        if (errorCode != XCP_SUCCESS) {\n            XCP_PRINTF(\"xcpTransportInit: error (%d) detected during allocation of reserved memory pool\\n\", errorCode);\n            XCP_DIAG_UPDATE(XCP_TRANSPORT_MEM_INIT_ERROR);\n            return errorCode;\n        }\n\n        xcpFrameSetCtoReservedMemPoolId(xcpCtoReservedMemPoolId);\n    }\n\n    /* Initialize XCP Frame handler */\n    errorCode = xcpFrameInit(argc, argv);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportInit: error (%d) detected during frame handler initialization\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_INIT_ERROR);\n        return errorCode;\n    }\n\n    initialized = true;\n\n    return errorCode;\n}\n\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n\nboolean_T xcpTransportTxReady(\n    XcpTransportQueueType_T queueType, /**< [in] type of the TX queue the packet has to be sent to */\n\tuint16_T daqId                     /**< [in] id of the DAQ list the packet refers to */\n)\n{\n    boolean_T ready = true;\n    /* In the lockless implementation we enqueue data only\n       if the previous transmission has been completed */\n    if ((queueType == XCP_TRANSPORT_TX_DEFAULT_QUEUE) &&\n        (daqId <  XCP_MEM_DAQ_RESERVED_POOLS_NUMBER)) {\n        ready = !daqTxRequest[daqId];\n    }\n\n    return ready;\n}\n\n\n/** If lockless streaming is enabled, trigger the transmission of\n    packets previously enqueued (by invoking xcpTransportTxPacketSet.\n    The function returns XCP_BUSY if the TX request is already\n    in progress */\nXcpErrorCode  xcpTransportTxTrigger(\n    XcpTransportQueueType_T queueType, /**< [in] type of the TX queue the packet has to be sent to */\n    uint16_T daqId                     /**< [in] id of the DAQ list the packet refers to */\n)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    if ((queueType != XCP_TRANSPORT_TX_DEFAULT_QUEUE) ||\n        (daqId >= XCP_MEM_DAQ_RESERVED_POOLS_NUMBER)) {\n        return XCP_INV_ARG;\n    }\n\n    if (!daqTxRequest[daqId]) {\n        if (!xcpFifoEmpty(daqDeferredTxFifo)) {\n            /* If the transmission of any packets was deferred \n               from previous run, we need to enqueue them at the\n               head of the daqTxFifo, as they need to be sent first */\n            xcpFifoSpliceHead(daqTxFifo, daqDeferredTxFifo);\n        }\n\n        XCP_MEM_BARRIER();\n        daqTxRequest[daqId] = true;\n    } else {\n        errorCode = XCP_BUSY;\n    }\n\n    return errorCode;\n}\n\n#else\n\nboolean_T xcpTransportTxReady(\n    XcpTransportQueueType_T queueType, /**< [in] type of the TX queue the packet has to be sent to */\n    uint16_T daqId                     /**< [in] id of the DAQ list the packet refers to */\n)\n{\n    XCP_UNUSED_PARAM(queueType);\n    XCP_UNUSED_PARAM(daqId);\n\n    /* In the standard (mutex-based) implementation we can always enqueue\n       new packets and therefore TX is always ready*/\n    return true;\n}\n\n\nXcpErrorCode  xcpTransportTxTrigger(\n    XcpTransportQueueType_T queueType, /**< [in] type of the TX queue the packet has to be sent to */\n    uint16_T daqId                     /**< [in] id of the DAQ list the packet refers to */\n)\n{\n    /* In the standard (mutex-based) implementation the transmission\n       is always in progress, as long as there are samples in the TX fifo.\n       For this reasons this method has no effect in this case */\n    XCP_UNUSED_PARAM(queueType);\n    XCP_UNUSED_PARAM(daqId);\n\n    return XCP_SUCCESS;\n}\n\n#endif\n\n\nXcpErrorCode xcpTransportTxPacketSet(\n    XcpTransportQueueType_T queueType, /**< [in] id of the TX queue the packet has to be sent to */\n    uint16_T daqId,       /**< [in] id of the DAQ list the packet refers to */\n    void  *msgBuffer,       /* [in] pointer to the buffer containing the full XCP message */\n    size_t msgBufferSize,   /* [in] size (in AG units) of the buffer */\n    size_t xcpPktOffset,    /* [in] offset (in AG units) where the actual XCP packet content has been copied (within xcpMsg buffer)  */\n    size_t xcpPktSize       /* [in] size (in BYTEs) of the XCP packet */\n    )\n{\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    uint8_T *msgFrame = NULL;\n    size_t msgFrameMaxSize = 0;\n    size_t msgFrameSize = 0;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    /* Lock must be excluded for DAQ lists associated to reserved memory pools */\n    boolean_T locklessTx = ((queueType == XCP_TRANSPORT_TX_DEFAULT_QUEUE)   ||\n                            (queueType == XCP_TRANSPORT_DEFERRED_TX_QUEUE)) &&\n                            (daqId < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER);\n#else\n    XCP_UNUSED_PARAM(daqId);\n#endif\n\n    /* Input parameters validation */\n    XCP_ERROR_IF((queueType != XCP_TRANSPORT_DEFERRED_TX_QUEUE) && \n                 ((queueType < 0) || (queueType >= XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER)), \n                 XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid queueType\\n\");\n    XCP_ERROR_IF(msgBuffer == NULL, XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid msgBuffer\\n\");\n    XCP_ERROR_IF(xcpPktOffset != xcpTransportPacketOffset(), XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid packet offset\\n\");\n    XCP_ERROR_IF(xcpPktSize == 0, XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid packet size\\n\");\n    XCP_ERROR_IF(msgBufferSize < (xcpPktOffset + XCP_IN_HW_AG(xcpPktSize)), XCP_INV_ARG, \"xcpTransportTxPacketSet: invalid msgBufferSize\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpTransportTxPacketSet: transport layer not initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_SET_COUNTER);\n\n    msgBufferHeader = (struct xcpFifoEntry *) msgBuffer;\n    msgFrame = (uint8_T *)msgBuffer + sizeof(struct xcpFifoEntry);\n    msgFrameMaxSize = msgBufferSize - sizeof(struct xcpFifoEntry);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    if (!locklessTx) {\n#endif\n    /* Now fill the XCP frame content \n       @note the lock is used to protect the txFifo data structures from concurrent execution */\n    XCP_MUTEX_LOCK(txLock);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    }\n#endif\n\n    errorCode = xcpFrameCreateMsg(msgFrame, msgFrameMaxSize, &msgFrameSize, xcpPktSize);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportTxPacketSet: xcpFrameCreateMsg failure detected (%d)\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_CREATE_MSG_ERROR);\n        goto error;\n    }\n\n    msgBufferHeader->msgFrameSize = msgFrameSize;\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    if (!locklessTx) {\n#endif\n        /* Now that the packet has been created, we can add it to the txFifo for transmission */\n        xcpFifoEnqueue(&txFifo[queueType], msgBufferHeader);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    } else {\n        if (queueType == XCP_TRANSPORT_DEFERRED_TX_QUEUE) {\n            xcpFifoEnqueue(&daqDeferredTxFifo[daqId], msgBufferHeader);\n        } else {\n         xcpFifoEnqueue(&daqTxFifo[daqId], msgBufferHeader);\n        }\n    }\n#endif\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_IN_COUNTER);\n\nerror:\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    if (!locklessTx) {\n#endif\n    XCP_MUTEX_UNLOCK(txLock);\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    }\n#endif\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpTransportTx(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t msgFrameSize = 0;\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    XcpTransportQueueType_T queueType = XCP_TRANSPORT_TX_HIGHEST_PRIO_QUEUE;\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    /* Lock must be excluded for DAQ lists associated to reserved memory pools */\n    boolean_T locklessTx = false;\n#endif\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpTransportTx: transport layer not initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_COUNTER);\n\n    XCP_MUTEX_LOCK(txLock);\n    /* Extract the message from the Fifos, starting from the highest priority */\n    xcpFifoDequeue(&txFifo[queueType], &msgBufferHeader);\n\n    XCP_MUTEX_UNLOCK(txLock);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    if (msgBufferHeader == NULL) {\n        uint16_T i = 0;\n        /* If the highest priority is empty, check if one of the DAQ-specific ones\n           has a pending request */\n        for (i = 0; (i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER) && !locklessTx; i++) {\n            lastDaqIdTx = (lastDaqIdTx + 1) %  XCP_MEM_DAQ_RESERVED_POOLS_NUMBER;\n            if (daqTxRequest[lastDaqIdTx]) {\n                xcpFifoDequeue(&daqTxFifo[lastDaqIdTx], &msgBufferHeader);\n                if (msgBufferHeader == NULL) {\n                    /* if no data are available, we can acknowledge the request\n                       straight away */\n                    daqTxRequest[lastDaqIdTx] = false;\n                } else {\n                    locklessTx = true;\n                }\n            }\n        }\n    }\n#endif\n    if (msgBufferHeader == NULL) {\n        /* If the highest priority is empty, and no DAQ packets are available\n           try the default queue */\n        XCP_MUTEX_LOCK(txLock);\n\n        queueType = XCP_TRANSPORT_TX_DEFAULT_QUEUE;\n        xcpFifoDequeue(&txFifo[queueType], &msgBufferHeader);\n        XCP_MUTEX_UNLOCK(txLock);\n    }\n\n    if (msgBufferHeader != NULL) {\n        msgFrameSize = msgBufferHeader->msgFrameSize;\n\n        /* Trying to send one XCP message via the frame handler\n           @note The frame handler will be responsible for releasing\n                 the message buffer if the data has been successfully sent\n                 (return code XCP_SUCCESS).\n                 If not, the memory area won't be freed and the message\n                 will need to go back to the FIFO. */\n        errorCode = xcpFrameMsgSend(msgBufferHeader, sizeof(struct xcpFifoEntry), msgFrameSize);\n\n        if (errorCode != XCP_SUCCESS) {\n            XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_SEND_ERROR);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n            if (!locklessTx) {\n#endif\n            XCP_MUTEX_LOCK(txLock);\n\n            xcpFifoEnqueueHead(&txFifo[queueType], msgBufferHeader);\n\n            XCP_MUTEX_UNLOCK(txLock);\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n            } else {\n                xcpFifoEnqueueHead(&daqTxFifo[lastDaqIdTx], msgBufferHeader);\n            }\n#endif\n        } else {\n            XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_PACKET_OUT_COUNTER);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n            if (locklessTx && xcpFifoEmpty(&daqTxFifo[lastDaqIdTx])) {\n                /* All packets in the queue have been sent,\n                   the request can be acknowledged */\n                XCP_MEM_BARRIER();\n                daqTxRequest[lastDaqIdTx] = false;\n            }\n#endif\n        }\n    } else {\n        errorCode = XCP_EMPTY;\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_TX_IS_EMPTY_COUNTER);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpTransportRx(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    size_t msgFrameSize = 0;\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpTransportRx: transport layer not initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_COUNTER);\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    /* Make sure that the blocks associated to the CTO reserved memory\n       pool are made available for subsequent allocations */\n    xcpMemReservedPoolFlushFreeMem(xcpCtoReservedMemPoolId);\n#endif\n\n    /* Trying to receive one XCP message via the frame handler\n       @note The frame handler is also responsible for allocating the\n             memory area and it is no longer responsible for the ownership\n             of the memory if the function has been successfully executed\n             (error code XCP_SUCCESS)\n             If there are no messages available, the return code is XCP_EMPTY */\n    errorCode = xcpFrameMsgRecv((void**) &msgBufferHeader, sizeof(struct xcpFifoEntry), &msgFrameSize);\n\n    if (errorCode == XCP_SUCCESS) {\n        /* Add the message to the Fifo */\n        msgBufferHeader->msgFrameSize = msgFrameSize;\n\n        XCP_MUTEX_LOCK(rxLock);\n\n        /* Only one RX queue available */\n        xcpFifoEnqueue(&rxFifo[XCP_TRANSPORT_RX_DEFAULT_QUEUE], msgBufferHeader);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_PACKET_IN_COUNTER);\n\n        XCP_MUTEX_UNLOCK(rxLock);\n    } else if (errorCode == XCP_EMPTY) {\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_IS_EMPTY_COUNTER);\n    } else {\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_RECV_ERROR);\n    }\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpTransportRxPacketGet(\n    XcpTransportQueueType_T queueType, /**< [in] id of the RX queue the packet has to be received from */\n    void  **msgBuffer,     /* [out] pointer to the buffer containing the full XCP message that has been extracted */\n    size_t *msgBufferSize, /* [out] size (in AG units) of the buffer */\n    size_t *xcpPktOffset,  /* [out] offset (in AG units) of the XCP packet within the message buffer */\n    size_t *xcpPktSize     /* [out] size (in BYTEs) of the XCP packet */\n    )\n{\n    struct xcpFifoEntry *msgBufferHeader = NULL;\n    uint8_T *msgFrame = NULL;\n    size_t msgFrameSize = 0;\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    /* Input parameters validation */\n    XCP_ERROR_IF((queueType < 0) || (queueType >= XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER), XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid queueType\\n\");\n    XCP_ERROR_IF(msgBuffer == NULL, XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid msgBuffer pointer\\n\");\n    XCP_ERROR_IF(msgBufferSize == NULL, XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid msgBufferSize pointer\\n\");\n    XCP_ERROR_IF(xcpPktOffset == NULL, XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid xcpPktOffset pointer\\n\");\n    XCP_ERROR_IF(xcpPktSize == NULL, XCP_INV_ARG, \"xcpTransportRxPacketGet: invalid xcpPktSize pointer\\n\");\n    XCP_ERROR_IF(!initialized, XCP_NOT_INITIALIZED, \"xcpTransportRxPacketGet: transport layer not initialized\\n\");\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_PACKET_GET_COUNTER);\n\n    XCP_MUTEX_LOCK(rxLock);\n\n    xcpFifoDequeue(&rxFifo[queueType], &msgBufferHeader);\n\n    XCP_MUTEX_UNLOCK(rxLock);\n\n    if (msgBufferHeader == NULL) {\n        return XCP_EMPTY; /* No messages in the FIFO */\n    }\n    else {\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_RX_PACKET_OUT_COUNTER);\n    }\n\n    msgFrame = (uint8_T *) msgBufferHeader + sizeof(struct xcpFifoEntry);\n    msgFrameSize = msgBufferHeader->msgFrameSize;\n\n    /* Extract a new XCP packet from the XCP message, and carry out all the relevant checks in the frame format */\n    errorCode = xcpFrameExtractPacket(msgFrame, msgFrameSize, xcpPktSize);\n    if (errorCode != XCP_SUCCESS) {\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_EXTRACT_PACKET_ERROR);\n    }\n\n    *msgBuffer = msgBufferHeader;\n    *msgBufferSize = msgBufferHeader->msgFrameSize + sizeof(struct xcpFifoEntry);\n    *xcpPktOffset = xcpTransportPacketOffset();\n\n    return errorCode;\n}\n\n\nsize_t xcpTransportPacketOffset(void)\n{\n    size_t size = sizeof(struct xcpFifoEntry);\n\n    size += XCP_IN_HW_AG(xcpFrameHeaderSize());\n\n    return size;\n}\n\n/* xcpPacketSize is the number of octets in the XCP Packet\n * Return value the buffer size in terms of target memory granularity needed to contain this packet.\n * On 32-bit address granularity processor, a packet of 6 contiguous BYTEs, we require 2 memory\n *  locations to contain it.\n */\nsize_t xcpTransportMsgBufferSize(size_t xcpPacketSize, XcpPacketType pktType)\n{\n    size_t size = 0;\n    size_t maxPacketSize = 0;\n    \n    maxPacketSize = (pktType == XCP_CTO) ? xcpFrameMaxCtoSize() : xcpFrameMaxDtoSize();\n\n    if (xcpPacketSize > maxPacketSize) {\n        XCP_PRINTF(\"xcpTransportMsgSize: invalid xcpPacketSize\\n\");\n        return 0;\n    }\n\n    size = sizeof(struct xcpFifoEntry);\n\n    size += XCP_IN_HW_AG(xcpFrameHeaderSize());\n    size += XCP_IN_HW_AG(xcpPacketSize);\n    size += XCP_IN_HW_AG(xcpFrameTailSize());\n\n    return size;\n}\n\n\nsize_t xcpTransportMaxDtoSize(void)\n{\n    return xcpFrameMaxDtoSize();\n}\n\n\nsize_t xcpTransportMaxCtoSize(void)\n{\n    return xcpFrameMaxCtoSize();\n}\n\n\nXcpErrorCode xcpTransportRestart(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RESTART_COUNTER);\n\n    /* Restart Frame Handler */\n    errorCode = xcpFrameRestart();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportRestart: error (%d) detected during frame handler restart\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_RESTART_ERROR);\n        return errorCode;\n    }\n\n    /* Empty TX and RX fifos */\n    xcpTransportEmptyTxFifo();\n    xcpTransportEmptyRxFifo();\n\n    return errorCode;\n}\n\n\nXcpErrorCode xcpTransportResynch(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RESYNCH_COUNTER);\n\n    /* Restart Frame Handler */\n    errorCode = xcpFrameRestart();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportRestart: error (%d) detected during frame handler restart\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_RESTART_ERROR);\n        return errorCode;\n    }\n\n    /* Empty TX FIFO */\n    xcpTransportEmptyTxFifo();\n\n    return errorCode;\n}\n\n\nxcpPoolId_T xcpTransportCtoReservedMemPoolId(void)\n{\n    return xcpCtoReservedMemPoolId;\n}\n\n\nXcpErrorCode xcpTransportReset(void)\n{\n    XcpErrorCode errorCode = XCP_SUCCESS;\n    XcpTransportQueueType_T i = 0;\n\n    if (!initialized) {\n        XCP_PRINTF(\"xcpTransportReset: transport layer already reset\\n\");\n        return XCP_SUCCESS; /* Nothing to do: just printing out a warning message*/\n    }\n\n    XCP_DIAG_UPDATE(XCP_TRANSPORT_RESET_COUNTER);\n\n    /* Reset XCP Frame handler */\n    errorCode = xcpFrameReset();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportReset: error (%d) detected during frame handler reset\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_FRAME_RESET_ERROR);\n        return errorCode;\n    }\n\n    /* Before resetting the txFifo and rxFifo, all the message buffers still enqueued need to be freed\n    as the ownership of the memory area was explicitly given to the Transport Layer */\n    xcpTransportEmptyTxFifo();\n    xcpTransportEmptyRxFifo();\n\n    /* Destroy the reserved memory pool */\n    xcpMemReservedPoolDestroy(xcpCtoReservedMemPoolId);\n\n    /* Reset XCP memory allocator */\n    errorCode = xcpMemReset();\n    if (errorCode != XCP_SUCCESS) {\n        XCP_PRINTF(\"xcpTransportReset: error (%d) detected during memory allocator reset\\n\", errorCode);\n        XCP_DIAG_UPDATE(XCP_TRANSPORT_MEM_RESET_ERROR);\n        return errorCode;\n    }\n\n    /* Now we can reset Tx and Rx Fifos */\n    /* Initialize Tx and Rx data structures*/\n    for (i = 0; i < XCP_TRANSPORT_TX_QUEUES_TYPES_NUMBER; i++) {\n        xcpFifoReset(&txFifo[i]);\n    }\n    for (i = 0; i < XCP_TRANSPORT_RX_QUEUES_TYPES_NUMBER; i++) {\n        xcpFifoReset(&rxFifo[i]);\n    }\n\n#ifdef XCP_LOCKLESS_SYNC_DATA_TRANSFER_SUPPORT\n    for (i = 0; i < XCP_MEM_DAQ_RESERVED_POOLS_NUMBER; i++) {\n        xcpFifoReset(&daqTxFifo[i]);\n        xcpFifoReset(&daqDeferredTxFifo[i]);\n        daqTxRequest[i] = false;\n    }\n    lastDaqIdTx = 0xFFFF;\n#endif\n\n    initialized = false;\n\n    return errorCode;\n}\n\n\n"},{"name":"xcp_utils.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2024a/toolbox/coder/xcp/src/target/server/common","tag":"","groupDisplay":"Other files","code":"/* Copyright 2022 The MathWorks, Inc. */\n\n#include \"xcp_utils.h\"\n\n/**\n * Sort elements in `toSort` in ascending order, keeping the correspondence with elements of\n * `toKeepAligned`.\n **/\nvoid xcpSortArray(size_t *toSort, size_t *toKeepAligned, size_t size)\n{\n    unsigned char sorted = size == 0; /* an empty array is already sorted */\n    size_t idx = 0;\n\n    while (!sorted) {\n        sorted = 1;\n        for (idx = 0; idx < size - 1; ++idx) {\n            if (toSort[idx + 1] < toSort[idx]) {\n                size_t tempToSort = toSort[idx];\n                size_t tempToKeepAligned = toKeepAligned[idx];\n\n                sorted = 0;\n\n                toKeepAligned[idx] = toKeepAligned[idx + 1];\n                toKeepAligned[idx + 1] = tempToKeepAligned;\n\n                toSort[idx] = toSort[idx + 1];\n                toSort[idx + 1] =  tempToSort;\n            }\n        }\n    }\n}\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};