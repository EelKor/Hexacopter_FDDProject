var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"Mixer_FaultInjection","ref":false,"files":[{"name":"ert_main.cpp","type":"source","group":"main","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Main file","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: ert_main.cpp\r\n//\r\n// Code generated for Simulink model 'Mixer_FaultInjection'.\r\n//\r\n// Model version                  : 4.142\r\n// Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n// C/C++ source code generated on : Fri Aug 23 16:15:46 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include \"Mixer_FaultInjection.h\"\r\n#include \"Mixer_FaultInjection_private.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"limits.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"MW_PX4_TaskControl.h\"\r\n#include \"nuttxinitialize.h\"\r\n#define UNUSED(x)                      x = x\r\n#define NAMELEN                        16\r\n\r\n// Function prototype declaration\r\nvoid exitFcn(int sig);\r\nvoid *terminateTask(void *arg);\r\nvoid *baseRateTask(void *arg);\r\nvoid *subrateTask(void *arg);\r\nvolatile boolean_T stopRequested = false;\r\nvolatile boolean_T runModel = true;\r\npx4_sem_t stopSem;\r\npx4_sem_t baserateTaskSem;\r\npthread_t schedulerThread;\r\npthread_t baseRateThread;\r\nvoid *threadJoinStatus;\r\nint terminatingmodel = 0;\r\nvoid *baseRateTask(void *arg)\r\n{\r\n  runModel = (rtmGetErrorStatus(Mixer_FaultInjection_M) == (NULL));\r\n  while (runModel) {\r\n    px4_sem_wait(&baserateTaskSem);\r\n    Mixer_FaultInjection_step();\r\n\r\n    // Get model outputs here\r\n    stopRequested = !((rtmGetErrorStatus(Mixer_FaultInjection_M) == (NULL)));\r\n  }\r\n\r\n  runModel = 0;\r\n  terminateTask(arg);\r\n  pthread_exit((void *)0);\r\n  return NULL;\r\n}\r\n\r\nvoid exitFcn(int sig)\r\n{\r\n  UNUSED(sig);\r\n  rtmSetErrorStatus(Mixer_FaultInjection_M, \"stopping the model\");\r\n  runModel = 0;\r\n}\r\n\r\nvoid *terminateTask(void *arg)\r\n{\r\n  UNUSED(arg);\r\n  terminatingmodel = 1;\r\n\r\n  {\r\n    runModel = 0;\r\n  }\r\n\r\n  MW_PX4_Terminate();\r\n\r\n  // Terminate model\r\n  Mixer_FaultInjection_terminate();\r\n  px4_sem_post(&stopSem);\r\n  return NULL;\r\n}\r\n\r\nint px4_simulink_app_task_main (int argc, char *argv[])\r\n{\r\n  rtmSetErrorStatus(Mixer_FaultInjection_M, 0);\r\n\r\n  // Initialize model\r\n  Mixer_FaultInjection_initialize();\r\n\r\n  // Call RTOS Initialization function\r\n  nuttxRTOSInit(0.004, 0);\r\n\r\n  // Wait for stop semaphore\r\n  px4_sem_wait(&stopSem);\r\n\r\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\r\n\r\n  {\r\n    int i;\r\n    for (i=0; i < MW_NUMBER_TIMER_DRIVEN_TASKS; i++) {\r\n      CHECK_STATUS(px4_sem_destroy(&timerTaskSem[i]), 0, \"px4_sem_destroy\");\r\n    }\r\n  }\r\n\r\n#endif\r\n\r\n  return 0;\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"Mixer_FaultInjection.cpp","type":"source","group":"model","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: Mixer_FaultInjection.cpp\r\n//\r\n// Code generated for Simulink model 'Mixer_FaultInjection'.\r\n//\r\n// Model version                  : 4.142\r\n// Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n// C/C++ source code generated on : Fri Aug 23 16:15:46 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#include \"Mixer_FaultInjection.h\"\r\n#include \"calcFaultInjectedPWM.h\"\r\n#include <math.h>\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"Mixer_FaultInjection_private.h\"\r\n\r\n// Block signals (default storage)\r\nB_Mixer_FaultInjection_T Mixer_FaultInjection_B;\r\n\r\n// Block states (default storage)\r\nDW_Mixer_FaultInjection_T Mixer_FaultInjection_DW;\r\n\r\n// Real-time model\r\nRT_MODEL_Mixer_FaultInjection_T Mixer_FaultInjection_M_ =\r\n  RT_MODEL_Mixer_FaultInjection_T();\r\nRT_MODEL_Mixer_FaultInjection_T *const Mixer_FaultInjection_M =\r\n  &Mixer_FaultInjection_M_;\r\n\r\n// Model step function\r\nvoid Mixer_FaultInjection_step(void)\r\n{\r\n  real_T rtb_Switch2;\r\n  real_T rtb_Switch3;\r\n  real_T rtb_Switch4;\r\n  real_T rtb_Switch5;\r\n  real_T tmp;\r\n  int32_T ParamStep;\r\n  real32_T ParamStep_0;\r\n  boolean_T b_varargout_1;\r\n  boolean_T rtb_Compare;\r\n\r\n  // MATLABSystem: '<S15>/SourceBlock'\r\n  b_varargout_1 = uORB_read_step(Mixer_FaultInjection_DW.obj_d.orbMetadataObj,\r\n    &Mixer_FaultInjection_DW.obj_d.eventStructObj,\r\n    &Mixer_FaultInjection_B.b_varargout_2, false, 5000.0);\r\n\r\n  // Outputs for Enabled SubSystem: '<S15>/Enabled Subsystem' incorporates:\r\n  //   EnablePort: '<S16>/Enable'\r\n\r\n  // Start for MATLABSystem: '<S15>/SourceBlock'\r\n  if (b_varargout_1) {\r\n    // SignalConversion generated from: '<S16>/In1'\r\n    Mixer_FaultInjection_B.In1 = Mixer_FaultInjection_B.b_varargout_2;\r\n  }\r\n\r\n  // End of Outputs for SubSystem: '<S15>/Enabled Subsystem'\r\n\r\n  // RelationalOperator: '<S7>/Compare' incorporates:\r\n  //   Constant: '<S7>/Constant'\r\n  //   DataTypeConversion: '<S1>/Data Type Conversion'\r\n\r\n  rtb_Compare = (Mixer_FaultInjection_B.In1.values[6] >=\r\n                 Mixer_FaultInjection_P.CompareToConstant_const);\r\n\r\n  // MATLABSystem: '<S4>/SourceBlock'\r\n  b_varargout_1 = uORB_read_step(Mixer_FaultInjection_DW.obj_f.orbMetadataObj,\r\n    &Mixer_FaultInjection_DW.obj_f.eventStructObj,\r\n    &Mixer_FaultInjection_B.b_varargout_2_c, false, 1.0);\r\n\r\n  // Outputs for Enabled SubSystem: '<S4>/Enabled Subsystem' incorporates:\r\n  //   EnablePort: '<S14>/Enable'\r\n\r\n  // Start for MATLABSystem: '<S4>/SourceBlock'\r\n  if (b_varargout_1) {\r\n    // SignalConversion generated from: '<S14>/In1'\r\n    Mixer_FaultInjection_B.In1_m = Mixer_FaultInjection_B.b_varargout_2_c;\r\n  }\r\n\r\n  // End of Outputs for SubSystem: '<S4>/Enabled Subsystem'\r\n\r\n  // MATLABSystem: '<S2>/Read Parameter13'\r\n  if (Mixer_FaultInjection_DW.obj_h.SampleTime !=\r\n      Mixer_FaultInjection_P.ReadParameter13_SampleTime) {\r\n    Mixer_FaultInjection_DW.obj_h.SampleTime =\r\n      Mixer_FaultInjection_P.ReadParameter13_SampleTime;\r\n  }\r\n\r\n  b_varargout_1 = MW_Param_Step(Mixer_FaultInjection_DW.obj_h.MW_PARAMHANDLE,\r\n    MW_INT32, &ParamStep);\r\n  if (b_varargout_1) {\r\n    ParamStep = 0;\r\n  }\r\n\r\n  // Switch: '<S1>/Switch' incorporates:\r\n  //   Constant: '<S1>/Constant'\r\n  //   DataTypeConversion: '<S2>/Data Type Conversion3'\r\n  //   MATLAB Function: '<Root>/MATLAB Function'\r\n  //   MATLABSystem: '<S2>/Read Parameter13'\r\n  //\r\n  if (rtb_Compare) {\r\n    Mixer_FaultInjection_B.Switch = Mixer_FaultInjection_P.Constant_Value_o;\r\n  } else {\r\n    // Outputs for Atomic SubSystem: '<S2>/CalcFaultInjectedPWM'\r\n    calcFaultInjectedPWM(((-Mixer_FaultInjection_B.In1_m.control[0] -\r\n      Mixer_FaultInjection_B.In1_m.control[2]) *\r\n                          Mixer_FaultInjection_B.In1_m.control[3] / 3.0F +\r\n                          Mixer_FaultInjection_B.In1_m.control[3]) * 1000.0F +\r\n                         1000.0F, static_cast<real_T>(ParamStep),\r\n                         &Mixer_FaultInjection_B.Switch,\r\n                         &Mixer_FaultInjection_P.CalcFaultInjectedPWM);\r\n\r\n    // End of Outputs for SubSystem: '<S2>/CalcFaultInjectedPWM'\r\n  }\r\n\r\n  // End of Switch: '<S1>/Switch'\r\n\r\n  // MATLABSystem: '<S2>/Read Parameter1'\r\n  if (Mixer_FaultInjection_DW.obj_o.SampleTime !=\r\n      Mixer_FaultInjection_P.ReadParameter1_SampleTime) {\r\n    Mixer_FaultInjection_DW.obj_o.SampleTime =\r\n      Mixer_FaultInjection_P.ReadParameter1_SampleTime;\r\n  }\r\n\r\n  b_varargout_1 = MW_Param_Step(Mixer_FaultInjection_DW.obj_o.MW_PARAMHANDLE,\r\n    MW_INT32, &ParamStep);\r\n  if (b_varargout_1) {\r\n    ParamStep = 0;\r\n  }\r\n\r\n  // Switch: '<S1>/Switch1' incorporates:\r\n  //   Constant: '<S1>/Constant1'\r\n  //   DataTypeConversion: '<S2>/Data Type Conversion1'\r\n  //   MATLAB Function: '<Root>/MATLAB Function'\r\n  //   MATLABSystem: '<S2>/Read Parameter1'\r\n  //\r\n  if (rtb_Compare) {\r\n    Mixer_FaultInjection_B.Switch1 = Mixer_FaultInjection_P.Constant1_Value;\r\n  } else {\r\n    // Outputs for Atomic SubSystem: '<S2>/CalcFaultInjectedPWM1'\r\n    calcFaultInjectedPWM(((Mixer_FaultInjection_B.In1_m.control[0] +\r\n      Mixer_FaultInjection_B.In1_m.control[2]) *\r\n                          Mixer_FaultInjection_B.In1_m.control[3] / 3.0F +\r\n                          Mixer_FaultInjection_B.In1_m.control[3]) * 1000.0F +\r\n                         1000.0F, static_cast<real_T>(ParamStep),\r\n                         &Mixer_FaultInjection_B.Switch1,\r\n                         &Mixer_FaultInjection_P.CalcFaultInjectedPWM1);\r\n\r\n    // End of Outputs for SubSystem: '<S2>/CalcFaultInjectedPWM1'\r\n  }\r\n\r\n  // End of Switch: '<S1>/Switch1'\r\n\r\n  // MATLABSystem: '<S2>/Read Parameter2'\r\n  if (Mixer_FaultInjection_DW.obj_g.SampleTime !=\r\n      Mixer_FaultInjection_P.ReadParameter2_SampleTime) {\r\n    Mixer_FaultInjection_DW.obj_g.SampleTime =\r\n      Mixer_FaultInjection_P.ReadParameter2_SampleTime;\r\n  }\r\n\r\n  b_varargout_1 = MW_Param_Step(Mixer_FaultInjection_DW.obj_g.MW_PARAMHANDLE,\r\n    MW_INT32, &ParamStep);\r\n  if (b_varargout_1) {\r\n    ParamStep = 0;\r\n  }\r\n\r\n  // Switch: '<S1>/Switch2' incorporates:\r\n  //   Constant: '<S1>/Constant2'\r\n  //   DataTypeConversion: '<S2>/Data Type Conversion2'\r\n  //   MATLAB Function: '<Root>/MATLAB Function'\r\n  //   MATLABSystem: '<S2>/Read Parameter2'\r\n  //\r\n  if (rtb_Compare) {\r\n    rtb_Switch2 = Mixer_FaultInjection_P.Constant2_Value;\r\n  } else {\r\n    // Outputs for Atomic SubSystem: '<S2>/CalcFaultInjectedPWM2'\r\n    calcFaultInjectedPWM((((Mixer_FaultInjection_B.In1_m.control[1] +\r\n      Mixer_FaultInjection_B.In1_m.control[0] / 2.0F) -\r\n      Mixer_FaultInjection_B.In1_m.control[2]) *\r\n                          Mixer_FaultInjection_B.In1_m.control[3] / 3.0F +\r\n                          Mixer_FaultInjection_B.In1_m.control[3]) * 1000.0F +\r\n                         1000.0F, static_cast<real_T>(ParamStep), &rtb_Switch2,\r\n                         &Mixer_FaultInjection_P.CalcFaultInjectedPWM2);\r\n\r\n    // End of Outputs for SubSystem: '<S2>/CalcFaultInjectedPWM2'\r\n  }\r\n\r\n  // End of Switch: '<S1>/Switch2'\r\n\r\n  // MATLABSystem: '<S2>/Read Parameter3'\r\n  if (Mixer_FaultInjection_DW.obj_e.SampleTime !=\r\n      Mixer_FaultInjection_P.ReadParameter3_SampleTime) {\r\n    Mixer_FaultInjection_DW.obj_e.SampleTime =\r\n      Mixer_FaultInjection_P.ReadParameter3_SampleTime;\r\n  }\r\n\r\n  b_varargout_1 = MW_Param_Step(Mixer_FaultInjection_DW.obj_e.MW_PARAMHANDLE,\r\n    MW_INT32, &ParamStep);\r\n  if (b_varargout_1) {\r\n    ParamStep = 0;\r\n  }\r\n\r\n  // Switch: '<S1>/Switch3' incorporates:\r\n  //   Constant: '<S1>/Constant3'\r\n  //   DataTypeConversion: '<S2>/Data Type Conversion4'\r\n  //   MATLAB Function: '<Root>/MATLAB Function'\r\n  //   MATLABSystem: '<S2>/Read Parameter3'\r\n  //\r\n  if (rtb_Compare) {\r\n    rtb_Switch3 = Mixer_FaultInjection_P.Constant3_Value;\r\n  } else {\r\n    // Outputs for Atomic SubSystem: '<S2>/CalcFaultInjectedPWM3'\r\n    calcFaultInjectedPWM((((-Mixer_FaultInjection_B.In1_m.control[1] -\r\n      Mixer_FaultInjection_B.In1_m.control[0] / 2.0F) +\r\n      Mixer_FaultInjection_B.In1_m.control[2]) *\r\n                          Mixer_FaultInjection_B.In1_m.control[3] / 3.0F +\r\n                          Mixer_FaultInjection_B.In1_m.control[3]) * 1000.0F +\r\n                         1000.0F, static_cast<real_T>(ParamStep), &rtb_Switch3,\r\n                         &Mixer_FaultInjection_P.CalcFaultInjectedPWM3);\r\n\r\n    // End of Outputs for SubSystem: '<S2>/CalcFaultInjectedPWM3'\r\n  }\r\n\r\n  // End of Switch: '<S1>/Switch3'\r\n\r\n  // MATLABSystem: '<S2>/Read Parameter4'\r\n  if (Mixer_FaultInjection_DW.obj.SampleTime !=\r\n      Mixer_FaultInjection_P.ReadParameter4_SampleTime) {\r\n    Mixer_FaultInjection_DW.obj.SampleTime =\r\n      Mixer_FaultInjection_P.ReadParameter4_SampleTime;\r\n  }\r\n\r\n  b_varargout_1 = MW_Param_Step(Mixer_FaultInjection_DW.obj.MW_PARAMHANDLE,\r\n    MW_INT32, &ParamStep);\r\n  if (b_varargout_1) {\r\n    ParamStep = 0;\r\n  }\r\n\r\n  // Switch: '<S1>/Switch4' incorporates:\r\n  //   Constant: '<S1>/Constant4'\r\n  //   DataTypeConversion: '<S2>/Data Type Conversion5'\r\n  //   MATLAB Function: '<Root>/MATLAB Function'\r\n  //   MATLABSystem: '<S2>/Read Parameter4'\r\n  //\r\n  if (rtb_Compare) {\r\n    rtb_Switch4 = Mixer_FaultInjection_P.Constant4_Value;\r\n  } else {\r\n    // Outputs for Atomic SubSystem: '<S2>/CalcFaultInjectedPWM4'\r\n    calcFaultInjectedPWM((((Mixer_FaultInjection_B.In1_m.control[1] -\r\n      Mixer_FaultInjection_B.In1_m.control[0] / 2.0F) +\r\n      Mixer_FaultInjection_B.In1_m.control[2]) *\r\n                          Mixer_FaultInjection_B.In1_m.control[3] / 3.0F +\r\n                          Mixer_FaultInjection_B.In1_m.control[3]) * 1000.0F +\r\n                         1000.0F, static_cast<real_T>(ParamStep), &rtb_Switch4,\r\n                         &Mixer_FaultInjection_P.CalcFaultInjectedPWM4);\r\n\r\n    // End of Outputs for SubSystem: '<S2>/CalcFaultInjectedPWM4'\r\n  }\r\n\r\n  // End of Switch: '<S1>/Switch4'\r\n\r\n  // MATLABSystem: '<S2>/Read Parameter'\r\n  if (Mixer_FaultInjection_DW.obj_hy.SampleTime !=\r\n      Mixer_FaultInjection_P.ReadParameter_SampleTime) {\r\n    Mixer_FaultInjection_DW.obj_hy.SampleTime =\r\n      Mixer_FaultInjection_P.ReadParameter_SampleTime;\r\n  }\r\n\r\n  b_varargout_1 = MW_Param_Step(Mixer_FaultInjection_DW.obj_hy.MW_PARAMHANDLE,\r\n    MW_SINGLE, &ParamStep_0);\r\n  if (b_varargout_1) {\r\n    ParamStep_0 = 0.0F;\r\n  }\r\n\r\n  // Switch: '<S1>/Switch5' incorporates:\r\n  //   Constant: '<S1>/Constant5'\r\n  //   DataTypeConversion: '<S2>/Data Type Conversion6'\r\n  //   MATLAB Function: '<Root>/MATLAB Function'\r\n  //   MATLABSystem: '<S2>/Read Parameter'\r\n  //\r\n  if (rtb_Compare) {\r\n    rtb_Switch5 = Mixer_FaultInjection_P.Constant5_Value;\r\n  } else {\r\n    // Outputs for Atomic SubSystem: '<S2>/CalcFaultInjectedPWM5'\r\n    calcFaultInjectedPWM((((-Mixer_FaultInjection_B.In1_m.control[1] +\r\n      Mixer_FaultInjection_B.In1_m.control[0] / 2.0F) -\r\n      Mixer_FaultInjection_B.In1_m.control[2]) *\r\n                          Mixer_FaultInjection_B.In1_m.control[3] / 3.0F +\r\n                          Mixer_FaultInjection_B.In1_m.control[3]) * 1000.0F +\r\n                         1000.0F, static_cast<real_T>(ParamStep_0), &rtb_Switch5,\r\n                         &Mixer_FaultInjection_P.CalcFaultInjectedPWM5);\r\n\r\n    // End of Outputs for SubSystem: '<S2>/CalcFaultInjectedPWM5'\r\n  }\r\n\r\n  // End of Switch: '<S1>/Switch5'\r\n\r\n  // BusAssignment: '<S6>/Bus Assignment' incorporates:\r\n  //   Constant: '<S17>/Constant'\r\n\r\n  Mixer_FaultInjection_B.BusAssignment = Mixer_FaultInjection_P.Constant_Value;\r\n\r\n  // DataTypeConversion: '<S6>/Data Type Conversion1' incorporates:\r\n  //   Constant: '<S6>/Constant17'\r\n\r\n  tmp = floor(Mixer_FaultInjection_P.Constant17_Value);\r\n  if (rtIsNaN(tmp) || rtIsInf(tmp)) {\r\n    tmp = 0.0;\r\n  } else {\r\n    tmp = fmod(tmp, 4.294967296E+9);\r\n  }\r\n\r\n  // BusAssignment: '<S6>/Bus Assignment' incorporates:\r\n  //   Constant: '<S6>/Constant'\r\n  //   DataTypeConversion: '<S6>/Data Type Conversion'\r\n  //   DataTypeConversion: '<S6>/Data Type Conversion1'\r\n\r\n  Mixer_FaultInjection_B.BusAssignment.noutputs = tmp < 0.0 ?\r\n    static_cast<uint32_T>(-static_cast<int32_T>(static_cast<uint32_T>(-tmp))) :\r\n    static_cast<uint32_T>(tmp);\r\n  Mixer_FaultInjection_B.BusAssignment.output[0] = static_cast<real32_T>\r\n    (Mixer_FaultInjection_B.Switch);\r\n  Mixer_FaultInjection_B.BusAssignment.output[1] = static_cast<real32_T>\r\n    (Mixer_FaultInjection_B.Switch1);\r\n  Mixer_FaultInjection_B.BusAssignment.output[2] = static_cast<real32_T>\r\n    (rtb_Switch2);\r\n  Mixer_FaultInjection_B.BusAssignment.output[3] = static_cast<real32_T>\r\n    (rtb_Switch3);\r\n  Mixer_FaultInjection_B.BusAssignment.output[4] = static_cast<real32_T>\r\n    (rtb_Switch4);\r\n  Mixer_FaultInjection_B.BusAssignment.output[5] = static_cast<real32_T>\r\n    (rtb_Switch5);\r\n  Mixer_FaultInjection_B.BusAssignment.output[6] = static_cast<real32_T>\r\n    (Mixer_FaultInjection_P.Constant_Value_g);\r\n  Mixer_FaultInjection_B.BusAssignment.output[7] = static_cast<real32_T>\r\n    (Mixer_FaultInjection_P.Constant_Value_g);\r\n  Mixer_FaultInjection_B.BusAssignment.output[8] = static_cast<real32_T>\r\n    (Mixer_FaultInjection_P.Constant_Value_g);\r\n  Mixer_FaultInjection_B.BusAssignment.output[9] = static_cast<real32_T>\r\n    (Mixer_FaultInjection_P.Constant_Value_g);\r\n  Mixer_FaultInjection_B.BusAssignment.output[10] = static_cast<real32_T>\r\n    (Mixer_FaultInjection_P.Constant_Value_g);\r\n  Mixer_FaultInjection_B.BusAssignment.output[11] = static_cast<real32_T>\r\n    (Mixer_FaultInjection_P.Constant_Value_g);\r\n  Mixer_FaultInjection_B.BusAssignment.output[12] = static_cast<real32_T>\r\n    (Mixer_FaultInjection_P.Constant_Value_g);\r\n  Mixer_FaultInjection_B.BusAssignment.output[13] = static_cast<real32_T>\r\n    (Mixer_FaultInjection_P.Constant_Value_g);\r\n  Mixer_FaultInjection_B.BusAssignment.output[14] = static_cast<real32_T>\r\n    (Mixer_FaultInjection_P.Constant_Value_g);\r\n  Mixer_FaultInjection_B.BusAssignment.output[15] = static_cast<real32_T>\r\n    (Mixer_FaultInjection_P.Constant_Value_g);\r\n\r\n  // MATLABSystem: '<S18>/SinkBlock' incorporates:\r\n  //   BusAssignment: '<S6>/Bus Assignment'\r\n\r\n  uORB_write_step(Mixer_FaultInjection_DW.obj_hyc.orbMetadataObj,\r\n                  &Mixer_FaultInjection_DW.obj_hyc.orbAdvertiseObj,\r\n                  &Mixer_FaultInjection_B.BusAssignment);\r\n}\r\n\r\n// Model initialize function\r\nvoid Mixer_FaultInjection_initialize(void)\r\n{\r\n  // Registration code\r\n\r\n  // initialize non-finites\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  {\r\n    static const char_T ParameterNameStr[14] = \"FDD_M1_STATUS\";\r\n    static const char_T ParameterNameStr_0[14] = \"FDD_M2_STATUS\";\r\n    static const char_T ParameterNameStr_1[14] = \"FDD_M3_STATUS\";\r\n    static const char_T ParameterNameStr_2[14] = \"FDD_M4_STATUS\";\r\n    static const char_T ParameterNameStr_3[14] = \"FDD_M5_STATUS\";\r\n    static const char_T ParameterNameStr_4[14] = \"FDD_M6_STATUS\";\r\n    real_T tmp;\r\n\r\n    // SystemInitialize for Enabled SubSystem: '<S15>/Enabled Subsystem'\r\n    // SystemInitialize for SignalConversion generated from: '<S16>/In1' incorporates:\r\n    //   Outport: '<S16>/Out1'\r\n\r\n    Mixer_FaultInjection_B.In1 = Mixer_FaultInjection_P.Out1_Y0;\r\n\r\n    // End of SystemInitialize for SubSystem: '<S15>/Enabled Subsystem'\r\n\r\n    // SystemInitialize for Enabled SubSystem: '<S4>/Enabled Subsystem'\r\n    // SystemInitialize for SignalConversion generated from: '<S14>/In1' incorporates:\r\n    //   Outport: '<S14>/Out1'\r\n\r\n    Mixer_FaultInjection_B.In1_m = Mixer_FaultInjection_P.Out1_Y0_c;\r\n\r\n    // End of SystemInitialize for SubSystem: '<S4>/Enabled Subsystem'\r\n\r\n    // Start for MATLABSystem: '<S15>/SourceBlock'\r\n    Mixer_FaultInjection_DW.obj_d.matlabCodegenIsDeleted = false;\r\n    Mixer_FaultInjection_DW.obj_d.isInitialized = 1;\r\n    Mixer_FaultInjection_DW.obj_d.orbMetadataObj = ORB_ID(input_rc);\r\n    uORB_read_initialize(Mixer_FaultInjection_DW.obj_d.orbMetadataObj,\r\n                         &Mixer_FaultInjection_DW.obj_d.eventStructObj);\r\n    Mixer_FaultInjection_DW.obj_d.isSetupComplete = true;\r\n\r\n    // Start for MATLABSystem: '<S4>/SourceBlock'\r\n    Mixer_FaultInjection_DW.obj_f.matlabCodegenIsDeleted = false;\r\n    Mixer_FaultInjection_DW.obj_f.isInitialized = 1;\r\n    Mixer_FaultInjection_DW.obj_f.orbMetadataObj = ORB_ID(actuator_controls_0);\r\n    uORB_read_initialize(Mixer_FaultInjection_DW.obj_f.orbMetadataObj,\r\n                         &Mixer_FaultInjection_DW.obj_f.eventStructObj);\r\n    Mixer_FaultInjection_DW.obj_f.isSetupComplete = true;\r\n\r\n    // Start for MATLABSystem: '<S2>/Read Parameter13'\r\n    Mixer_FaultInjection_DW.obj_h.matlabCodegenIsDeleted = false;\r\n    Mixer_FaultInjection_DW.obj_h.SampleTime =\r\n      Mixer_FaultInjection_P.ReadParameter13_SampleTime;\r\n    Mixer_FaultInjection_DW.obj_h.isInitialized = 1;\r\n    if (Mixer_FaultInjection_DW.obj_h.SampleTime == -1.0) {\r\n      tmp = 0.2;\r\n    } else {\r\n      tmp = Mixer_FaultInjection_DW.obj_h.SampleTime;\r\n    }\r\n\r\n    Mixer_FaultInjection_DW.obj_h.MW_PARAMHANDLE = MW_Init_Param\r\n      (&ParameterNameStr[0], true, tmp * 1000.0);\r\n    Mixer_FaultInjection_DW.obj_h.isSetupComplete = true;\r\n\r\n    // End of Start for MATLABSystem: '<S2>/Read Parameter13'\r\n\r\n    // Start for MATLABSystem: '<S2>/Read Parameter1'\r\n    Mixer_FaultInjection_DW.obj_o.matlabCodegenIsDeleted = false;\r\n    Mixer_FaultInjection_DW.obj_o.SampleTime =\r\n      Mixer_FaultInjection_P.ReadParameter1_SampleTime;\r\n    Mixer_FaultInjection_DW.obj_o.isInitialized = 1;\r\n    if (Mixer_FaultInjection_DW.obj_o.SampleTime == -1.0) {\r\n      tmp = 0.2;\r\n    } else {\r\n      tmp = Mixer_FaultInjection_DW.obj_o.SampleTime;\r\n    }\r\n\r\n    Mixer_FaultInjection_DW.obj_o.MW_PARAMHANDLE = MW_Init_Param\r\n      (&ParameterNameStr_0[0], true, tmp * 1000.0);\r\n    Mixer_FaultInjection_DW.obj_o.isSetupComplete = true;\r\n\r\n    // End of Start for MATLABSystem: '<S2>/Read Parameter1'\r\n\r\n    // Start for MATLABSystem: '<S2>/Read Parameter2'\r\n    Mixer_FaultInjection_DW.obj_g.matlabCodegenIsDeleted = false;\r\n    Mixer_FaultInjection_DW.obj_g.SampleTime =\r\n      Mixer_FaultInjection_P.ReadParameter2_SampleTime;\r\n    Mixer_FaultInjection_DW.obj_g.isInitialized = 1;\r\n    if (Mixer_FaultInjection_DW.obj_g.SampleTime == -1.0) {\r\n      tmp = 0.2;\r\n    } else {\r\n      tmp = Mixer_FaultInjection_DW.obj_g.SampleTime;\r\n    }\r\n\r\n    Mixer_FaultInjection_DW.obj_g.MW_PARAMHANDLE = MW_Init_Param\r\n      (&ParameterNameStr_1[0], true, tmp * 1000.0);\r\n    Mixer_FaultInjection_DW.obj_g.isSetupComplete = true;\r\n\r\n    // End of Start for MATLABSystem: '<S2>/Read Parameter2'\r\n\r\n    // Start for MATLABSystem: '<S2>/Read Parameter3'\r\n    Mixer_FaultInjection_DW.obj_e.matlabCodegenIsDeleted = false;\r\n    Mixer_FaultInjection_DW.obj_e.SampleTime =\r\n      Mixer_FaultInjection_P.ReadParameter3_SampleTime;\r\n    Mixer_FaultInjection_DW.obj_e.isInitialized = 1;\r\n    if (Mixer_FaultInjection_DW.obj_e.SampleTime == -1.0) {\r\n      tmp = 0.2;\r\n    } else {\r\n      tmp = Mixer_FaultInjection_DW.obj_e.SampleTime;\r\n    }\r\n\r\n    Mixer_FaultInjection_DW.obj_e.MW_PARAMHANDLE = MW_Init_Param\r\n      (&ParameterNameStr_2[0], true, tmp * 1000.0);\r\n    Mixer_FaultInjection_DW.obj_e.isSetupComplete = true;\r\n\r\n    // End of Start for MATLABSystem: '<S2>/Read Parameter3'\r\n\r\n    // Start for MATLABSystem: '<S2>/Read Parameter4'\r\n    Mixer_FaultInjection_DW.obj.matlabCodegenIsDeleted = false;\r\n    Mixer_FaultInjection_DW.obj.SampleTime =\r\n      Mixer_FaultInjection_P.ReadParameter4_SampleTime;\r\n    Mixer_FaultInjection_DW.obj.isInitialized = 1;\r\n    if (Mixer_FaultInjection_DW.obj.SampleTime == -1.0) {\r\n      tmp = 0.2;\r\n    } else {\r\n      tmp = Mixer_FaultInjection_DW.obj.SampleTime;\r\n    }\r\n\r\n    Mixer_FaultInjection_DW.obj.MW_PARAMHANDLE = MW_Init_Param\r\n      (&ParameterNameStr_3[0], true, tmp * 1000.0);\r\n    Mixer_FaultInjection_DW.obj.isSetupComplete = true;\r\n\r\n    // End of Start for MATLABSystem: '<S2>/Read Parameter4'\r\n\r\n    // Start for MATLABSystem: '<S2>/Read Parameter'\r\n    Mixer_FaultInjection_DW.obj_hy.matlabCodegenIsDeleted = false;\r\n    Mixer_FaultInjection_DW.obj_hy.SampleTime =\r\n      Mixer_FaultInjection_P.ReadParameter_SampleTime;\r\n    Mixer_FaultInjection_DW.obj_hy.isInitialized = 1;\r\n    if (Mixer_FaultInjection_DW.obj_hy.SampleTime == -1.0) {\r\n      tmp = 0.2;\r\n    } else {\r\n      tmp = Mixer_FaultInjection_DW.obj_hy.SampleTime;\r\n    }\r\n\r\n    Mixer_FaultInjection_DW.obj_hy.MW_PARAMHANDLE = MW_Init_Param\r\n      (&ParameterNameStr_4[0], true, tmp * 1000.0);\r\n    Mixer_FaultInjection_DW.obj_hy.isSetupComplete = true;\r\n\r\n    // End of Start for MATLABSystem: '<S2>/Read Parameter'\r\n\r\n    // Start for MATLABSystem: '<S18>/SinkBlock' incorporates:\r\n    //   BusAssignment: '<S6>/Bus Assignment'\r\n\r\n    Mixer_FaultInjection_DW.obj_hyc.matlabCodegenIsDeleted = false;\r\n    Mixer_FaultInjection_DW.obj_hyc.isInitialized = 1;\r\n    Mixer_FaultInjection_DW.obj_hyc.orbMetadataObj = ORB_ID(actuator_outputs);\r\n    uORB_write_initialize(Mixer_FaultInjection_DW.obj_hyc.orbMetadataObj,\r\n                          &Mixer_FaultInjection_DW.obj_hyc.orbAdvertiseObj,\r\n                          &Mixer_FaultInjection_B.BusAssignment_m, 1);\r\n    Mixer_FaultInjection_DW.obj_hyc.isSetupComplete = true;\r\n  }\r\n}\r\n\r\n// Model terminate function\r\nvoid Mixer_FaultInjection_terminate(void)\r\n{\r\n  // Terminate for MATLABSystem: '<S15>/SourceBlock'\r\n  if (!Mixer_FaultInjection_DW.obj_d.matlabCodegenIsDeleted) {\r\n    Mixer_FaultInjection_DW.obj_d.matlabCodegenIsDeleted = true;\r\n    if ((Mixer_FaultInjection_DW.obj_d.isInitialized == 1) &&\r\n        Mixer_FaultInjection_DW.obj_d.isSetupComplete) {\r\n      uORB_read_terminate(&Mixer_FaultInjection_DW.obj_d.eventStructObj);\r\n    }\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S15>/SourceBlock'\r\n\r\n  // Terminate for MATLABSystem: '<S4>/SourceBlock'\r\n  if (!Mixer_FaultInjection_DW.obj_f.matlabCodegenIsDeleted) {\r\n    Mixer_FaultInjection_DW.obj_f.matlabCodegenIsDeleted = true;\r\n    if ((Mixer_FaultInjection_DW.obj_f.isInitialized == 1) &&\r\n        Mixer_FaultInjection_DW.obj_f.isSetupComplete) {\r\n      uORB_read_terminate(&Mixer_FaultInjection_DW.obj_f.eventStructObj);\r\n    }\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S4>/SourceBlock'\r\n\r\n  // Terminate for MATLABSystem: '<S2>/Read Parameter13'\r\n  if (!Mixer_FaultInjection_DW.obj_h.matlabCodegenIsDeleted) {\r\n    Mixer_FaultInjection_DW.obj_h.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter13'\r\n\r\n  // Terminate for MATLABSystem: '<S2>/Read Parameter1'\r\n  if (!Mixer_FaultInjection_DW.obj_o.matlabCodegenIsDeleted) {\r\n    Mixer_FaultInjection_DW.obj_o.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter1'\r\n\r\n  // Terminate for MATLABSystem: '<S2>/Read Parameter2'\r\n  if (!Mixer_FaultInjection_DW.obj_g.matlabCodegenIsDeleted) {\r\n    Mixer_FaultInjection_DW.obj_g.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter2'\r\n\r\n  // Terminate for MATLABSystem: '<S2>/Read Parameter3'\r\n  if (!Mixer_FaultInjection_DW.obj_e.matlabCodegenIsDeleted) {\r\n    Mixer_FaultInjection_DW.obj_e.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter3'\r\n\r\n  // Terminate for MATLABSystem: '<S2>/Read Parameter4'\r\n  if (!Mixer_FaultInjection_DW.obj.matlabCodegenIsDeleted) {\r\n    Mixer_FaultInjection_DW.obj.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter4'\r\n\r\n  // Terminate for MATLABSystem: '<S2>/Read Parameter'\r\n  if (!Mixer_FaultInjection_DW.obj_hy.matlabCodegenIsDeleted) {\r\n    Mixer_FaultInjection_DW.obj_hy.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter'\r\n\r\n  // Terminate for MATLABSystem: '<S18>/SinkBlock'\r\n  if (!Mixer_FaultInjection_DW.obj_hyc.matlabCodegenIsDeleted) {\r\n    Mixer_FaultInjection_DW.obj_hyc.matlabCodegenIsDeleted = true;\r\n    if ((Mixer_FaultInjection_DW.obj_hyc.isInitialized == 1) &&\r\n        Mixer_FaultInjection_DW.obj_hyc.isSetupComplete) {\r\n      uORB_write_terminate(&Mixer_FaultInjection_DW.obj_hyc.orbAdvertiseObj);\r\n    }\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S18>/SinkBlock'\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"Mixer_FaultInjection.h","type":"header","group":"model","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: Mixer_FaultInjection.h\r\n//\r\n// Code generated for Simulink model 'Mixer_FaultInjection'.\r\n//\r\n// Model version                  : 4.142\r\n// Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n// C/C++ source code generated on : Fri Aug 23 16:15:46 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef RTW_HEADER_Mixer_FaultInjection_h_\r\n#define RTW_HEADER_Mixer_FaultInjection_h_\r\n#include <poll.h>\r\n#include <uORB/uORB.h>\r\n#include \"rtwtypes.h\"\r\n#include \"MW_Parameter.h\"\r\n#include \"MW_ParameterRead.h\"\r\n#include \"MW_uORB_Read.h\"\r\n#include \"MW_uORB_Write.h\"\r\n#include \"Mixer_FaultInjection_types.h\"\r\n#include <uORB/topics/actuator_outputs.h>\r\n#include <uORB/topics/input_rc.h>\r\n#include <uORB/topics/actuator_controls.h>\r\n#include \"calcFaultInjectedPWM.h\"\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#include <stddef.h>\r\n\r\n// Macros for accessing real-time model data structure\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n// Block signals (default storage)\r\nstruct B_Mixer_FaultInjection_T {\r\n  px4_Bus_actuator_outputs BusAssignment;// '<S6>/Bus Assignment'\r\n  px4_Bus_actuator_outputs BusAssignment_m;// '<S6>/Bus Assignment'\r\n  px4_Bus_input_rc In1;                // '<S16>/In1'\r\n  px4_Bus_input_rc b_varargout_2;\r\n  px4_Bus_actuator_controls In1_m;     // '<S14>/In1'\r\n  px4_Bus_actuator_controls b_varargout_2_c;\r\n  real_T Switch;                       // '<S1>/Switch'\r\n  real_T Switch1;                      // '<S1>/Switch1'\r\n};\r\n\r\n// Block states (default storage) for system '<Root>'\r\nstruct DW_Mixer_FaultInjection_T {\r\n  px4_internal_block_ParameterUpdate_Mixer_FaultInjection_T obj;// '<S2>/Read Parameter4' \r\n  px4_internal_block_ParameterUpdate_Mixer_FaultInjection_T obj_e;// '<S2>/Read Parameter3' \r\n  px4_internal_block_ParameterUpdate_Mixer_FaultInjection_T obj_g;// '<S2>/Read Parameter2' \r\n  px4_internal_block_ParameterUpdate_Mixer_FaultInjection_T obj_h;// '<S2>/Read Parameter13' \r\n  px4_internal_block_ParameterUpdate_Mixer_FaultInjection_T obj_o;// '<S2>/Read Parameter1' \r\n  px4_internal_block_ParameterUpdate_Mixer_FaultInjection_T obj_hy;// '<S2>/Read Parameter' \r\n  px4_internal_block_Subscriber_Mixer_FaultInjection_T obj_d;// '<S15>/SourceBlock' \r\n  px4_internal_block_Subscriber_Mixer_FaultInjection_T obj_f;// '<S4>/SourceBlock' \r\n  px4_internal_block_Publisher_Mixer_FaultInjection_T obj_hyc;// '<S18>/SinkBlock' \r\n};\r\n\r\n// Parameters (default storage)\r\nstruct P_Mixer_FaultInjection_T_ {\r\n  real_T IDLEPWM;                      // Variable: IDLEPWM\r\n                                          //  Referenced by:\r\n                                          //    '<S8>/Constant'\r\n                                          //    '<S8>/IDLE PWM'\r\n                                          //    '<S9>/Constant'\r\n                                          //    '<S9>/IDLE PWM'\r\n                                          //    '<S10>/Constant'\r\n                                          //    '<S10>/IDLE PWM'\r\n                                          //    '<S11>/Constant'\r\n                                          //    '<S11>/IDLE PWM'\r\n                                          //    '<S12>/Constant'\r\n                                          //    '<S12>/IDLE PWM'\r\n                                          //    '<S13>/Constant'\r\n                                          //    '<S13>/IDLE PWM'\r\n\r\n  real_T CompareToConstant_const;     // Mask Parameter: CompareToConstant_const\r\n                                         //  Referenced by: '<S7>/Constant'\r\n\r\n  px4_Bus_actuator_outputs Constant_Value;// Computed Parameter: Constant_Value\r\n                                             //  Referenced by: '<S17>/Constant'\r\n\r\n  px4_Bus_input_rc Out1_Y0;            // Computed Parameter: Out1_Y0\r\n                                          //  Referenced by: '<S16>/Out1'\r\n\r\n  px4_Bus_input_rc Constant_Value_l;   // Computed Parameter: Constant_Value_l\r\n                                          //  Referenced by: '<S15>/Constant'\r\n\r\n  px4_Bus_actuator_controls Out1_Y0_c; // Computed Parameter: Out1_Y0_c\r\n                                          //  Referenced by: '<S14>/Out1'\r\n\r\n  px4_Bus_actuator_controls Constant_Value_c;// Computed Parameter: Constant_Value_c\r\n                                                //  Referenced by: '<S4>/Constant'\r\n\r\n  real_T Constant1_Value;              // Expression: 1000\r\n                                          //  Referenced by: '<S1>/Constant1'\r\n\r\n  real_T Constant2_Value;              // Expression: 1000\r\n                                          //  Referenced by: '<S1>/Constant2'\r\n\r\n  real_T Constant3_Value;              // Expression: 1000\r\n                                          //  Referenced by: '<S1>/Constant3'\r\n\r\n  real_T Constant4_Value;              // Expression: 1000\r\n                                          //  Referenced by: '<S1>/Constant4'\r\n\r\n  real_T Constant5_Value;              // Expression: 1000\r\n                                          //  Referenced by: '<S1>/Constant5'\r\n\r\n  real_T Constant_Value_o;             // Expression: 1000\r\n                                          //  Referenced by: '<S1>/Constant'\r\n\r\n  real_T ReadParameter_SampleTime;     // Expression: -1\r\n                                          //  Referenced by: '<S2>/Read Parameter'\r\n\r\n  real_T ReadParameter1_SampleTime;    // Expression: -1\r\n                                          //  Referenced by: '<S2>/Read Parameter1'\r\n\r\n  real_T ReadParameter13_SampleTime;   // Expression: -1\r\n                                          //  Referenced by: '<S2>/Read Parameter13'\r\n\r\n  real_T ReadParameter2_SampleTime;    // Expression: -1\r\n                                          //  Referenced by: '<S2>/Read Parameter2'\r\n\r\n  real_T ReadParameter3_SampleTime;    // Expression: -1\r\n                                          //  Referenced by: '<S2>/Read Parameter3'\r\n\r\n  real_T ReadParameter4_SampleTime;    // Expression: -1\r\n                                          //  Referenced by: '<S2>/Read Parameter4'\r\n\r\n  real_T Constant_Value_g;             // Expression: 0\r\n                                          //  Referenced by: '<S6>/Constant'\r\n\r\n  real_T Constant17_Value;             // Expression: 6\r\n                                          //  Referenced by: '<S6>/Constant17'\r\n\r\n  P_calcFaultInjectedPWM_T CalcFaultInjectedPWM;// '<S2>/CalcFaultInjectedPWM'\r\n  P_calcFaultInjectedPWM_T CalcFaultInjectedPWM5;// '<S2>/CalcFaultInjectedPWM5' \r\n  P_calcFaultInjectedPWM_T CalcFaultInjectedPWM4;// '<S2>/CalcFaultInjectedPWM4' \r\n  P_calcFaultInjectedPWM_T CalcFaultInjectedPWM3;// '<S2>/CalcFaultInjectedPWM3' \r\n  P_calcFaultInjectedPWM_T CalcFaultInjectedPWM2;// '<S2>/CalcFaultInjectedPWM2' \r\n  P_calcFaultInjectedPWM_T CalcFaultInjectedPWM1;// '<S2>/CalcFaultInjectedPWM1' \r\n};\r\n\r\n// Real-time Model Data Structure\r\nstruct tag_RTM_Mixer_FaultInjection_T {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n// Block parameters (default storage)\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern P_Mixer_FaultInjection_T Mixer_FaultInjection_P;\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n\r\n// Block signals (default storage)\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern struct B_Mixer_FaultInjection_T Mixer_FaultInjection_B;\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n\r\n// Block states (default storage)\r\nextern struct DW_Mixer_FaultInjection_T Mixer_FaultInjection_DW;\r\n\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  // Model entry point functions\r\n  extern void Mixer_FaultInjection_initialize(void);\r\n  extern void Mixer_FaultInjection_step(void);\r\n  extern void Mixer_FaultInjection_terminate(void);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n\r\n// Real-time Model object\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern RT_MODEL_Mixer_FaultInjection_T *const Mixer_FaultInjection_M;\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n//-\r\n//  These blocks were eliminated from the model due to optimizations:\r\n//\r\n//  Block '<S4>/NOT' : Unused code path elimination\r\n//  Block '<S5>/Bitwise Operator' : Unused code path elimination\r\n//  Block '<S5>/Data Type Conversion' : Unused code path elimination\r\n//  Block '<S5>/Data Type Conversion1' : Unused code path elimination\r\n//  Block '<S5>/Data Type Conversion2' : Unused code path elimination\r\n//  Block '<S5>/Gain' : Unused code path elimination\r\n//  Block '<S5>/Gain1' : Unused code path elimination\r\n//  Block '<S15>/NOT' : Unused code path elimination\r\n\r\n\r\n//-\r\n//  The generated code includes comments that allow you to trace directly\r\n//  back to the appropriate location in the model.  The basic format\r\n//  is <system>/block_name, where system is the system number (uniquely\r\n//  assigned by Simulink) and block_name is the name of the block.\r\n//\r\n//  Use the MATLAB hilite_system command to trace the generated code back\r\n//  to the model.  For example,\r\n//\r\n//  hilite_system('<S3>')    - opens system 3\r\n//  hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n//\r\n//  Here is the system hierarchy for this model\r\n//\r\n//  '<Root>' : 'Mixer_FaultInjection'\r\n//  '<S1>'   : 'Mixer_FaultInjection/Emergency Kill'\r\n//  '<S2>'   : 'Mixer_FaultInjection/Fault_Injection_SIL'\r\n//  '<S3>'   : 'Mixer_FaultInjection/MATLAB Function'\r\n//  '<S4>'   : 'Mixer_FaultInjection/PX4 uORB Read'\r\n//  '<S5>'   : 'Mixer_FaultInjection/Radio Control Transmitter'\r\n//  '<S6>'   : 'Mixer_FaultInjection/Subsystem'\r\n//  '<S7>'   : 'Mixer_FaultInjection/Emergency Kill/Compare To Constant'\r\n//  '<S8>'   : 'Mixer_FaultInjection/Fault_Injection_SIL/CalcFaultInjectedPWM'\r\n//  '<S9>'   : 'Mixer_FaultInjection/Fault_Injection_SIL/CalcFaultInjectedPWM1'\r\n//  '<S10>'  : 'Mixer_FaultInjection/Fault_Injection_SIL/CalcFaultInjectedPWM2'\r\n//  '<S11>'  : 'Mixer_FaultInjection/Fault_Injection_SIL/CalcFaultInjectedPWM3'\r\n//  '<S12>'  : 'Mixer_FaultInjection/Fault_Injection_SIL/CalcFaultInjectedPWM4'\r\n//  '<S13>'  : 'Mixer_FaultInjection/Fault_Injection_SIL/CalcFaultInjectedPWM5'\r\n//  '<S14>'  : 'Mixer_FaultInjection/PX4 uORB Read/Enabled Subsystem'\r\n//  '<S15>'  : 'Mixer_FaultInjection/Radio Control Transmitter/PX4 uORB Read'\r\n//  '<S16>'  : 'Mixer_FaultInjection/Radio Control Transmitter/PX4 uORB Read/Enabled Subsystem'\r\n//  '<S17>'  : 'Mixer_FaultInjection/Subsystem/PX4 uORB Message'\r\n//  '<S18>'  : 'Mixer_FaultInjection/Subsystem/PX4 uORB Write'\r\n\r\n#endif                                 // RTW_HEADER_Mixer_FaultInjection_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"Mixer_FaultInjection_private.h","type":"header","group":"model","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: Mixer_FaultInjection_private.h\r\n//\r\n// Code generated for Simulink model 'Mixer_FaultInjection'.\r\n//\r\n// Model version                  : 4.142\r\n// Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n// C/C++ source code generated on : Fri Aug 23 16:15:46 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef RTW_HEADER_Mixer_FaultInjection_private_h_\r\n#define RTW_HEADER_Mixer_FaultInjection_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"Mixer_FaultInjection_types.h\"\r\n#ifndef PORTABLE_WORDSIZES\r\n#ifndef UCHAR_MAX\r\n#include <limits.h>\r\n#endif\r\n\r\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\r\n#error Code was generated for compiler with different sized uchar/char. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized ushort/short. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( UINT_MAX != (0xFFFFFFFFU) ) || ( INT_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized uint/int. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( ULONG_MAX != (0xFFFFFFFFU) ) || ( LONG_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized ulong/long. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n// Skipping ulong_long/long_long check: insufficient preprocessor integer range. \r\n#endif                                 // PORTABLE_WORDSIZES\r\n#endif                            // RTW_HEADER_Mixer_FaultInjection_private_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"Mixer_FaultInjection_types.h","type":"header","group":"model","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: Mixer_FaultInjection_types.h\r\n//\r\n// Code generated for Simulink model 'Mixer_FaultInjection'.\r\n//\r\n// Model version                  : 4.142\r\n// Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n// C/C++ source code generated on : Fri Aug 23 16:15:46 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef RTW_HEADER_Mixer_FaultInjection_types_h_\r\n#define RTW_HEADER_Mixer_FaultInjection_types_h_\r\n#include \"rtwtypes.h\"\r\n#include \"MW_Parameter.h\"\r\n#include <uORB/topics/actuator_controls.h>\r\n#include <uORB/topics/input_rc.h>\r\n#include <uORB/topics/actuator_outputs.h>\r\n\r\n// Custom Type definition for MATLABSystem: '<S2>/Read Parameter4'\r\n#include \"MW_Parameter.h\"\r\n#ifndef struct_px4_internal_block_ParameterUpdate_Mixer_FaultInjection_T\r\n#define struct_px4_internal_block_ParameterUpdate_Mixer_FaultInjection_T\r\n\r\nstruct px4_internal_block_ParameterUpdate_Mixer_FaultInjection_T\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  real_T SampleTime;\r\n  MW_Param_Handle MW_PARAMHANDLE;\r\n};\r\n\r\n#endif      // struct_px4_internal_block_ParameterUpdate_Mixer_FaultInjection_T\r\n\r\n#ifndef struct_b_px4_internal_block_SampleTimeImpl_Mixer_FaultInjection_T\r\n#define struct_b_px4_internal_block_SampleTimeImpl_Mixer_FaultInjection_T\r\n\r\nstruct b_px4_internal_block_SampleTimeImpl_Mixer_FaultInjection_T\r\n{\r\n  int32_T __dummy;\r\n};\r\n\r\n#endif     // struct_b_px4_internal_block_SampleTimeImpl_Mixer_FaultInjection_T\r\n\r\n#ifndef struct_px4_internal_block_Subscriber_Mixer_FaultInjection_T\r\n#define struct_px4_internal_block_Subscriber_Mixer_FaultInjection_T\r\n\r\nstruct px4_internal_block_Subscriber_Mixer_FaultInjection_T\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  b_px4_internal_block_SampleTimeImpl_Mixer_FaultInjection_T SampleTimeHandler;\r\n  pollfd_t eventStructObj;\r\n  orb_metadata_t * orbMetadataObj;\r\n};\r\n\r\n#endif           // struct_px4_internal_block_Subscriber_Mixer_FaultInjection_T\r\n\r\n#ifndef struct_px4_internal_block_Publisher_Mixer_FaultInjection_T\r\n#define struct_px4_internal_block_Publisher_Mixer_FaultInjection_T\r\n\r\nstruct px4_internal_block_Publisher_Mixer_FaultInjection_T\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  orb_advert_t orbAdvertiseObj;\r\n  orb_metadata_t * orbMetadataObj;\r\n};\r\n\r\n#endif            // struct_px4_internal_block_Publisher_Mixer_FaultInjection_T\r\n\r\n// Parameters for system: '<S2>/CalcFaultInjectedPWM1'\r\ntypedef struct P_calcFaultInjectedPWM_T_ P_calcFaultInjectedPWM_T;\r\n\r\n// Parameters (default storage)\r\ntypedef struct P_Mixer_FaultInjection_T_ P_Mixer_FaultInjection_T;\r\n\r\n// Forward declaration for rtModel\r\ntypedef struct tag_RTM_Mixer_FaultInjection_T RT_MODEL_Mixer_FaultInjection_T;\r\n\r\n#endif                              // RTW_HEADER_Mixer_FaultInjection_types_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"calcFaultInjectedPWM.cpp","type":"source","group":"subsystem","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: calcFaultInjectedPWM.cpp\r\n//\r\n// Code generated for Simulink model 'Mixer_FaultInjection'.\r\n//\r\n// Model version                  : 4.142\r\n// Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n// C/C++ source code generated on : Fri Aug 23 16:15:46 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#include \"rtwtypes.h\"\r\n#include \"calcFaultInjectedPWM.h\"\r\n#include \"Mixer_FaultInjection.h\"\r\n#include \"Mixer_FaultInjection_private.h\"\r\n\r\n//\r\n// Output and update for atomic system:\r\n//    '<S2>/CalcFaultInjectedPWM1'\r\n//    '<S2>/CalcFaultInjectedPWM2'\r\n//    '<S2>/CalcFaultInjectedPWM3'\r\n//    '<S2>/CalcFaultInjectedPWM4'\r\n//    '<S2>/CalcFaultInjectedPWM5'\r\n//    '<S2>/CalcFaultInjectedPWM'\r\n//\r\nvoid calcFaultInjectedPWM(real32_T rtu_PWMIn, real_T rtu_ActuatorStatus, real_T *\r\n  rty_PWMOut, P_calcFaultInjectedPWM_T *localP)\r\n{\r\n  real_T u0;\r\n\r\n  // Gain: '<S9>/Gain'\r\n  u0 = localP->Gain_Gain * rtu_ActuatorStatus;\r\n\r\n  // Saturate: '<S9>/Saturation1'\r\n  if (u0 > localP->Saturation1_UpperSat) {\r\n    u0 = localP->Saturation1_UpperSat;\r\n  } else if (u0 < localP->Saturation1_LowerSat) {\r\n    u0 = localP->Saturation1_LowerSat;\r\n  }\r\n\r\n  // Sum: '<S9>/Sum' incorporates:\r\n  //   Constant: '<S9>/Constant'\r\n  //   Constant: '<S9>/IDLE PWM'\r\n  //   Product: '<S9>/Product'\r\n  //   Saturate: '<S9>/Saturation1'\r\n  //   Sum: '<S9>/Add'\r\n\r\n  *rty_PWMOut = (rtu_PWMIn - Mixer_FaultInjection_P.IDLEPWM) * u0 +\r\n    Mixer_FaultInjection_P.IDLEPWM;\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"calcFaultInjectedPWM.h","type":"header","group":"subsystem","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: calcFaultInjectedPWM.h\r\n//\r\n// Code generated for Simulink model 'Mixer_FaultInjection'.\r\n//\r\n// Model version                  : 4.142\r\n// Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n// C/C++ source code generated on : Fri Aug 23 16:15:46 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef RTW_HEADER_calcFaultInjectedPWM_h_\r\n#define RTW_HEADER_calcFaultInjectedPWM_h_\r\n#include <poll.h>\r\n#include <uORB/uORB.h>\r\n#include \"rtwtypes.h\"\r\n#include \"MW_Parameter.h\"\r\n#include \"MW_ParameterRead.h\"\r\n#include \"MW_uORB_Read.h\"\r\n#include \"MW_uORB_Write.h\"\r\n#include \"Mixer_FaultInjection_types.h\"\r\n\r\n// Parameters for system: '<S2>/CalcFaultInjectedPWM1'\r\nstruct P_calcFaultInjectedPWM_T_ {\r\n  real_T Gain_Gain;                    // Expression: 0.01\r\n                                          //  Referenced by: '<S9>/Gain'\r\n\r\n  real_T Saturation1_UpperSat;         // Expression: 1\r\n                                          //  Referenced by: '<S9>/Saturation1'\r\n\r\n  real_T Saturation1_LowerSat;         // Expression: 0\r\n                                          //  Referenced by: '<S9>/Saturation1'\r\n\r\n};\r\n\r\nextern void calcFaultInjectedPWM(real32_T rtu_PWMIn, real_T rtu_ActuatorStatus,\r\n  real_T *rty_PWMOut, P_calcFaultInjectedPWM_T *localP);\r\n\r\n#endif                                 // RTW_HEADER_calcFaultInjectedPWM_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"Mixer_FaultInjection_data.cpp","type":"source","group":"data","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Data files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: Mixer_FaultInjection_data.cpp\r\n//\r\n// Code generated for Simulink model 'Mixer_FaultInjection'.\r\n//\r\n// Model version                  : 4.142\r\n// Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n// C/C++ source code generated on : Fri Aug 23 16:15:46 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#include \"Mixer_FaultInjection.h\"\r\n\r\n// Block parameters (default storage)\r\nP_Mixer_FaultInjection_T Mixer_FaultInjection_P = {\r\n  // Variable: IDLEPWM\r\n  //  Referenced by:\r\n  //    '<S8>/Constant'\r\n  //    '<S8>/IDLE PWM'\r\n  //    '<S9>/Constant'\r\n  //    '<S9>/IDLE PWM'\r\n  //    '<S10>/Constant'\r\n  //    '<S10>/IDLE PWM'\r\n  //    '<S11>/Constant'\r\n  //    '<S11>/IDLE PWM'\r\n  //    '<S12>/Constant'\r\n  //    '<S12>/IDLE PWM'\r\n  //    '<S13>/Constant'\r\n  //    '<S13>/IDLE PWM'\r\n\r\n  900.0,\r\n\r\n  // Mask Parameter: CompareToConstant_const\r\n  //  Referenced by: '<S7>/Constant'\r\n\r\n  1800.0,\r\n\r\n  // Computed Parameter: Constant_Value\r\n  //  Referenced by: '<S17>/Constant'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    0U,                                // noutputs\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,\r\n      0.0F, 0.0F, 0.0F, 0.0F }\r\n    ,                                  // output\r\n\r\n    {\r\n      0U, 0U, 0U, 0U }\r\n    // _padding0\r\n  },\r\n\r\n  // Computed Parameter: Out1_Y0\r\n  //  Referenced by: '<S16>/Out1'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    (0ULL),                            // timestamp_last_signal\r\n    0,                                 // rssi\r\n    0U,                                // rc_lost_frame_count\r\n    0U,                                // rc_total_frame_count\r\n    0U,                                // rc_ppm_frame_length\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U }\r\n    ,                                  // values\r\n    0U,                                // channel_count\r\n    false,                             // rc_failsafe\r\n    false,                             // rc_lost\r\n    0U,                                // input_source\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U }\r\n    // _padding0\r\n  },\r\n\r\n  // Computed Parameter: Constant_Value_l\r\n  //  Referenced by: '<S15>/Constant'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    (0ULL),                            // timestamp_last_signal\r\n    0,                                 // rssi\r\n    0U,                                // rc_lost_frame_count\r\n    0U,                                // rc_total_frame_count\r\n    0U,                                // rc_ppm_frame_length\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U }\r\n    ,                                  // values\r\n    0U,                                // channel_count\r\n    false,                             // rc_failsafe\r\n    false,                             // rc_lost\r\n    0U,                                // input_source\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U }\r\n    // _padding0\r\n  },\r\n\r\n  // Computed Parameter: Out1_Y0_c\r\n  //  Referenced by: '<S14>/Out1'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    (0ULL),                            // timestamp_sample\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F }\r\n    // control\r\n  },\r\n\r\n  // Computed Parameter: Constant_Value_c\r\n  //  Referenced by: '<S4>/Constant'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    (0ULL),                            // timestamp_sample\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F }\r\n    // control\r\n  },\r\n\r\n  // Expression: 1000\r\n  //  Referenced by: '<S1>/Constant1'\r\n\r\n  1000.0,\r\n\r\n  // Expression: 1000\r\n  //  Referenced by: '<S1>/Constant2'\r\n\r\n  1000.0,\r\n\r\n  // Expression: 1000\r\n  //  Referenced by: '<S1>/Constant3'\r\n\r\n  1000.0,\r\n\r\n  // Expression: 1000\r\n  //  Referenced by: '<S1>/Constant4'\r\n\r\n  1000.0,\r\n\r\n  // Expression: 1000\r\n  //  Referenced by: '<S1>/Constant5'\r\n\r\n  1000.0,\r\n\r\n  // Expression: 1000\r\n  //  Referenced by: '<S1>/Constant'\r\n\r\n  1000.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S2>/Read Parameter'\r\n\r\n  -1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S2>/Read Parameter1'\r\n\r\n  -1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S2>/Read Parameter13'\r\n\r\n  -1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S2>/Read Parameter2'\r\n\r\n  -1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S2>/Read Parameter3'\r\n\r\n  -1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S2>/Read Parameter4'\r\n\r\n  -1.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S6>/Constant'\r\n\r\n  0.0,\r\n\r\n  // Expression: 6\r\n  //  Referenced by: '<S6>/Constant17'\r\n\r\n  6.0,\r\n\r\n  // Start of '<S2>/CalcFaultInjectedPWM'\r\n  {\r\n    // Expression: 0.01\r\n    //  Referenced by: '<S8>/Gain'\r\n\r\n    0.01,\r\n\r\n    // Expression: 1\r\n    //  Referenced by: '<S8>/Saturation1'\r\n\r\n    1.0,\r\n\r\n    // Expression: 0\r\n    //  Referenced by: '<S8>/Saturation1'\r\n\r\n    0.0\r\n  }\r\n  ,\r\n\r\n  // End of '<S2>/CalcFaultInjectedPWM'\r\n\r\n  // Start of '<S2>/CalcFaultInjectedPWM5'\r\n  {\r\n    // Expression: 0.01\r\n    //  Referenced by: '<S13>/Gain'\r\n\r\n    0.01,\r\n\r\n    // Expression: 1\r\n    //  Referenced by: '<S13>/Saturation1'\r\n\r\n    1.0,\r\n\r\n    // Expression: 0\r\n    //  Referenced by: '<S13>/Saturation1'\r\n\r\n    0.0\r\n  }\r\n  ,\r\n\r\n  // End of '<S2>/CalcFaultInjectedPWM5'\r\n\r\n  // Start of '<S2>/CalcFaultInjectedPWM4'\r\n  {\r\n    // Expression: 0.01\r\n    //  Referenced by: '<S12>/Gain'\r\n\r\n    0.01,\r\n\r\n    // Expression: 1\r\n    //  Referenced by: '<S12>/Saturation1'\r\n\r\n    1.0,\r\n\r\n    // Expression: 0\r\n    //  Referenced by: '<S12>/Saturation1'\r\n\r\n    0.0\r\n  }\r\n  ,\r\n\r\n  // End of '<S2>/CalcFaultInjectedPWM4'\r\n\r\n  // Start of '<S2>/CalcFaultInjectedPWM3'\r\n  {\r\n    // Expression: 0.01\r\n    //  Referenced by: '<S11>/Gain'\r\n\r\n    0.01,\r\n\r\n    // Expression: 1\r\n    //  Referenced by: '<S11>/Saturation1'\r\n\r\n    1.0,\r\n\r\n    // Expression: 0\r\n    //  Referenced by: '<S11>/Saturation1'\r\n\r\n    0.0\r\n  }\r\n  ,\r\n\r\n  // End of '<S2>/CalcFaultInjectedPWM3'\r\n\r\n  // Start of '<S2>/CalcFaultInjectedPWM2'\r\n  {\r\n    // Expression: 0.01\r\n    //  Referenced by: '<S10>/Gain'\r\n\r\n    0.01,\r\n\r\n    // Expression: 1\r\n    //  Referenced by: '<S10>/Saturation1'\r\n\r\n    1.0,\r\n\r\n    // Expression: 0\r\n    //  Referenced by: '<S10>/Saturation1'\r\n\r\n    0.0\r\n  }\r\n  ,\r\n\r\n  // End of '<S2>/CalcFaultInjectedPWM2'\r\n\r\n  // Start of '<S2>/CalcFaultInjectedPWM1'\r\n  {\r\n    // Expression: 0.01\r\n    //  Referenced by: '<S9>/Gain'\r\n\r\n    0.01,\r\n\r\n    // Expression: 1\r\n    //  Referenced by: '<S9>/Saturation1'\r\n\r\n    1.0,\r\n\r\n    // Expression: 0\r\n    //  Referenced by: '<S9>/Saturation1'\r\n\r\n    0.0\r\n  }\r\n  // End of '<S2>/CalcFaultInjectedPWM1'\r\n};\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rtGetInf.cpp","type":"source","group":"utility","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rtGetInf.cpp\r\n//\r\n// Code generated for Simulink model 'Mixer_FaultInjection'.\r\n//\r\n// Model version                  : 4.142\r\n// Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n// C/C++ source code generated on : Fri Aug 23 16:15:46 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n\r\n#include \"rtwtypes.h\"\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rtGetInf.h\"\r\n\r\n}\r\n\r\n#include <stddef.h>\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#define NumBitsPerChar                 8U\r\n\r\nextern \"C\"\r\n{\r\n  //\r\n  // Initialize rtInf needed by the generated code.\r\n  // Inf is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  real_T rtGetInf(void)\r\n  {\r\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n    real_T inf = 0.0;\r\n    if (bitsPerReal == 32U) {\r\n      inf = rtGetInfF();\r\n    } else {\r\n      uint16_T one = 1U;\r\n      enum {\r\n        LittleEndian,\r\n        BigEndian\r\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n      switch (machByteOrder) {\r\n       case LittleEndian:\r\n        {\r\n          union {\r\n            LittleEndianIEEEDouble bitVal;\r\n            real_T fltVal;\r\n          } tmpVal;\r\n\r\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n          tmpVal.bitVal.words.wordL = 0x00000000U;\r\n          inf = tmpVal.fltVal;\r\n          break;\r\n        }\r\n\r\n       case BigEndian:\r\n        {\r\n          union {\r\n            BigEndianIEEEDouble bitVal;\r\n            real_T fltVal;\r\n          } tmpVal;\r\n\r\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n          tmpVal.bitVal.words.wordL = 0x00000000U;\r\n          inf = tmpVal.fltVal;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return inf;\r\n  }\r\n\r\n  //\r\n  // Initialize rtInfF needed by the generated code.\r\n  // Inf is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  real32_T rtGetInfF(void)\r\n  {\r\n    IEEESingle infF;\r\n    infF.wordL.wordLuint = 0x7F800000U;\r\n    return infF.wordL.wordLreal;\r\n  }\r\n\r\n  //\r\n  // Initialize rtMinusInf needed by the generated code.\r\n  // Inf is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  real_T rtGetMinusInf(void)\r\n  {\r\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n    real_T minf = 0.0;\r\n    if (bitsPerReal == 32U) {\r\n      minf = rtGetMinusInfF();\r\n    } else {\r\n      uint16_T one = 1U;\r\n      enum {\r\n        LittleEndian,\r\n        BigEndian\r\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n      switch (machByteOrder) {\r\n       case LittleEndian:\r\n        {\r\n          union {\r\n            LittleEndianIEEEDouble bitVal;\r\n            real_T fltVal;\r\n          } tmpVal;\r\n\r\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n          tmpVal.bitVal.words.wordL = 0x00000000U;\r\n          minf = tmpVal.fltVal;\r\n          break;\r\n        }\r\n\r\n       case BigEndian:\r\n        {\r\n          union {\r\n            BigEndianIEEEDouble bitVal;\r\n            real_T fltVal;\r\n          } tmpVal;\r\n\r\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n          tmpVal.bitVal.words.wordL = 0x00000000U;\r\n          minf = tmpVal.fltVal;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return minf;\r\n  }\r\n\r\n  //\r\n  // Initialize rtMinusInfF needed by the generated code.\r\n  // Inf is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  real32_T rtGetMinusInfF(void)\r\n  {\r\n    IEEESingle minfF;\r\n    minfF.wordL.wordLuint = 0xFF800000U;\r\n    return minfF.wordL.wordLreal;\r\n  }\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rtGetInf.h\r\n//\r\n// Code generated for Simulink model 'Mixer_FaultInjection'.\r\n//\r\n// Model version                  : 4.142\r\n// Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n// C/C++ source code generated on : Fri Aug 23 16:15:46 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#include \"rtwtypes.h\"\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern real_T rtGetInf(void);\r\n  extern real32_T rtGetInfF(void);\r\n  extern real_T rtGetMinusInf(void);\r\n  extern real32_T rtGetMinusInfF(void);\r\n\r\n#ifdef __cplusplus\r\n\r\n}                                      // extern \"C\"\r\n\r\n#endif\r\n#endif                                 // RTW_HEADER_rtGetInf_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rtGetNaN.cpp","type":"source","group":"utility","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rtGetNaN.cpp\r\n//\r\n// Code generated for Simulink model 'Mixer_FaultInjection'.\r\n//\r\n// Model version                  : 4.142\r\n// Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n// C/C++ source code generated on : Fri Aug 23 16:15:46 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n\r\n#include \"rtwtypes.h\"\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rtGetNaN.h\"\r\n\r\n}\r\n\r\n#include <stddef.h>\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#define NumBitsPerChar                 8U\r\n\r\nextern \"C\"\r\n{\r\n  //\r\n  // Initialize rtNaN needed by the generated code.\r\n  // NaN is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  real_T rtGetNaN(void)\r\n  {\r\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n    real_T nan = 0.0;\r\n    if (bitsPerReal == 32U) {\r\n      nan = rtGetNaNF();\r\n    } else {\r\n      uint16_T one = 1U;\r\n      enum {\r\n        LittleEndian,\r\n        BigEndian\r\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n      switch (machByteOrder) {\r\n       case LittleEndian:\r\n        {\r\n          union {\r\n            LittleEndianIEEEDouble bitVal;\r\n            real_T fltVal;\r\n          } tmpVal;\r\n\r\n          tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n          tmpVal.bitVal.words.wordL = 0x00000000U;\r\n          nan = tmpVal.fltVal;\r\n          break;\r\n        }\r\n\r\n       case BigEndian:\r\n        {\r\n          union {\r\n            BigEndianIEEEDouble bitVal;\r\n            real_T fltVal;\r\n          } tmpVal;\r\n\r\n          tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\r\n          tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\r\n          nan = tmpVal.fltVal;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return nan;\r\n  }\r\n\r\n  //\r\n  // Initialize rtNaNF needed by the generated code.\r\n  // NaN is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  real32_T rtGetNaNF(void)\r\n  {\r\n    IEEESingle nanF = { { 0.0F } };\r\n\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        nanF.wordL.wordLuint = 0xFFC00000U;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        nanF.wordL.wordLuint = 0x7FFFFFFFU;\r\n        break;\r\n      }\r\n    }\r\n\r\n    return nanF.wordL.wordLreal;\r\n  }\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rtGetNaN.h\r\n//\r\n// Code generated for Simulink model 'Mixer_FaultInjection'.\r\n//\r\n// Model version                  : 4.142\r\n// Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n// C/C++ source code generated on : Fri Aug 23 16:15:46 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#include \"rtwtypes.h\"\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern real_T rtGetNaN(void);\r\n  extern real32_T rtGetNaNF(void);\r\n\r\n#ifdef __cplusplus\r\n\r\n}                                      // extern \"C\"\r\n\r\n#endif\r\n#endif                                 // RTW_HEADER_rtGetNaN_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rt_nonfinite.cpp","type":"source","group":"utility","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rt_nonfinite.cpp\r\n//\r\n// Code generated for Simulink model 'Mixer_FaultInjection'.\r\n//\r\n// Model version                  : 4.142\r\n// Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n// C/C++ source code generated on : Fri Aug 23 16:15:46 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rtGetNaN.h\"\r\n\r\n}\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rtGetInf.h\"\r\n\r\n}\r\n\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#define NumBitsPerChar                 8U\r\n\r\nextern \"C\"\r\n{\r\n  real_T rtInf;\r\n  real_T rtMinusInf;\r\n  real_T rtNaN;\r\n  real32_T rtInfF;\r\n  real32_T rtMinusInfF;\r\n  real32_T rtNaNF;\r\n}\r\n\r\nextern \"C\"\r\n{\r\n  //\r\n  // Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n  // generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  void rt_InitInfAndNaN(size_t realSize)\r\n  {\r\n    (void) (realSize);\r\n    rtNaN = rtGetNaN();\r\n    rtNaNF = rtGetNaNF();\r\n    rtInf = rtGetInf();\r\n    rtInfF = rtGetInfF();\r\n    rtMinusInf = rtGetMinusInf();\r\n    rtMinusInfF = rtGetMinusInfF();\r\n  }\r\n\r\n  // Test if value is infinite\r\n  boolean_T rtIsInf(real_T value)\r\n  {\r\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n  }\r\n\r\n  // Test if single-precision value is infinite\r\n  boolean_T rtIsInfF(real32_T value)\r\n  {\r\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n  }\r\n\r\n  // Test if value is not a number\r\n  boolean_T rtIsNaN(real_T value)\r\n  {\r\n    boolean_T result = (boolean_T) 0;\r\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n    if (bitsPerReal == 32U) {\r\n      result = rtIsNaNF((real32_T)value);\r\n    } else {\r\n      uint16_T one = 1U;\r\n      enum {\r\n        LittleEndian,\r\n        BigEndian\r\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n      switch (machByteOrder) {\r\n       case LittleEndian:\r\n        {\r\n          union {\r\n            LittleEndianIEEEDouble bitVal;\r\n            real_T fltVal;\r\n          } tmpVal;\r\n\r\n          tmpVal.fltVal = value;\r\n          result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\r\n                               0x7FF00000 &&\r\n                               ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                                (tmpVal.bitVal.words.wordL != 0) ));\r\n          break;\r\n        }\r\n\r\n       case BigEndian:\r\n        {\r\n          union {\r\n            BigEndianIEEEDouble bitVal;\r\n            real_T fltVal;\r\n          } tmpVal;\r\n\r\n          tmpVal.fltVal = value;\r\n          result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\r\n                               0x7FF00000 &&\r\n                               ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                                (tmpVal.bitVal.words.wordL != 0) ));\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // Test if single-precision value is not a number\r\n  boolean_T rtIsNaNF(real32_T value)\r\n  {\r\n    IEEESingle tmp;\r\n    tmp.wordL.wordLreal = value;\r\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n  }\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rt_nonfinite.h\r\n//\r\n// Code generated for Simulink model 'Mixer_FaultInjection'.\r\n//\r\n// Model version                  : 4.142\r\n// Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n// C/C++ source code generated on : Fri Aug 23 16:15:46 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#define NOT_USING_NONFINITE_LITERALS   1\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern real_T rtInf;\r\n  extern real_T rtMinusInf;\r\n  extern real_T rtNaN;\r\n  extern real32_T rtInfF;\r\n  extern real32_T rtMinusInfF;\r\n  extern real32_T rtNaNF;\r\n  extern void rt_InitInfAndNaN(size_t realSize);\r\n  extern boolean_T rtIsInf(real_T value);\r\n  extern boolean_T rtIsInfF(real32_T value);\r\n  extern boolean_T rtIsNaN(real_T value);\r\n  extern boolean_T rtIsNaNF(real32_T value);\r\n  struct BigEndianIEEEDouble {\r\n    struct {\r\n      uint32_T wordH;\r\n      uint32_T wordL;\r\n    } words;\r\n  };\r\n\r\n  struct LittleEndianIEEEDouble {\r\n    struct {\r\n      uint32_T wordL;\r\n      uint32_T wordH;\r\n    } words;\r\n  };\r\n\r\n  struct IEEESingle {\r\n    union {\r\n      real32_T wordLreal;\r\n      uint32_T wordLuint;\r\n    } wordL;\r\n  };\r\n\r\n#ifdef __cplusplus\r\n\r\n}                                      // extern \"C\"\r\n\r\n#endif\r\n#endif                                 // RTW_HEADER_rt_nonfinite_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rtwtypes.h\r\n//\r\n// Code generated for Simulink model 'Mixer_FaultInjection'.\r\n//\r\n// Model version                  : 4.142\r\n// Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n// C/C++ source code generated on : Fri Aug 23 16:15:46 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n// Logical type definitions\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n//=======================================================================*\r\n//  Target hardware information\r\n//    Device type: ARM Compatible->ARM Cortex\r\n//    Number of bits:     char:   8    short:   16    int:  32\r\n//                        long:  32    long long:  64\r\n//                        native word size:  32\r\n//    Byte ordering: LittleEndian\r\n//    Signed integer division rounds to: Zero\r\n//    Shift right on a signed integer as arithmetic shift: on\r\n// =======================================================================\r\n#ifdef PORTABLE_WORDSIZES              // PORTABLE_WORDSIZES defined\r\n\r\n//=======================================================================*\r\n//  Host information\r\n//    Number of bits:     char:   8    short:   16    int:  32\r\n//                        long:  32\r\n//                        long long:  64\r\n//                        native word size:  64\r\n// =======================================================================\r\n\r\n//=======================================================================*\r\n//  Fixed width word size data types:                                     *\r\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n//    real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n// =======================================================================\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n//===========================================================================*\r\n//  Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n//                            real_T, time_T, ulong_T, ulonglong_T.           *\r\n// ===========================================================================\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned int ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\n\r\n#else                                  // PORTABLE_WORDSIZES not defined\r\n\r\n//=======================================================================*\r\n//  Fixed width word size data types:                                     *\r\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n//    real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n// =======================================================================\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n//===========================================================================*\r\n//  Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n//                            real_T, time_T, ulong_T, ulonglong_T.           *\r\n// ===========================================================================\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n#endif                                 // PORTABLE_WORDSIZES\r\n\r\n//===========================================================================*\r\n//  Complex number type definitions                                           *\r\n// ===========================================================================\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n//=======================================================================*\r\n//  Min and Max:                                                          *\r\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n// =======================================================================\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n// Block D-Work pointer type\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 // RTWTYPES_H\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Interface files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rtmodel.h\r\n//\r\n// Code generated for Simulink model 'Mixer_FaultInjection'.\r\n//\r\n// Model version                  : 4.142\r\n// Simulink Coder version         : 23.2 (R2023b) 01-Aug-2023\r\n// C/C++ source code generated on : Fri Aug 23 16:15:46 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"Mixer_FaultInjection.h\"\r\n\r\n// Macros generated for backwards compatibility\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 // RTW_HEADER_rtmodel_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"MW_PX4_TaskControl.cpp","type":"source","group":"legacy","path":"C:\\ProgramData\\MATLAB\\SupportPackages\\R2023b\\toolbox\\target\\supportpackages\\px4\\src\\","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2018-2022 The MathWorks, Inc.\n *\n * File: MW_PX4_TaskControl.c\n *\n * Abstract:\n *  This file contains the main application for Simulink that is launched\n *  by PX4 stack at boot up. The main function spawns a new task and assigns\n *  the main function in ert_main.c as callback.\n *\n */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n/*Simulink model generated code specific headers*/\n\n#define MW_StringifyDefine(x) MW_StringifyDefineExpanded(x)\n#define MW_StringifyDefineExpanded(x) #x\n\n#define MW_StringifyDefineFunction(x, y) MW_StringifyDefineExpandedFunction(x, y)\n#define MW_StringifyDefineExpandedFunction(x, y) x##y\n\n#define MW_StringifyDefineX(x) MW_StringifyDefineExpandedX(x)\n#define MW_StringifyDefineExpandedX(x) x.##h\n\n#define MW_StringifyDefineTypesX(x) MW_StringifyDefineExpandedTypesX(x)\n#define MW_StringifyDefineExpandedTypesX(x) x##_types.h\n\n#define MW_StringifyDefinePrivateX(x) MW_StringifyDefineExpandedPrivateX(x)\n#define MW_StringifyDefineExpandedPrivateX(x) x##_private.h\n\n#include MW_StringifyDefine(MODEL.h)\n#include MW_StringifyDefine(MW_StringifyDefineTypesX(MODEL))\n#include MW_StringifyDefine(MW_StringifyDefinePrivateX(MODEL))\n\n#ifndef MW_PX4_DISABLE_MAVLINK\n#include \"mavlink_main.h\"\n#endif\n\n#define DEBUG 0\n\n#ifdef PIL\nextern int errorOccurred;\n#endif\n\nextern \"C\" __EXPORT int px4_simulink_app_main(int argc,\n                                              char* argv[]); /* sbcheck:ok:extern_c needed */\n\nextern struct hrt_call\n    BaseRate_HRT; /* Base-rate HRT-callback is used to post base-rate semaphore */\nextern int terminatingmodel;\nextern int baserate_sem_copy; /* used for checking HRT semaphore water-mark*/\nstatic bool g_baseRateLife =\n    false;                        /* global storage to contain the status of the px4_simulink_app */\nstatic int px4_simulink_app_task; /* Handle of daemon thread */\nchar mavlink_shell_started = 0;\n\n#ifndef MW_PX4_DISABLE_MAVLINK\nconst char* mavlink_start_command[] = {\"mavlink\",      \"start\", \"-r\",     \"800000\", \"-d\",\n                                       \"/dev/ttyACM0\", \"-m\",    \"config\", \"-x\",     0};\n#endif\n\n/* Print the correct usage. */\nvoid px4_app_usage(const char* reason) {\n    if (reason) {\n        PX4_INFO(\"px4_simulink_app : %s\\n\", reason);\n    }\n    errx(1, \"usage: px4_simulink_app {start|stop|status} [-p <additional params>]\\n\\n\");\n}\n\n#if defined(MW_PX4_DISABLE_MAVLINK)\nuint8_t buffer[100];\nMavlinkShell shell;\nvoid shellWait(MavlinkShell* shell_ptr, uint8_t buf[]) {\n    /*The shell wait here is to be used for commands which are expected to\n      return a few characters (a max. of 100 characters.)*/\n    int read = 0, readTotal = 0;\n    for (int i = 0; i < 100; i++) {\n        buf[i] = 0;\n    }\n    while (strstr((char*)buf, \"nsh>\") == NULL) {\n        read = shell_ptr->read(buf + readTotal, 100 - readTotal);\n        readTotal = readTotal + read;\n    }\n}\n#endif\n\nvoid px4_simulink_app_control_MAVLink() {\n    if (mavlink_shell_started == 0) {\n#ifdef MW_PX4_DISABLE_MAVLINK\n        shell.start();\n        shellWait(&shell, buffer);\n#endif\n    }\n\n#ifndef MW_PX4_DISABLE_MAVLINK\n    int narg = sizeof(mavlink_start_command) / sizeof(mavlink_start_command[0]);\n    Mavlink::start(narg - 1, (char**)mavlink_start_command);\n#endif\n\n#ifdef MW_PX4_DISABLE_MAVLINK\n    shell.write((uint8_t*)\"mavlink stop-all\\n\", sizeof(\"mavlink stop-all\\n\"));\n    usleep(100000);\n#endif\n}\n\nint px4_simulink_app_main(int argc, char* argv[]) {\n    if (argc < 2) {\n        px4_app_usage(\"missing command\");\n    }\n\n    if (!strcmp(argv[1], \"start\")) {\n        if (g_baseRateLife == false) {\n            /* Start the Simulink Tasks here */\n#if DEBUG\n            printf(\"px4_simulink_app : Starting the Simulink model\\n\");\n            fflush(stdout);\n#endif\n\n            /* Reset semaphore */\n            g_baseRateLife = true;\n            terminatingmodel =\n                0; // reset global variable. For more info on the rational behind this, please see:\n            // http://nuttx.org/doku.php?id=wiki:nxinternal:tasks-vs-processes#nuttx_flat-build_behavior\n\n            px4_simulink_app_task = px4_task_spawn_cmd(\n                \"px4_simulink_app_task\", /* Definition of px4_task_spawn_cmd :\n                                            C:\\px4\\Firmware\\src\\platforms\\nuttx\\px4_layer\\px4_nuttx_tasks.c\n                                          */\n                SCHED_DEFAULT,           /* For STM32 F4, NuttX has SCHED_DEFAULT as SCHED_RR */\n                SCHED_PRIORITY_MAX - 15, /* SCHED_PRIORITY_MAX: 255 */\n                2048, px4_simulink_app_task_main, (char* const*)NULL);\n\n        } else {\n            warnx(\"px4_simulink_app : Simulink model is already running\\n\");\n            fflush(stdout);\n        }\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    if (!strcmp(argv[1], \"stop\")) {\n        if (g_baseRateLife == true) {\n#ifdef PIL\n            errorOccurred = 1;\n#else\n            rtmSetErrorStatus(MW_StringifyDefineFunction(MODEL, _M), \"Module stopped by user\");\n            g_baseRateLife = false;\n            px4_sem_post(&baserateTaskSem);\n#endif\n#if DEBUG\n            PX4_INFO(\"px4_simulink_app : Exiting the Simulink model\\n\");\n#endif\n        } else {\n            warnx(\"px4_simulink_app : No Simulink model is running\\n\");\n        }\n\n        fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    if (!strcmp(argv[1], \"status\")) {\n        if (g_baseRateLife) {\n            PX4_INFO(\"px4_simulink_app : model is running\\n\");\n        } else {\n            PX4_INFO(\"px4_simulink_app : model is not started\\n\");\n        }\n        fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    px4_app_usage(\"unrecognized command\");\n#if defined(MW_PX4_NUTTX_BUILD)\n    exit(1);\n#else\n    return 1;\n#endif\n}\n\nvoid MW_PX4_Terminate() {\n    hrt_cancel(&BaseRate_HRT);\n    g_baseRateLife = false; // set status of PX4 Simulink App to stop\n\n#if defined(MW_HRT_CONSTRAINT) && (1 == MW_HRT_CONSTRAINT)\n    if (baserate_sem_copy > MW_SEM_WATERMARK) {\n        PX4_INFO(\"Hard real-time constraint violated, shutting down. Updating log file. \\n\");\n        FILE* fp_taskover_run = NULL;\n        char msg_watermark[100] = {0};\n        char msg_timestamp[50] = {0};\n        struct tm* sTm;\n        time_t now = time(NULL);\n        sTm = gmtime(&now);\n        sprintf(msg_watermark,\n                \"Base-rate semaphore exceeded water-mark value %d. Model base-rate = %.3f sec.\",\n                MW_SEM_WATERMARK, (float)MW_BASERATE_PERIOD);\n        strftime(msg_timestamp, sizeof(msg_timestamp), \"%Y-%m-%d %H:%M:%S\", sTm);\n        fp_taskover_run = fopen(\"/fs/microsd/log/task_overrun_log.txt\", \"a+\");\n        fprintf(fp_taskover_run, \"%s Timestamp=%s \\n\", msg_watermark, msg_timestamp);\n        fclose(fp_taskover_run);\n    }\n#endif\n\n#if DEBUG\n    PX4_INFO(\"px4_simulink_app : Received command to end the Simulink task \\n\");\n    fflush(stdout);\n#endif\n}\n\n// LocalWords:  HRT px nsh mavlink nuttx doku nxinternal Nutt SCHED fs microsd\n// LocalWords:  dev ACM tty\n"},{"name":"MW_ParameterRead.cpp","type":"source","group":"legacy","path":"C:\\ProgramData\\MATLAB\\SupportPackages\\R2023b\\toolbox\\target\\supportpackages\\px4\\src\\","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2020 The MathWorks, Inc. */\n/* Reads the Parameter value and outputs the same.\n\n **/\n#include \"MW_ParameterRead.h\"\n\n//Below Macro can be enabled for debugging purposes\n#define DEBUG 0\n\n/*\n ****************************************************************************************************************************************************\n * Wrapper function For Initializing and getting the parameter handle\n * Input Params\n * isString  - Denotes if the Parameter is string or numeric\n * sampleTime - Sample time of the block\n \n * Output Params\n * param_handle  - Handle to the requested parameter.\n ****************************************************************************************************************************************************\n */\nMW_Param_Handle MW_Init_Param(void * ParameterName, uint8_T isString , double sampleTime)\n{\n\n    MW_Param_Handle param_handle = PARAM_INVALID;\n    char * parameterStr;\n    /* Check parameters */\n    if (0 == isString)\n    {\n        fprintf(stderr,\"Only string as ParameterName name is supported.\\n\");\n#if defined(MW_PX4_NUTTX_BUILD)\t\n\texit(1);\n#else\n\treturn 1;\n#endif\n    }\n    else\n    {\n        parameterStr = (char*)ParameterName;\n    }\n    param_handle = param_find(parameterStr);\n#if DEBUG\n    printf(\"In MW_Init_Param. Parameter name = %s.\\n\", parameterStr);\n#endif\n    if (param_handle != PARAM_INVALID)\n    {\n#if DEBUG\n        printf(\"In MW_Init_Param. Valid Parameter Handle = %u.\\n\", param_handle);\n#endif    \n    }\n    else\n    {\n#if DEBUG\n        printf(\"In MW_Init_Param. Invalid Parameter Handle. \\n\");\n#endif\n    }\n    return param_handle;\n}\n\n/*\n ****************************************************************************************************************************************************\n * Wrapper function For reading the parameter\n * Input Params\n * param_h  - Handle to the parameter requested\n * dataType - Data Type of the Parameter Requested\n * dataPtr - Pointer to the data, into which param_get is written to\n *\n * Output Params\n * status  - 0 for a valid Parameter Handle ; 1 for a valid Parameter Handle\n ****************************************************************************************************************************************************\n */\nbool MW_Param_Step(MW_Param_Handle param_h, MW_PARAM_DATA_TYPE dataType, void * dataPtr)\n{\n    //status - 0 for a valid Parameter Handle\n    //status - 1 for an invalid Parameter Handle\n    bool status = 1;\n    if (param_h != PARAM_INVALID)\n    {\n#if DEBUG\n        printf(\"In MW_Param_Step.Parameter Handle = %u.\\n\", param_h);\n#endif\n        int32_t  ReturnTmpInt;\n        float ReturnTmpFlt;\n        switch (dataType)\n        {\n            case MW_INT32:\n                if (!param_get(param_h, &ReturnTmpInt))\n                {\n                    *(int*)dataPtr  = ReturnTmpInt;\n#if DEBUG\n                    printf(\"In MW_Param_Step MW_INT32. Value = %ld\\n\", *(int*)dataPtr);\n#endif\n                }\n                break;\n            case MW_SINGLE:\n                if (!param_get(param_h, &ReturnTmpFlt))\n                {\n                    *(float*)dataPtr  = ReturnTmpFlt;\n#if DEBUG\n                    printf(\"In MW_Param_Step MW_SINGLE. Value = %4.4f\\n\", *(float*)dataPtr);\n#endif\n                }\n                break;\n            default:\n                break;\n        }\n         status = 0;\n    }\n    return status;\n}\n\nvoid MW_Param_terminate(void) \n{\n}\n"},{"name":"MW_custom_RTOS_header.h","type":"header","group":"other","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _MW_CUSTOM_RTOS_HEADER_H_\r\n#define _MW_CUSTOM_RTOS_HEADER_H_\r\n#define MW_BASERATE_PRIORITY           250\r\n#define MW_BASERATE_PERIOD             0.004\r\n#define MW_NUMBER_SUBRATES             0\r\n#define MW_NUMBER_APERIODIC_TASKS      0\r\n#define MW_IS_CONCURRENT               0\r\n#define MW_NUMBER_TIMER_DRIVEN_TASKS   0\r\n\r\nextern void exitFcn(int sig);\r\nextern void *terminateTask(void *arg);\r\nextern void *baseRateTask(void *arg);\r\nextern void *subrateTask(void *arg);\r\nextern pthread_t schedulerThread;\r\nextern pthread_t baseRateThread;\r\nextern pthread_t subRateThread[];\r\nextern px4_sem_t stopSem;\r\nextern px4_sem_t baserateTaskSem;\r\nextern px4_sem_t subrateTaskSem[];\r\nextern int taskId[];\r\nextern int subratePriority[];\r\n\r\n#endif\r\n\r\n#define MW_MAX_TASKNAME                16\r\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"MW_PX4_TaskControl.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE PX4 Host Target\n#define MW_CONNECTIONINFO_XCPONTCPIP_IPADDRESS codertarget.pixhawk.registry.getLoopbackIP\n#define MW_CONNECTIONINFO_XCPONTCPIP_PORT 17725\n#define MW_CONNECTIONINFO_XCPONTCPIP_VERBOSE 1\n#define MW_EXTMODE_CONFIGURATION XCP on TCP/IP\n#define MW_RTOS NuttX\n#define MW_RTOSBASERATETASKPRIORITY 250\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 0\n#define MW_CMAKECONFIG 0\n#define MW_SIMULATOR 0\n#define MW_GAZEBOSIMMODEL 0\n#define MW_SIMULINKIO_MODELTRANSPORTDATAFCN px4.internal.ConnectedIO.getConfigsetInfo\n#define MW_SIMULINKIO_SERVERDEPLOYFCN px4.internal.ConnectedIO.buildAndDeployPX4IOServer\n#define MW_PWM_CH1_DISARMED 900\n#define MW_PWM_CH2_DISARMED 900\n#define MW_PWM_CH3_DISARMED 900\n#define MW_PWM_CH4_DISARMED 900\n#define MW_PWM_CH5_DISARMED 900\n#define MW_PWM_CH6_DISARMED 900\n#define MW_PWM_CH7_DISARMED 900\n#define MW_PWM_CH8_DISARMED 900\n#define MW_HRT_CONSTRAINT 0\n#define MW_SEM_WATERMARK 20\n#define MW_OBC_CONNECTIVITY_IP 127.0.0.1\n#define MW_IOBLOCKSMODE deployed\n#define MW_DATAVERSION 2016.02\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"MW_uORB_Read.cpp","type":"source","group":"legacy","path":"C:\\ProgramData\\MATLAB\\SupportPackages\\R2023b\\toolbox\\target\\supportpackages\\px4\\src\\","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2020 The MathWorks, Inc. */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"MW_uORB_Read.h\"\n\n#define DEBUG 0\n\nvoid uORB_read_initialize(orb_metadata_t* orbData, pollfd_t* eventStructObj) {\n    int fd = orb_subscribe(orbData);\n    eventStructObj->fd = fd;\n    eventStructObj->events = POLLIN;\n#if DEBUG\n    PX4_INFO(\"* Subscribed to topic: %s (fd = %d)*\\n\", orbData->o_name, fd);\n#endif\n}\n\nboolean_T uORB_read_step(orb_metadata_t* orbData,\n                         pollfd_t* eventStructObj,\n                         void* busData,\n                         boolean_T blockingMode,\n                         double blockingTimeout) {\n    boolean_T updated = 0;\n    bool isUpdated = false;\n    if (blockingMode) {\n#if defined(MW_PX4_NUTTX_BUILD)\n        int poll_ret = px4_poll(eventStructObj, 1, blockingTimeout);\n        static int error_counter = 0;\n        if (poll_ret == 0) {\n#if DEBUG\n            PX4_ERR(\"Got no data within %.9lf second\", blockingTimeout / 1000.0);\n#endif\n        } else if (poll_ret < 0) {\n            if (error_counter < 10 || error_counter % 500 == 0) {\n                /* use a counter to prevent flooding and slowing the system down */\n#if DEBUG\n                PX4_ERR(\"ERROR return value from poll(): %d\", poll_ret);\n#endif\n            }\n            error_counter++;\n\n        } else {\n            if (eventStructObj->revents & POLLIN) {\n                orb_copy(orbData, eventStructObj->fd, busData);\n                updated = 1;\n            }\n        }\n#elif defined(MW_PX4_POSIX_BUILD)\n        double count = 0;\n        /* The blocking timeout mentioned in the block mask is seconds but\n         * system object converts it to milliseconds*/\n        while (count < blockingTimeout) {\n            // Sleep for 1 ms and then again check if\n            // uORB topic is updated\n            usleep(1000);\n            orb_check(eventStructObj->fd, &isUpdated);\n            if (isUpdated) {\n                orb_copy(orbData, eventStructObj->fd, busData);\n                break;\n            }\n            count++;\n        }\n\n        updated = isUpdated ? 1 : 0;\n#endif\n    } else {\n        orb_check(eventStructObj->fd, &isUpdated);\n        if (isUpdated) {\n            orb_copy(orbData, eventStructObj->fd, busData);\n        }\n        updated = isUpdated ? 1 : 0;\n    }\n\n    return updated;\n}\n\nvoid uORB_read_terminate(const pollfd_t* eventStructObj) {\n    orb_unsubscribe(eventStructObj->fd);\n}\n"},{"name":"MW_uORB_Write.cpp","type":"source","group":"legacy","path":"C:\\ProgramData\\MATLAB\\SupportPackages\\R2023b\\toolbox\\target\\supportpackages\\px4\\src\\","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018 The MathWorks, Inc. */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"MW_uORB_Write.h\"\n\n#define DEBUG 0\n\nvoid uORB_write_initialize(orb_metadata_t* orbData,\n                          orb_advert_t* orbAdvertObj,\n                          void* busData,\n                          int queueLen) {\n    *orbAdvertObj = orb_advertise_queue(orbData, busData, queueLen);    \n#if DEBUG\n    PX4_INFO(\"Started advertising topic: %s \\n\",  orbData->o_name);\n#endif    \n}\n\nvoid uORB_write_step(orb_metadata_t* orbData,\n                    orb_advert_t* orbAdvertObj,\n                    void* busData) {\n    orb_publish(orbData, *orbAdvertObj, busData);\n}\n\nvoid uORB_write_terminate(const orb_advert_t* orbAdvertObj) {\n    orb_unadvertise(*orbAdvertObj);\n}\n"},{"name":"MW_uORB_busstruct_conversion.h","type":"header","group":"other","path":"E:\\OneDrive\\Research\\Hexacopter_FDDProject\\work\\code\\Mixer_FaultInjection_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _MW_UORB_BUSSTRUCT_CONVERSION_H_\r\n#define _MW_UORB_BUSSTRUCT_CONVERSION_H_\r\n\r\n#include <uORB/topics/actuator_controls.h>\r\n#include <uORB/topics/actuator_outputs.h>\r\n#include <uORB/topics/input_rc.h>\r\n\r\ntypedef struct actuator_controls_s  px4_Bus_actuator_controls ;\r\ntypedef struct actuator_outputs_s  px4_Bus_actuator_outputs ;\r\ntypedef struct input_rc_s  px4_Bus_input_rc ;\r\n\r\n#endif\r\n"},{"name":"nuttxinitialize.cpp","type":"source","group":"legacy","path":"C:\\ProgramData\\MATLAB\\SupportPackages\\R2023b\\toolbox\\target\\supportpackages\\px4\\src\\","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2018-2022 The MathWorks, Inc.\n *\n * File: nuttxinitialize.c\n *\n * Abstract:\n *  This file contains RTOS thread creation functions\n *\n */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n\n/***********************************************\n * Added for Simulink Threads\n ************************************************/\npthread_attr_t attr;\nstatic baseRateInfo_t g_info;\nstruct sched_param g_sp;\n// extern volatile boolean_T runModel ;\n\n/***********************************************\n * Added for HRT\n ************************************************/\nstruct hrt_call BaseRate_HRT;\nint baserate_sem_copy;\n\n\n#define MW_RTOS_DEBUG 0\n\nbaseRateInfo_t EXT_sig_info;\nbaseRateInfo_t SDCard_sig_info;\nextern pthread_t backgroundThread;\nextern pthread_t loggingThread;\nextern void exitFcn(int sig);\n\nvoid setTaskPeriod(double periodInSeconds, int sigNo) {\n    timer_t timerId;\n    struct sigevent sev;\n    struct itimerspec its;\n    long stNanoSec;\n    int status;\n\n    /* Create a timer */\n    sev.sigev_notify = SIGEV_SIGNAL;\n    sev.sigev_signo = sigNo;\n    sev.sigev_value.sival_ptr = &timerId;\n    status = timer_create(CLOCK_REALTIME, &sev, &timerId);\n    CHECK_STATUS(status, 0, \"timer_create\");\n\n    /* Arm real-time scheduling timer */\n    stNanoSec = (long)(periodInSeconds * 1e9);\n    its.it_value.tv_sec = stNanoSec / 1000000000;\n    its.it_value.tv_nsec = stNanoSec % 1000000000;\n    its.it_interval.tv_sec = its.it_value.tv_sec;\n    its.it_interval.tv_nsec = its.it_value.tv_nsec;\n    status = timer_settime(timerId, 0, &its, NULL);\n    CHECK_STATUS(status, 0, \"timer_settime\");\n}\n\nvoid print_sem_value() {\n    PX4_WARN(\"Sem value = %d\", baserate_sem_copy);\n}\n\nstatic void Base_HRT_Callback(void* arg) {\n#ifndef PX4_CONNECTEDIO\n    int sem_value_check;\n\n    px4_sem_getvalue(&baserateTaskSem, &sem_value_check);\n    px4_sem_post(&baserateTaskSem);\n    baserate_sem_copy = sem_value_check;\n\n#endif\n}\n\n/* ---------------------------- */\n/* Externally visible functions */\n/* ---------------------------- */\nvoid myWaitForThisEvent(int sigNo) {\n    sigset_t sigMask;\n\n    sigemptyset(&sigMask);\n    sigaddset(&sigMask, sigNo);\n    sigwaitinfo(&sigMask, NULL);\n    //\tCHECK_STATUS_NOT(status, -1, \"sigwaitinfo\");\n}\n\nvoid MW_PX4_WaitForThisEvent(void* arg) {\n#ifdef EXT_MODE\n    /*pace External mode thread at 10 Hz*/\n    usleep(100000);\n\n    /*Signaling is causing issue when sample time is greater than 0.1\n     and model runs for more than 60 seconds. In this case model stop is not\n     stopping External mode. Using usleep for now to sleep the External Mode thread.*/\n\n    // baseRateInfo_t ext_info = *((baseRateInfo_t *)arg);\n    // static boolean_T isTaskPeriodSet = false;\n    // boolean_T rtmStopReq = rtmGetStopRequested(MW_StringifyDefineFunction(MODEL, _M));\n\n    // if (!isTaskPeriodSet) {\n    //     setTaskPeriod(ext_info.period, ext_info.sigNo);\n    //     isTaskPeriodSet = true;\n    // }\n\n    // if (!rtmStopReq) {\n    //     myWaitForThisEvent(ext_info.sigNo);\n    // }\n\n#endif\n}\n\nvoid myAddBlockForThisEvent(int sigNo) {\n    int status;\n    sigset_t sigMask;\n\n    sigemptyset(&sigMask);\n    sigaddset(&sigMask, sigNo);\n    status = pthread_sigmask(SIG_BLOCK, &sigMask, NULL);\n    CHECK_STATUS(status, 0, \"pthread_sigmask\");\n}\n\nvoid nuttxRTOSInit(double baseRatePeriod, int numSubrates) {\n    /* This is because in Daren's original Task callback ,a sleep was added before creating the\n     * threads*/\n    sleep(1);\n\n    int status;\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    size_t stackSize;\n    int baseRatePriority = MW_BASERATE_PRIORITY;\n#endif\n\n#ifdef MW_HAS_MULTIPLE_RATES\n    int i;\n    // char taskName[20];\n#endif\n#if defined(MW_PX4_NUTTX_BUILD)\n    sched_lock();\n#endif\n    // status = px4_sem_init(&termSem, 0, 0); PX4 PSP Dev: termSem no longer needed\n    // CHECK_STATUS(status, 0,\"px4_sem_init:termSem\");\n    status = px4_sem_init(&stopSem, 0, 0);\n    CHECK_STATUS(status, 0, \"px4_sem_init:stopSem\");\n    status = px4_sem_init(&baserateTaskSem, 0, 0);\n    CHECK_STATUS(status, 0, \"px4_sem_init:baserateTaskSem\");\n\n    // or you can use/check: _POSIX_PRIORITY_SCHEDULING\n    // _POSIX_THREAD_PRIORITY_SCHEDULING\n#if !defined(_POSIX_PRIORITY_SCHEDULING)\n    PX4_INFO(\"Priority scheduling is NOT supported by your system.\");\n    PX4_INFO(\"The generated code will not run correctly because your\");\n    PX4_INFO(\"model contains multiple rates and uses multi-tasking\");\n    PX4_INFO(\"code generation mode. You can only run the generated code\");\n    PX4_INFO(\"in single-tasking mode in your system. Open\");\n    PX4_INFO(\"Simulation -> Configuration Parameters -> Solver dialog\");\n    PX4_INFO(\"and set \\\"Tasking mode for periodic sample times\\\" parameter to SingleTasking.\");\n    PX4_INFO(\n        \"Re-build the Simulink model with the new settings and try executing the generated code \"\n        \"again.\");\n    fflush(stdout);\n    exit(-1);\n#endif\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    /* Set scheduling policy of the main thread to SCHED_FIFO */\n    g_sp.sched_priority = sched_get_priority_max(SCHED_FIFO) - 50;\n    status = sched_setscheduler(0, SCHED_FIFO, &g_sp);\n    CHECK_STATUS(status, 0, \"sched_setscheduler\");\n\n    /*Added init attribute and scheduler policy */\n    pthread_attr_init(&attr);\n    status = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n    CHECK_STATUS(status, 0, \"pthread_attr_setinheritsched\");\n    status = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedpolicy\");\n    // status = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n    // CHECK_STATUS(status, 0, \"pthread_attr_setdetachstate\");\n\n    /* PTHREAD_STACK_MIN is the minimum stack size required to start a thread */\n    stackSize = 8192 + PTHREAD_STACK_MIN;\n\n    /*added stack attribute back in */\n    status = pthread_attr_setstacksize(&attr, stackSize);\n    CHECK_STATUS(status, 0, \"pthread_attr_setstacksize\");\n#endif\n    /* set up info structure */\n    g_info.period = baseRatePeriod;\n    g_info.sigNo = BASERATE_TIMER_SIGNAL; // SIGRTMIN;\n\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"   stackSize = %d sched_priority = %d\", stackSize, g_sp.sched_priority);\n    PX4_INFO(\"   MW_BASERATE_PERIOD = %8.5f MW_BASERATE_PRIORITY = %d SIGRTMIN = 0x%08X\",\n             (double)baseRatePeriod, (int)baseRatePriority, SIGRTMIN);\n    PX4_INFO(\"   Init info.period = %8.5f sigNo = 0x%04X\", g_info.period, g_info.sigNo);\n    PX4_INFO(\"**creating the Base Rate thread before calling pthread_create**\");\n    fflush(stdout);\n#endif\n\n    /* Create the Base Rate Task here */\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = baseRatePriority;\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&baseRateThread, &attr, &baseRateTask, (void*)&g_info);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&baseRateThread, nullptr, &baseRateTask, (void*)&g_info);\n#endif\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"** Base Rate Task ID = %d with Priority = %d\\n\", baseRateThread, g_sp.sched_priority);\n    fflush(stdout);\n#endif\n\n/* Create sub-rate Tasks here */\n#ifdef MW_HAS_MULTIPLE_RATES\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"Creating sub-rate task threads\\n\");\n    PX4_INFO(\"Number of sub rate tasks: %d \\n\", MW_NUMBER_SUBRATES);\n    fflush(stdout);\n#endif\n\n    for (i = 0; i < MW_NUMBER_SUBRATES; i++) {\n        taskId[i] = i;\n        status = px4_sem_init(&subrateTaskSem[i], 0, 0);\n        CHECK_STATUS(status, 0, \"px4_sem_init: subrateTaskSem\");\n        // g_sp.sched_priority = MW_BASERATE_PRIORITY -40 + subratePriority[i] - 1;\n        g_sp.sched_priority = subratePriority[i];\n#if MW_RTOS_DEBUG\n        PX4_INFO(\"MW_SUBRATE_PRIORITY = %d \", (int)g_sp.sched_priority);\n#endif\n\n#if defined(MW_PX4_NUTTX_BUILD)\n        status = pthread_attr_setschedparam(&attr, &g_sp);\n        CHECK_STATUS(status, 0, \"pthread_attr_setschedparam\");\n        status = pthread_create(&subRateThread[i], &attr, &subrateTask, (void*)&taskId[i]);\n#elif defined(MW_PX4_POSIX_BUILD)\n        status = pthread_create(&subRateThread[i], nullptr, &subrateTask, (void*)&taskId[i]);\n#endif\n        CHECK_STATUS(status, 0, \"pthread_create\");\n\n#if MW_RTOS_DEBUG\n        PX4_INFO(\"** Sub Rate Task ID = %d \", subRateThread[i]);\n        fflush(stdout);\n#endif\n    }\n#endif // End of \"If Multiple Rates\" check\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = baseRatePriority;\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n#endif\n\n    /* Create the Scheduler Task here */\n    long stMicroSec;\n    stMicroSec = (long)(g_info.period * 1e6);\n    hrt_call_every(&BaseRate_HRT, stMicroSec, stMicroSec, Base_HRT_Callback,\n                   NULL); // timing callback to post base-rate semaphore\n\n/* Create the External Mode Task here */\n#ifdef EXT_MODE\n    /*---------- Creating EXT-mode Background Task ------------------*/\n    /* Setup signal info to block for EXT Mode */\n    EXT_sig_info.period = 0.1; // Sample rate at which we want Simulink to update w/ ext mode\n    EXT_sig_info.sigNo = SIGRTMIN;\n    /* Signaling the thread not working for low sample frequency*/\n    // sigemptyset(&EXT_sig_info.sigMask);\n    // sigaddset(&EXT_sig_info.sigMask, EXT_sig_info.sigNo);\n    // myAddBlockForThisEvent(EXT_sig_info.sigNo);\n\n    /* Setup thread for Custom Task */\n    fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = 40; // default is 100\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&backgroundThread, &attr, &backgroundTask, (void*)&EXT_sig_info);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&backgroundThread, nullptr, &backgroundTask, (void*)&EXT_sig_info);\n#endif\n    CHECK_STATUS(status, 0, \"EXT Mode Background pthread_create\");\n/*---------------------------------------------------------*/\n#endif\n\n/* Create the SD Card Task here */\n#if MAT_FILE\n    /*---------- Creating SD Card Background Task ------------------*/\n    fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = 40; // default is 100\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&loggingThread, &attr, &loggingThreadFcn, NULL);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&loggingThread, nullptr, &loggingThreadFcn, NULL);\n#endif\n    CHECK_STATUS(status, 0, \"SD Card Background pthread_create\");\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"** SD Card Background ID = %d \", loggingThread);\n    fflush(stdout);\n#endif\n\n/*---------------------------------------------------------*/\n#endif\n\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"px4_simulink_app : Created Simulink task threads successfully\\n\");\n    fflush(stdout);\n#endif\n#if defined(MW_PX4_NUTTX_BUILD)\n    sched_unlock();\n#endif\n}\n\n/*---------- Following function is added as a workaround for uavcan module build failure -------------\n  Original definition of the function is in the file <px4dir>\\Firmware\\Boards\\px4\\fmu-v5\\src\\can.c*/\n#if defined(MW_PX4_NUTTX_BUILD) && defined(CONFIG_CAN) && defined(UAVCAN_NUM_IFACES_RUNTIME)\n__EXPORT\nuint16_t board_get_can_interfaces(void)\n{\n\tuint16_t enabled_interfaces = 0x7;\n\n\tif (!PX4_MFT_HW_SUPPORTED(PX4_MFT_CAN2)) {\n\t\tenabled_interfaces &= ~(1 << 1);\n\t}\n\n\tif (!PX4_MFT_HW_SUPPORTED(PX4_MFT_CAN3)) {\n\t\tenabled_interfaces &= ~(1 << 2);\n\t}\n\n\treturn enabled_interfaces;\n }\n#endif\n/*---------------------------------------------------------*/\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};