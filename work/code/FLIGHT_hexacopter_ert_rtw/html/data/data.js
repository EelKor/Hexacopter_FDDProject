var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"FLIGHT_hexacopter","ref":false,"files":[{"name":"ert_main.cpp","type":"source","group":"main","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Main file","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: ert_main.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.146\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu Apr 24 17:45:28 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include <stdio.h>\n#include <stdlib.h>\n#include \"FLIGHT_hexacopter.h\"\n#include \"FLIGHT_hexacopter_private.h\"\n#include \"rtwtypes.h\"\n#include \"limits.h\"\n#include \"rt_nonfinite.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"nuttxinitialize.h\"\n#define UNUSED(x)                      x = x\n#define NAMELEN                        16\n\n// Function prototype declaration\nvoid exitFcn(int sig);\nvoid *terminateTask(void *arg);\nvoid *baseRateTask(void *arg);\nvoid *subrateTask(void *arg);\nvolatile boolean_T stopRequested = false;\nvolatile boolean_T runModel = true;\npx4_sem_t stopSem;\npx4_sem_t baserateTaskSem;\npx4_sem_t subrateTaskSem[1];\nint taskId[1];\npthread_t schedulerThread;\npthread_t baseRateThread;\nvoid *threadJoinStatus;\nint terminatingmodel = 0;\npthread_t subRateThread[1];\nint subratePriority[1];\nvoid *subrateTask(void *arg)\n{\n  int tid = *((int *) arg);\n  int subRateId;\n  subRateId = tid + 1;\n  while (runModel) {\n    px4_sem_wait(&subrateTaskSem[tid]);\n    if (terminatingmodel)\n      break;\n\n#ifdef MW_RTOS_DEBUG\n\n    printf(\" -subrate task %d semaphore received\\n\", subRateId);\n\n#endif\n\n    FLIGHT_hexacopter_step(subRateId);\n\n    // Get model outputs here\n  }\n\n  pthread_exit((void *)0);\n  return NULL;\n}\n\nvoid *baseRateTask(void *arg)\n{\n  runModel = (rtmGetErrorStatus(FLIGHT_hexacopter_M) == (NULL));\n  while (runModel) {\n    px4_sem_wait(&baserateTaskSem);\n\n#ifdef MW_RTOS_DEBUG\n\n    printf(\"*base rate task semaphore received\\n\");\n    fflush(stdout);\n\n#endif\n\n    if (rtmStepTask(FLIGHT_hexacopter_M, 1)\n        ) {\n      px4_sem_post(&subrateTaskSem[0]);\n    }\n\n    FLIGHT_hexacopter_step(0);\n\n    // Get model outputs here\n    stopRequested = !((rtmGetErrorStatus(FLIGHT_hexacopter_M) == (NULL)));\n  }\n\n  terminateTask(arg);\n  pthread_exit((void *)0);\n  return NULL;\n}\n\nvoid exitFcn(int sig)\n{\n  UNUSED(sig);\n  rtmSetErrorStatus(FLIGHT_hexacopter_M, \"stopping the model\");\n  runModel = 0;\n}\n\nvoid *terminateTask(void *arg)\n{\n  UNUSED(arg);\n  terminatingmodel = 1;\n\n  {\n    int i;\n\n    // Signal all periodic tasks to complete\n    for (i=0; i<1; i++) {\n      CHECK_STATUS(px4_sem_post(&subrateTaskSem[i]), 0, \"px4_sem_post\");\n      CHECK_STATUS(px4_sem_destroy(&subrateTaskSem[i]), 0, \"px4_sem_destroy\");\n    }\n\n    // Wait for all periodic tasks to complete\n    for (i=0; i<1; i++) {\n      CHECK_STATUS(pthread_join(subRateThread[i], &threadJoinStatus), 0,\n                   \"pthread_join\");\n    }\n\n    runModel = 0;\n  }\n\n  MW_PX4_Terminate();\n\n  // Terminate model\n  FLIGHT_hexacopter_terminate();\n  px4_sem_post(&stopSem);\n  return NULL;\n}\n\nint px4_simulink_app_task_main (int argc, char *argv[])\n{\n  subratePriority[0] = 249;\n  px4_simulink_app_control_MAVLink();\n  rtmSetErrorStatus(FLIGHT_hexacopter_M, 0);\n\n  // Initialize model\n  FLIGHT_hexacopter_initialize();\n\n  // Call RTOS Initialization function\n  nuttxRTOSInit(0.001, 1);\n\n  // Wait for stop semaphore\n  px4_sem_wait(&stopSem);\n\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\n\n  {\n    int i;\n    for (i=0; i < MW_NUMBER_TIMER_DRIVEN_TASKS; i++) {\n      CHECK_STATUS(px4_sem_destroy(&timerTaskSem[i]), 0, \"px4_sem_destroy\");\n    }\n  }\n\n#endif\n\n  return 0;\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"FLIGHT_hexacopter.cpp","type":"source","group":"model","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: FLIGHT_hexacopter.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.146\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu Apr 24 17:45:28 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include \"FLIGHT_hexacopter.h\"\n#include \"FLIGHT_hexacopter_types.h\"\n#include \"rtwtypes.h\"\n#include \"FLIGHT_hexacopter_private.h\"\n#include <math.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rt_defines.h\"\n\n// Block signals (default storage)\nB_FLIGHT_hexacopter_T FLIGHT_hexacopter_B;\n\n// Block states (default storage)\nDW_FLIGHT_hexacopter_T FLIGHT_hexacopter_DW;\n\n// Real-time model\nRT_MODEL_FLIGHT_hexacopter_T FLIGHT_hexacopter_M_ = RT_MODEL_FLIGHT_hexacopter_T\n  ();\nRT_MODEL_FLIGHT_hexacopter_T *const FLIGHT_hexacopter_M = &FLIGHT_hexacopter_M_;\n\n// Forward declaration for local functions\nstatic void FLIGHT_hexacopter_PWM_setupImpl(px4_internal_block_PWM_FLIGHT_T *obj,\n  boolean_T armPWM, boolean_T forceFailsafe);\nstatic void rate_monotonic_scheduler(void);\n\n//\n// Set which subrates need to run this base step (base rate always runs).\n// This function must be called prior to calling the model step function\n// in order to remember which rates need to run this base step.  The\n// buffering of events allows for overlapping preemption.\n//\nvoid FLIGHT_hexacopter_SetEventsForThisBaseStep(boolean_T *eventFlags)\n{\n  // Task runs when its counter is zero, computed via rtmStepTask macro\n  eventFlags[1] = ((boolean_T)rtmStepTask(FLIGHT_hexacopter_M, 1));\n}\n\n//\n//         This function updates active task flag for each subrate\n//         and rate transition flags for tasks that exchange data.\n//         The function assumes rate-monotonic multitasking scheduler.\n//         The function must be called at model base rate so that\n//         the generated code self-manages all its subrates and rate\n//         transition flags.\n//\nstatic void rate_monotonic_scheduler(void)\n{\n  // To ensure a deterministic data transfer between two rates,\n  //  data is transferred at the priority of a fast task and the frequency\n  //  of the slow task.  The following flags indicate when the data transfer\n  //  happens.  That is, a rate interaction flag is set true when both rates\n  //  will run, and false otherwise.\n\n\n  // tid 0 shares data with slower tid rate: 1\n  FLIGHT_hexacopter_M->Timing.RateInteraction.TID0_1 =\n    (FLIGHT_hexacopter_M->Timing.TaskCounters.TID[1] == 0);\n\n  // Compute which subrates run during the next base time step.  Subrates\n  //  are an integer multiple of the base rate counter.  Therefore, the subtask\n  //  counter is reset when it reaches its limit (zero means run).\n\n  (FLIGHT_hexacopter_M->Timing.TaskCounters.TID[1])++;\n  if ((FLIGHT_hexacopter_M->Timing.TaskCounters.TID[1]) > 4) {// Sample time: [0.005s, 0.0s] \n    FLIGHT_hexacopter_M->Timing.TaskCounters.TID[1] = 0;\n  }\n}\n\n// System initialize for atomic system:\nvoid FLIGHT_he_PX4Timestamp_Init(DW_PX4Timestamp_FLIGHT_hexaco_T *localDW)\n{\n  // Start for MATLABSystem: '<S3>/PX4 Timestamp'\n  localDW->obj.matlabCodegenIsDeleted = false;\n  localDW->objisempty = true;\n  localDW->obj.isInitialized = 1;\n  localDW->obj.isSetupComplete = true;\n}\n\n// Output and update for atomic system:\nvoid FLIGHT_hexacop_PX4Timestamp(B_PX4Timestamp_FLIGHT_hexacop_T *localB)\n{\n  // MATLABSystem: '<S3>/PX4 Timestamp'\n  localB->PX4Timestamp = hrt_absolute_time();\n}\n\n// Termination for atomic system:\nvoid FLIGHT_he_PX4Timestamp_Term(DW_PX4Timestamp_FLIGHT_hexaco_T *localDW)\n{\n  // Terminate for MATLABSystem: '<S3>/PX4 Timestamp'\n  if (!localDW->obj.matlabCodegenIsDeleted) {\n    localDW->obj.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S3>/PX4 Timestamp'\n}\n\n// System initialize for atomic system:\nvoid FLIGHT_h_ReadParameter_Init(DW_ReadParameter_FLIGHT_hexac_T *localDW)\n{\n  static const char_T ParameterNameStr[14] = \"MPC_THR_HOVER\";\n  real_T tmp;\n\n  // Start for MATLABSystem: '<S19>/Read Parameter'\n  localDW->obj.matlabCodegenIsDeleted = false;\n  localDW->objisempty = true;\n  localDW->obj.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  localDW->obj.isInitialized = 1;\n  if (localDW->obj.SampleTime == -1.0) {\n    tmp = 0.2;\n  } else {\n    tmp = localDW->obj.SampleTime;\n  }\n\n  localDW->obj.MW_PARAMHANDLE = MW_Init_Param(&ParameterNameStr[0], true, tmp *\n    1000.0);\n  localDW->obj.isSetupComplete = true;\n\n  // End of Start for MATLABSystem: '<S19>/Read Parameter'\n}\n\n// Output and update for atomic system:\nvoid FLIGHT_hexaco_ReadParameter(B_ReadParameter_FLIGHT_hexaco_T *localB,\n  DW_ReadParameter_FLIGHT_hexac_T *localDW)\n{\n  boolean_T b_varargout_2;\n\n  // MATLABSystem: '<S19>/Read Parameter'\n  if (localDW->obj.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    localDW->obj.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  b_varargout_2 = MW_Param_Step(localDW->obj.MW_PARAMHANDLE, MW_SINGLE,\n    &localB->ReadParameter_o1);\n  if (b_varargout_2) {\n    localB->ReadParameter_o1 = 0.0F;\n  }\n\n  // End of MATLABSystem: '<S19>/Read Parameter'\n}\n\n// Termination for atomic system:\nvoid FLIGHT_h_ReadParameter_Term(DW_ReadParameter_FLIGHT_hexac_T *localDW)\n{\n  // Terminate for MATLABSystem: '<S19>/Read Parameter'\n  if (!localDW->obj.matlabCodegenIsDeleted) {\n    localDW->obj.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S19>/Read Parameter'\n}\n\n// System initialize for atomic system:\nvoid FLIGHT__ReadParameter1_Init(DW_ReadParameter1_FLIGHT_hexa_T *localDW)\n{\n  static const char_T ParameterNameStr[16] = \"MPC_Z_VEL_P_ACC\";\n  real_T tmp;\n\n  // Start for MATLABSystem: '<S19>/Read Parameter1'\n  localDW->obj.matlabCodegenIsDeleted = false;\n  localDW->objisempty = true;\n  localDW->obj.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  localDW->obj.isInitialized = 1;\n  if (localDW->obj.SampleTime == -1.0) {\n    tmp = 0.2;\n  } else {\n    tmp = localDW->obj.SampleTime;\n  }\n\n  localDW->obj.MW_PARAMHANDLE = MW_Init_Param(&ParameterNameStr[0], true, tmp *\n    1000.0);\n  localDW->obj.isSetupComplete = true;\n\n  // End of Start for MATLABSystem: '<S19>/Read Parameter1'\n}\n\n// Output and update for atomic system:\nvoid FLIGHT_hexac_ReadParameter1(B_ReadParameter1_FLIGHT_hexac_T *localB,\n  DW_ReadParameter1_FLIGHT_hexa_T *localDW)\n{\n  boolean_T b_varargout_2;\n\n  // MATLABSystem: '<S19>/Read Parameter1'\n  if (localDW->obj.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    localDW->obj.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  b_varargout_2 = MW_Param_Step(localDW->obj.MW_PARAMHANDLE, MW_SINGLE,\n    &localB->ReadParameter1_o1);\n  if (b_varargout_2) {\n    localB->ReadParameter1_o1 = 0.0F;\n  }\n\n  // End of MATLABSystem: '<S19>/Read Parameter1'\n}\n\n// Termination for atomic system:\nvoid FLIGHT__ReadParameter1_Term(DW_ReadParameter1_FLIGHT_hexa_T *localDW)\n{\n  // Terminate for MATLABSystem: '<S19>/Read Parameter1'\n  if (!localDW->obj.matlabCodegenIsDeleted) {\n    localDW->obj.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S19>/Read Parameter1'\n}\n\n// System initialize for atomic system:\nvoid FLIGHT__ReadParameter2_Init(DW_ReadParameter2_FLIGHT_hexa_T *localDW)\n{\n  static const char_T ParameterNameStr[16] = \"MPC_Z_VEL_I_ACC\";\n  real_T tmp;\n\n  // Start for MATLABSystem: '<S19>/Read Parameter2'\n  localDW->obj.matlabCodegenIsDeleted = false;\n  localDW->objisempty = true;\n  localDW->obj.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  localDW->obj.isInitialized = 1;\n  if (localDW->obj.SampleTime == -1.0) {\n    tmp = 0.2;\n  } else {\n    tmp = localDW->obj.SampleTime;\n  }\n\n  localDW->obj.MW_PARAMHANDLE = MW_Init_Param(&ParameterNameStr[0], true, tmp *\n    1000.0);\n  localDW->obj.isSetupComplete = true;\n\n  // End of Start for MATLABSystem: '<S19>/Read Parameter2'\n}\n\n// Output and update for atomic system:\nvoid FLIGHT_hexac_ReadParameter2(B_ReadParameter2_FLIGHT_hexac_T *localB,\n  DW_ReadParameter2_FLIGHT_hexa_T *localDW)\n{\n  boolean_T b_varargout_2;\n\n  // MATLABSystem: '<S19>/Read Parameter2'\n  if (localDW->obj.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    localDW->obj.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  b_varargout_2 = MW_Param_Step(localDW->obj.MW_PARAMHANDLE, MW_SINGLE,\n    &localB->ReadParameter2_o1);\n  if (b_varargout_2) {\n    localB->ReadParameter2_o1 = 0.0F;\n  }\n\n  // End of MATLABSystem: '<S19>/Read Parameter2'\n}\n\n// Termination for atomic system:\nvoid FLIGHT__ReadParameter2_Term(DW_ReadParameter2_FLIGHT_hexa_T *localDW)\n{\n  // Terminate for MATLABSystem: '<S19>/Read Parameter2'\n  if (!localDW->obj.matlabCodegenIsDeleted) {\n    localDW->obj.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S19>/Read Parameter2'\n}\n\n// System initialize for atomic system:\nvoid FLIGHT__ReadParameter3_Init(DW_ReadParameter3_FLIGHT_hexa_T *localDW)\n{\n  static const char_T ParameterNameStr[16] = \"MPC_Z_VEL_D_ACC\";\n  real_T tmp;\n\n  // Start for MATLABSystem: '<S19>/Read Parameter3'\n  localDW->obj.matlabCodegenIsDeleted = false;\n  localDW->objisempty = true;\n  localDW->obj.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  localDW->obj.isInitialized = 1;\n  if (localDW->obj.SampleTime == -1.0) {\n    tmp = 0.2;\n  } else {\n    tmp = localDW->obj.SampleTime;\n  }\n\n  localDW->obj.MW_PARAMHANDLE = MW_Init_Param(&ParameterNameStr[0], true, tmp *\n    1000.0);\n  localDW->obj.isSetupComplete = true;\n\n  // End of Start for MATLABSystem: '<S19>/Read Parameter3'\n}\n\n// Output and update for atomic system:\nvoid FLIGHT_hexac_ReadParameter3(B_ReadParameter3_FLIGHT_hexac_T *localB,\n  DW_ReadParameter3_FLIGHT_hexa_T *localDW)\n{\n  boolean_T b_varargout_2;\n\n  // MATLABSystem: '<S19>/Read Parameter3'\n  if (localDW->obj.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    localDW->obj.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  b_varargout_2 = MW_Param_Step(localDW->obj.MW_PARAMHANDLE, MW_SINGLE,\n    &localB->ReadParameter3_o1);\n  if (b_varargout_2) {\n    localB->ReadParameter3_o1 = 0.0F;\n  }\n\n  // End of MATLABSystem: '<S19>/Read Parameter3'\n}\n\n// Termination for atomic system:\nvoid FLIGHT__ReadParameter3_Term(DW_ReadParameter3_FLIGHT_hexa_T *localDW)\n{\n  // Terminate for MATLABSystem: '<S19>/Read Parameter3'\n  if (!localDW->obj.matlabCodegenIsDeleted) {\n    localDW->obj.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S19>/Read Parameter3'\n}\n\n// System initialize for atomic system:\nvoid FLIGHT__PX4Timestamp_b_Init(DW_PX4Timestamp_FLIGHT_hexa_b_T *localDW)\n{\n  // Start for MATLABSystem: '<S565>/PX4 Timestamp'\n  localDW->obj.matlabCodegenIsDeleted = false;\n  localDW->objisempty = true;\n  localDW->obj.isInitialized = 1;\n  localDW->obj.isSetupComplete = true;\n}\n\n// Output and update for atomic system:\nvoid FLIGHT_hexac_PX4Timestamp_o(B_PX4Timestamp_FLIGHT_hexac_l_T *localB)\n{\n  // MATLABSystem: '<S565>/PX4 Timestamp'\n  localB->PX4Timestamp = hrt_absolute_time();\n}\n\n// Termination for atomic system:\nvoid FLIGHT__PX4Timestamp_o_Term(DW_PX4Timestamp_FLIGHT_hexa_b_T *localDW)\n{\n  // Terminate for MATLABSystem: '<S565>/PX4 Timestamp'\n  if (!localDW->obj.matlabCodegenIsDeleted) {\n    localDW->obj.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S565>/PX4 Timestamp'\n}\n\n// System initialize for atomic system:\nvoid FLIGHT__PX4Timestamp_l_Init(DW_PX4Timestamp_FLIGHT_hexa_f_T *localDW)\n{\n  // Start for MATLABSystem: '<S15>/PX4 Timestamp'\n  localDW->obj.matlabCodegenIsDeleted = false;\n  localDW->objisempty = true;\n  localDW->obj.isInitialized = 1;\n  localDW->obj.isSetupComplete = true;\n}\n\n// Output and update for atomic system:\nvoid FLIGHT_hexac_PX4Timestamp_p(B_PX4Timestamp_FLIGHT_hexac_c_T *localB)\n{\n  // MATLABSystem: '<S15>/PX4 Timestamp'\n  localB->PX4Timestamp = hrt_absolute_time();\n}\n\n// Termination for atomic system:\nvoid FLIGHT__PX4Timestamp_b_Term(DW_PX4Timestamp_FLIGHT_hexa_f_T *localDW)\n{\n  // Terminate for MATLABSystem: '<S15>/PX4 Timestamp'\n  if (!localDW->obj.matlabCodegenIsDeleted) {\n    localDW->obj.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S15>/PX4 Timestamp'\n}\n\nreal32_T rt_roundf_snf(real32_T u)\n{\n  real32_T y;\n  if (static_cast<real32_T>(fabs(static_cast<real_T>(u))) < 8.388608E+6F) {\n    if (u >= 0.5F) {\n      y = static_cast<real32_T>(floor(static_cast<real_T>(u + 0.5F)));\n    } else if (u > -0.5F) {\n      y = u * 0.0F;\n    } else {\n      y = static_cast<real32_T>(ceil(static_cast<real_T>(u - 0.5F)));\n    }\n  } else {\n    y = u;\n  }\n\n  return y;\n}\n\nreal32_T rt_atan2f_snf(real32_T u0, real32_T u1)\n{\n  real32_T y;\n  if (rtIsNaNF(u0) || rtIsNaNF(u1)) {\n    y = (rtNaNF);\n  } else if (rtIsInfF(u0) && rtIsInfF(u1)) {\n    int32_T tmp;\n    int32_T tmp_0;\n    if (u0 > 0.0F) {\n      tmp = 1;\n    } else {\n      tmp = -1;\n    }\n\n    if (u1 > 0.0F) {\n      tmp_0 = 1;\n    } else {\n      tmp_0 = -1;\n    }\n\n    y = static_cast<real32_T>(atan2(static_cast<real_T>(static_cast<real32_T>\n      (tmp)), static_cast<real_T>(static_cast<real32_T>(tmp_0))));\n  } else if (u1 == 0.0F) {\n    if (u0 > 0.0F) {\n      y = RT_PIF / 2.0F;\n    } else if (u0 < 0.0F) {\n      y = -(RT_PIF / 2.0F);\n    } else {\n      y = 0.0F;\n    }\n  } else {\n    y = static_cast<real32_T>(atan2(static_cast<real_T>(u0), static_cast<real_T>\n      (u1)));\n  }\n\n  return y;\n}\n\nstatic void FLIGHT_hexacopter_PWM_setupImpl(px4_internal_block_PWM_FLIGHT_T *obj,\n  boolean_T armPWM, boolean_T forceFailsafe)\n{\n  obj->isMain = true;\n  pwm_open(&obj->actuatorAdvertiseObj, &obj->armAdvertiseObj);\n  obj->servoCount = 8;\n  if (armPWM) {\n    pwm_arm(&obj->armAdvertiseObj);\n    obj->isArmed = true;\n  } else {\n    pwm_disarm(&obj->armAdvertiseObj);\n    obj->isArmed = false;\n  }\n\n  obj->channelMask = 63;\n  if (obj->isMain) {\n    if (forceFailsafe) {\n      pwm_disarm(&obj->armAdvertiseObj);\n    } else {\n      pwm_arm(&obj->armAdvertiseObj);\n    }\n  }\n}\n\n// Model step function for TID0\nvoid FLIGHT_hexacopter_step0(void)     // Sample time: [0.001s, 0.0s]\n{\n  int32_T ParamStep;\n  int32_T ParamStep_0;\n  int32_T ParamStep_1;\n  int32_T ParamStep_2;\n  int32_T ParamStep_3;\n  int32_T i;\n  real32_T ParamStep_4;\n  real32_T ParamStep_5;\n  real32_T rtb_IProdOut;\n  real32_T rtb_IProdOut_a;\n  real32_T rtb_NProdOut;\n  real32_T rtb_NProdOut_a;\n  real32_T rtb_NProdOut_g;\n  real32_T rtb_Sum4;\n  uint32_T tmp;\n  uint16_T tmp_0;\n  boolean_T b_varargout_1;\n  boolean_T rtb_Compare_a;\n\n  {                                    // Sample time: [0.001s, 0.0s]\n    rate_monotonic_scheduler();\n  }\n\n  // RateTransition: '<Root>/Rate Transition5' incorporates:\n  //   RateTransition: '<Root>/Rate Transition'\n\n  if (FLIGHT_hexacopter_M->Timing.RateInteraction.TID0_1) {\n    // RateTransition: '<Root>/Rate Transition5'\n    FLIGHT_hexacopter_B.RateTransition5 =\n      FLIGHT_hexacopter_DW.RateTransition5_Buffer0;\n\n    // RateTransition: '<Root>/Rate Transition'\n    FLIGHT_hexacopter_B.RateTransition =\n      FLIGHT_hexacopter_DW.RateTransition_Buffer0;\n\n    // RateTransition: '<Root>/Rate Transition1'\n    FLIGHT_hexacopter_B.RateTransition1 =\n      FLIGHT_hexacopter_DW.RateTransition1_Buffer0;\n\n    // RateTransition: '<Root>/Rate Transition2'\n    FLIGHT_hexacopter_B.RateTransition2 =\n      FLIGHT_hexacopter_DW.RateTransition2_Buffer0;\n  }\n\n  // End of RateTransition: '<Root>/Rate Transition5'\n\n  // MATLABSystem: '<S575>/SourceBlock'\n  b_varargout_1 = uORB_read_step(FLIGHT_hexacopter_DW.obj_pe.orbMetadataObj,\n    &FLIGHT_hexacopter_DW.obj_pe.eventStructObj, &FLIGHT_hexacopter_B.r3, false,\n    1.0);\n\n  // Outputs for Enabled SubSystem: '<S575>/Enabled Subsystem' incorporates:\n  //   EnablePort: '<S576>/Enable'\n\n  // Start for MATLABSystem: '<S575>/SourceBlock'\n  if (b_varargout_1) {\n    // SignalConversion generated from: '<S576>/In1'\n    FLIGHT_hexacopter_B.In1_h = FLIGHT_hexacopter_B.r3;\n  }\n\n  // End of Outputs for SubSystem: '<S575>/Enabled Subsystem'\n\n  // RateTransition: '<Root>/Rate Transition6'\n  if (FLIGHT_hexacopter_M->Timing.RateInteraction.TID0_1) {\n    // RateTransition: '<Root>/Rate Transition6'\n    FLIGHT_hexacopter_B.RateTransition6 =\n      FLIGHT_hexacopter_DW.RateTransition6_Buffer0;\n  }\n\n  // End of RateTransition: '<Root>/Rate Transition6'\n\n  // Outputs for Enabled SubSystem: '<Root>/SAS' incorporates:\n  //   EnablePort: '<S9>/Enable'\n\n  if (FLIGHT_hexacopter_B.RateTransition6) {\n    // MATLABSystem: '<S9>/Read Parameter2'\n    if (FLIGHT_hexacopter_DW.obj_d.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_d.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_d.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_4);\n    if (b_varargout_1) {\n      ParamStep_4 = 0.0F;\n    }\n\n    // Sum: '<S9>/Sum1'\n    rtb_Sum4 = FLIGHT_hexacopter_B.RateTransition -\n      FLIGHT_hexacopter_B.In1_h.xyz[0];\n\n    // Product: '<S501>/NProd Out' incorporates:\n    //   Constant: '<S9>/Constant'\n    //   DiscreteIntegrator: '<S493>/Filter'\n    //   MATLABSystem: '<S9>/Read Parameter2'\n    //   Product: '<S491>/DProd Out'\n    //   Sum: '<S493>/SumD'\n    //\n    rtb_NProdOut = (rtb_Sum4 * ParamStep_4 - FLIGHT_hexacopter_DW.Filter_DSTATE)\n      * FLIGHT_hexacopter_P.Constant_Value_j4;\n\n    // MATLABSystem: '<S9>/read_mc_rollrate_p'\n    if (FLIGHT_hexacopter_DW.obj.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_4);\n    if (b_varargout_1) {\n      ParamStep_4 = 0.0F;\n    }\n\n    // Sum: '<S507>/Sum' incorporates:\n    //   DiscreteIntegrator: '<S498>/Integrator'\n    //   MATLABSystem: '<S9>/read_mc_rollrate_p'\n    //   Product: '<S503>/PProd Out'\n    //\n    FLIGHT_hexacopter_B.Sum = (rtb_Sum4 * ParamStep_4 +\n      FLIGHT_hexacopter_DW.Integrator_DSTATE) + rtb_NProdOut;\n\n    // MATLABSystem: '<S9>/Read Parameter1'\n    if (FLIGHT_hexacopter_DW.obj_ea.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_ea.SampleTime =\n        FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_ea.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_4);\n    if (b_varargout_1) {\n      ParamStep_4 = 0.0F;\n    }\n\n    // Product: '<S495>/IProd Out' incorporates:\n    //   MATLABSystem: '<S9>/Read Parameter1'\n    //\n    rtb_IProdOut = rtb_Sum4 * ParamStep_4;\n\n    // MATLABSystem: '<S9>/Read Parameter5'\n    if (FLIGHT_hexacopter_DW.obj_h.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_h.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_h.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_4);\n    if (b_varargout_1) {\n      ParamStep_4 = 0.0F;\n    }\n\n    // Sum: '<S9>/Sum'\n    rtb_Sum4 = FLIGHT_hexacopter_B.RateTransition1 -\n      FLIGHT_hexacopter_B.In1_h.xyz[1];\n\n    // Product: '<S451>/NProd Out' incorporates:\n    //   Constant: '<S9>/Constant1'\n    //   DiscreteIntegrator: '<S443>/Filter'\n    //   MATLABSystem: '<S9>/Read Parameter5'\n    //   Product: '<S441>/DProd Out'\n    //   Sum: '<S443>/SumD'\n    //\n    rtb_NProdOut_g = (rtb_Sum4 * ParamStep_4 -\n                      FLIGHT_hexacopter_DW.Filter_DSTATE_j) *\n      FLIGHT_hexacopter_P.Constant1_Value_f;\n\n    // MATLABSystem: '<S9>/Read Parameter3'\n    if (FLIGHT_hexacopter_DW.obj_b.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_b.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_b.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_4);\n    if (b_varargout_1) {\n      ParamStep_4 = 0.0F;\n    }\n\n    // Sum: '<S457>/Sum' incorporates:\n    //   DiscreteIntegrator: '<S448>/Integrator'\n    //   MATLABSystem: '<S9>/Read Parameter3'\n    //   Product: '<S453>/PProd Out'\n    //\n    FLIGHT_hexacopter_B.Sum_a = (rtb_Sum4 * ParamStep_4 +\n      FLIGHT_hexacopter_DW.Integrator_DSTATE_c) + rtb_NProdOut_g;\n\n    // MATLABSystem: '<S9>/Read Parameter4'\n    if (FLIGHT_hexacopter_DW.obj_p.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_p.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_p.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_4);\n    if (b_varargout_1) {\n      ParamStep_4 = 0.0F;\n    }\n\n    // Product: '<S445>/IProd Out' incorporates:\n    //   MATLABSystem: '<S9>/Read Parameter4'\n    //\n    rtb_IProdOut_a = rtb_Sum4 * ParamStep_4;\n\n    // MATLABSystem: '<S9>/Read Parameter8'\n    if (FLIGHT_hexacopter_DW.obj_i.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_i.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_i.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_4);\n    if (b_varargout_1) {\n      ParamStep_4 = 0.0F;\n    }\n\n    // Sum: '<S9>/Sum4'\n    rtb_Sum4 = FLIGHT_hexacopter_B.RateTransition2 -\n      FLIGHT_hexacopter_B.In1_h.xyz[2];\n\n    // Product: '<S551>/NProd Out' incorporates:\n    //   Constant: '<S9>/Constant2'\n    //   DiscreteIntegrator: '<S543>/Filter'\n    //   MATLABSystem: '<S9>/Read Parameter8'\n    //   Product: '<S541>/DProd Out'\n    //   Sum: '<S543>/SumD'\n    //\n    rtb_NProdOut_a = (rtb_Sum4 * ParamStep_4 -\n                      FLIGHT_hexacopter_DW.Filter_DSTATE_h) *\n      FLIGHT_hexacopter_P.Constant2_Value_m;\n\n    // MATLABSystem: '<S9>/Read Parameter6'\n    if (FLIGHT_hexacopter_DW.obj_a.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_a.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_a.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_4);\n    if (b_varargout_1) {\n      ParamStep_4 = 0.0F;\n    }\n\n    // MATLABSystem: '<S9>/Read Parameter9'\n    if (FLIGHT_hexacopter_DW.obj_e.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_e.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_e.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_5);\n    if (b_varargout_1) {\n      ParamStep_5 = 0.0F;\n    }\n\n    // Sum: '<S9>/Sum2' incorporates:\n    //   DiscreteIntegrator: '<S548>/Integrator'\n    //   MATLABSystem: '<S9>/Read Parameter6'\n    //   MATLABSystem: '<S9>/Read Parameter9'\n    //   Product: '<S553>/PProd Out'\n    //   Product: '<S9>/yawrate_feedforward'\n    //   Sum: '<S557>/Sum'\n    //\n    FLIGHT_hexacopter_B.Sum2 = ((rtb_Sum4 * ParamStep_4 +\n      FLIGHT_hexacopter_DW.Integrator_DSTATE_l) + rtb_NProdOut_a) + ParamStep_5 *\n      FLIGHT_hexacopter_B.RateTransition2;\n\n    // MATLABSystem: '<S9>/Read Parameter7'\n    if (FLIGHT_hexacopter_DW.obj_j.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_j.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_j.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_4);\n    if (b_varargout_1) {\n      ParamStep_4 = 0.0F;\n    }\n\n    // Update for DiscreteIntegrator: '<S493>/Filter'\n    FLIGHT_hexacopter_DW.Filter_DSTATE += FLIGHT_hexacopter_P.Filter_gainval_o *\n      rtb_NProdOut;\n\n    // Update for DiscreteIntegrator: '<S498>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE +=\n      FLIGHT_hexacopter_P.Integrator_gainval_i * rtb_IProdOut;\n\n    // Update for DiscreteIntegrator: '<S443>/Filter'\n    FLIGHT_hexacopter_DW.Filter_DSTATE_j += FLIGHT_hexacopter_P.Filter_gainval_f\n      * rtb_NProdOut_g;\n\n    // Update for DiscreteIntegrator: '<S448>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_c +=\n      FLIGHT_hexacopter_P.Integrator_gainval_im * rtb_IProdOut_a;\n\n    // Update for DiscreteIntegrator: '<S543>/Filter'\n    FLIGHT_hexacopter_DW.Filter_DSTATE_h += FLIGHT_hexacopter_P.Filter_gainval_m\n      * rtb_NProdOut_a;\n\n    // Update for DiscreteIntegrator: '<S548>/Integrator' incorporates:\n    //   MATLABSystem: '<S9>/Read Parameter7'\n    //   Product: '<S545>/IProd Out'\n    //\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_l += rtb_Sum4 * ParamStep_4 *\n      FLIGHT_hexacopter_P.Integrator_gainval_e;\n  }\n\n  // End of Outputs for SubSystem: '<Root>/SAS'\n\n  // RateTransition: '<Root>/Rate Transition3'\n  if (FLIGHT_hexacopter_M->Timing.RateInteraction.TID0_1) {\n    // RateTransition: '<Root>/Rate Transition3'\n    FLIGHT_hexacopter_B.RateTransition3 =\n      FLIGHT_hexacopter_DW.RateTransition3_Buffer0;\n  }\n\n  // End of RateTransition: '<Root>/Rate Transition3'\n\n  // Outputs for Enabled SubSystem: '<Root>/Mixer' incorporates:\n  //   EnablePort: '<S6>/Enable'\n\n  if (FLIGHT_hexacopter_B.RateTransition6) {\n    // MATLAB Function: '<S6>/pwm_out2'\n    // Function description:\n    //   Control allocation. The quadrotor type is X-configuration,\n    //   and the airframe is as follows:\n    // 3↓   1↑\n    //   \\ /\n    //   / \\\n    // 2↑   4↓\n    // Input：\n    //   Roll, Pitch, Yaw: attitude controller output.\n    //   Thrust\n    //  M1 = uint16(Thrust*scale + (- Roll + Pitch + Yaw) * scale_att + idle_PWM); \n    //  M2 = uint16(Thrust*scale + (Roll - Pitch + Yaw) * scale_att + idle_PWM); \n    //  M3 = uint16(Thrust*scale + (Roll + Pitch - Yaw) * scale_att + idle_PWM); \n    //  M4 = uint16(Thrust*scale + (- Roll - Pitch - Yaw) * scale_att + idle_PWM); \n    //  Hex X\n    //  M1 = ((Pitch + Roll / 2 - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M2 = ((Pitch - Roll / 2 + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M3 = ((-Roll - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM;\n    //  M4 = ((-Pitch - Roll / 2 + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M5 = ((-Pitch + Roll / 2 - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M6 = ((Roll + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM;\n    //  M7 = 1000;\n    //  M8 = 1000;\n    //  Hex X (From Adam)\n    //  Hex X (Version 2)\n    //  Roll/Yaw\n    //  M1 = ((-Roll - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM;\n    //  M2 = ((Roll + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM;\n    //  % + Pitch/Roll\n    //  M6 = ((Pitch + Roll / 2 - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M4 = ((Pitch - Roll / 2 + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  % - Pitch/Roll\n    //  M5 = ((-Pitch - Roll / 2 + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M3 = ((-Pitch + Roll / 2 - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    ParamStep_4 = rt_roundf_snf(((-FLIGHT_hexacopter_B.Sum -\n      FLIGHT_hexacopter_B.Sum2) * FLIGHT_hexacopter_B.RateTransition3 / 3.0F +\n      FLIGHT_hexacopter_B.RateTransition3) * 1000.0F);\n    if (ParamStep_4 < 65536.0F) {\n      if (ParamStep_4 >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(ParamStep_4);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (ParamStep_4 < 65536.0F) {\n      if (ParamStep_4 >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(ParamStep_4);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S6>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S6>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[0] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[0] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[0] = static_cast<uint16_T>(tmp);\n    }\n\n    // MATLAB Function: '<S6>/pwm_out2'\n    ParamStep_4 = rt_roundf_snf(((FLIGHT_hexacopter_B.Sum +\n      FLIGHT_hexacopter_B.Sum2) * FLIGHT_hexacopter_B.RateTransition3 / 3.0F +\n      FLIGHT_hexacopter_B.RateTransition3) * 1000.0F);\n    if (ParamStep_4 < 65536.0F) {\n      if (ParamStep_4 >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(ParamStep_4);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (ParamStep_4 < 65536.0F) {\n      if (ParamStep_4 >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(ParamStep_4);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S6>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S6>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[1] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[1] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[1] = static_cast<uint16_T>(tmp);\n    }\n\n    // MATLAB Function: '<S6>/pwm_out2'\n    ParamStep_4 = rt_roundf_snf((((FLIGHT_hexacopter_B.Sum / 2.0F +\n      FLIGHT_hexacopter_B.Sum_a) - FLIGHT_hexacopter_B.Sum2) *\n      FLIGHT_hexacopter_B.RateTransition3 / 3.0F +\n      FLIGHT_hexacopter_B.RateTransition3) * 1000.0F);\n    if (ParamStep_4 < 65536.0F) {\n      if (ParamStep_4 >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(ParamStep_4);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (ParamStep_4 < 65536.0F) {\n      if (ParamStep_4 >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(ParamStep_4);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S6>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S6>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[2] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[2] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[2] = static_cast<uint16_T>(tmp);\n    }\n\n    // MATLAB Function: '<S6>/pwm_out2'\n    ParamStep_4 = rt_roundf_snf((((-FLIGHT_hexacopter_B.Sum_a -\n      FLIGHT_hexacopter_B.Sum / 2.0F) + FLIGHT_hexacopter_B.Sum2) *\n      FLIGHT_hexacopter_B.RateTransition3 / 3.0F +\n      FLIGHT_hexacopter_B.RateTransition3) * 1000.0F);\n    if (ParamStep_4 < 65536.0F) {\n      if (ParamStep_4 >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(ParamStep_4);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (ParamStep_4 < 65536.0F) {\n      if (ParamStep_4 >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(ParamStep_4);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S6>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S6>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[3] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[3] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[3] = static_cast<uint16_T>(tmp);\n    }\n\n    // MATLAB Function: '<S6>/pwm_out2'\n    ParamStep_4 = rt_roundf_snf((((FLIGHT_hexacopter_B.Sum_a -\n      FLIGHT_hexacopter_B.Sum / 2.0F) + FLIGHT_hexacopter_B.Sum2) *\n      FLIGHT_hexacopter_B.RateTransition3 / 3.0F +\n      FLIGHT_hexacopter_B.RateTransition3) * 1000.0F);\n    if (ParamStep_4 < 65536.0F) {\n      if (ParamStep_4 >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(ParamStep_4);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (ParamStep_4 < 65536.0F) {\n      if (ParamStep_4 >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(ParamStep_4);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S6>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S6>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[4] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[4] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[4] = static_cast<uint16_T>(tmp);\n    }\n\n    // MATLAB Function: '<S6>/pwm_out2'\n    ParamStep_4 = rt_roundf_snf((((FLIGHT_hexacopter_B.Sum / 2.0F -\n      FLIGHT_hexacopter_B.Sum_a) - FLIGHT_hexacopter_B.Sum2) *\n      FLIGHT_hexacopter_B.RateTransition3 / 3.0F +\n      FLIGHT_hexacopter_B.RateTransition3) * 1000.0F);\n    if (ParamStep_4 < 65536.0F) {\n      if (ParamStep_4 >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(ParamStep_4);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (ParamStep_4 < 65536.0F) {\n      if (ParamStep_4 >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(ParamStep_4);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S6>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S6>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[5] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[5] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S6>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[5] = static_cast<uint16_T>(tmp);\n    }\n  }\n\n  // End of Outputs for SubSystem: '<Root>/Mixer'\n\n  // DataTypeConversion: '<S4>/Data Type Conversion6'\n  for (i = 0; i < 6; i++) {\n    FLIGHT_hexacopter_B.DataTypeConversion6[i] =\n      FLIGHT_hexacopter_B.Output_Limits1[i];\n  }\n\n  // End of DataTypeConversion: '<S4>/Data Type Conversion6'\n\n  // MATLABSystem: '<S4>/Read Parameter13'\n  if (FLIGHT_hexacopter_DW.obj_g.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_g.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_g.MW_PARAMHANDLE,\n    MW_INT32, &i);\n  if (b_varargout_1) {\n    i = 0;\n  }\n\n  // RateTransition: '<Root>/Rate Transition4'\n  if (FLIGHT_hexacopter_M->Timing.RateInteraction.TID0_1) {\n    // RateTransition: '<Root>/Rate Transition4'\n    FLIGHT_hexacopter_B.RateTransition4 =\n      FLIGHT_hexacopter_DW.RateTransition4_Buffer0;\n  }\n\n  // End of RateTransition: '<Root>/Rate Transition4'\n\n  // RelationalOperator: '<S180>/Compare' incorporates:\n  //   Constant: '<S180>/Constant'\n\n  rtb_Compare_a = (FLIGHT_hexacopter_B.RateTransition4 >=\n                   FLIGHT_hexacopter_P.CompareToConstant_const);\n\n  // MATLABSystem: '<S4>/Read Parameter1'\n  if (FLIGHT_hexacopter_DW.obj_j5.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_j5.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_j5.MW_PARAMHANDLE,\n    MW_INT32, &ParamStep);\n  if (b_varargout_1) {\n    ParamStep = 0;\n  }\n\n  // MATLABSystem: '<S4>/Read Parameter2'\n  if (FLIGHT_hexacopter_DW.obj_ao.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_ao.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_ao.MW_PARAMHANDLE,\n    MW_INT32, &ParamStep_0);\n  if (b_varargout_1) {\n    ParamStep_0 = 0;\n  }\n\n  // MATLABSystem: '<S4>/Read Parameter3'\n  if (FLIGHT_hexacopter_DW.obj_n.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_n.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_n.MW_PARAMHANDLE,\n    MW_INT32, &ParamStep_1);\n  if (b_varargout_1) {\n    ParamStep_1 = 0;\n  }\n\n  // MATLABSystem: '<S4>/Read Parameter4'\n  if (FLIGHT_hexacopter_DW.obj_c.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_c.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_c.MW_PARAMHANDLE,\n    MW_INT32, &ParamStep_2);\n  if (b_varargout_1) {\n    ParamStep_2 = 0;\n  }\n\n  // MATLABSystem: '<S4>/Read Parameter5'\n  if (FLIGHT_hexacopter_DW.obj_aq.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_aq.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_aq.MW_PARAMHANDLE,\n    MW_INT32, &ParamStep_3);\n  if (b_varargout_1) {\n    ParamStep_3 = 0;\n  }\n\n  // Switch: '<S4>/Switch' incorporates:\n  //   Constant: '<S4>/Constant'\n  //   DataTypeConversion: '<S4>/Data Type Conversion3'\n  //   MATLABSystem: '<S4>/Read Parameter13'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.u0 = i;\n  } else {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Constant_Value_mc;\n  }\n\n  // Gain: '<S181>/Gain' incorporates:\n  //   Switch: '<S4>/Switch'\n\n  FLIGHT_hexacopter_B.u0 *= FLIGHT_hexacopter_P.Gain_Gain_j;\n\n  // Saturate: '<S181>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S181>/Constant'\n  //   Product: '<S181>/Product'\n  //   Saturate: '<S181>/Saturation'\n  //   Sum: '<S181>/Sum'\n  //   Sum: '<S181>/Sum1'\n\n  FLIGHT_hexacopter_B.u0 = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[0]) -\n    FLIGHT_hexacopter_P.Constant_Value_kf) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_kf);\n  if (rtIsNaN(FLIGHT_hexacopter_B.u0) || rtIsInf(FLIGHT_hexacopter_B.u0)) {\n    FLIGHT_hexacopter_B.u0 = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.u0 = fmod(FLIGHT_hexacopter_B.u0, 65536.0);\n  }\n\n  FLIGHT_hexacopter_B.DataTypeConversion7_k[0] = static_cast<uint16_T>\n    (FLIGHT_hexacopter_B.u0 < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-\n       static_cast<int16_T>(static_cast<uint16_T>(-FLIGHT_hexacopter_B.u0)))) :\n     static_cast<int32_T>(static_cast<uint16_T>(FLIGHT_hexacopter_B.u0)));\n\n  // Switch: '<S4>/Switch1' incorporates:\n  //   Constant: '<S4>/Constant1'\n  //   DataTypeConversion: '<S4>/Data Type Conversion2'\n  //   MATLABSystem: '<S4>/Read Parameter1'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.u0 = ParamStep;\n  } else {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Constant1_Value;\n  }\n\n  // Gain: '<S182>/Gain' incorporates:\n  //   Switch: '<S4>/Switch1'\n\n  FLIGHT_hexacopter_B.u0 *= FLIGHT_hexacopter_P.Gain_Gain_h;\n\n  // Saturate: '<S182>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat_m) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat_m;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat_o)\n  {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat_o;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S182>/Constant'\n  //   Product: '<S182>/Product'\n  //   Saturate: '<S182>/Saturation'\n  //   Sum: '<S182>/Sum'\n  //   Sum: '<S182>/Sum1'\n\n  FLIGHT_hexacopter_B.u0 = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[1]) -\n    FLIGHT_hexacopter_P.Constant_Value_ms) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_ms);\n  if (rtIsNaN(FLIGHT_hexacopter_B.u0) || rtIsInf(FLIGHT_hexacopter_B.u0)) {\n    FLIGHT_hexacopter_B.u0 = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.u0 = fmod(FLIGHT_hexacopter_B.u0, 65536.0);\n  }\n\n  FLIGHT_hexacopter_B.DataTypeConversion7_k[1] = static_cast<uint16_T>\n    (FLIGHT_hexacopter_B.u0 < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-\n       static_cast<int16_T>(static_cast<uint16_T>(-FLIGHT_hexacopter_B.u0)))) :\n     static_cast<int32_T>(static_cast<uint16_T>(FLIGHT_hexacopter_B.u0)));\n\n  // Switch: '<S4>/Switch2' incorporates:\n  //   Constant: '<S4>/Constant2'\n  //   DataTypeConversion: '<S4>/Data Type Conversion'\n  //   MATLABSystem: '<S4>/Read Parameter2'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.u0 = ParamStep_0;\n  } else {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Constant2_Value;\n  }\n\n  // Gain: '<S183>/Gain' incorporates:\n  //   Switch: '<S4>/Switch2'\n\n  FLIGHT_hexacopter_B.u0 *= FLIGHT_hexacopter_P.Gain_Gain_c;\n\n  // Saturate: '<S183>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat_b) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat_b;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat_g)\n  {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat_g;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S183>/Constant'\n  //   Product: '<S183>/Product'\n  //   Saturate: '<S183>/Saturation'\n  //   Sum: '<S183>/Sum'\n  //   Sum: '<S183>/Sum1'\n\n  FLIGHT_hexacopter_B.u0 = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[2]) -\n    FLIGHT_hexacopter_P.Constant_Value_ii) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_ii);\n  if (rtIsNaN(FLIGHT_hexacopter_B.u0) || rtIsInf(FLIGHT_hexacopter_B.u0)) {\n    FLIGHT_hexacopter_B.u0 = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.u0 = fmod(FLIGHT_hexacopter_B.u0, 65536.0);\n  }\n\n  FLIGHT_hexacopter_B.DataTypeConversion7_k[2] = static_cast<uint16_T>\n    (FLIGHT_hexacopter_B.u0 < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-\n       static_cast<int16_T>(static_cast<uint16_T>(-FLIGHT_hexacopter_B.u0)))) :\n     static_cast<int32_T>(static_cast<uint16_T>(FLIGHT_hexacopter_B.u0)));\n\n  // Switch: '<S4>/Switch3' incorporates:\n  //   Constant: '<S4>/Constant3'\n  //   DataTypeConversion: '<S4>/Data Type Conversion4'\n  //   MATLABSystem: '<S4>/Read Parameter3'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.u0 = ParamStep_1;\n  } else {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Constant3_Value;\n  }\n\n  // Gain: '<S184>/Gain' incorporates:\n  //   Switch: '<S4>/Switch3'\n\n  FLIGHT_hexacopter_B.u0 *= FLIGHT_hexacopter_P.Gain_Gain_n;\n\n  // Saturate: '<S184>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat_be) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat_be;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat_e)\n  {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat_e;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S184>/Constant'\n  //   Product: '<S184>/Product'\n  //   Saturate: '<S184>/Saturation'\n  //   Sum: '<S184>/Sum'\n  //   Sum: '<S184>/Sum1'\n\n  FLIGHT_hexacopter_B.u0 = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[3]) -\n    FLIGHT_hexacopter_P.Constant_Value_j4x) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_j4x);\n  if (rtIsNaN(FLIGHT_hexacopter_B.u0) || rtIsInf(FLIGHT_hexacopter_B.u0)) {\n    FLIGHT_hexacopter_B.u0 = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.u0 = fmod(FLIGHT_hexacopter_B.u0, 65536.0);\n  }\n\n  FLIGHT_hexacopter_B.DataTypeConversion7_k[3] = static_cast<uint16_T>\n    (FLIGHT_hexacopter_B.u0 < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-\n       static_cast<int16_T>(static_cast<uint16_T>(-FLIGHT_hexacopter_B.u0)))) :\n     static_cast<int32_T>(static_cast<uint16_T>(FLIGHT_hexacopter_B.u0)));\n\n  // Switch: '<S4>/Switch4' incorporates:\n  //   Constant: '<S4>/Constant4'\n  //   DataTypeConversion: '<S4>/Data Type Conversion1'\n  //   MATLABSystem: '<S4>/Read Parameter4'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.u0 = ParamStep_2;\n  } else {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Constant4_Value;\n  }\n\n  // Gain: '<S185>/Gain' incorporates:\n  //   Switch: '<S4>/Switch4'\n\n  FLIGHT_hexacopter_B.u0 *= FLIGHT_hexacopter_P.Gain_Gain_f;\n\n  // Saturate: '<S185>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat_d) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat_d;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat_l)\n  {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat_l;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S185>/Constant'\n  //   Product: '<S185>/Product'\n  //   Saturate: '<S185>/Saturation'\n  //   Sum: '<S185>/Sum'\n  //   Sum: '<S185>/Sum1'\n\n  FLIGHT_hexacopter_B.u0 = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[4]) -\n    FLIGHT_hexacopter_P.Constant_Value_l) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_l);\n  if (rtIsNaN(FLIGHT_hexacopter_B.u0) || rtIsInf(FLIGHT_hexacopter_B.u0)) {\n    FLIGHT_hexacopter_B.u0 = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.u0 = fmod(FLIGHT_hexacopter_B.u0, 65536.0);\n  }\n\n  FLIGHT_hexacopter_B.DataTypeConversion7_k[4] = static_cast<uint16_T>\n    (FLIGHT_hexacopter_B.u0 < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-\n       static_cast<int16_T>(static_cast<uint16_T>(-FLIGHT_hexacopter_B.u0)))) :\n     static_cast<int32_T>(static_cast<uint16_T>(FLIGHT_hexacopter_B.u0)));\n\n  // Switch: '<S4>/Switch5' incorporates:\n  //   Constant: '<S4>/Constant5'\n  //   DataTypeConversion: '<S4>/Data Type Conversion5'\n  //   MATLABSystem: '<S4>/Read Parameter5'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.u0 = ParamStep_3;\n  } else {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Constant5_Value;\n  }\n\n  // Gain: '<S186>/Gain' incorporates:\n  //   Switch: '<S4>/Switch5'\n\n  FLIGHT_hexacopter_B.u0 *= FLIGHT_hexacopter_P.Gain_Gain_m;\n\n  // Saturate: '<S186>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat_i) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat_i;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat_n)\n  {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat_n;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S186>/Constant'\n  //   Product: '<S186>/Product'\n  //   Saturate: '<S186>/Saturation'\n  //   Sum: '<S186>/Sum'\n  //   Sum: '<S186>/Sum1'\n\n  FLIGHT_hexacopter_B.u0 = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[5]) -\n    FLIGHT_hexacopter_P.Constant_Value_o) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_o);\n  if (rtIsNaN(FLIGHT_hexacopter_B.u0) || rtIsInf(FLIGHT_hexacopter_B.u0)) {\n    FLIGHT_hexacopter_B.u0 = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.u0 = fmod(FLIGHT_hexacopter_B.u0, 65536.0);\n  }\n\n  FLIGHT_hexacopter_B.DataTypeConversion7_k[5] = static_cast<uint16_T>\n    (FLIGHT_hexacopter_B.u0 < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-\n       static_cast<int16_T>(static_cast<uint16_T>(-FLIGHT_hexacopter_B.u0)))) :\n     static_cast<int32_T>(static_cast<uint16_T>(FLIGHT_hexacopter_B.u0)));\n\n  // MATLABSystem: '<Root>/PX4 PWM Output' incorporates:\n  //   Logic: '<Root>/NOT'\n\n  for (i = 0; i < 8; i++) {\n    FLIGHT_hexacopter_B.pwmValue[i] = 0U;\n  }\n\n  FLIGHT_hexacopter_B.pwmValue[0] = FLIGHT_hexacopter_B.DataTypeConversion7_k[0];\n  FLIGHT_hexacopter_B.pwmValue[1] = FLIGHT_hexacopter_B.DataTypeConversion7_k[1];\n  FLIGHT_hexacopter_B.pwmValue[2] = FLIGHT_hexacopter_B.DataTypeConversion7_k[2];\n  FLIGHT_hexacopter_B.pwmValue[3] = FLIGHT_hexacopter_B.DataTypeConversion7_k[3];\n  FLIGHT_hexacopter_B.pwmValue[4] = FLIGHT_hexacopter_B.DataTypeConversion7_k[4];\n  FLIGHT_hexacopter_B.pwmValue[5] = FLIGHT_hexacopter_B.DataTypeConversion7_k[5];\n  if (FLIGHT_hexacopter_B.RateTransition5) {\n    if (!FLIGHT_hexacopter_DW.obj_dl.isArmed) {\n      FLIGHT_hexacopter_DW.obj_dl.isArmed = true;\n      pwm_arm(&FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n    }\n\n    pwm_setServo(FLIGHT_hexacopter_DW.obj_dl.servoCount,\n                 FLIGHT_hexacopter_DW.obj_dl.channelMask,\n                 &FLIGHT_hexacopter_B.pwmValue[0],\n                 FLIGHT_hexacopter_DW.obj_dl.isMain,\n                 &FLIGHT_hexacopter_DW.obj_dl.actuatorAdvertiseObj);\n  } else {\n    pwm_disarm(&FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n    FLIGHT_hexacopter_DW.obj_dl.isArmed = false;\n    pwm_resetServo(FLIGHT_hexacopter_DW.obj_dl.servoCount,\n                   FLIGHT_hexacopter_DW.obj_dl.isMain,\n                   &FLIGHT_hexacopter_DW.obj_dl.actuatorAdvertiseObj);\n  }\n\n  if (FLIGHT_hexacopter_DW.obj_dl.isMain) {\n    if (!FLIGHT_hexacopter_B.RateTransition5) {\n      pwm_disarm(&FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n    } else {\n      pwm_arm(&FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n    }\n  }\n\n  // End of MATLABSystem: '<Root>/PX4 PWM Output'\n  FLIGHT_hexac_PX4Timestamp_o(&FLIGHT_hexacopter_B.PX4Timestamp_o);\n\n  // BusAssignment: '<S565>/Bus Assignment' incorporates:\n  //   MATLABSystem: '<S565>/PX4 Timestamp'\n\n  FLIGHT_hexacopter_B.BusAssignment_gi.timestamp =\n    FLIGHT_hexacopter_B.PX4Timestamp_o.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment_gi.control_power[0] =\n    FLIGHT_hexacopter_B.Sum;\n  FLIGHT_hexacopter_B.BusAssignment_gi.control_power[1] =\n    FLIGHT_hexacopter_B.Sum_a;\n  FLIGHT_hexacopter_B.BusAssignment_gi.control_power[2] =\n    FLIGHT_hexacopter_B.Sum2;\n  FLIGHT_hexacopter_B.BusAssignment_gi._padding0[0] = 0U;\n  FLIGHT_hexacopter_B.BusAssignment_gi._padding0[1] = 0U;\n  FLIGHT_hexacopter_B.BusAssignment_gi._padding0[2] = 0U;\n  FLIGHT_hexacopter_B.BusAssignment_gi._padding0[3] = 0U;\n\n  // MATLABSystem: '<S567>/SinkBlock' incorporates:\n  //   BusAssignment: '<S565>/Bus Assignment'\n\n  uORB_write_step(FLIGHT_hexacopter_DW.obj_jk.orbMetadataObj,\n                  &FLIGHT_hexacopter_DW.obj_jk.orbAdvertiseObj,\n                  &FLIGHT_hexacopter_B.BusAssignment_gi);\n  FLIGHT_hexac_PX4Timestamp_o(&FLIGHT_hexacopter_B.PX4Timestamp_n);\n  FLIGHT_hexac_PX4Timestamp_o(&FLIGHT_hexacopter_B.PX4Timestamp_p);\n\n  // BusAssignment: '<S569>/Bus Assignment' incorporates:\n  //   Constant: '<S568>/Constant'\n  //   Gain: '<S568>/Gain'\n  //   MATLABSystem: '<S12>/PX4 Timestamp'\n  //   MATLABSystem: '<S569>/PX4 Timestamp'\n  //   Saturate: '<S568>/Saturation'\n  //   Sum: '<S568>/Subtract'\n\n  FLIGHT_hexacopter_B.BusAssignment_f.timestamp =\n    FLIGHT_hexacopter_B.PX4Timestamp_n.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment_f.timestamp_sample =\n    FLIGHT_hexacopter_B.PX4Timestamp_p.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment_f.reversible_flags = 0U;\n  for (i = 0; i < 6; i++) {\n    // DataTypeConversion: '<Root>/Data Type Conversion'\n    ParamStep = FLIGHT_hexacopter_B.Output_Limits1[i];\n\n    // Saturate: '<S568>/Saturation'\n    if (ParamStep > FLIGHT_hexacopter_P.Saturation_UpperSat_ep) {\n      ParamStep_4 = FLIGHT_hexacopter_P.Saturation_UpperSat_ep;\n    } else if (ParamStep < FLIGHT_hexacopter_P.Saturation_LowerSat_p) {\n      ParamStep_4 = FLIGHT_hexacopter_P.Saturation_LowerSat_p;\n    } else {\n      ParamStep_4 = static_cast<real32_T>(ParamStep);\n    }\n\n    FLIGHT_hexacopter_B.BusAssignment_f.control[i] = (ParamStep_4 -\n      FLIGHT_hexacopter_P.Constant_Value_ez) * FLIGHT_hexacopter_P.Gain_Gain_mg;\n\n    // Saturate: '<S568>/Saturation' incorporates:\n    //   Constant: '<S12>/Constant1'\n    //   Constant: '<S568>/Constant'\n    //   Gain: '<S568>/Gain'\n    //   Sum: '<S568>/Subtract'\n\n    ParamStep_4 = FLIGHT_hexacopter_P.Constant1_Value_i[i];\n    if (ParamStep_4 > FLIGHT_hexacopter_P.Saturation_UpperSat_ep) {\n      ParamStep_4 = FLIGHT_hexacopter_P.Saturation_UpperSat_ep;\n    } else if (ParamStep_4 < FLIGHT_hexacopter_P.Saturation_LowerSat_p) {\n      ParamStep_4 = FLIGHT_hexacopter_P.Saturation_LowerSat_p;\n    }\n\n    FLIGHT_hexacopter_B.BusAssignment_f.control[i + 6] = (ParamStep_4 -\n      FLIGHT_hexacopter_P.Constant_Value_ez) * FLIGHT_hexacopter_P.Gain_Gain_mg;\n    FLIGHT_hexacopter_B.BusAssignment_f._padding0[i] = 0U;\n  }\n\n  // End of BusAssignment: '<S569>/Bus Assignment'\n\n  // MATLABSystem: '<S572>/SinkBlock' incorporates:\n  //   BusAssignment: '<S569>/Bus Assignment'\n\n  uORB_write_step(FLIGHT_hexacopter_DW.obj_hf.orbMetadataObj,\n                  &FLIGHT_hexacopter_DW.obj_hf.orbAdvertiseObj,\n                  &FLIGHT_hexacopter_B.BusAssignment_f);\n  FLIGHT_hexac_PX4Timestamp_o(&FLIGHT_hexacopter_B.PX4Timestamp_ok);\n\n  // BusAssignment: '<S570>/Bus Assignment' incorporates:\n  //   Constant: '<S12>/Constant'\n  //   Constant: '<S12>/Constant2'\n  //   DataTypeConversion: '<Root>/Data Type Conversion1'\n  //   MATLABSystem: '<S570>/PX4 Timestamp'\n\n  FLIGHT_hexacopter_B.BusAssignment.timestamp =\n    FLIGHT_hexacopter_B.PX4Timestamp_ok.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment.noutputs =\n    FLIGHT_hexacopter_P.Constant2_Value_e;\n  for (i = 0; i < 6; i++) {\n    FLIGHT_hexacopter_B.BusAssignment.output[i] =\n      FLIGHT_hexacopter_B.DataTypeConversion7_k[i];\n  }\n\n  for (i = 0; i < 10; i++) {\n    FLIGHT_hexacopter_B.BusAssignment.output[i + 6] =\n      FLIGHT_hexacopter_P.Constant_Value_bm[i];\n  }\n\n  FLIGHT_hexacopter_B.BusAssignment._padding0[0] = 0U;\n  FLIGHT_hexacopter_B.BusAssignment._padding0[1] = 0U;\n  FLIGHT_hexacopter_B.BusAssignment._padding0[2] = 0U;\n  FLIGHT_hexacopter_B.BusAssignment._padding0[3] = 0U;\n\n  // End of BusAssignment: '<S570>/Bus Assignment'\n\n  // MATLABSystem: '<S574>/SinkBlock' incorporates:\n  //   BusAssignment: '<S570>/Bus Assignment'\n\n  uORB_write_step(FLIGHT_hexacopter_DW.obj_px.orbMetadataObj,\n                  &FLIGHT_hexacopter_DW.obj_px.orbAdvertiseObj,\n                  &FLIGHT_hexacopter_B.BusAssignment);\n}\n\n// Model step function for TID1\nvoid FLIGHT_hexacopter_step1(void)     // Sample time: [0.005s, 0.0s]\n{\n  real_T rtb_out_yawrate;\n  int32_T i;\n  real32_T ParamStep;\n  real32_T rtb_DeadZone;\n  real32_T rtb_Saturation3;\n  real32_T rtb_SinCos_o2;\n  real32_T rtb_sincos_o1_0;\n  real32_T rtb_sincos_o1_idx_1;\n  real32_T rtb_sincos_o2_idx_1;\n  real32_T tmp_1;\n  int8_T tmp;\n  int8_T tmp_0;\n  boolean_T b_varargout_1;\n  boolean_T rtb_Compare;\n  boolean_T rtb_Compare_o;\n  FLIGHT_hexac_PX4Timestamp_p(&FLIGHT_hexacopter_B.PX4Timestamp_pn);\n\n  // MATLABSystem: '<S410>/SourceBlock'\n  b_varargout_1 = uORB_read_step(FLIGHT_hexacopter_DW.obj_p2.orbMetadataObj,\n    &FLIGHT_hexacopter_DW.obj_p2.eventStructObj, &FLIGHT_hexacopter_B.r2, false,\n    5000.0);\n\n  // Outputs for Enabled SubSystem: '<S410>/Enabled Subsystem' incorporates:\n  //   EnablePort: '<S411>/Enable'\n\n  // Start for MATLABSystem: '<S410>/SourceBlock'\n  if (b_varargout_1) {\n    // SignalConversion generated from: '<S411>/In1'\n    FLIGHT_hexacopter_B.In1_n = FLIGHT_hexacopter_B.r2;\n  }\n\n  // End of Outputs for SubSystem: '<S410>/Enabled Subsystem'\n\n  // SignalConversion generated from: '<S408>/Bus Selector'\n  for (i = 0; i < 18; i++) {\n    FLIGHT_hexacopter_B.values[i] = FLIGHT_hexacopter_B.In1_n.values[i];\n  }\n\n  // End of SignalConversion generated from: '<S408>/Bus Selector'\n\n  // MATLABSystem: '<S401>/SourceBlock'\n  b_varargout_1 = uORB_read_step(FLIGHT_hexacopter_DW.obj_kk.orbMetadataObj,\n    &FLIGHT_hexacopter_DW.obj_kk.eventStructObj, &FLIGHT_hexacopter_B.r, false,\n    1.0);\n\n  // Outputs for Enabled SubSystem: '<S401>/Enabled Subsystem' incorporates:\n  //   EnablePort: '<S403>/Enable'\n\n  // Start for MATLABSystem: '<S401>/SourceBlock'\n  if (b_varargout_1) {\n    // SignalConversion generated from: '<S403>/In1'\n    FLIGHT_hexacopter_B.In1 = FLIGHT_hexacopter_B.r;\n  }\n\n  // End of Outputs for SubSystem: '<S401>/Enabled Subsystem'\n\n  // RelationalOperator: '<S409>/Compare' incorporates:\n  //   Constant: '<S409>/Constant'\n\n  rtb_Compare = (FLIGHT_hexacopter_B.values[4] >=\n                 FLIGHT_hexacopter_P.CompareToConstant3_const);\n\n  // If: '<Root>/If'\n  if ((FLIGHT_hexacopter_B.values[5] > 1400) && (FLIGHT_hexacopter_B.values[5] <\n       1800)) {\n    // Outputs for IfAction SubSystem: '<Root>/Altitude_Mode' incorporates:\n    //   ActionPort: '<S1>/Action Port'\n\n    // Fcn: '<S18>/Fcn2' incorporates:\n    //   DataTypeConversion: '<S18>/Data Type Conversion1'\n\n    rtb_Saturation3 = (static_cast<real32_T>(FLIGHT_hexacopter_B.values[0]) -\n                       1514.0F) / 500.0F;\n\n    // DeadZone: '<S18>/Dead Zone3'\n    if (rtb_Saturation3 > FLIGHT_hexacopter_P.DeadZone3_End) {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone3_End;\n    } else if (rtb_Saturation3 >= FLIGHT_hexacopter_P.DeadZone3_Start) {\n      ParamStep = 0.0F;\n    } else {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone3_Start;\n    }\n\n    // End of DeadZone: '<S18>/Dead Zone3'\n\n    // Saturate: '<S18>/Saturation9'\n    if (ParamStep > FLIGHT_hexacopter_P.Saturation9_UpperSat) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation9_UpperSat;\n    } else if (ParamStep < FLIGHT_hexacopter_P.Saturation9_LowerSat) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation9_LowerSat;\n    }\n\n    // SignalConversion generated from: '<S1>/des_roll' incorporates:\n    //   Gain: '<S18>/Gain1'\n    //   Merge: '<Root>/Merge1'\n    //   Saturate: '<S18>/Saturation9'\n\n    FLIGHT_hexacopter_B.Merge1[0] = FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_ROLL *\n      ParamStep;\n\n    // Fcn: '<S18>/Fcn7' incorporates:\n    //   DataTypeConversion: '<S18>/Data Type Conversion10'\n\n    rtb_Saturation3 = (static_cast<real32_T>(FLIGHT_hexacopter_B.values[3]) -\n                       1514.0F) / 500.0F;\n\n    // DeadZone: '<S18>/Dead Zone2'\n    if (rtb_Saturation3 > FLIGHT_hexacopter_P.DeadZone2_End) {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone2_End;\n    } else if (rtb_Saturation3 >= FLIGHT_hexacopter_P.DeadZone2_Start) {\n      ParamStep = 0.0F;\n    } else {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone2_Start;\n    }\n\n    // End of DeadZone: '<S18>/Dead Zone2'\n\n    // Saturate: '<S18>/Saturation3'\n    if (ParamStep > FLIGHT_hexacopter_P.Saturation3_UpperSat) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation3_UpperSat;\n    } else if (ParamStep < FLIGHT_hexacopter_P.Saturation3_LowerSat) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation3_LowerSat;\n    }\n\n    // SignalConversion generated from: '<S1>/des_r' incorporates:\n    //   Gain: '<S18>/Gain3'\n    //   Merge: '<Root>/Merge1'\n    //   Saturate: '<S18>/Saturation3'\n\n    FLIGHT_hexacopter_B.Merge1[2] = FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_RATE_Y\n      * ParamStep;\n\n    // Fcn: '<S18>/Fcn3' incorporates:\n    //   DataTypeConversion: '<S18>/Data Type Conversion11'\n\n    rtb_Saturation3 = (static_cast<real32_T>(FLIGHT_hexacopter_B.values[2]) -\n                       1514.0F) / 500.0F;\n\n    // DeadZone: '<S18>/Dead Zone4'\n    if (rtb_Saturation3 > FLIGHT_hexacopter_P.DeadZone4_End) {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone4_End;\n    } else if (rtb_Saturation3 >= FLIGHT_hexacopter_P.DeadZone4_Start) {\n      ParamStep = 0.0F;\n    } else {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone4_Start;\n    }\n\n    // End of DeadZone: '<S18>/Dead Zone4'\n\n    // Saturate: '<S18>/Saturation10'\n    if (ParamStep > FLIGHT_hexacopter_P.Saturation10_UpperSat) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation10_UpperSat;\n    } else if (ParamStep < FLIGHT_hexacopter_P.Saturation10_LowerSat) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation10_LowerSat;\n    }\n\n    // Gain: '<S18>/Gain' incorporates:\n    //   Saturate: '<S18>/Saturation10'\n\n    FLIGHT_hexacopter_B.Merge = FLIGHT_hexacopter_P.Gain_Gain_e * ParamStep;\n\n    // Outputs for Enabled SubSystem: '<S1>/Vz Controller' incorporates:\n    //   EnablePort: '<S19>/Enable'\n\n    if (rtb_Compare) {\n      // Gain: '<S19>/Gain' incorporates:\n      //   Sum: '<S19>/Sum3'\n\n      rtb_Saturation3 = (FLIGHT_hexacopter_B.Merge - FLIGHT_hexacopter_B.In1.vz)\n        * FLIGHT_hexacopter_P.Gain_Gain_d;\n      FLIGHT_hexac_ReadParameter3(&FLIGHT_hexacopter_B.ReadParameter3_p,\n        &FLIGHT_hexacopter_DW.ReadParameter3_p);\n\n      // Product: '<S59>/NProd Out' incorporates:\n      //   Constant: '<S19>/Constant'\n      //   DiscreteIntegrator: '<S51>/Filter'\n      //   Product: '<S49>/DProd Out'\n      //   Sum: '<S51>/SumD'\n\n      rtb_SinCos_o2 = (rtb_Saturation3 *\n                       FLIGHT_hexacopter_B.ReadParameter3_p.ReadParameter3_o1 -\n                       FLIGHT_hexacopter_DW.Filter_DSTATE_i) *\n        FLIGHT_hexacopter_P.Constant_Value_bi;\n      FLIGHT_hexac_ReadParameter1(&FLIGHT_hexacopter_B.ReadParameter1_pna,\n        &FLIGHT_hexacopter_DW.ReadParameter1_pna);\n\n      // Sum: '<S65>/Sum' incorporates:\n      //   DiscreteIntegrator: '<S56>/Integrator'\n      //   Product: '<S61>/PProd Out'\n\n      rtb_DeadZone = (rtb_Saturation3 *\n                      FLIGHT_hexacopter_B.ReadParameter1_pna.ReadParameter1_o1 +\n                      FLIGHT_hexacopter_DW.Integrator_DSTATE_e) + rtb_SinCos_o2;\n      FLIGHT_hexaco_ReadParameter(&FLIGHT_hexacopter_B.ReadParameter_pn,\n        &FLIGHT_hexacopter_DW.ReadParameter_pn);\n\n      // Saturate: '<S63>/Saturation'\n      if (rtb_DeadZone > FLIGHT_hexacopter_P.PIDController4_UpperSaturationL) {\n        ParamStep = FLIGHT_hexacopter_P.PIDController4_UpperSaturationL;\n      } else if (rtb_DeadZone <\n                 FLIGHT_hexacopter_P.PIDController4_LowerSaturationL) {\n        ParamStep = FLIGHT_hexacopter_P.PIDController4_LowerSaturationL;\n      } else {\n        ParamStep = rtb_DeadZone;\n      }\n\n      // Sum: '<S19>/Sum6' incorporates:\n      //   Saturate: '<S63>/Saturation'\n\n      FLIGHT_hexacopter_B.Saturation1_i = ParamStep +\n        FLIGHT_hexacopter_B.ReadParameter_pn.ReadParameter_o1;\n\n      // Saturate: '<S19>/Saturation1'\n      if (FLIGHT_hexacopter_B.Saturation1_i >\n          FLIGHT_hexacopter_P.Saturation1_UpperSat) {\n        // Sum: '<S19>/Sum6' incorporates:\n        //   Saturate: '<S19>/Saturation1'\n\n        FLIGHT_hexacopter_B.Saturation1_i =\n          FLIGHT_hexacopter_P.Saturation1_UpperSat;\n      } else if (FLIGHT_hexacopter_B.Saturation1_i <\n                 FLIGHT_hexacopter_P.Saturation1_LowerSat) {\n        // Sum: '<S19>/Sum6' incorporates:\n        //   Saturate: '<S19>/Saturation1'\n\n        FLIGHT_hexacopter_B.Saturation1_i =\n          FLIGHT_hexacopter_P.Saturation1_LowerSat;\n      }\n\n      // End of Saturate: '<S19>/Saturation1'\n\n      // DeadZone: '<S48>/DeadZone'\n      if (rtb_DeadZone > FLIGHT_hexacopter_P.PIDController4_UpperSaturationL) {\n        rtb_DeadZone -= FLIGHT_hexacopter_P.PIDController4_UpperSaturationL;\n      } else if (rtb_DeadZone >=\n                 FLIGHT_hexacopter_P.PIDController4_LowerSaturationL) {\n        rtb_DeadZone = 0.0F;\n      } else {\n        rtb_DeadZone -= FLIGHT_hexacopter_P.PIDController4_LowerSaturationL;\n      }\n\n      // End of DeadZone: '<S48>/DeadZone'\n      FLIGHT_hexac_ReadParameter2(&FLIGHT_hexacopter_B.ReadParameter2_pn,\n        &FLIGHT_hexacopter_DW.ReadParameter2_pn);\n\n      // Product: '<S53>/IProd Out'\n      rtb_Saturation3 *= FLIGHT_hexacopter_B.ReadParameter2_pn.ReadParameter2_o1;\n\n      // Update for DiscreteIntegrator: '<S51>/Filter'\n      FLIGHT_hexacopter_DW.Filter_DSTATE_i += FLIGHT_hexacopter_P.Filter_gainval\n        * rtb_SinCos_o2;\n\n      // Switch: '<S46>/Switch1' incorporates:\n      //   Constant: '<S46>/Clamping_zero'\n      //   Constant: '<S46>/Constant'\n      //   Constant: '<S46>/Constant2'\n      //   RelationalOperator: '<S46>/fix for DT propagation issue'\n\n      if (rtb_DeadZone > FLIGHT_hexacopter_P.Clamping_zero_Value) {\n        tmp = FLIGHT_hexacopter_P.Constant_Value_jc;\n      } else {\n        tmp = FLIGHT_hexacopter_P.Constant2_Value_mj;\n      }\n\n      // Switch: '<S46>/Switch2' incorporates:\n      //   Constant: '<S46>/Clamping_zero'\n      //   Constant: '<S46>/Constant3'\n      //   Constant: '<S46>/Constant4'\n      //   RelationalOperator: '<S46>/fix for DT propagation issue1'\n\n      if (rtb_Saturation3 > FLIGHT_hexacopter_P.Clamping_zero_Value) {\n        tmp_0 = FLIGHT_hexacopter_P.Constant3_Value_es;\n      } else {\n        tmp_0 = FLIGHT_hexacopter_P.Constant4_Value_j;\n      }\n\n      // Switch: '<S46>/Switch' incorporates:\n      //   Constant: '<S46>/Clamping_zero'\n      //   Constant: '<S46>/Constant1'\n      //   Logic: '<S46>/AND3'\n      //   RelationalOperator: '<S46>/Equal1'\n      //   RelationalOperator: '<S46>/Relational Operator'\n      //   Switch: '<S46>/Switch1'\n      //   Switch: '<S46>/Switch2'\n\n      if ((FLIGHT_hexacopter_P.Clamping_zero_Value != rtb_DeadZone) && (tmp ==\n           tmp_0)) {\n        rtb_Saturation3 = FLIGHT_hexacopter_P.Constant1_Value_n;\n      }\n\n      // Update for DiscreteIntegrator: '<S56>/Integrator' incorporates:\n      //   Switch: '<S46>/Switch'\n\n      FLIGHT_hexacopter_DW.Integrator_DSTATE_e +=\n        FLIGHT_hexacopter_P.Integrator_gainval * rtb_Saturation3;\n    }\n\n    // End of Outputs for SubSystem: '<S1>/Vz Controller'\n\n    // SignalConversion generated from: '<S1>/throttle' incorporates:\n    //   Merge: '<Root>/Merge1'\n\n    FLIGHT_hexacopter_B.Merge1[3] = FLIGHT_hexacopter_B.Saturation1_i;\n\n    // Fcn: '<S18>/Fcn1' incorporates:\n    //   DataTypeConversion: '<S18>/Data Type Conversion2'\n\n    rtb_Saturation3 = (static_cast<real32_T>(FLIGHT_hexacopter_B.values[1]) -\n                       1514.0F) / 500.0F;\n\n    // DeadZone: '<S18>/Dead Zone1'\n    if (rtb_Saturation3 > FLIGHT_hexacopter_P.DeadZone1_End) {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone1_End;\n    } else if (rtb_Saturation3 >= FLIGHT_hexacopter_P.DeadZone1_Start) {\n      ParamStep = 0.0F;\n    } else {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone1_Start;\n    }\n\n    // End of DeadZone: '<S18>/Dead Zone1'\n\n    // Saturate: '<S18>/Saturation1'\n    if (ParamStep > FLIGHT_hexacopter_P.Saturation1_UpperSat_d) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation1_UpperSat_d;\n    } else if (ParamStep < FLIGHT_hexacopter_P.Saturation1_LowerSat_b) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation1_LowerSat_b;\n    }\n\n    // SignalConversion generated from: '<S1>/des_pitch' incorporates:\n    //   Gain: '<S18>/Gain2'\n    //   Merge: '<Root>/Merge1'\n    //   Saturate: '<S18>/Saturation1'\n\n    FLIGHT_hexacopter_B.Merge1[1] = FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_PITCH *\n      ParamStep;\n\n    // End of Outputs for SubSystem: '<Root>/Altitude_Mode'\n  } else if (FLIGHT_hexacopter_B.values[5] >= 1800) {\n    // Outputs for IfAction SubSystem: '<Root>/If Action Subsystem' incorporates:\n    //   ActionPort: '<S5>/Action Port'\n\n    // Outputs for Enabled SubSystem: '<S5>/XY Pos Controller' incorporates:\n    //   EnablePort: '<S190>/Enable'\n\n    if (rtb_Compare) {\n      // MATLABSystem: '<S190>/Read Parameter'\n      if (FLIGHT_hexacopter_DW.obj_eq.SampleTime !=\n          FLIGHT_hexacopter_P.SampleTime) {\n        FLIGHT_hexacopter_DW.obj_eq.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n      }\n\n      b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_eq.MW_PARAMHANDLE,\n        MW_SINGLE, &ParamStep);\n      if (b_varargout_1) {\n        ParamStep = 0.0F;\n      }\n\n      // Product: '<S335>/PProd Out' incorporates:\n      //   Constant: '<S5>/Constant'\n      //   MATLABSystem: '<S190>/Read Parameter'\n      //   Sum: '<S190>/Sum'\n      //\n      FLIGHT_hexacopter_B.PProdOut[0] = (FLIGHT_hexacopter_P.Constant_Value_k[0]\n        - FLIGHT_hexacopter_B.In1.x) * ParamStep;\n      FLIGHT_hexacopter_B.PProdOut[1] = (FLIGHT_hexacopter_P.Constant_Value_k[1]\n        - FLIGHT_hexacopter_B.In1.y) * ParamStep;\n    }\n\n    // End of Outputs for SubSystem: '<S5>/XY Pos Controller'\n\n    // SignalConversion generated from: '<S5>/des_xy' incorporates:\n    //   Constant: '<S5>/Constant'\n\n    FLIGHT_hexacopter_B.OutportBufferFordes_xy[0] =\n      FLIGHT_hexacopter_P.Constant_Value_k[0];\n    FLIGHT_hexacopter_B.OutportBufferFordes_xy[1] =\n      FLIGHT_hexacopter_P.Constant_Value_k[1];\n\n    // Outputs for Enabled SubSystem: '<S5>/XY Velocity Controller' incorporates:\n    //   EnablePort: '<S191>/Enable'\n\n    if (rtb_Compare) {\n      // Trigonometry: '<S349>/SinCos'\n      rtb_Saturation3 = static_cast<real32_T>(sin(static_cast<real_T>\n        (FLIGHT_hexacopter_B.In1.heading)));\n      rtb_SinCos_o2 = static_cast<real32_T>(cos(static_cast<real_T>\n        (FLIGHT_hexacopter_B.In1.heading)));\n\n      // MATLABSystem: '<S191>/Read Parameter'\n      if (FLIGHT_hexacopter_DW.obj_pi.SampleTime !=\n          FLIGHT_hexacopter_P.SampleTime) {\n        FLIGHT_hexacopter_DW.obj_pi.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n      }\n\n      b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_pi.MW_PARAMHANDLE,\n        MW_SINGLE, &ParamStep);\n      if (b_varargout_1) {\n        ParamStep = 0.0F;\n      }\n\n      // Sum: '<S191>/Sum'\n      rtb_DeadZone = FLIGHT_hexacopter_B.PProdOut[0] -\n        FLIGHT_hexacopter_B.In1.vx;\n      rtb_sincos_o2_idx_1 = FLIGHT_hexacopter_B.PProdOut[1] -\n        FLIGHT_hexacopter_B.In1.vy;\n\n      // Saturate: '<S191>/Saturation' incorporates:\n      //   Gain: '<S349>/Gain'\n      //   MATLABSystem: '<S191>/Read Parameter'\n      //   Product: '<S347>/MatrixMultiply'\n      //   Product: '<S388>/PProd Out'\n      //   Reshape: '<S349>/Reshape'\n      //   Reshape: '<S349>/Reshape1'\n      //\n      rtb_sincos_o1_idx_1 = (rtb_SinCos_o2 * rtb_DeadZone + rtb_Saturation3 *\n        rtb_sincos_o2_idx_1) * ParamStep;\n      if (rtb_sincos_o1_idx_1 > FLIGHT_hexacopter_P.Saturation_UpperSat_e) {\n        // Saturate: '<S191>/Saturation'\n        FLIGHT_hexacopter_B.Saturation[0] =\n          FLIGHT_hexacopter_P.Saturation_UpperSat_e;\n      } else if (rtb_sincos_o1_idx_1 < FLIGHT_hexacopter_P.Saturation_LowerSat_a)\n      {\n        // Saturate: '<S191>/Saturation'\n        FLIGHT_hexacopter_B.Saturation[0] =\n          FLIGHT_hexacopter_P.Saturation_LowerSat_a;\n      } else {\n        // Saturate: '<S191>/Saturation'\n        FLIGHT_hexacopter_B.Saturation[0] = rtb_sincos_o1_idx_1;\n      }\n\n      rtb_sincos_o1_idx_1 = (FLIGHT_hexacopter_P.Gain_Gain_a * rtb_Saturation3 *\n        rtb_DeadZone + rtb_SinCos_o2 * rtb_sincos_o2_idx_1) * ParamStep;\n      if (rtb_sincos_o1_idx_1 > FLIGHT_hexacopter_P.Saturation_UpperSat_e) {\n        // Saturate: '<S191>/Saturation'\n        FLIGHT_hexacopter_B.Saturation[1] =\n          FLIGHT_hexacopter_P.Saturation_UpperSat_e;\n      } else if (rtb_sincos_o1_idx_1 < FLIGHT_hexacopter_P.Saturation_LowerSat_a)\n      {\n        // Saturate: '<S191>/Saturation'\n        FLIGHT_hexacopter_B.Saturation[1] =\n          FLIGHT_hexacopter_P.Saturation_LowerSat_a;\n      } else {\n        // Saturate: '<S191>/Saturation'\n        FLIGHT_hexacopter_B.Saturation[1] = rtb_sincos_o1_idx_1;\n      }\n\n      // End of Saturate: '<S191>/Saturation'\n\n      // Gain: '<S191>/Gain1'\n      FLIGHT_hexacopter_B.Gain1 = FLIGHT_hexacopter_P.Gain1_Gain_i *\n        FLIGHT_hexacopter_B.Saturation[0];\n    }\n\n    // End of Outputs for SubSystem: '<S5>/XY Velocity Controller'\n\n    // SignalConversion generated from: '<S5>/des_pitch' incorporates:\n    //   Merge: '<Root>/Merge1'\n\n    FLIGHT_hexacopter_B.Merge1[1] = FLIGHT_hexacopter_B.Gain1;\n\n    // SignalConversion generated from: '<S5>/des_roll' incorporates:\n    //   Merge: '<Root>/Merge1'\n\n    FLIGHT_hexacopter_B.Merge1[0] = FLIGHT_hexacopter_B.Saturation[1];\n\n    // Fcn: '<S188>/Fcn3' incorporates:\n    //   DataTypeConversion: '<S188>/Data Type Conversion11'\n\n    rtb_Saturation3 = (static_cast<real32_T>(FLIGHT_hexacopter_B.values[2]) -\n                       1514.0F) / 500.0F;\n\n    // DeadZone: '<S188>/Dead Zone4'\n    if (rtb_Saturation3 > FLIGHT_hexacopter_P.DeadZone4_End_l) {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone4_End_l;\n    } else if (rtb_Saturation3 >= FLIGHT_hexacopter_P.DeadZone4_Start_d) {\n      ParamStep = 0.0F;\n    } else {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone4_Start_d;\n    }\n\n    // End of DeadZone: '<S188>/Dead Zone4'\n\n    // Saturate: '<S188>/Saturation10'\n    if (ParamStep > FLIGHT_hexacopter_P.Saturation10_UpperSat_m) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation10_UpperSat_m;\n    } else if (ParamStep < FLIGHT_hexacopter_P.Saturation10_LowerSat_n) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation10_LowerSat_n;\n    }\n\n    // Sum: '<S5>/Add' incorporates:\n    //   Gain: '<S188>/Gain'\n    //   Saturate: '<S188>/Saturation10'\n\n    FLIGHT_hexacopter_B.Add = FLIGHT_hexacopter_P.Gain_Gain_o * ParamStep +\n      FLIGHT_hexacopter_B.In1.z;\n\n    // Outputs for Enabled SubSystem: '<S5>/Vz Controller' incorporates:\n    //   EnablePort: '<S189>/Enable'\n\n    // Outputs for Enabled SubSystem: '<S5>/Altitude Controller' incorporates:\n    //   EnablePort: '<S187>/Enable'\n\n    if (rtb_Compare) {\n      // MATLABSystem: '<S187>/Read Parameter1'\n      if (FLIGHT_hexacopter_DW.obj_m.SampleTime !=\n          FLIGHT_hexacopter_P.SampleTime) {\n        FLIGHT_hexacopter_DW.obj_m.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n      }\n\n      b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_m.MW_PARAMHANDLE,\n        MW_SINGLE, &ParamStep);\n      if (b_varargout_1) {\n        ParamStep = 0.0F;\n      }\n\n      // Product: '<S231>/PProd Out' incorporates:\n      //   MATLABSystem: '<S187>/Read Parameter1'\n      //   Sum: '<S187>/Sum'\n      //\n      FLIGHT_hexacopter_B.des_vz = (FLIGHT_hexacopter_B.Add -\n        FLIGHT_hexacopter_B.In1.z) * ParamStep;\n\n      // Saturate: '<S233>/Saturation'\n      if (FLIGHT_hexacopter_B.des_vz >\n          FLIGHT_hexacopter_P.PIDController4_UpperSaturatio_h) {\n        // Product: '<S231>/PProd Out' incorporates:\n        //   SignalConversion generated from: '<S189>/des_vz'\n\n        FLIGHT_hexacopter_B.des_vz =\n          FLIGHT_hexacopter_P.PIDController4_UpperSaturatio_h;\n      } else if (FLIGHT_hexacopter_B.des_vz <\n                 FLIGHT_hexacopter_P.PIDController4_LowerSaturatio_a) {\n        // Product: '<S231>/PProd Out' incorporates:\n        //   SignalConversion generated from: '<S189>/des_vz'\n\n        FLIGHT_hexacopter_B.des_vz =\n          FLIGHT_hexacopter_P.PIDController4_LowerSaturatio_a;\n      }\n\n      // End of Saturate: '<S233>/Saturation'\n\n      // Gain: '<S189>/Gain' incorporates:\n      //   Sum: '<S189>/Sum3'\n\n      rtb_Saturation3 = (FLIGHT_hexacopter_B.des_vz - FLIGHT_hexacopter_B.In1.vz)\n        * FLIGHT_hexacopter_P.Gain_Gain_b;\n      FLIGHT_hexac_ReadParameter3(&FLIGHT_hexacopter_B.ReadParameter3_pn,\n        &FLIGHT_hexacopter_DW.ReadParameter3_pn);\n\n      // DiscreteIntegrator: '<S274>/Filter'\n      if ((FLIGHT_hexacopter_B.des_vz > 0.0F) &&\n          (FLIGHT_hexacopter_DW.Filter_PrevResetState <= 0)) {\n        FLIGHT_hexacopter_DW.Filter_DSTATE_g =\n          FLIGHT_hexacopter_P.PIDController4_InitialConditi_l;\n      }\n\n      // Product: '<S282>/NProd Out' incorporates:\n      //   Constant: '<S189>/Constant'\n      //   DiscreteIntegrator: '<S274>/Filter'\n      //   Product: '<S272>/DProd Out'\n      //   Sum: '<S274>/SumD'\n\n      rtb_SinCos_o2 = (rtb_Saturation3 *\n                       FLIGHT_hexacopter_B.ReadParameter3_pn.ReadParameter3_o1 -\n                       FLIGHT_hexacopter_DW.Filter_DSTATE_g) *\n        FLIGHT_hexacopter_P.Constant_Value_e;\n      FLIGHT_hexac_ReadParameter1(&FLIGHT_hexacopter_B.ReadParameter1_pnaev,\n        &FLIGHT_hexacopter_DW.ReadParameter1_pnaev);\n\n      // DiscreteIntegrator: '<S279>/Integrator'\n      if ((FLIGHT_hexacopter_B.des_vz > 0.0F) &&\n          (FLIGHT_hexacopter_DW.Integrator_PrevResetState <= 0)) {\n        FLIGHT_hexacopter_DW.Integrator_DSTATE_k =\n          FLIGHT_hexacopter_P.PIDController4_InitialConditi_i;\n      }\n\n      // Sum: '<S288>/Sum' incorporates:\n      //   DiscreteIntegrator: '<S279>/Integrator'\n      //   Product: '<S284>/PProd Out'\n\n      rtb_DeadZone = (rtb_Saturation3 *\n                      FLIGHT_hexacopter_B.ReadParameter1_pnaev.ReadParameter1_o1\n                      + FLIGHT_hexacopter_DW.Integrator_DSTATE_k) +\n        rtb_SinCos_o2;\n      FLIGHT_hexaco_ReadParameter(&FLIGHT_hexacopter_B.ReadParameter_pna,\n        &FLIGHT_hexacopter_DW.ReadParameter_pna);\n\n      // Saturate: '<S286>/Saturation'\n      if (rtb_DeadZone > FLIGHT_hexacopter_P.PIDController4_UpperSaturati_hy) {\n        ParamStep = FLIGHT_hexacopter_P.PIDController4_UpperSaturati_hy;\n      } else if (rtb_DeadZone <\n                 FLIGHT_hexacopter_P.PIDController4_LowerSaturatio_f) {\n        ParamStep = FLIGHT_hexacopter_P.PIDController4_LowerSaturatio_f;\n      } else {\n        ParamStep = rtb_DeadZone;\n      }\n\n      // Sum: '<S189>/Sum6' incorporates:\n      //   Saturate: '<S286>/Saturation'\n\n      FLIGHT_hexacopter_B.Saturation1 = ParamStep +\n        FLIGHT_hexacopter_B.ReadParameter_pna.ReadParameter_o1;\n\n      // Saturate: '<S189>/Saturation1'\n      if (FLIGHT_hexacopter_B.Saturation1 >\n          FLIGHT_hexacopter_P.Saturation1_UpperSat_e) {\n        // Sum: '<S189>/Sum6' incorporates:\n        //   Saturate: '<S189>/Saturation1'\n\n        FLIGHT_hexacopter_B.Saturation1 =\n          FLIGHT_hexacopter_P.Saturation1_UpperSat_e;\n      } else if (FLIGHT_hexacopter_B.Saturation1 <\n                 FLIGHT_hexacopter_P.Saturation1_LowerSat_bn) {\n        // Sum: '<S189>/Sum6' incorporates:\n        //   Saturate: '<S189>/Saturation1'\n\n        FLIGHT_hexacopter_B.Saturation1 =\n          FLIGHT_hexacopter_P.Saturation1_LowerSat_bn;\n      }\n\n      // End of Saturate: '<S189>/Saturation1'\n\n      // DeadZone: '<S271>/DeadZone'\n      if (rtb_DeadZone > FLIGHT_hexacopter_P.PIDController4_UpperSaturati_hy) {\n        rtb_DeadZone -= FLIGHT_hexacopter_P.PIDController4_UpperSaturati_hy;\n      } else if (rtb_DeadZone >=\n                 FLIGHT_hexacopter_P.PIDController4_LowerSaturatio_f) {\n        rtb_DeadZone = 0.0F;\n      } else {\n        rtb_DeadZone -= FLIGHT_hexacopter_P.PIDController4_LowerSaturatio_f;\n      }\n\n      // End of DeadZone: '<S271>/DeadZone'\n      FLIGHT_hexac_ReadParameter2(&FLIGHT_hexacopter_B.ReadParameter2_pna,\n        &FLIGHT_hexacopter_DW.ReadParameter2_pna);\n\n      // Product: '<S276>/IProd Out'\n      rtb_Saturation3 *=\n        FLIGHT_hexacopter_B.ReadParameter2_pna.ReadParameter2_o1;\n\n      // Update for DiscreteIntegrator: '<S274>/Filter'\n      FLIGHT_hexacopter_DW.Filter_DSTATE_g +=\n        FLIGHT_hexacopter_P.Filter_gainval_h * rtb_SinCos_o2;\n      if (FLIGHT_hexacopter_B.des_vz > 0.0F) {\n        FLIGHT_hexacopter_DW.Filter_PrevResetState = 1;\n      } else if (FLIGHT_hexacopter_B.des_vz < 0.0F) {\n        FLIGHT_hexacopter_DW.Filter_PrevResetState = -1;\n      } else if (FLIGHT_hexacopter_B.des_vz == 0.0F) {\n        FLIGHT_hexacopter_DW.Filter_PrevResetState = 0;\n      } else {\n        FLIGHT_hexacopter_DW.Filter_PrevResetState = 2;\n      }\n\n      // End of Update for DiscreteIntegrator: '<S274>/Filter'\n\n      // Switch: '<S269>/Switch1' incorporates:\n      //   Constant: '<S269>/Clamping_zero'\n      //   Constant: '<S269>/Constant'\n      //   Constant: '<S269>/Constant2'\n      //   RelationalOperator: '<S269>/fix for DT propagation issue'\n\n      if (rtb_DeadZone > FLIGHT_hexacopter_P.Clamping_zero_Value_f) {\n        tmp = FLIGHT_hexacopter_P.Constant_Value_mn;\n      } else {\n        tmp = FLIGHT_hexacopter_P.Constant2_Value_p;\n      }\n\n      // Switch: '<S269>/Switch2' incorporates:\n      //   Constant: '<S269>/Clamping_zero'\n      //   Constant: '<S269>/Constant3'\n      //   Constant: '<S269>/Constant4'\n      //   RelationalOperator: '<S269>/fix for DT propagation issue1'\n\n      if (rtb_Saturation3 > FLIGHT_hexacopter_P.Clamping_zero_Value_f) {\n        tmp_0 = FLIGHT_hexacopter_P.Constant3_Value_n;\n      } else {\n        tmp_0 = FLIGHT_hexacopter_P.Constant4_Value_i;\n      }\n\n      // Switch: '<S269>/Switch' incorporates:\n      //   Constant: '<S269>/Clamping_zero'\n      //   Constant: '<S269>/Constant1'\n      //   Logic: '<S269>/AND3'\n      //   RelationalOperator: '<S269>/Equal1'\n      //   RelationalOperator: '<S269>/Relational Operator'\n      //   Switch: '<S269>/Switch1'\n      //   Switch: '<S269>/Switch2'\n\n      if ((FLIGHT_hexacopter_P.Clamping_zero_Value_f != rtb_DeadZone) && (tmp ==\n           tmp_0)) {\n        rtb_Saturation3 = FLIGHT_hexacopter_P.Constant1_Value_m;\n      }\n\n      // Update for DiscreteIntegrator: '<S279>/Integrator' incorporates:\n      //   Switch: '<S269>/Switch'\n\n      FLIGHT_hexacopter_DW.Integrator_DSTATE_k +=\n        FLIGHT_hexacopter_P.Integrator_gainval_l * rtb_Saturation3;\n      if (FLIGHT_hexacopter_B.des_vz > 0.0F) {\n        FLIGHT_hexacopter_DW.Integrator_PrevResetState = 1;\n      } else if (FLIGHT_hexacopter_B.des_vz < 0.0F) {\n        FLIGHT_hexacopter_DW.Integrator_PrevResetState = -1;\n      } else if (FLIGHT_hexacopter_B.des_vz == 0.0F) {\n        FLIGHT_hexacopter_DW.Integrator_PrevResetState = 0;\n      } else {\n        FLIGHT_hexacopter_DW.Integrator_PrevResetState = 2;\n      }\n\n      // End of Update for DiscreteIntegrator: '<S279>/Integrator'\n    }\n\n    // End of Outputs for SubSystem: '<S5>/Altitude Controller'\n    // End of Outputs for SubSystem: '<S5>/Vz Controller'\n\n    // Gain: '<S18>/Gain' incorporates:\n    //   Merge: '<Root>/Merge'\n    //   SignalConversion generated from: '<S5>/des_vz'\n\n    FLIGHT_hexacopter_B.Merge = FLIGHT_hexacopter_B.des_vz;\n\n    // SignalConversion generated from: '<S5>/throttle' incorporates:\n    //   Merge: '<Root>/Merge1'\n\n    FLIGHT_hexacopter_B.Merge1[3] = FLIGHT_hexacopter_B.Saturation1;\n\n    // Fcn: '<S188>/Fcn7' incorporates:\n    //   DataTypeConversion: '<S188>/Data Type Conversion10'\n\n    rtb_Saturation3 = (static_cast<real32_T>(FLIGHT_hexacopter_B.values[3]) -\n                       1514.0F) / 500.0F;\n\n    // DeadZone: '<S188>/Dead Zone2'\n    if (rtb_Saturation3 > FLIGHT_hexacopter_P.DeadZone2_End_k) {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone2_End_k;\n    } else if (rtb_Saturation3 >= FLIGHT_hexacopter_P.DeadZone2_Start_k) {\n      ParamStep = 0.0F;\n    } else {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone2_Start_k;\n    }\n\n    // End of DeadZone: '<S188>/Dead Zone2'\n\n    // Saturate: '<S188>/Saturation3'\n    if (ParamStep > FLIGHT_hexacopter_P.Saturation3_UpperSat_b) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation3_UpperSat_b;\n    } else if (ParamStep < FLIGHT_hexacopter_P.Saturation3_LowerSat_a) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation3_LowerSat_a;\n    }\n\n    // SignalConversion generated from: '<S5>/des_r' incorporates:\n    //   Gain: '<S188>/Gain3'\n    //   Merge: '<Root>/Merge1'\n    //   Saturate: '<S188>/Saturation3'\n\n    FLIGHT_hexacopter_B.Merge1[2] = FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_RATE_Y\n      * ParamStep;\n\n    // End of Outputs for SubSystem: '<Root>/If Action Subsystem'\n  } else {\n    // Outputs for IfAction SubSystem: '<Root>/Stabilized_Mode' incorporates:\n    //   ActionPort: '<S10>/Action Port'\n\n    // Gain: '<S10>/Gain' incorporates:\n    //   Constant: '<S10>/Constant'\n    //   Sum: '<S10>/Sum'\n\n    rtb_Saturation3 = static_cast<real32_T>((static_cast<real_T>\n      (FLIGHT_hexacopter_B.values[2]) - FLIGHT_hexacopter_P.Constant_Value_c) *\n      FLIGHT_hexacopter_P.Gain_Gain);\n\n    // DeadZone: '<S10>/Dead Zone3'\n    if (rtb_Saturation3 > FLIGHT_hexacopter_P.DeadZone3_End_l) {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone3_End_l;\n    } else if (rtb_Saturation3 >= FLIGHT_hexacopter_P.DeadZone3_Start_p) {\n      ParamStep = 0.0F;\n    } else {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone3_Start_p;\n    }\n\n    // End of DeadZone: '<S10>/Dead Zone3'\n\n    // Saturate: '<S10>/Saturation'\n    if (ParamStep > FLIGHT_hexacopter_P.Saturation_UpperSat_o) {\n      // SignalConversion generated from: '<S10>/throttle' incorporates:\n      //   Merge: '<Root>/Merge1'\n\n      FLIGHT_hexacopter_B.Merge1[3] = FLIGHT_hexacopter_P.Saturation_UpperSat_o;\n    } else if (ParamStep < FLIGHT_hexacopter_P.Saturation_LowerSat_el) {\n      // SignalConversion generated from: '<S10>/throttle' incorporates:\n      //   Merge: '<Root>/Merge1'\n\n      FLIGHT_hexacopter_B.Merge1[3] = FLIGHT_hexacopter_P.Saturation_LowerSat_el;\n    } else {\n      // SignalConversion generated from: '<S10>/throttle' incorporates:\n      //   Merge: '<Root>/Merge1'\n\n      FLIGHT_hexacopter_B.Merge1[3] = ParamStep;\n    }\n\n    // End of Saturate: '<S10>/Saturation'\n\n    // Gain: '<S10>/Gain2' incorporates:\n    //   Constant: '<S10>/Constant1'\n    //   Sum: '<S10>/Sum1'\n\n    rtb_Saturation3 = (static_cast<real32_T>(FLIGHT_hexacopter_B.values[3]) -\n                       FLIGHT_hexacopter_P.Constant1_Value_l) *\n      FLIGHT_hexacopter_P.Gain2_Gain;\n\n    // DeadZone: '<S10>/Dead Zone2'\n    if (rtb_Saturation3 > FLIGHT_hexacopter_P.DeadZone2_End_e) {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone2_End_e;\n    } else if (rtb_Saturation3 >= FLIGHT_hexacopter_P.DeadZone2_Start_o) {\n      ParamStep = 0.0F;\n    } else {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone2_Start_o;\n    }\n\n    // End of DeadZone: '<S10>/Dead Zone2'\n\n    // Saturate: '<S10>/Saturation1'\n    if (ParamStep > FLIGHT_hexacopter_P.Saturation1_UpperSat_l) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation1_UpperSat_l;\n    } else if (ParamStep < FLIGHT_hexacopter_P.Saturation1_LowerSat_i) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation1_LowerSat_i;\n    }\n\n    // SignalConversion generated from: '<S10>/des_r' incorporates:\n    //   Gain: '<S10>/Gain6'\n    //   Merge: '<Root>/Merge1'\n    //   Saturate: '<S10>/Saturation1'\n\n    FLIGHT_hexacopter_B.Merge1[2] = FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_RATE_Y\n      * ParamStep;\n\n    // Gain: '<S10>/Gain1' incorporates:\n    //   Constant: '<S10>/Constant2'\n    //   Sum: '<S10>/Sum2'\n\n    rtb_Saturation3 = (static_cast<real32_T>(FLIGHT_hexacopter_B.values[1]) -\n                       FLIGHT_hexacopter_P.Constant2_Value_i) *\n      FLIGHT_hexacopter_P.Gain1_Gain_m;\n\n    // DeadZone: '<S10>/Dead Zone1'\n    if (rtb_Saturation3 > FLIGHT_hexacopter_P.DeadZone1_End_m) {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone1_End_m;\n    } else if (rtb_Saturation3 >= FLIGHT_hexacopter_P.DeadZone1_Start_c) {\n      ParamStep = 0.0F;\n    } else {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone1_Start_c;\n    }\n\n    // End of DeadZone: '<S10>/Dead Zone1'\n\n    // Saturate: '<S10>/Saturation2'\n    if (ParamStep > FLIGHT_hexacopter_P.Saturation2_UpperSat) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation2_UpperSat;\n    } else if (ParamStep < FLIGHT_hexacopter_P.Saturation2_LowerSat) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation2_LowerSat;\n    }\n\n    // SignalConversion generated from: '<S10>/des_P' incorporates:\n    //   Gain: '<S10>/Gain5'\n    //   Merge: '<Root>/Merge1'\n    //   Saturate: '<S10>/Saturation2'\n\n    FLIGHT_hexacopter_B.Merge1[1] = FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_PITCH *\n      ParamStep;\n\n    // Gain: '<S10>/Gain3' incorporates:\n    //   Constant: '<S10>/Constant3'\n    //   Sum: '<S10>/Sum3'\n\n    rtb_Saturation3 = (static_cast<real32_T>(FLIGHT_hexacopter_B.values[0]) -\n                       FLIGHT_hexacopter_P.Constant3_Value_e) *\n      FLIGHT_hexacopter_P.Gain3_Gain;\n\n    // DeadZone: '<S10>/Dead Zone'\n    if (rtb_Saturation3 > FLIGHT_hexacopter_P.DeadZone_End) {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone_End;\n    } else if (rtb_Saturation3 >= FLIGHT_hexacopter_P.DeadZone_Start) {\n      ParamStep = 0.0F;\n    } else {\n      ParamStep = rtb_Saturation3 - FLIGHT_hexacopter_P.DeadZone_Start;\n    }\n\n    // End of DeadZone: '<S10>/Dead Zone'\n\n    // Saturate: '<S10>/Saturation3'\n    if (ParamStep > FLIGHT_hexacopter_P.Saturation3_UpperSat_b4) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation3_UpperSat_b4;\n    } else if (ParamStep < FLIGHT_hexacopter_P.Saturation3_LowerSat_j) {\n      ParamStep = FLIGHT_hexacopter_P.Saturation3_LowerSat_j;\n    }\n\n    // Gain: '<S10>/Gain4' incorporates:\n    //   Merge: '<Root>/Merge1'\n    //   Saturate: '<S10>/Saturation3'\n\n    FLIGHT_hexacopter_B.Merge1[0] = FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_ROLL *\n      ParamStep;\n\n    // End of Outputs for SubSystem: '<Root>/Stabilized_Mode'\n  }\n\n  // End of If: '<Root>/If'\n\n  // RelationalOperator: '<S407>/Compare' incorporates:\n  //   Constant: '<S407>/Constant'\n\n  rtb_Compare_o = (FLIGHT_hexacopter_B.values[6] >=\n                   FLIGHT_hexacopter_P.CompareToConstant_const_n);\n  FLIGHT_hexacop_PX4Timestamp(&FLIGHT_hexacopter_B.PX4Timestamp);\n\n  // MATLABSystem: '<S3>/Read Parameter1'\n  if (FLIGHT_hexacopter_DW.obj_ct.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n  {\n    FLIGHT_hexacopter_DW.obj_ct.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_ct.MW_PARAMHANDLE,\n    MW_SINGLE, &ParamStep);\n  if (b_varargout_1) {\n    ParamStep = 0.0F;\n  }\n\n  // MATLABSystem: '<S3>/Read Parameter'\n  if (FLIGHT_hexacopter_DW.obj_cf.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n  {\n    FLIGHT_hexacopter_DW.obj_cf.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_cf.MW_PARAMHANDLE,\n    MW_SINGLE, &rtb_Saturation3);\n  if (b_varargout_1) {\n    rtb_Saturation3 = 0.0F;\n  }\n\n  // MATLABSystem: '<S3>/Read Parameter2'\n  if (FLIGHT_hexacopter_DW.obj_l.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    FLIGHT_hexacopter_DW.obj_l.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_l.MW_PARAMHANDLE,\n    MW_INT32, &i);\n  if (b_varargout_1) {\n    i = 0;\n  }\n\n  // MATLAB Function: '<S3>/MATLAB Function' incorporates:\n  //   DataTypeConversion: '<S3>/Data Type Conversion'\n  //   DataTypeConversion: '<S3>/Data Type Conversion1'\n  //   DataTypeConversion: '<S3>/Data Type Conversion2'\n  //   DataTypeConversion: '<S3>/Data Type Conversion3'\n  //   DataTypeConversion: '<S3>/Data Type Conversion4'\n  //   DataTypeConversion: '<S3>/Data Type Conversion5'\n  //   MATLABSystem: '<S3>/PX4 Timestamp'\n  //   MATLABSystem: '<S3>/Read Parameter'\n  //   MATLABSystem: '<S3>/Read Parameter1'\n  //   MATLABSystem: '<S3>/Read Parameter2'\n  //\n  FLIGHT_hexacopter_B.out_roll = FLIGHT_hexacopter_B.Merge1[0];\n  FLIGHT_hexacopter_B.out_pitch = FLIGHT_hexacopter_B.Merge1[1];\n  rtb_out_yawrate = FLIGHT_hexacopter_B.Merge1[2];\n  if (rtb_Compare_o && (FLIGHT_hexacopter_DW.start_time_usec == -1.0)) {\n    FLIGHT_hexacopter_DW.start_time_usec = static_cast<real_T>\n      (FLIGHT_hexacopter_B.PX4Timestamp.PX4Timestamp);\n  }\n\n  if (rtb_Compare_o && (FLIGHT_hexacopter_DW.start_time_usec > 0.0)) {\n    //  time calculation\n    FLIGHT_hexacopter_B.reletive_time_sec = (static_cast<real_T>\n      (FLIGHT_hexacopter_B.PX4Timestamp.PX4Timestamp) -\n      FLIGHT_hexacopter_DW.start_time_usec) * 1.0E-6;\n  } else {\n    FLIGHT_hexacopter_DW.start_time_usec = -1.0;\n    FLIGHT_hexacopter_B.reletive_time_sec = 0.0;\n  }\n\n  //  Define Doublet\n  FLIGHT_hexacopter_B.peak_angle_rad = ParamStep * 0.017453292519943295;\n\n  //  Default Output\n  //  Generate Doublet Command\n  if (rtb_Compare_o) {\n    switch (i) {\n     case 1:\n      if ((FLIGHT_hexacopter_B.reletive_time_sec >= 0.0) &&\n          (FLIGHT_hexacopter_B.reletive_time_sec < rtb_Saturation3)) {\n        FLIGHT_hexacopter_B.out_roll = FLIGHT_hexacopter_B.peak_angle_rad;\n      } else if ((FLIGHT_hexacopter_B.reletive_time_sec >= rtb_Saturation3) &&\n                 (FLIGHT_hexacopter_B.reletive_time_sec < static_cast<real_T>\n                  (rtb_Saturation3) + rtb_Saturation3)) {\n        FLIGHT_hexacopter_B.out_roll = -FLIGHT_hexacopter_B.peak_angle_rad;\n      } else {\n        FLIGHT_hexacopter_B.out_roll = 0.0;\n      }\n      break;\n\n     case 2:\n      if ((FLIGHT_hexacopter_B.reletive_time_sec >= 0.0) &&\n          (FLIGHT_hexacopter_B.reletive_time_sec < rtb_Saturation3)) {\n        FLIGHT_hexacopter_B.out_pitch = FLIGHT_hexacopter_B.peak_angle_rad;\n      } else if ((FLIGHT_hexacopter_B.reletive_time_sec >= rtb_Saturation3) &&\n                 (FLIGHT_hexacopter_B.reletive_time_sec < static_cast<real_T>\n                  (rtb_Saturation3) + rtb_Saturation3)) {\n        FLIGHT_hexacopter_B.out_pitch = -FLIGHT_hexacopter_B.peak_angle_rad;\n      } else {\n        FLIGHT_hexacopter_B.out_pitch = 0.0;\n      }\n      break;\n\n     case 3:\n      if ((FLIGHT_hexacopter_B.reletive_time_sec >= 0.0) &&\n          (FLIGHT_hexacopter_B.reletive_time_sec < rtb_Saturation3)) {\n        rtb_out_yawrate = FLIGHT_hexacopter_B.peak_angle_rad;\n      } else if ((FLIGHT_hexacopter_B.reletive_time_sec >= rtb_Saturation3) &&\n                 (FLIGHT_hexacopter_B.reletive_time_sec < static_cast<real_T>\n                  (rtb_Saturation3) + rtb_Saturation3)) {\n        rtb_out_yawrate = -FLIGHT_hexacopter_B.peak_angle_rad;\n      } else {\n        rtb_out_yawrate = 0.0;\n      }\n      break;\n    }\n  }\n\n  // End of MATLAB Function: '<S3>/MATLAB Function'\n\n  // Gain: '<S579>/1//2' incorporates:\n  //   Constant: '<Root>/Constant'\n  //   DataTypeConversion: '<S3>/Data Type Conversion7'\n  //   DataTypeConversion: '<S3>/Data Type Conversion8'\n\n  rtb_DeadZone = FLIGHT_hexacopter_P.u2_Gain *\n    FLIGHT_hexacopter_P.Constant_Value_a5;\n  rtb_sincos_o1_idx_1 = FLIGHT_hexacopter_P.u2_Gain * static_cast<real32_T>\n    (FLIGHT_hexacopter_B.out_pitch);\n  ParamStep = FLIGHT_hexacopter_P.u2_Gain * static_cast<real32_T>\n    (FLIGHT_hexacopter_B.out_roll);\n\n  // Trigonometry: '<S579>/sincos'\n  rtb_SinCos_o2 = static_cast<real32_T>(cos(static_cast<real_T>(rtb_DeadZone)));\n  rtb_DeadZone = static_cast<real32_T>(sin(static_cast<real_T>(rtb_DeadZone)));\n  rtb_sincos_o2_idx_1 = static_cast<real32_T>(cos(static_cast<real_T>\n    (rtb_sincos_o1_idx_1)));\n  rtb_sincos_o1_idx_1 = static_cast<real32_T>(sin(static_cast<real_T>\n    (rtb_sincos_o1_idx_1)));\n  rtb_Saturation3 = static_cast<real32_T>(cos(static_cast<real_T>(ParamStep)));\n  rtb_sincos_o1_0 = static_cast<real32_T>(sin(static_cast<real_T>(ParamStep)));\n\n  // BusAssignment: '<S15>/Bus Assignment' incorporates:\n  //   Constant: '<S577>/Constant'\n\n  FLIGHT_hexacopter_B.BusAssignment_d = FLIGHT_hexacopter_P.Constant_Value_j;\n\n  // BusAssignment: '<S15>/Bus Assignment' incorporates:\n  //   Constant: '<S15>/Constant'\n  //   DataTypeConversion: '<S3>/Data Type Conversion7'\n  //   DataTypeConversion: '<S3>/Data Type Conversion8'\n  //   DataTypeConversion: '<S3>/Data Type Conversion9'\n  //   MATLABSystem: '<S15>/PX4 Timestamp'\n\n  FLIGHT_hexacopter_B.BusAssignment_d.timestamp =\n    FLIGHT_hexacopter_B.PX4Timestamp_pn.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment_d.roll_body = static_cast<real32_T>\n    (FLIGHT_hexacopter_B.out_roll);\n  FLIGHT_hexacopter_B.BusAssignment_d.pitch_body = static_cast<real32_T>\n    (FLIGHT_hexacopter_B.out_pitch);\n  FLIGHT_hexacopter_B.BusAssignment_d.yaw_sp_move_rate = static_cast<real32_T>\n    (rtb_out_yawrate);\n  FLIGHT_hexacopter_B.BusAssignment_d.thrust_body[0] =\n    FLIGHT_hexacopter_P.Constant_Value_gq;\n  FLIGHT_hexacopter_B.BusAssignment_d.thrust_body[1] =\n    FLIGHT_hexacopter_P.Constant_Value_gq;\n  FLIGHT_hexacopter_B.BusAssignment_d.thrust_body[2] =\n    FLIGHT_hexacopter_B.Merge1[3];\n\n  // Fcn: '<S579>/q0' incorporates:\n  //   Fcn: '<S579>/q1'\n  //   Trigonometry: '<S579>/sincos'\n\n  ParamStep = rtb_SinCos_o2 * rtb_sincos_o2_idx_1;\n  tmp_1 = rtb_DeadZone * rtb_sincos_o1_idx_1;\n\n  // BusAssignment: '<S15>/Bus Assignment' incorporates:\n  //   Fcn: '<S579>/q0'\n  //   Fcn: '<S579>/q1'\n  //   Trigonometry: '<S579>/sincos'\n\n  FLIGHT_hexacopter_B.BusAssignment_d.q_d[0] = ParamStep * rtb_Saturation3 +\n    tmp_1 * rtb_sincos_o1_0;\n  FLIGHT_hexacopter_B.BusAssignment_d.q_d[1] = ParamStep * rtb_sincos_o1_0 -\n    tmp_1 * rtb_Saturation3;\n\n  // Fcn: '<S579>/q2' incorporates:\n  //   Fcn: '<S579>/q3'\n  //   Trigonometry: '<S579>/sincos'\n\n  ParamStep = rtb_DeadZone * rtb_sincos_o2_idx_1;\n  tmp_1 = rtb_SinCos_o2 * rtb_sincos_o1_idx_1;\n\n  // BusAssignment: '<S15>/Bus Assignment' incorporates:\n  //   Fcn: '<S579>/q2'\n  //   Fcn: '<S579>/q3'\n  //   Trigonometry: '<S579>/sincos'\n\n  FLIGHT_hexacopter_B.BusAssignment_d.q_d[2] = tmp_1 * rtb_Saturation3 +\n    ParamStep * rtb_sincos_o1_0;\n  FLIGHT_hexacopter_B.BusAssignment_d.q_d[3] = ParamStep * rtb_Saturation3 -\n    tmp_1 * rtb_sincos_o1_0;\n\n  // MATLABSystem: '<S578>/SinkBlock' incorporates:\n  //   BusAssignment: '<S15>/Bus Assignment'\n\n  uORB_write_step(FLIGHT_hexacopter_DW.obj_pt.orbMetadataObj,\n                  &FLIGHT_hexacopter_DW.obj_pt.orbAdvertiseObj,\n                  &FLIGHT_hexacopter_B.BusAssignment_d);\n  FLIGHT_hexacop_PX4Timestamp(&FLIGHT_hexacopter_B.PX4Timestamp_pna);\n\n  // BusAssignment: '<S16>/Bus Assignment' incorporates:\n  //   Constant: '<S580>/Constant'\n\n  FLIGHT_hexacopter_B.BusAssignment_g = FLIGHT_hexacopter_P.Constant_Value_n;\n\n  // BusAssignment: '<S16>/Bus Assignment' incorporates:\n  //   MATLABSystem: '<S16>/PX4 Timestamp'\n\n  FLIGHT_hexacopter_B.BusAssignment_g.timestamp =\n    FLIGHT_hexacopter_B.PX4Timestamp_pna.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment_g.vx = FLIGHT_hexacopter_B.PProdOut[0];\n  FLIGHT_hexacopter_B.BusAssignment_g.vy = FLIGHT_hexacopter_B.PProdOut[1];\n  FLIGHT_hexacopter_B.BusAssignment_g.vz = FLIGHT_hexacopter_B.Merge;\n  FLIGHT_hexacopter_B.BusAssignment_g.x =\n    FLIGHT_hexacopter_B.OutportBufferFordes_xy[0];\n  FLIGHT_hexacopter_B.BusAssignment_g.y =\n    FLIGHT_hexacopter_B.OutportBufferFordes_xy[1];\n  FLIGHT_hexacopter_B.BusAssignment_g.z = FLIGHT_hexacopter_B.Add;\n\n  // MATLABSystem: '<S581>/SinkBlock' incorporates:\n  //   BusAssignment: '<S16>/Bus Assignment'\n\n  uORB_write_step(FLIGHT_hexacopter_DW.obj_pa.orbMetadataObj,\n                  &FLIGHT_hexacopter_DW.obj_pa.orbAdvertiseObj,\n                  &FLIGHT_hexacopter_B.BusAssignment_g);\n  FLIGHT_hexac_PX4Timestamp_p(&FLIGHT_hexacopter_B.PX4Timestamp_pnae);\n\n  // MATLABSystem: '<S404>/SourceBlock'\n  b_varargout_1 = uORB_read_step(FLIGHT_hexacopter_DW.obj_ab.orbMetadataObj,\n    &FLIGHT_hexacopter_DW.obj_ab.eventStructObj, &FLIGHT_hexacopter_B.r1, false,\n    1.0);\n\n  // Outputs for Enabled SubSystem: '<S404>/Enabled Subsystem' incorporates:\n  //   EnablePort: '<S405>/Enable'\n\n  // Start for MATLABSystem: '<S404>/SourceBlock'\n  if (b_varargout_1) {\n    // SignalConversion generated from: '<S405>/In1'\n    FLIGHT_hexacopter_B.In1_k = FLIGHT_hexacopter_B.r1;\n  }\n\n  // End of Outputs for SubSystem: '<S404>/Enabled Subsystem'\n\n  // Outputs for Enabled SubSystem: '<Root>/CAS' incorporates:\n  //   EnablePort: '<S2>/Enable'\n\n  //  Quaternion conversion to Euler angles based on the PX4 Firmware v1.10.2\n  //  release.\n  if (rtb_Compare) {\n    // MATLABSystem: '<S2>/Read Parameter9'\n    if (FLIGHT_hexacopter_DW.obj_k.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n    {\n      FLIGHT_hexacopter_DW.obj_k.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_k.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // Gain: '<S73>/Gain1' incorporates:\n    //   MATLABSystem: '<S2>/Read Parameter9'\n    //\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Gain1_Gain_g * ParamStep;\n\n    // MATLABSystem: '<S2>/Read Parameter'\n    if (FLIGHT_hexacopter_DW.obj_jz.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n    {\n      FLIGHT_hexacopter_DW.obj_jz.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_jz.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // Product: '<S166>/PProd Out' incorporates:\n    //   DataTypeConversion: '<S3>/Data Type Conversion8'\n    //   MATLAB Function: '<Root>/quat2eul'\n    //   MATLABSystem: '<S2>/Read Parameter'\n    //   Sum: '<S2>/Sum3'\n    //\n    ParamStep *= static_cast<real32_T>(FLIGHT_hexacopter_B.out_roll) -\n      rt_atan2f_snf((FLIGHT_hexacopter_B.In1_k.q[0] *\n                     FLIGHT_hexacopter_B.In1_k.q[1] +\n                     FLIGHT_hexacopter_B.In1_k.q[2] *\n                     FLIGHT_hexacopter_B.In1_k.q[3]) * 2.0F,\n                    ((FLIGHT_hexacopter_B.In1_k.q[0] *\n                      FLIGHT_hexacopter_B.In1_k.q[0] -\n                      FLIGHT_hexacopter_B.In1_k.q[1] *\n                      FLIGHT_hexacopter_B.In1_k.q[1]) -\n                     FLIGHT_hexacopter_B.In1_k.q[2] *\n                     FLIGHT_hexacopter_B.In1_k.q[2]) +\n                    FLIGHT_hexacopter_B.In1_k.q[3] *\n                    FLIGHT_hexacopter_B.In1_k.q[3]);\n\n    // Switch: '<S169>/Switch2' incorporates:\n    //   RelationalOperator: '<S169>/LowerRelop1'\n\n    if (ParamStep > rtb_SinCos_o2) {\n      // Switch: '<S169>/Switch2'\n      FLIGHT_hexacopter_B.Switch2 = rtb_SinCos_o2;\n    } else {\n      // Gain: '<S2>/Gain'\n      rtb_SinCos_o2 *= FLIGHT_hexacopter_P.Gain_Gain_m3;\n\n      // Switch: '<S169>/Switch' incorporates:\n      //   RelationalOperator: '<S169>/UpperRelop'\n\n      if (ParamStep < rtb_SinCos_o2) {\n        // Switch: '<S169>/Switch2'\n        FLIGHT_hexacopter_B.Switch2 = rtb_SinCos_o2;\n      } else {\n        // Switch: '<S169>/Switch2'\n        FLIGHT_hexacopter_B.Switch2 = ParamStep;\n      }\n\n      // End of Switch: '<S169>/Switch'\n    }\n\n    // End of Switch: '<S169>/Switch2'\n\n    // MATLABSystem: '<S2>/Read Parameter10'\n    if (FLIGHT_hexacopter_DW.obj_ds.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n    {\n      FLIGHT_hexacopter_DW.obj_ds.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_ds.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // Gain: '<S74>/Gain1' incorporates:\n    //   MATLABSystem: '<S2>/Read Parameter10'\n    //\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Gain1_Gain_c * ParamStep;\n\n    // MATLABSystem: '<S2>/Read Parameter1'\n    if (FLIGHT_hexacopter_DW.obj_o.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n    {\n      FLIGHT_hexacopter_DW.obj_o.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_o.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // Product: '<S115>/PProd Out' incorporates:\n    //   DataTypeConversion: '<S3>/Data Type Conversion7'\n    //   MATLAB Function: '<Root>/quat2eul'\n    //   MATLABSystem: '<S2>/Read Parameter1'\n    //   Sum: '<S2>/Sum2'\n    //\n    ParamStep *= static_cast<real32_T>(FLIGHT_hexacopter_B.out_pitch) -\n      static_cast<real32_T>(asin(static_cast<real_T>\n      ((FLIGHT_hexacopter_B.In1_k.q[1] * FLIGHT_hexacopter_B.In1_k.q[3] -\n        FLIGHT_hexacopter_B.In1_k.q[0] * FLIGHT_hexacopter_B.In1_k.q[2]) * -2.0F)));\n\n    // Switch: '<S118>/Switch2' incorporates:\n    //   RelationalOperator: '<S118>/LowerRelop1'\n\n    if (ParamStep > rtb_SinCos_o2) {\n      // Switch: '<S118>/Switch2'\n      FLIGHT_hexacopter_B.Switch2_i = rtb_SinCos_o2;\n    } else {\n      // Gain: '<S2>/Gain1'\n      rtb_SinCos_o2 *= FLIGHT_hexacopter_P.Gain1_Gain;\n\n      // Switch: '<S118>/Switch' incorporates:\n      //   RelationalOperator: '<S118>/UpperRelop'\n\n      if (ParamStep < rtb_SinCos_o2) {\n        // Switch: '<S118>/Switch2'\n        FLIGHT_hexacopter_B.Switch2_i = rtb_SinCos_o2;\n      } else {\n        // Switch: '<S118>/Switch2'\n        FLIGHT_hexacopter_B.Switch2_i = ParamStep;\n      }\n\n      // End of Switch: '<S118>/Switch'\n    }\n\n    // End of Switch: '<S118>/Switch2'\n  }\n\n  // End of Outputs for SubSystem: '<Root>/CAS'\n\n  // BusAssignment: '<S17>/Bus Assignment' incorporates:\n  //   Constant: '<S582>/Constant'\n\n  FLIGHT_hexacopter_B.BusAssignment_e = FLIGHT_hexacopter_P.Constant_Value_i;\n\n  // BusAssignment: '<S17>/Bus Assignment' incorporates:\n  //   Constant: '<S17>/Constant'\n  //   DataTypeConversion: '<S3>/Data Type Conversion9'\n  //   MATLABSystem: '<S17>/PX4 Timestamp'\n\n  FLIGHT_hexacopter_B.BusAssignment_e.timestamp =\n    FLIGHT_hexacopter_B.PX4Timestamp_pnae.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment_e.roll = FLIGHT_hexacopter_B.Switch2;\n  FLIGHT_hexacopter_B.BusAssignment_e.pitch = FLIGHT_hexacopter_B.Switch2_i;\n  FLIGHT_hexacopter_B.BusAssignment_e.yaw = static_cast<real32_T>\n    (rtb_out_yawrate);\n  FLIGHT_hexacopter_B.BusAssignment_e.thrust_body[0] =\n    FLIGHT_hexacopter_P.Constant_Value_ll;\n  FLIGHT_hexacopter_B.BusAssignment_e.thrust_body[1] =\n    FLIGHT_hexacopter_P.Constant_Value_ll;\n  FLIGHT_hexacopter_B.BusAssignment_e.thrust_body[2] =\n    FLIGHT_hexacopter_B.Merge1[3];\n\n  // MATLABSystem: '<S583>/SinkBlock' incorporates:\n  //   BusAssignment: '<S17>/Bus Assignment'\n\n  uORB_write_step(FLIGHT_hexacopter_DW.obj_a4.orbMetadataObj,\n                  &FLIGHT_hexacopter_DW.obj_a4.orbAdvertiseObj,\n                  &FLIGHT_hexacopter_B.BusAssignment_e);\n\n  // RateTransition: '<Root>/Rate Transition'\n  FLIGHT_hexacopter_DW.RateTransition_Buffer0 = FLIGHT_hexacopter_B.Switch2;\n\n  // RateTransition: '<Root>/Rate Transition1'\n  FLIGHT_hexacopter_DW.RateTransition1_Buffer0 = FLIGHT_hexacopter_B.Switch2_i;\n\n  // RateTransition: '<Root>/Rate Transition2' incorporates:\n  //   DataTypeConversion: '<S3>/Data Type Conversion9'\n\n  FLIGHT_hexacopter_DW.RateTransition2_Buffer0 = static_cast<real32_T>\n    (rtb_out_yawrate);\n\n  // RateTransition: '<Root>/Rate Transition3'\n  FLIGHT_hexacopter_DW.RateTransition3_Buffer0 = FLIGHT_hexacopter_B.Merge1[3];\n\n  // RateTransition: '<Root>/Rate Transition4'\n  FLIGHT_hexacopter_DW.RateTransition4_Buffer0 = FLIGHT_hexacopter_B.values[7];\n\n  // RateTransition: '<Root>/Rate Transition5'\n  FLIGHT_hexacopter_DW.RateTransition5_Buffer0 = rtb_Compare;\n\n  // RateTransition: '<Root>/Rate Transition6'\n  FLIGHT_hexacopter_DW.RateTransition6_Buffer0 = rtb_Compare;\n}\n\n// Use this function only if you need to maintain compatibility with an existing static main program.\nvoid FLIGHT_hexacopter_step(int_T tid)\n{\n  switch (tid) {\n   case 0 :\n    FLIGHT_hexacopter_step0();\n    break;\n\n   case 1 :\n    FLIGHT_hexacopter_step1();\n    break;\n\n   default :\n    // do nothing\n    break;\n  }\n}\n\n// Model initialize function\nvoid FLIGHT_hexacopter_initialize(void)\n{\n  // Registration code\n\n  // initialize non-finites\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  {\n    static const char_T ParameterNameStr[14] = \"FDD_M1_STATUS\";\n    static const char_T ParameterNameStr_0[14] = \"FDD_M2_STATUS\";\n    static const char_T ParameterNameStr_1[14] = \"FDD_M3_STATUS\";\n    static const char_T ParameterNameStr_2[14] = \"FDD_M4_STATUS\";\n    static const char_T ParameterNameStr_3[14] = \"FDD_M5_STATUS\";\n    static const char_T ParameterNameStr_4[14] = \"FDD_M6_STATUS\";\n    static const char_T ParameterNameStr_5[17] = \"DOUBLET_PEAK_ANG\";\n    static const char_T ParameterNameStr_6[11] = \"DOUBLET_DT\";\n    static const char_T ParameterNameStr_7[13] = \"DOUBLET_AXIS\";\n    static const char_T ParameterNameStr_8[16] = \"MC_ROLLRATE_MAX\";\n    static const char_T ParameterNameStr_9[10] = \"MC_ROLL_P\";\n    static const char_T ParameterNameStr_a[17] = \"MC_PITCHRATE_MAX\";\n    static const char_T ParameterNameStr_b[11] = \"MC_PITCH_P\";\n    static const char_T ParameterNameStr_c[14] = \"MC_ROLLRATE_D\";\n    static const char_T ParameterNameStr_d[14] = \"MC_ROLLRATE_P\";\n    static const char_T ParameterNameStr_e[14] = \"MC_ROLLRATE_I\";\n    static const char_T ParameterNameStr_f[15] = \"MC_PITCHRATE_D\";\n    static const char_T ParameterNameStr_g[15] = \"MC_PITCHRATE_P\";\n    static const char_T ParameterNameStr_h[15] = \"MC_PITCHRATE_I\";\n    static const char_T ParameterNameStr_i[13] = \"MC_YAWRATE_D\";\n    static const char_T ParameterNameStr_j[13] = \"MC_YAWRATE_P\";\n    static const char_T ParameterNameStr_k[14] = \"MC_YAWRATE_FF\";\n    static const char_T ParameterNameStr_l[13] = \"MC_YAWRATE_I\";\n    static const char_T ParameterNameStr_m[8] = \"MPC_Z_P\";\n    static const char_T ParameterNameStr_n[9] = \"MPC_XY_P\";\n    static const char_T ParameterNameStr_o[17] = \"MPC_XY_VEL_P_ACC\";\n    real_T tmp;\n    int32_T i;\n\n    // Start for RateTransition: '<Root>/Rate Transition5'\n    FLIGHT_hexacopter_B.RateTransition5 =\n      FLIGHT_hexacopter_P.RateTransition5_InitialConditio;\n\n    // Start for RateTransition: '<Root>/Rate Transition'\n    FLIGHT_hexacopter_B.RateTransition =\n      FLIGHT_hexacopter_P.RateTransition_InitialCondition;\n\n    // Start for RateTransition: '<Root>/Rate Transition1'\n    FLIGHT_hexacopter_B.RateTransition1 =\n      FLIGHT_hexacopter_P.RateTransition1_InitialConditio;\n\n    // Start for RateTransition: '<Root>/Rate Transition2'\n    FLIGHT_hexacopter_B.RateTransition2 =\n      FLIGHT_hexacopter_P.RateTransition2_InitialConditio;\n\n    // Start for RateTransition: '<Root>/Rate Transition6'\n    FLIGHT_hexacopter_B.RateTransition6 =\n      FLIGHT_hexacopter_P.RateTransition6_InitialConditio;\n\n    // Start for RateTransition: '<Root>/Rate Transition3'\n    FLIGHT_hexacopter_B.RateTransition3 =\n      FLIGHT_hexacopter_P.RateTransition3_InitialConditio;\n\n    // Start for RateTransition: '<Root>/Rate Transition4'\n    FLIGHT_hexacopter_B.RateTransition4 =\n      FLIGHT_hexacopter_P.RateTransition4_InitialConditio;\n\n    // InitializeConditions for RateTransition: '<Root>/Rate Transition5'\n    FLIGHT_hexacopter_DW.RateTransition5_Buffer0 =\n      FLIGHT_hexacopter_P.RateTransition5_InitialConditio;\n\n    // InitializeConditions for RateTransition: '<Root>/Rate Transition'\n    FLIGHT_hexacopter_DW.RateTransition_Buffer0 =\n      FLIGHT_hexacopter_P.RateTransition_InitialCondition;\n\n    // InitializeConditions for RateTransition: '<Root>/Rate Transition1'\n    FLIGHT_hexacopter_DW.RateTransition1_Buffer0 =\n      FLIGHT_hexacopter_P.RateTransition1_InitialConditio;\n\n    // InitializeConditions for RateTransition: '<Root>/Rate Transition2'\n    FLIGHT_hexacopter_DW.RateTransition2_Buffer0 =\n      FLIGHT_hexacopter_P.RateTransition2_InitialConditio;\n\n    // InitializeConditions for RateTransition: '<Root>/Rate Transition6'\n    FLIGHT_hexacopter_DW.RateTransition6_Buffer0 =\n      FLIGHT_hexacopter_P.RateTransition6_InitialConditio;\n\n    // InitializeConditions for RateTransition: '<Root>/Rate Transition3'\n    FLIGHT_hexacopter_DW.RateTransition3_Buffer0 =\n      FLIGHT_hexacopter_P.RateTransition3_InitialConditio;\n\n    // InitializeConditions for RateTransition: '<Root>/Rate Transition4'\n    FLIGHT_hexacopter_DW.RateTransition4_Buffer0 =\n      FLIGHT_hexacopter_P.RateTransition4_InitialConditio;\n\n    // SystemInitialize for IfAction SubSystem: '<Root>/Altitude_Mode'\n    // SystemInitialize for Enabled SubSystem: '<S1>/Vz Controller'\n    // InitializeConditions for DiscreteIntegrator: '<S51>/Filter'\n    FLIGHT_hexacopter_DW.Filter_DSTATE_i =\n      FLIGHT_hexacopter_P.PIDController4_InitialCondition;\n\n    // InitializeConditions for DiscreteIntegrator: '<S56>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_e =\n      FLIGHT_hexacopter_P.PIDController4_InitialConditi_a;\n    FLIGHT__ReadParameter3_Init(&FLIGHT_hexacopter_DW.ReadParameter3_p);\n    FLIGHT__ReadParameter1_Init(&FLIGHT_hexacopter_DW.ReadParameter1_pna);\n    FLIGHT_h_ReadParameter_Init(&FLIGHT_hexacopter_DW.ReadParameter_pn);\n    FLIGHT__ReadParameter2_Init(&FLIGHT_hexacopter_DW.ReadParameter2_pn);\n\n    // SystemInitialize for Sum: '<S19>/Sum6' incorporates:\n    //   Outport: '<S19>/throttle'\n    //   Saturate: '<S19>/Saturation1'\n\n    FLIGHT_hexacopter_B.Saturation1_i = FLIGHT_hexacopter_P.throttle_Y0;\n\n    // End of SystemInitialize for SubSystem: '<S1>/Vz Controller'\n    // End of SystemInitialize for SubSystem: '<Root>/Altitude_Mode'\n\n    // SystemInitialize for Enabled SubSystem: '<Root>/CAS'\n    // Start for MATLABSystem: '<S2>/Read Parameter9'\n    FLIGHT_hexacopter_DW.obj_k.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_k.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_k.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_k.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_k.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_k.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_8[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_k.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S2>/Read Parameter9'\n\n    // Start for MATLABSystem: '<S2>/Read Parameter'\n    FLIGHT_hexacopter_DW.obj_jz.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_jz.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_jz.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_jz.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_jz.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_jz.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_9[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_jz.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S2>/Read Parameter'\n\n    // Start for MATLABSystem: '<S2>/Read Parameter10'\n    FLIGHT_hexacopter_DW.obj_ds.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_ds.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_ds.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_ds.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_ds.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_ds.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_a[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_ds.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S2>/Read Parameter10'\n\n    // Start for MATLABSystem: '<S2>/Read Parameter1'\n    FLIGHT_hexacopter_DW.obj_o.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_o.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_o.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_o.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_o.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_o.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_b[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_o.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S2>/Read Parameter1'\n\n    // SystemInitialize for Switch: '<S169>/Switch2' incorporates:\n    //   Outport: '<S2>/des_p'\n\n    FLIGHT_hexacopter_B.Switch2 = FLIGHT_hexacopter_P.des_p_Y0;\n\n    // SystemInitialize for Switch: '<S118>/Switch2' incorporates:\n    //   Outport: '<S2>/des_q'\n\n    FLIGHT_hexacopter_B.Switch2_i = FLIGHT_hexacopter_P.des_q_Y0;\n\n    // End of SystemInitialize for SubSystem: '<Root>/CAS'\n\n    // SystemInitialize for MATLAB Function: '<S3>/MATLAB Function'\n    FLIGHT_hexacopter_DW.start_time_usec = -1.0;\n\n    // SystemInitialize for IfAction SubSystem: '<Root>/If Action Subsystem'\n    // SystemInitialize for Enabled SubSystem: '<S5>/Altitude Controller'\n    // Start for MATLABSystem: '<S187>/Read Parameter1'\n    FLIGHT_hexacopter_DW.obj_m.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_m.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_m.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_m.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_m.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_m.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_m[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_m.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S187>/Read Parameter1'\n    // End of SystemInitialize for SubSystem: '<S5>/Altitude Controller'\n\n    // SystemInitialize for SignalConversion generated from: '<S5>/des_xy' incorporates:\n    //   Constant: '<S5>/Constant'\n\n    FLIGHT_hexacopter_B.OutportBufferFordes_xy[0] =\n      FLIGHT_hexacopter_P.Constant_Value_k[0];\n    FLIGHT_hexacopter_B.OutportBufferFordes_xy[1] =\n      FLIGHT_hexacopter_P.Constant_Value_k[1];\n\n    // SystemInitialize for Enabled SubSystem: '<S5>/Vz Controller'\n    // InitializeConditions for DiscreteIntegrator: '<S274>/Filter'\n    FLIGHT_hexacopter_DW.Filter_DSTATE_g =\n      FLIGHT_hexacopter_P.PIDController4_InitialConditi_l;\n    FLIGHT_hexacopter_DW.Filter_PrevResetState = 2;\n\n    // InitializeConditions for DiscreteIntegrator: '<S279>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_k =\n      FLIGHT_hexacopter_P.PIDController4_InitialConditi_i;\n    FLIGHT_hexacopter_DW.Integrator_PrevResetState = 2;\n    FLIGHT__ReadParameter3_Init(&FLIGHT_hexacopter_DW.ReadParameter3_pn);\n    FLIGHT__ReadParameter1_Init(&FLIGHT_hexacopter_DW.ReadParameter1_pnaev);\n    FLIGHT_h_ReadParameter_Init(&FLIGHT_hexacopter_DW.ReadParameter_pna);\n    FLIGHT__ReadParameter2_Init(&FLIGHT_hexacopter_DW.ReadParameter2_pna);\n\n    // SystemInitialize for Sum: '<S189>/Sum6' incorporates:\n    //   Outport: '<S189>/throttle'\n    //   Saturate: '<S189>/Saturation1'\n\n    FLIGHT_hexacopter_B.Saturation1 = FLIGHT_hexacopter_P.throttle_Y0_o;\n\n    // SystemInitialize for Product: '<S231>/PProd Out' incorporates:\n    //   Outport: '<S189>/log_alt'\n    //   SignalConversion generated from: '<S189>/des_vz'\n\n    FLIGHT_hexacopter_B.des_vz = FLIGHT_hexacopter_P.log_alt_Y0;\n\n    // End of SystemInitialize for SubSystem: '<S5>/Vz Controller'\n\n    // SystemInitialize for Enabled SubSystem: '<S5>/XY Pos Controller'\n    // Start for MATLABSystem: '<S190>/Read Parameter'\n    FLIGHT_hexacopter_DW.obj_eq.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_eq.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_eq.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_eq.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_eq.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_eq.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_n[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_eq.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S190>/Read Parameter'\n\n    // SystemInitialize for Product: '<S335>/PProd Out' incorporates:\n    //   Outport: '<S190>/des_vxvy'\n\n    FLIGHT_hexacopter_B.PProdOut[0] = FLIGHT_hexacopter_P.des_vxvy_Y0;\n    FLIGHT_hexacopter_B.PProdOut[1] = FLIGHT_hexacopter_P.des_vxvy_Y0;\n\n    // End of SystemInitialize for SubSystem: '<S5>/XY Pos Controller'\n\n    // SystemInitialize for Enabled SubSystem: '<S5>/XY Velocity Controller'\n    // Start for MATLABSystem: '<S191>/Read Parameter'\n    FLIGHT_hexacopter_DW.obj_pi.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_pi.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_pi.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_pi.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_pi.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_pi.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_o[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_pi.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S191>/Read Parameter'\n\n    // SystemInitialize for Gain: '<S191>/Gain1' incorporates:\n    //   Outport: '<S191>/des_pitch'\n\n    FLIGHT_hexacopter_B.Gain1 = FLIGHT_hexacopter_P.des_pitch_Y0;\n\n    // SystemInitialize for Outport: '<S191>/des_roll' incorporates:\n    //   Saturate: '<S191>/Saturation'\n\n    FLIGHT_hexacopter_B.Saturation[1] = FLIGHT_hexacopter_P.des_roll_Y0;\n\n    // End of SystemInitialize for SubSystem: '<S5>/XY Velocity Controller'\n\n    // SystemInitialize for Sum: '<S5>/Add' incorporates:\n    //   Outport: '<S5>/des_z'\n\n    FLIGHT_hexacopter_B.Add = FLIGHT_hexacopter_P.des_z_Y0;\n\n    // End of SystemInitialize for SubSystem: '<Root>/If Action Subsystem'\n\n    // SystemInitialize for Gain: '<S18>/Gain' incorporates:\n    //   Merge: '<Root>/Merge'\n\n    FLIGHT_hexacopter_B.Merge = FLIGHT_hexacopter_P.Merge_InitialOutput;\n\n    // SystemInitialize for Merge: '<Root>/Merge1'\n    FLIGHT_hexacopter_B.Merge1[0] = FLIGHT_hexacopter_P.Merge1_InitialOutput;\n    FLIGHT_hexacopter_B.Merge1[1] = FLIGHT_hexacopter_P.Merge1_InitialOutput;\n    FLIGHT_hexacopter_B.Merge1[2] = FLIGHT_hexacopter_P.Merge1_InitialOutput;\n    FLIGHT_hexacopter_B.Merge1[3] = FLIGHT_hexacopter_P.Merge1_InitialOutput;\n\n    // SystemInitialize for Enabled SubSystem: '<Root>/Mixer'\n    for (i = 0; i < 6; i++) {\n      // SystemInitialize for Saturate: '<S6>/Output_Limits1' incorporates:\n      //   Outport: '<S6>/PWM'\n\n      FLIGHT_hexacopter_B.Output_Limits1[i] = FLIGHT_hexacopter_P.PWM_Y0;\n    }\n\n    // End of SystemInitialize for SubSystem: '<Root>/Mixer'\n\n    // SystemInitialize for Enabled SubSystem: '<S401>/Enabled Subsystem'\n    // SystemInitialize for SignalConversion generated from: '<S403>/In1' incorporates:\n    //   Outport: '<S403>/Out1'\n\n    FLIGHT_hexacopter_B.In1 = FLIGHT_hexacopter_P.Out1_Y0;\n\n    // End of SystemInitialize for SubSystem: '<S401>/Enabled Subsystem'\n\n    // SystemInitialize for Enabled SubSystem: '<S404>/Enabled Subsystem'\n    // SystemInitialize for SignalConversion generated from: '<S405>/In1' incorporates:\n    //   Outport: '<S405>/Out1'\n\n    FLIGHT_hexacopter_B.In1_k = FLIGHT_hexacopter_P.Out1_Y0_d;\n\n    // End of SystemInitialize for SubSystem: '<S404>/Enabled Subsystem'\n\n    // SystemInitialize for Enabled SubSystem: '<S410>/Enabled Subsystem'\n    // SystemInitialize for SignalConversion generated from: '<S411>/In1' incorporates:\n    //   Outport: '<S411>/Out1'\n\n    FLIGHT_hexacopter_B.In1_n = FLIGHT_hexacopter_P.Out1_Y0_p;\n\n    // End of SystemInitialize for SubSystem: '<S410>/Enabled Subsystem'\n\n    // SystemInitialize for Enabled SubSystem: '<Root>/SAS'\n    // InitializeConditions for DiscreteIntegrator: '<S493>/Filter'\n    FLIGHT_hexacopter_DW.Filter_DSTATE =\n      FLIGHT_hexacopter_P.pid_ctrl_rollrate_InitialCondit;\n\n    // InitializeConditions for DiscreteIntegrator: '<S498>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE =\n      FLIGHT_hexacopter_P.pid_ctrl_rollrate_InitialCond_c;\n\n    // InitializeConditions for DiscreteIntegrator: '<S443>/Filter'\n    FLIGHT_hexacopter_DW.Filter_DSTATE_j =\n      FLIGHT_hexacopter_P.pid_ctrl_pitchrate_InitialCondi;\n\n    // InitializeConditions for DiscreteIntegrator: '<S448>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_c =\n      FLIGHT_hexacopter_P.pid_ctrl_pitchrate_InitialCon_c;\n\n    // InitializeConditions for DiscreteIntegrator: '<S543>/Filter'\n    FLIGHT_hexacopter_DW.Filter_DSTATE_h =\n      FLIGHT_hexacopter_P.pid_ctrl_yawrate_InitialConditi;\n\n    // InitializeConditions for DiscreteIntegrator: '<S548>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_l =\n      FLIGHT_hexacopter_P.pid_ctrl_yawrate_InitialCondi_h;\n\n    // Start for MATLABSystem: '<S9>/Read Parameter2'\n    FLIGHT_hexacopter_DW.obj_d.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_d.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_d.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_d.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_d.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_d.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_c[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_d.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S9>/Read Parameter2'\n\n    // Start for MATLABSystem: '<S9>/read_mc_rollrate_p'\n    FLIGHT_hexacopter_DW.obj.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj.MW_PARAMHANDLE = MW_Init_Param(&ParameterNameStr_d\n      [0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S9>/read_mc_rollrate_p'\n\n    // Start for MATLABSystem: '<S9>/Read Parameter1'\n    FLIGHT_hexacopter_DW.obj_ea.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_ea.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_ea.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_ea.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_ea.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_ea.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_e[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_ea.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S9>/Read Parameter1'\n\n    // Start for MATLABSystem: '<S9>/Read Parameter5'\n    FLIGHT_hexacopter_DW.obj_h.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_h.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_h.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_h.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_h.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_h.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_f[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_h.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S9>/Read Parameter5'\n\n    // Start for MATLABSystem: '<S9>/Read Parameter3'\n    FLIGHT_hexacopter_DW.obj_b.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_b.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_b.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_b.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_b.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_b.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_g[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_b.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S9>/Read Parameter3'\n\n    // Start for MATLABSystem: '<S9>/Read Parameter4'\n    FLIGHT_hexacopter_DW.obj_p.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_p.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_p.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_p.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_p.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_p.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_h[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_p.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S9>/Read Parameter4'\n\n    // Start for MATLABSystem: '<S9>/Read Parameter8'\n    FLIGHT_hexacopter_DW.obj_i.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_i.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_i.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_i.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_i.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_i.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_i[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_i.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S9>/Read Parameter8'\n\n    // Start for MATLABSystem: '<S9>/Read Parameter6'\n    FLIGHT_hexacopter_DW.obj_a.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_a.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_a.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_a.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_a.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_a.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_j[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_a.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S9>/Read Parameter6'\n\n    // Start for MATLABSystem: '<S9>/Read Parameter9'\n    FLIGHT_hexacopter_DW.obj_e.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_e.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_e.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_e.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_e.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_e.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_k[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_e.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S9>/Read Parameter9'\n\n    // Start for MATLABSystem: '<S9>/Read Parameter7'\n    FLIGHT_hexacopter_DW.obj_j.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_j.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_j.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_j.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_j.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_j.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_l[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_j.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S9>/Read Parameter7'\n\n    // SystemInitialize for Sum: '<S507>/Sum' incorporates:\n    //   Outport: '<S9>/tau_roll'\n\n    FLIGHT_hexacopter_B.Sum = FLIGHT_hexacopter_P.tau_roll_Y0;\n\n    // SystemInitialize for Sum: '<S457>/Sum' incorporates:\n    //   Outport: '<S9>/tau_pitch'\n\n    FLIGHT_hexacopter_B.Sum_a = FLIGHT_hexacopter_P.tau_pitch_Y0;\n\n    // SystemInitialize for Sum: '<S9>/Sum2' incorporates:\n    //   Outport: '<S9>/tau_yaw'\n\n    FLIGHT_hexacopter_B.Sum2 = FLIGHT_hexacopter_P.tau_yaw_Y0;\n\n    // End of SystemInitialize for SubSystem: '<Root>/SAS'\n\n    // SystemInitialize for Enabled SubSystem: '<S575>/Enabled Subsystem'\n    // SystemInitialize for SignalConversion generated from: '<S576>/In1' incorporates:\n    //   Outport: '<S576>/Out1'\n\n    FLIGHT_hexacopter_B.In1_h = FLIGHT_hexacopter_P.Out1_Y0_pn;\n\n    // End of SystemInitialize for SubSystem: '<S575>/Enabled Subsystem'\n\n    // Start for MATLABSystem: '<S575>/SourceBlock'\n    FLIGHT_hexacopter_DW.obj_pe.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_pe.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_pe.orbMetadataObj = ORB_ID(vehicle_angular_velocity);\n    uORB_read_initialize(FLIGHT_hexacopter_DW.obj_pe.orbMetadataObj,\n                         &FLIGHT_hexacopter_DW.obj_pe.eventStructObj);\n    FLIGHT_hexacopter_DW.obj_pe.isSetupComplete = true;\n\n    // Start for MATLABSystem: '<S4>/Read Parameter13'\n    FLIGHT_hexacopter_DW.obj_g.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_g.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_g.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_g.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_g.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_g.MW_PARAMHANDLE = MW_Init_Param(&ParameterNameStr\n      [0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_g.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter13'\n\n    // Start for MATLABSystem: '<S4>/Read Parameter1'\n    FLIGHT_hexacopter_DW.obj_j5.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_j5.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_j5.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_j5.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_j5.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_j5.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_0[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_j5.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter1'\n\n    // Start for MATLABSystem: '<S4>/Read Parameter2'\n    FLIGHT_hexacopter_DW.obj_ao.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_ao.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_ao.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_ao.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_ao.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_ao.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_1[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_ao.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter2'\n\n    // Start for MATLABSystem: '<S4>/Read Parameter3'\n    FLIGHT_hexacopter_DW.obj_n.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_n.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_n.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_n.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_n.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_n.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_2[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_n.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter3'\n\n    // Start for MATLABSystem: '<S4>/Read Parameter4'\n    FLIGHT_hexacopter_DW.obj_c.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_c.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_c.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_c.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_c.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_c.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_3[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_c.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter4'\n\n    // Start for MATLABSystem: '<S4>/Read Parameter5'\n    FLIGHT_hexacopter_DW.obj_aq.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_aq.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_aq.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_aq.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_aq.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_aq.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_4[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_aq.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter5'\n\n    // Start for MATLABSystem: '<Root>/PX4 PWM Output'\n    FLIGHT_hexacopter_DW.obj_dl.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_dl.isSetupComplete = false;\n    FLIGHT_hexacopter_DW.obj_dl.isInitialized = 1;\n    FLIGHT_hexacopter_PWM_setupImpl(&FLIGHT_hexacopter_DW.obj_dl, false, false);\n    FLIGHT_hexacopter_DW.obj_dl.isSetupComplete = true;\n    FLIGHT__PX4Timestamp_b_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_o);\n\n    // Start for MATLABSystem: '<S567>/SinkBlock' incorporates:\n    //   BusAssignment: '<S565>/Bus Assignment'\n\n    FLIGHT_hexacopter_DW.obj_jk.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_jk.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_jk.orbMetadataObj = ORB_ID\n      (actuator_controls_status_0);\n    uORB_write_initialize(FLIGHT_hexacopter_DW.obj_jk.orbMetadataObj,\n                          &FLIGHT_hexacopter_DW.obj_jk.orbAdvertiseObj,\n                          &FLIGHT_hexacopter_B.BusAssignment_gi, 1);\n    FLIGHT_hexacopter_DW.obj_jk.isSetupComplete = true;\n    FLIGHT__PX4Timestamp_b_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_n);\n    FLIGHT__PX4Timestamp_b_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_p);\n\n    // Start for MATLABSystem: '<S572>/SinkBlock' incorporates:\n    //   BusAssignment: '<S569>/Bus Assignment'\n\n    FLIGHT_hexacopter_DW.obj_hf.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_hf.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_hf.orbMetadataObj = ORB_ID(actuator_motors);\n    uORB_write_initialize(FLIGHT_hexacopter_DW.obj_hf.orbMetadataObj,\n                          &FLIGHT_hexacopter_DW.obj_hf.orbAdvertiseObj,\n                          &FLIGHT_hexacopter_B.BusAssignment_f, 1);\n    FLIGHT_hexacopter_DW.obj_hf.isSetupComplete = true;\n    FLIGHT__PX4Timestamp_b_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_ok);\n\n    // Start for MATLABSystem: '<S574>/SinkBlock' incorporates:\n    //   BusAssignment: '<S570>/Bus Assignment'\n\n    FLIGHT_hexacopter_DW.obj_px.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_px.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_px.orbMetadataObj = ORB_ID(actuator_outputs);\n    uORB_write_initialize(FLIGHT_hexacopter_DW.obj_px.orbMetadataObj,\n                          &FLIGHT_hexacopter_DW.obj_px.orbAdvertiseObj,\n                          &FLIGHT_hexacopter_B.BusAssignment, 1);\n    FLIGHT_hexacopter_DW.obj_px.isSetupComplete = true;\n    FLIGHT__PX4Timestamp_l_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_pn);\n\n    // Start for MATLABSystem: '<S410>/SourceBlock'\n    FLIGHT_hexacopter_DW.obj_p2.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_p2.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_p2.orbMetadataObj = ORB_ID(input_rc);\n    uORB_read_initialize(FLIGHT_hexacopter_DW.obj_p2.orbMetadataObj,\n                         &FLIGHT_hexacopter_DW.obj_p2.eventStructObj);\n    FLIGHT_hexacopter_DW.obj_p2.isSetupComplete = true;\n\n    // Start for MATLABSystem: '<S401>/SourceBlock'\n    FLIGHT_hexacopter_DW.obj_kk.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_kk.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_kk.orbMetadataObj = ORB_ID(vehicle_local_position);\n    uORB_read_initialize(FLIGHT_hexacopter_DW.obj_kk.orbMetadataObj,\n                         &FLIGHT_hexacopter_DW.obj_kk.eventStructObj);\n    FLIGHT_hexacopter_DW.obj_kk.isSetupComplete = true;\n    FLIGHT_he_PX4Timestamp_Init(&FLIGHT_hexacopter_DW.PX4Timestamp);\n\n    // Start for MATLABSystem: '<S3>/Read Parameter1'\n    FLIGHT_hexacopter_DW.obj_ct.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_ct.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_ct.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_ct.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_ct.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_ct.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_5[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_ct.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S3>/Read Parameter1'\n\n    // Start for MATLABSystem: '<S3>/Read Parameter'\n    FLIGHT_hexacopter_DW.obj_cf.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_cf.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_cf.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_cf.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_cf.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_cf.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_6[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_cf.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S3>/Read Parameter'\n\n    // Start for MATLABSystem: '<S3>/Read Parameter2'\n    FLIGHT_hexacopter_DW.obj_l.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_l.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_l.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_l.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_l.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_l.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_7[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_l.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S3>/Read Parameter2'\n\n    // Start for MATLABSystem: '<S578>/SinkBlock' incorporates:\n    //   BusAssignment: '<S15>/Bus Assignment'\n\n    FLIGHT_hexacopter_DW.obj_pt.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_pt.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_pt.orbMetadataObj = ORB_ID\n      (vehicle_attitude_setpoint);\n    uORB_write_initialize(FLIGHT_hexacopter_DW.obj_pt.orbMetadataObj,\n                          &FLIGHT_hexacopter_DW.obj_pt.orbAdvertiseObj,\n                          &FLIGHT_hexacopter_B.BusAssignment_d, 1);\n    FLIGHT_hexacopter_DW.obj_pt.isSetupComplete = true;\n    FLIGHT_he_PX4Timestamp_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_pna);\n\n    // Start for MATLABSystem: '<S581>/SinkBlock' incorporates:\n    //   BusAssignment: '<S16>/Bus Assignment'\n\n    FLIGHT_hexacopter_DW.obj_pa.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_pa.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_pa.orbMetadataObj = ORB_ID\n      (vehicle_local_position_setpoint);\n    uORB_write_initialize(FLIGHT_hexacopter_DW.obj_pa.orbMetadataObj,\n                          &FLIGHT_hexacopter_DW.obj_pa.orbAdvertiseObj,\n                          &FLIGHT_hexacopter_B.BusAssignment_g, 1);\n    FLIGHT_hexacopter_DW.obj_pa.isSetupComplete = true;\n    FLIGHT__PX4Timestamp_l_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_pnae);\n\n    // Start for MATLABSystem: '<S404>/SourceBlock'\n    FLIGHT_hexacopter_DW.obj_ab.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_ab.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_ab.orbMetadataObj = ORB_ID(vehicle_odometry);\n    uORB_read_initialize(FLIGHT_hexacopter_DW.obj_ab.orbMetadataObj,\n                         &FLIGHT_hexacopter_DW.obj_ab.eventStructObj);\n    FLIGHT_hexacopter_DW.obj_ab.isSetupComplete = true;\n\n    // Start for MATLABSystem: '<S583>/SinkBlock' incorporates:\n    //   BusAssignment: '<S17>/Bus Assignment'\n\n    FLIGHT_hexacopter_DW.obj_a4.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_a4.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_a4.orbMetadataObj = ORB_ID(vehicle_rates_setpoint);\n    uORB_write_initialize(FLIGHT_hexacopter_DW.obj_a4.orbMetadataObj,\n                          &FLIGHT_hexacopter_DW.obj_a4.orbAdvertiseObj,\n                          &FLIGHT_hexacopter_B.BusAssignment_e, 1);\n    FLIGHT_hexacopter_DW.obj_a4.isSetupComplete = true;\n  }\n}\n\n// Model terminate function\nvoid FLIGHT_hexacopter_terminate(void)\n{\n  // Terminate for MATLABSystem: '<S575>/SourceBlock'\n  if (!FLIGHT_hexacopter_DW.obj_pe.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_pe.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_pe.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_pe.isSetupComplete) {\n      uORB_read_terminate(&FLIGHT_hexacopter_DW.obj_pe.eventStructObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S575>/SourceBlock'\n\n  // Terminate for Enabled SubSystem: '<Root>/SAS'\n  // Terminate for MATLABSystem: '<S9>/Read Parameter2'\n  if (!FLIGHT_hexacopter_DW.obj_d.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_d.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S9>/Read Parameter2'\n\n  // Terminate for MATLABSystem: '<S9>/read_mc_rollrate_p'\n  if (!FLIGHT_hexacopter_DW.obj.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S9>/read_mc_rollrate_p'\n\n  // Terminate for MATLABSystem: '<S9>/Read Parameter1'\n  if (!FLIGHT_hexacopter_DW.obj_ea.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_ea.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S9>/Read Parameter1'\n\n  // Terminate for MATLABSystem: '<S9>/Read Parameter5'\n  if (!FLIGHT_hexacopter_DW.obj_h.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_h.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S9>/Read Parameter5'\n\n  // Terminate for MATLABSystem: '<S9>/Read Parameter3'\n  if (!FLIGHT_hexacopter_DW.obj_b.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_b.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S9>/Read Parameter3'\n\n  // Terminate for MATLABSystem: '<S9>/Read Parameter4'\n  if (!FLIGHT_hexacopter_DW.obj_p.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_p.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S9>/Read Parameter4'\n\n  // Terminate for MATLABSystem: '<S9>/Read Parameter8'\n  if (!FLIGHT_hexacopter_DW.obj_i.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_i.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S9>/Read Parameter8'\n\n  // Terminate for MATLABSystem: '<S9>/Read Parameter6'\n  if (!FLIGHT_hexacopter_DW.obj_a.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_a.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S9>/Read Parameter6'\n\n  // Terminate for MATLABSystem: '<S9>/Read Parameter9'\n  if (!FLIGHT_hexacopter_DW.obj_e.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_e.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S9>/Read Parameter9'\n\n  // Terminate for MATLABSystem: '<S9>/Read Parameter7'\n  if (!FLIGHT_hexacopter_DW.obj_j.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_j.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S9>/Read Parameter7'\n  // End of Terminate for SubSystem: '<Root>/SAS'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter13'\n  if (!FLIGHT_hexacopter_DW.obj_g.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_g.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter13'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter1'\n  if (!FLIGHT_hexacopter_DW.obj_j5.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_j5.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter1'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter2'\n  if (!FLIGHT_hexacopter_DW.obj_ao.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_ao.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter2'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter3'\n  if (!FLIGHT_hexacopter_DW.obj_n.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_n.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter3'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter4'\n  if (!FLIGHT_hexacopter_DW.obj_c.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_c.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter4'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter5'\n  if (!FLIGHT_hexacopter_DW.obj_aq.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_aq.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter5'\n\n  // Terminate for MATLABSystem: '<Root>/PX4 PWM Output'\n  if (!FLIGHT_hexacopter_DW.obj_dl.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_dl.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_dl.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_dl.isSetupComplete) {\n      pwm_disarm(&FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n      pwm_resetServo(FLIGHT_hexacopter_DW.obj_dl.servoCount,\n                     FLIGHT_hexacopter_DW.obj_dl.isMain,\n                     &FLIGHT_hexacopter_DW.obj_dl.actuatorAdvertiseObj);\n      pwm_close(FLIGHT_hexacopter_DW.obj_dl.servoCount,\n                &FLIGHT_hexacopter_DW.obj_dl.actuatorAdvertiseObj,\n                &FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<Root>/PX4 PWM Output'\n  FLIGHT__PX4Timestamp_o_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_o);\n\n  // Terminate for MATLABSystem: '<S567>/SinkBlock'\n  if (!FLIGHT_hexacopter_DW.obj_jk.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_jk.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_jk.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_jk.isSetupComplete) {\n      uORB_write_terminate(&FLIGHT_hexacopter_DW.obj_jk.orbAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S567>/SinkBlock'\n  FLIGHT__PX4Timestamp_o_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_n);\n  FLIGHT__PX4Timestamp_o_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_p);\n\n  // Terminate for MATLABSystem: '<S572>/SinkBlock'\n  if (!FLIGHT_hexacopter_DW.obj_hf.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_hf.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_hf.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_hf.isSetupComplete) {\n      uORB_write_terminate(&FLIGHT_hexacopter_DW.obj_hf.orbAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S572>/SinkBlock'\n  FLIGHT__PX4Timestamp_o_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_ok);\n\n  // Terminate for MATLABSystem: '<S574>/SinkBlock'\n  if (!FLIGHT_hexacopter_DW.obj_px.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_px.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_px.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_px.isSetupComplete) {\n      uORB_write_terminate(&FLIGHT_hexacopter_DW.obj_px.orbAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S574>/SinkBlock'\n  FLIGHT__PX4Timestamp_b_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_pn);\n\n  // Terminate for MATLABSystem: '<S410>/SourceBlock'\n  if (!FLIGHT_hexacopter_DW.obj_p2.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_p2.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_p2.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_p2.isSetupComplete) {\n      uORB_read_terminate(&FLIGHT_hexacopter_DW.obj_p2.eventStructObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S410>/SourceBlock'\n\n  // Terminate for MATLABSystem: '<S401>/SourceBlock'\n  if (!FLIGHT_hexacopter_DW.obj_kk.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_kk.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_kk.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_kk.isSetupComplete) {\n      uORB_read_terminate(&FLIGHT_hexacopter_DW.obj_kk.eventStructObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S401>/SourceBlock'\n\n  // Terminate for IfAction SubSystem: '<Root>/Altitude_Mode'\n  // Terminate for Enabled SubSystem: '<S1>/Vz Controller'\n  FLIGHT__ReadParameter3_Term(&FLIGHT_hexacopter_DW.ReadParameter3_p);\n  FLIGHT__ReadParameter1_Term(&FLIGHT_hexacopter_DW.ReadParameter1_pna);\n  FLIGHT_h_ReadParameter_Term(&FLIGHT_hexacopter_DW.ReadParameter_pn);\n  FLIGHT__ReadParameter2_Term(&FLIGHT_hexacopter_DW.ReadParameter2_pn);\n\n  // End of Terminate for SubSystem: '<S1>/Vz Controller'\n  // End of Terminate for SubSystem: '<Root>/Altitude_Mode'\n\n  // Terminate for IfAction SubSystem: '<Root>/If Action Subsystem'\n  // Terminate for Enabled SubSystem: '<S5>/XY Pos Controller'\n  // Terminate for MATLABSystem: '<S190>/Read Parameter'\n  if (!FLIGHT_hexacopter_DW.obj_eq.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_eq.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S190>/Read Parameter'\n  // End of Terminate for SubSystem: '<S5>/XY Pos Controller'\n\n  // Terminate for Enabled SubSystem: '<S5>/XY Velocity Controller'\n  // Terminate for MATLABSystem: '<S191>/Read Parameter'\n  if (!FLIGHT_hexacopter_DW.obj_pi.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_pi.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S191>/Read Parameter'\n  // End of Terminate for SubSystem: '<S5>/XY Velocity Controller'\n\n  // Terminate for Enabled SubSystem: '<S5>/Altitude Controller'\n  // Terminate for MATLABSystem: '<S187>/Read Parameter1'\n  if (!FLIGHT_hexacopter_DW.obj_m.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_m.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S187>/Read Parameter1'\n  // End of Terminate for SubSystem: '<S5>/Altitude Controller'\n\n  // Terminate for Enabled SubSystem: '<S5>/Vz Controller'\n  FLIGHT__ReadParameter3_Term(&FLIGHT_hexacopter_DW.ReadParameter3_pn);\n  FLIGHT__ReadParameter1_Term(&FLIGHT_hexacopter_DW.ReadParameter1_pnaev);\n  FLIGHT_h_ReadParameter_Term(&FLIGHT_hexacopter_DW.ReadParameter_pna);\n  FLIGHT__ReadParameter2_Term(&FLIGHT_hexacopter_DW.ReadParameter2_pna);\n\n  // End of Terminate for SubSystem: '<S5>/Vz Controller'\n  // End of Terminate for SubSystem: '<Root>/If Action Subsystem'\n  FLIGHT_he_PX4Timestamp_Term(&FLIGHT_hexacopter_DW.PX4Timestamp);\n\n  // Terminate for MATLABSystem: '<S3>/Read Parameter1'\n  if (!FLIGHT_hexacopter_DW.obj_ct.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_ct.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S3>/Read Parameter1'\n\n  // Terminate for MATLABSystem: '<S3>/Read Parameter'\n  if (!FLIGHT_hexacopter_DW.obj_cf.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_cf.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S3>/Read Parameter'\n\n  // Terminate for MATLABSystem: '<S3>/Read Parameter2'\n  if (!FLIGHT_hexacopter_DW.obj_l.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_l.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S3>/Read Parameter2'\n\n  // Terminate for MATLABSystem: '<S578>/SinkBlock'\n  if (!FLIGHT_hexacopter_DW.obj_pt.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_pt.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_pt.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_pt.isSetupComplete) {\n      uORB_write_terminate(&FLIGHT_hexacopter_DW.obj_pt.orbAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S578>/SinkBlock'\n  FLIGHT_he_PX4Timestamp_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_pna);\n\n  // Terminate for MATLABSystem: '<S581>/SinkBlock'\n  if (!FLIGHT_hexacopter_DW.obj_pa.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_pa.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_pa.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_pa.isSetupComplete) {\n      uORB_write_terminate(&FLIGHT_hexacopter_DW.obj_pa.orbAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S581>/SinkBlock'\n  FLIGHT__PX4Timestamp_b_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_pnae);\n\n  // Terminate for MATLABSystem: '<S404>/SourceBlock'\n  if (!FLIGHT_hexacopter_DW.obj_ab.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_ab.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_ab.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_ab.isSetupComplete) {\n      uORB_read_terminate(&FLIGHT_hexacopter_DW.obj_ab.eventStructObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S404>/SourceBlock'\n\n  // Terminate for Enabled SubSystem: '<Root>/CAS'\n  // Terminate for MATLABSystem: '<S2>/Read Parameter9'\n  if (!FLIGHT_hexacopter_DW.obj_k.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_k.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter9'\n\n  // Terminate for MATLABSystem: '<S2>/Read Parameter'\n  if (!FLIGHT_hexacopter_DW.obj_jz.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_jz.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter'\n\n  // Terminate for MATLABSystem: '<S2>/Read Parameter10'\n  if (!FLIGHT_hexacopter_DW.obj_ds.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_ds.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter10'\n\n  // Terminate for MATLABSystem: '<S2>/Read Parameter1'\n  if (!FLIGHT_hexacopter_DW.obj_o.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_o.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter1'\n  // End of Terminate for SubSystem: '<Root>/CAS'\n\n  // Terminate for MATLABSystem: '<S583>/SinkBlock'\n  if (!FLIGHT_hexacopter_DW.obj_a4.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_a4.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_a4.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_a4.isSetupComplete) {\n      uORB_write_terminate(&FLIGHT_hexacopter_DW.obj_a4.orbAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S583>/SinkBlock'\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"FLIGHT_hexacopter.h","type":"header","group":"model","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: FLIGHT_hexacopter.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.146\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu Apr 24 17:45:28 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef FLIGHT_hexacopter_h_\n#define FLIGHT_hexacopter_h_\n#include <drivers/drv_hrt.h>\n#include <poll.h>\n#include <uORB/uORB.h>\n#include \"rtwtypes.h\"\n#include \"MW_Parameter.h\"\n#include \"MW_ParameterRead.h\"\n#include \"MW_PX4_PWM.h\"\n#include \"MW_uORB_Read.h\"\n#include \"MW_uORB_Write.h\"\n#include \"FLIGHT_hexacopter_types.h\"\n#include <uORB/topics/vehicle_local_position.h>\n#include <uORB/topics/vehicle_odometry.h>\n#include <uORB/topics/actuator_outputs.h>\n#include <uORB/topics/input_rc.h>\n#include <uORB/topics/actuator_motors.h>\n#include <uORB/topics/vehicle_local_position_setpoint.h>\n#include <uORB/topics/vehicle_attitude_setpoint.h>\n#include <uORB/topics/vehicle_angular_velocity.h>\n#include <uORB/topics/vehicle_rates_setpoint.h>\n#include <uORB/topics/actuator_controls_status.h>\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include <stddef.h>\n\n// Macros for accessing real-time model data structure\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmStepTask\n#define rtmStepTask(rtm, idx)          ((rtm)->Timing.TaskCounters.TID[(idx)] == 0)\n#endif\n\n#ifndef rtmTaskCounter\n#define rtmTaskCounter(rtm, idx)       ((rtm)->Timing.TaskCounters.TID[(idx)])\n#endif\n\n// Block signals for system '<S3>/PX4 Timestamp'\nstruct B_PX4Timestamp_FLIGHT_hexacop_T {\n  uint64_T PX4Timestamp;               // '<S3>/PX4 Timestamp'\n};\n\n// Block states (default storage) for system '<S3>/PX4 Timestamp'\nstruct DW_PX4Timestamp_FLIGHT_hexaco_T {\n  px4_internal_block_getPX4Abso_T obj; // '<S3>/PX4 Timestamp'\n  boolean_T objisempty;                // '<S3>/PX4 Timestamp'\n};\n\n// Block signals for system '<S19>/Read Parameter'\nstruct B_ReadParameter_FLIGHT_hexaco_T {\n  real32_T ReadParameter_o1;           // '<S19>/Read Parameter'\n};\n\n// Block states (default storage) for system '<S19>/Read Parameter'\nstruct DW_ReadParameter_FLIGHT_hexac_T {\n  px4_internal_block_ParameterU_T obj; // '<S19>/Read Parameter'\n  boolean_T objisempty;                // '<S19>/Read Parameter'\n};\n\n// Block signals for system '<S19>/Read Parameter1'\nstruct B_ReadParameter1_FLIGHT_hexac_T {\n  real32_T ReadParameter1_o1;          // '<S19>/Read Parameter1'\n};\n\n// Block states (default storage) for system '<S19>/Read Parameter1'\nstruct DW_ReadParameter1_FLIGHT_hexa_T {\n  px4_internal_block_ParameterU_T obj; // '<S19>/Read Parameter1'\n  boolean_T objisempty;                // '<S19>/Read Parameter1'\n};\n\n// Block signals for system '<S19>/Read Parameter2'\nstruct B_ReadParameter2_FLIGHT_hexac_T {\n  real32_T ReadParameter2_o1;          // '<S19>/Read Parameter2'\n};\n\n// Block states (default storage) for system '<S19>/Read Parameter2'\nstruct DW_ReadParameter2_FLIGHT_hexa_T {\n  px4_internal_block_ParameterU_T obj; // '<S19>/Read Parameter2'\n  boolean_T objisempty;                // '<S19>/Read Parameter2'\n};\n\n// Block signals for system '<S19>/Read Parameter3'\nstruct B_ReadParameter3_FLIGHT_hexac_T {\n  real32_T ReadParameter3_o1;          // '<S19>/Read Parameter3'\n};\n\n// Block states (default storage) for system '<S19>/Read Parameter3'\nstruct DW_ReadParameter3_FLIGHT_hexa_T {\n  px4_internal_block_ParameterU_T obj; // '<S19>/Read Parameter3'\n  boolean_T objisempty;                // '<S19>/Read Parameter3'\n};\n\n// Block signals for system '<S565>/PX4 Timestamp'\nstruct B_PX4Timestamp_FLIGHT_hexac_l_T {\n  uint64_T PX4Timestamp;               // '<S565>/PX4 Timestamp'\n};\n\n// Block states (default storage) for system '<S565>/PX4 Timestamp'\nstruct DW_PX4Timestamp_FLIGHT_hexa_b_T {\n  px4_internal_block_getPX4Abso_T obj; // '<S565>/PX4 Timestamp'\n  boolean_T objisempty;                // '<S565>/PX4 Timestamp'\n};\n\n// Block signals for system '<S15>/PX4 Timestamp'\nstruct B_PX4Timestamp_FLIGHT_hexac_c_T {\n  uint64_T PX4Timestamp;               // '<S15>/PX4 Timestamp'\n};\n\n// Block states (default storage) for system '<S15>/PX4 Timestamp'\nstruct DW_PX4Timestamp_FLIGHT_hexa_f_T {\n  px4_internal_block_getPX4Abso_T obj; // '<S15>/PX4 Timestamp'\n  boolean_T objisempty;                // '<S15>/PX4 Timestamp'\n};\n\n// Block signals (default storage)\nstruct B_FLIGHT_hexacopter_T {\n  px4_Bus_vehicle_local_position In1;  // '<S403>/In1'\n  px4_Bus_vehicle_local_position r;\n  px4_Bus_vehicle_odometry In1_k;      // '<S405>/In1'\n  px4_Bus_vehicle_odometry r1;\n  px4_Bus_actuator_outputs BusAssignment;// '<S570>/Bus Assignment'\n  px4_Bus_input_rc In1_n;              // '<S411>/In1'\n  px4_Bus_input_rc r2;\n  px4_Bus_actuator_motors BusAssignment_f;// '<S569>/Bus Assignment'\n  px4_Bus_vehicle_local_position_setpoint BusAssignment_g;// '<S16>/Bus Assignment' \n  px4_Bus_vehicle_attitude_setpoint BusAssignment_d;// '<S15>/Bus Assignment'\n  px4_Bus_vehicle_angular_velocity In1_h;// '<S576>/In1'\n  px4_Bus_vehicle_angular_velocity r3;\n  px4_Bus_vehicle_rates_setpoint BusAssignment_e;// '<S17>/Bus Assignment'\n  uint16_T values[18];\n  px4_Bus_actuator_controls_status BusAssignment_gi;// '<S565>/Bus Assignment'\n  uint16_T pwmValue[8];\n  uint16_T DataTypeConversion6[6];     // '<S4>/Data Type Conversion6'\n  uint16_T DataTypeConversion7_k[6];   // '<S4>/Data Type Conversion7'\n  real_T reletive_time_sec;\n  real_T peak_angle_rad;\n  real_T out_roll;                     // '<S3>/MATLAB Function'\n  real_T out_pitch;                    // '<S3>/MATLAB Function'\n  real_T u0;\n  real32_T RateTransition;             // '<Root>/Rate Transition'\n  real32_T RateTransition1;            // '<Root>/Rate Transition1'\n  real32_T RateTransition2;            // '<Root>/Rate Transition2'\n  real32_T RateTransition3;            // '<Root>/Rate Transition3'\n  real32_T Merge1[4];                  // '<Root>/Merge1'\n  real32_T Merge;                      // '<Root>/Merge'\n  real32_T Sum;                        // '<S507>/Sum'\n  real32_T Sum_a;                      // '<S457>/Sum'\n  real32_T Sum2;                       // '<S9>/Sum2'\n  real32_T OutportBufferFordes_xy[2];  // '<S5>/Constant'\n  real32_T Add;                        // '<S5>/Add'\n  real32_T Saturation[2];              // '<S191>/Saturation'\n  real32_T Gain1;                      // '<S191>/Gain1'\n  real32_T PProdOut[2];                // '<S335>/PProd Out'\n  real32_T des_vz;                     // '<S189>/des_vz'\n  real32_T Saturation1;                // '<S189>/Saturation1'\n  real32_T Saturation1_i;              // '<S19>/Saturation1'\n  real32_T Switch2;                    // '<S169>/Switch2'\n  real32_T Switch2_i;                  // '<S118>/Switch2'\n  uint16_T RateTransition4;            // '<Root>/Rate Transition4'\n  uint16_T Output_Limits1[6];          // '<S6>/Output_Limits1'\n  boolean_T RateTransition5;           // '<Root>/Rate Transition5'\n  boolean_T RateTransition6;           // '<Root>/Rate Transition6'\n  B_PX4Timestamp_FLIGHT_hexac_c_T PX4Timestamp_pnae;// '<S15>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexacop_T PX4Timestamp_pna;// '<S3>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexac_c_T PX4Timestamp_pn;// '<S15>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexac_l_T PX4Timestamp_ok;// '<S565>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexac_l_T PX4Timestamp_n;// '<S565>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexac_l_T PX4Timestamp_p;// '<S565>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexac_l_T PX4Timestamp_o;// '<S565>/PX4 Timestamp'\n  B_ReadParameter3_FLIGHT_hexac_T ReadParameter3_pn;// '<S19>/Read Parameter3'\n  B_ReadParameter2_FLIGHT_hexac_T ReadParameter2_pna;// '<S19>/Read Parameter2'\n  B_ReadParameter1_FLIGHT_hexac_T ReadParameter1_pnaev;// '<S19>/Read Parameter1' \n  B_ReadParameter_FLIGHT_hexaco_T ReadParameter_pna;// '<S19>/Read Parameter'\n  B_ReadParameter3_FLIGHT_hexac_T ReadParameter3_p;// '<S19>/Read Parameter3'\n  B_ReadParameter2_FLIGHT_hexac_T ReadParameter2_pn;// '<S19>/Read Parameter2'\n  B_ReadParameter1_FLIGHT_hexac_T ReadParameter1_pna;// '<S19>/Read Parameter1'\n  B_ReadParameter_FLIGHT_hexaco_T ReadParameter_pn;// '<S19>/Read Parameter'\n  B_PX4Timestamp_FLIGHT_hexacop_T PX4Timestamp;// '<S3>/PX4 Timestamp'\n};\n\n// Block states (default storage) for system '<Root>'\nstruct DW_FLIGHT_hexacopter_T {\n  px4_internal_block_ParameterU_T obj; // '<S9>/read_mc_rollrate_p'\n  px4_internal_block_ParameterU_T obj_e;// '<S9>/Read Parameter9'\n  px4_internal_block_ParameterU_T obj_i;// '<S9>/Read Parameter8'\n  px4_internal_block_ParameterU_T obj_j;// '<S9>/Read Parameter7'\n  px4_internal_block_ParameterU_T obj_a;// '<S9>/Read Parameter6'\n  px4_internal_block_ParameterU_T obj_h;// '<S9>/Read Parameter5'\n  px4_internal_block_ParameterU_T obj_p;// '<S9>/Read Parameter4'\n  px4_internal_block_ParameterU_T obj_b;// '<S9>/Read Parameter3'\n  px4_internal_block_ParameterU_T obj_d;// '<S9>/Read Parameter2'\n  px4_internal_block_ParameterU_T obj_ea;// '<S9>/Read Parameter1'\n  px4_internal_block_ParameterU_T obj_pi;// '<S191>/Read Parameter'\n  px4_internal_block_ParameterU_T obj_eq;// '<S190>/Read Parameter'\n  px4_internal_block_ParameterU_T obj_m;// '<S187>/Read Parameter1'\n  px4_internal_block_ParameterU_T obj_aq;// '<S4>/Read Parameter5'\n  px4_internal_block_ParameterU_T obj_c;// '<S4>/Read Parameter4'\n  px4_internal_block_ParameterU_T obj_n;// '<S4>/Read Parameter3'\n  px4_internal_block_ParameterU_T obj_ao;// '<S4>/Read Parameter2'\n  px4_internal_block_ParameterU_T obj_g;// '<S4>/Read Parameter13'\n  px4_internal_block_ParameterU_T obj_j5;// '<S4>/Read Parameter1'\n  px4_internal_block_ParameterU_T obj_l;// '<S3>/Read Parameter2'\n  px4_internal_block_ParameterU_T obj_ct;// '<S3>/Read Parameter1'\n  px4_internal_block_ParameterU_T obj_cf;// '<S3>/Read Parameter'\n  px4_internal_block_ParameterU_T obj_k;// '<S2>/Read Parameter9'\n  px4_internal_block_ParameterU_T obj_ds;// '<S2>/Read Parameter10'\n  px4_internal_block_ParameterU_T obj_o;// '<S2>/Read Parameter1'\n  px4_internal_block_ParameterU_T obj_jz;// '<S2>/Read Parameter'\n  px4_internal_block_Subscriber_T obj_pe;// '<S575>/SourceBlock'\n  px4_internal_block_Subscriber_T obj_p2;// '<S410>/SourceBlock'\n  px4_internal_block_Subscriber_T obj_ab;// '<S404>/SourceBlock'\n  px4_internal_block_Subscriber_T obj_kk;// '<S401>/SourceBlock'\n  px4_internal_block_PWM_FLIGHT_T obj_dl;// '<Root>/PX4 PWM Output'\n  px4_internal_block_Publisher__T obj_a4;// '<S583>/SinkBlock'\n  px4_internal_block_Publisher__T obj_pa;// '<S581>/SinkBlock'\n  px4_internal_block_Publisher__T obj_pt;// '<S578>/SinkBlock'\n  px4_internal_block_Publisher__T obj_px;// '<S574>/SinkBlock'\n  px4_internal_block_Publisher__T obj_hf;// '<S572>/SinkBlock'\n  px4_internal_block_Publisher__T obj_jk;// '<S567>/SinkBlock'\n  real_T start_time_usec;              // '<S3>/MATLAB Function'\n  real32_T Filter_DSTATE;              // '<S493>/Filter'\n  real32_T Integrator_DSTATE;          // '<S498>/Integrator'\n  real32_T Filter_DSTATE_j;            // '<S443>/Filter'\n  real32_T Integrator_DSTATE_c;        // '<S448>/Integrator'\n  real32_T Filter_DSTATE_h;            // '<S543>/Filter'\n  real32_T Integrator_DSTATE_l;        // '<S548>/Integrator'\n  real32_T Filter_DSTATE_g;            // '<S274>/Filter'\n  real32_T Integrator_DSTATE_k;        // '<S279>/Integrator'\n  real32_T Filter_DSTATE_i;            // '<S51>/Filter'\n  real32_T Integrator_DSTATE_e;        // '<S56>/Integrator'\n  real32_T RateTransition_Buffer0;     // '<Root>/Rate Transition'\n  real32_T RateTransition1_Buffer0;    // '<Root>/Rate Transition1'\n  real32_T RateTransition2_Buffer0;    // '<Root>/Rate Transition2'\n  real32_T RateTransition3_Buffer0;    // '<Root>/Rate Transition3'\n  uint16_T RateTransition4_Buffer0;    // '<Root>/Rate Transition4'\n  int8_T Filter_PrevResetState;        // '<S274>/Filter'\n  int8_T Integrator_PrevResetState;    // '<S279>/Integrator'\n  boolean_T RateTransition5_Buffer0;   // '<Root>/Rate Transition5'\n  boolean_T RateTransition6_Buffer0;   // '<Root>/Rate Transition6'\n  DW_PX4Timestamp_FLIGHT_hexa_f_T PX4Timestamp_pnae;// '<S15>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexaco_T PX4Timestamp_pna;// '<S3>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexa_f_T PX4Timestamp_pn;// '<S15>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexa_b_T PX4Timestamp_ok;// '<S565>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexa_b_T PX4Timestamp_n;// '<S565>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexa_b_T PX4Timestamp_p;// '<S565>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexa_b_T PX4Timestamp_o;// '<S565>/PX4 Timestamp'\n  DW_ReadParameter3_FLIGHT_hexa_T ReadParameter3_pn;// '<S19>/Read Parameter3'\n  DW_ReadParameter2_FLIGHT_hexa_T ReadParameter2_pna;// '<S19>/Read Parameter2'\n  DW_ReadParameter1_FLIGHT_hexa_T ReadParameter1_pnaev;// '<S19>/Read Parameter1' \n  DW_ReadParameter_FLIGHT_hexac_T ReadParameter_pna;// '<S19>/Read Parameter'\n  DW_ReadParameter3_FLIGHT_hexa_T ReadParameter3_p;// '<S19>/Read Parameter3'\n  DW_ReadParameter2_FLIGHT_hexa_T ReadParameter2_pn;// '<S19>/Read Parameter2'\n  DW_ReadParameter1_FLIGHT_hexa_T ReadParameter1_pna;// '<S19>/Read Parameter1'\n  DW_ReadParameter_FLIGHT_hexac_T ReadParameter_pn;// '<S19>/Read Parameter'\n  DW_PX4Timestamp_FLIGHT_hexaco_T PX4Timestamp;// '<S3>/PX4 Timestamp'\n};\n\n// Parameters (default storage)\nstruct P_FLIGHT_hexacopter_T_ {\n  real_T SampleTime;                   // Variable: SampleTime\n                                          //  Referenced by:\n                                          //    '<S2>/Read Parameter'\n                                          //    '<S2>/Read Parameter1'\n                                          //    '<S2>/Read Parameter10'\n                                          //    '<S2>/Read Parameter9'\n                                          //    '<S3>/Read Parameter'\n                                          //    '<S3>/Read Parameter1'\n                                          //    '<S3>/Read Parameter2'\n                                          //    '<S19>/Read Parameter'\n                                          //    '<S19>/Read Parameter1'\n                                          //    '<S19>/Read Parameter2'\n                                          //    '<S19>/Read Parameter3'\n                                          //    '<S187>/Read Parameter1'\n                                          //    '<S189>/Read Parameter'\n                                          //    '<S189>/Read Parameter1'\n                                          //    '<S189>/Read Parameter2'\n                                          //    '<S189>/Read Parameter3'\n                                          //    '<S190>/Read Parameter'\n                                          //    '<S191>/Read Parameter'\n\n  real_T SampleTime_SAS;               // Variable: SampleTime_SAS\n                                          //  Referenced by:\n                                          //    '<S4>/Read Parameter1'\n                                          //    '<S4>/Read Parameter13'\n                                          //    '<S4>/Read Parameter2'\n                                          //    '<S4>/Read Parameter3'\n                                          //    '<S4>/Read Parameter4'\n                                          //    '<S4>/Read Parameter5'\n                                          //    '<S9>/Read Parameter1'\n                                          //    '<S9>/Read Parameter2'\n                                          //    '<S9>/Read Parameter3'\n                                          //    '<S9>/Read Parameter4'\n                                          //    '<S9>/Read Parameter5'\n                                          //    '<S9>/Read Parameter6'\n                                          //    '<S9>/Read Parameter7'\n                                          //    '<S9>/Read Parameter8'\n                                          //    '<S9>/Read Parameter9'\n                                          //    '<S9>/read_mc_rollrate_p'\n\n  real32_T MAX_CONTROL_ANGLE_PITCH;    // Variable: MAX_CONTROL_ANGLE_PITCH\n                                          //  Referenced by:\n                                          //    '<S10>/Gain5'\n                                          //    '<S18>/Gain2'\n\n  real32_T MAX_CONTROL_ANGLE_RATE_Y;   // Variable: MAX_CONTROL_ANGLE_RATE_Y\n                                          //  Referenced by:\n                                          //    '<S10>/Gain6'\n                                          //    '<S18>/Gain3'\n                                          //    '<S188>/Gain3'\n\n  real32_T MAX_CONTROL_ANGLE_ROLL;     // Variable: MAX_CONTROL_ANGLE_ROLL\n                                          //  Referenced by:\n                                          //    '<S10>/Gain4'\n                                          //    '<S18>/Gain1'\n\n  real32_T PIDController4_InitialCondition;\n                              // Mask Parameter: PIDController4_InitialCondition\n                                 //  Referenced by: '<S51>/Filter'\n\n  real32_T PIDController4_InitialConditi_l;\n                              // Mask Parameter: PIDController4_InitialConditi_l\n                                 //  Referenced by: '<S274>/Filter'\n\n  real32_T pid_ctrl_rollrate_InitialCondit;\n                              // Mask Parameter: pid_ctrl_rollrate_InitialCondit\n                                 //  Referenced by: '<S493>/Filter'\n\n  real32_T pid_ctrl_pitchrate_InitialCondi;\n                              // Mask Parameter: pid_ctrl_pitchrate_InitialCondi\n                                 //  Referenced by: '<S443>/Filter'\n\n  real32_T pid_ctrl_yawrate_InitialConditi;\n                              // Mask Parameter: pid_ctrl_yawrate_InitialConditi\n                                 //  Referenced by: '<S543>/Filter'\n\n  real32_T PIDController4_InitialConditi_a;\n                              // Mask Parameter: PIDController4_InitialConditi_a\n                                 //  Referenced by: '<S56>/Integrator'\n\n  real32_T PIDController4_InitialConditi_i;\n                              // Mask Parameter: PIDController4_InitialConditi_i\n                                 //  Referenced by: '<S279>/Integrator'\n\n  real32_T pid_ctrl_rollrate_InitialCond_c;\n                              // Mask Parameter: pid_ctrl_rollrate_InitialCond_c\n                                 //  Referenced by: '<S498>/Integrator'\n\n  real32_T pid_ctrl_pitchrate_InitialCon_c;\n                              // Mask Parameter: pid_ctrl_pitchrate_InitialCon_c\n                                 //  Referenced by: '<S448>/Integrator'\n\n  real32_T pid_ctrl_yawrate_InitialCondi_h;\n                              // Mask Parameter: pid_ctrl_yawrate_InitialCondi_h\n                                 //  Referenced by: '<S548>/Integrator'\n\n  real32_T PIDController4_LowerSaturationL;\n                              // Mask Parameter: PIDController4_LowerSaturationL\n                                 //  Referenced by:\n                                 //    '<S63>/Saturation'\n                                 //    '<S48>/DeadZone'\n\n  real32_T PIDController4_LowerSaturatio_a;\n                              // Mask Parameter: PIDController4_LowerSaturatio_a\n                                 //  Referenced by: '<S233>/Saturation'\n\n  real32_T PIDController4_LowerSaturatio_f;\n                              // Mask Parameter: PIDController4_LowerSaturatio_f\n                                 //  Referenced by:\n                                 //    '<S286>/Saturation'\n                                 //    '<S271>/DeadZone'\n\n  real32_T PIDController4_UpperSaturationL;\n                              // Mask Parameter: PIDController4_UpperSaturationL\n                                 //  Referenced by:\n                                 //    '<S63>/Saturation'\n                                 //    '<S48>/DeadZone'\n\n  real32_T PIDController4_UpperSaturatio_h;\n                              // Mask Parameter: PIDController4_UpperSaturatio_h\n                                 //  Referenced by: '<S233>/Saturation'\n\n  real32_T PIDController4_UpperSaturati_hy;\n                              // Mask Parameter: PIDController4_UpperSaturati_hy\n                                 //  Referenced by:\n                                 //    '<S286>/Saturation'\n                                 //    '<S271>/DeadZone'\n\n  uint16_T CompareToConstant_const;   // Mask Parameter: CompareToConstant_const\n                                         //  Referenced by: '<S180>/Constant'\n\n  uint16_T CompareToConstant3_const; // Mask Parameter: CompareToConstant3_const\n                                        //  Referenced by: '<S409>/Constant'\n\n  uint16_T CompareToConstant_const_n;\n                                    // Mask Parameter: CompareToConstant_const_n\n                                       //  Referenced by: '<S407>/Constant'\n\n  px4_Bus_vehicle_local_position Out1_Y0;// Computed Parameter: Out1_Y0\n                                            //  Referenced by: '<S403>/Out1'\n\n  px4_Bus_vehicle_local_position Constant_Value;// Computed Parameter: Constant_Value\n                                                   //  Referenced by: '<S401>/Constant'\n\n  px4_Bus_vehicle_odometry Out1_Y0_d;  // Computed Parameter: Out1_Y0_d\n                                          //  Referenced by: '<S405>/Out1'\n\n  px4_Bus_vehicle_odometry Constant_Value_g;// Computed Parameter: Constant_Value_g\n                                               //  Referenced by: '<S404>/Constant'\n\n  px4_Bus_actuator_outputs Constant_Value_f;// Computed Parameter: Constant_Value_f\n                                               //  Referenced by: '<S573>/Constant'\n\n  px4_Bus_actuator_motors Constant_Value_m;// Computed Parameter: Constant_Value_m\n                                              //  Referenced by: '<S571>/Constant'\n\n  px4_Bus_input_rc Out1_Y0_p;          // Computed Parameter: Out1_Y0_p\n                                          //  Referenced by: '<S411>/Out1'\n\n  px4_Bus_input_rc Constant_Value_b;   // Computed Parameter: Constant_Value_b\n                                          //  Referenced by: '<S410>/Constant'\n\n  px4_Bus_vehicle_local_position_setpoint Constant_Value_n;// Computed Parameter: Constant_Value_n\n                                                              //  Referenced by: '<S580>/Constant'\n\n  px4_Bus_vehicle_attitude_setpoint Constant_Value_j;// Computed Parameter: Constant_Value_j\n                                                        //  Referenced by: '<S577>/Constant'\n\n  px4_Bus_vehicle_angular_velocity Out1_Y0_pn;// Computed Parameter: Out1_Y0_pn\n                                                 //  Referenced by: '<S576>/Out1'\n\n  px4_Bus_vehicle_angular_velocity Constant_Value_gk;// Computed Parameter: Constant_Value_gk\n                                                        //  Referenced by: '<S575>/Constant'\n\n  px4_Bus_vehicle_rates_setpoint Constant_Value_i;// Computed Parameter: Constant_Value_i\n                                                     //  Referenced by: '<S582>/Constant'\n\n  px4_Bus_actuator_controls_status Constant_Value_a;// Computed Parameter: Constant_Value_a\n                                                       //  Referenced by: '<S566>/Constant'\n\n  real_T Constant1_Value;              // Expression: 100\n                                          //  Referenced by: '<S4>/Constant1'\n\n  real_T Constant2_Value;              // Expression: 100\n                                          //  Referenced by: '<S4>/Constant2'\n\n  real_T Constant3_Value;              // Expression: 100\n                                          //  Referenced by: '<S4>/Constant3'\n\n  real_T Constant4_Value;              // Expression: 100\n                                          //  Referenced by: '<S4>/Constant4'\n\n  real_T Constant5_Value;              // Expression: 100\n                                          //  Referenced by: '<S4>/Constant5'\n\n  real_T Constant_Value_mc;            // Expression: 100\n                                          //  Referenced by: '<S4>/Constant'\n\n  real_T Constant_Value_c;             // Expression: 1094\n                                          //  Referenced by: '<S10>/Constant'\n\n  real_T Gain_Gain;                    // Expression: 1/800\n                                          //  Referenced by: '<S10>/Gain'\n\n  real_T Gain_Gain_j;                  // Expression: 0.01\n                                          //  Referenced by: '<S181>/Gain'\n\n  real_T Saturation_UpperSat;          // Expression: 1\n                                          //  Referenced by: '<S181>/Saturation'\n\n  real_T Saturation_LowerSat;          // Expression: 0\n                                          //  Referenced by: '<S181>/Saturation'\n\n  real_T Gain_Gain_h;                  // Expression: 0.01\n                                          //  Referenced by: '<S182>/Gain'\n\n  real_T Saturation_UpperSat_m;        // Expression: 1\n                                          //  Referenced by: '<S182>/Saturation'\n\n  real_T Saturation_LowerSat_o;        // Expression: 0\n                                          //  Referenced by: '<S182>/Saturation'\n\n  real_T Gain_Gain_c;                  // Expression: 0.01\n                                          //  Referenced by: '<S183>/Gain'\n\n  real_T Saturation_UpperSat_b;        // Expression: 1\n                                          //  Referenced by: '<S183>/Saturation'\n\n  real_T Saturation_LowerSat_g;        // Expression: 0\n                                          //  Referenced by: '<S183>/Saturation'\n\n  real_T Gain_Gain_n;                  // Expression: 0.01\n                                          //  Referenced by: '<S184>/Gain'\n\n  real_T Saturation_UpperSat_be;       // Expression: 1\n                                          //  Referenced by: '<S184>/Saturation'\n\n  real_T Saturation_LowerSat_e;        // Expression: 0\n                                          //  Referenced by: '<S184>/Saturation'\n\n  real_T Gain_Gain_f;                  // Expression: 0.01\n                                          //  Referenced by: '<S185>/Gain'\n\n  real_T Saturation_UpperSat_d;        // Expression: 1\n                                          //  Referenced by: '<S185>/Saturation'\n\n  real_T Saturation_LowerSat_l;        // Expression: 0\n                                          //  Referenced by: '<S185>/Saturation'\n\n  real_T Gain_Gain_m;                  // Expression: 0.01\n                                          //  Referenced by: '<S186>/Gain'\n\n  real_T Saturation_UpperSat_i;        // Expression: 1\n                                          //  Referenced by: '<S186>/Saturation'\n\n  real_T Saturation_LowerSat_n;        // Expression: 0\n                                          //  Referenced by: '<S186>/Saturation'\n\n  real32_T Gain1_Gain;                 // Computed Parameter: Gain1_Gain\n                                          //  Referenced by: '<S2>/Gain1'\n\n  real32_T Gain_Gain_m3;               // Computed Parameter: Gain_Gain_m3\n                                          //  Referenced by: '<S2>/Gain'\n\n  real32_T des_p_Y0;                   // Computed Parameter: des_p_Y0\n                                          //  Referenced by: '<S2>/des_p'\n\n  real32_T des_q_Y0;                   // Computed Parameter: des_q_Y0\n                                          //  Referenced by: '<S2>/des_q'\n\n  real32_T Gain1_Gain_g;               // Computed Parameter: Gain1_Gain_g\n                                          //  Referenced by: '<S73>/Gain1'\n\n  real32_T Gain1_Gain_c;               // Computed Parameter: Gain1_Gain_c\n                                          //  Referenced by: '<S74>/Gain1'\n\n  real32_T throttle_Y0;                // Computed Parameter: throttle_Y0\n                                          //  Referenced by: '<S19>/throttle'\n\n  real32_T Constant1_Value_n;          // Computed Parameter: Constant1_Value_n\n                                          //  Referenced by: '<S46>/Constant1'\n\n  real32_T Constant_Value_bi;          // Computed Parameter: Constant_Value_bi\n                                          //  Referenced by: '<S19>/Constant'\n\n  real32_T Gain_Gain_d;                // Computed Parameter: Gain_Gain_d\n                                          //  Referenced by: '<S19>/Gain'\n\n  real32_T Filter_gainval;             // Computed Parameter: Filter_gainval\n                                          //  Referenced by: '<S51>/Filter'\n\n  real32_T Integrator_gainval;         // Computed Parameter: Integrator_gainval\n                                          //  Referenced by: '<S56>/Integrator'\n\n  real32_T Saturation1_UpperSat;     // Computed Parameter: Saturation1_UpperSat\n                                        //  Referenced by: '<S19>/Saturation1'\n\n  real32_T Saturation1_LowerSat;     // Computed Parameter: Saturation1_LowerSat\n                                        //  Referenced by: '<S19>/Saturation1'\n\n  real32_T Clamping_zero_Value;       // Computed Parameter: Clamping_zero_Value\n                                         //  Referenced by: '<S46>/Clamping_zero'\n\n  real32_T DeadZone3_Start;            // Computed Parameter: DeadZone3_Start\n                                          //  Referenced by: '<S18>/Dead Zone3'\n\n  real32_T DeadZone3_End;              // Computed Parameter: DeadZone3_End\n                                          //  Referenced by: '<S18>/Dead Zone3'\n\n  real32_T Saturation9_UpperSat;     // Computed Parameter: Saturation9_UpperSat\n                                        //  Referenced by: '<S18>/Saturation9'\n\n  real32_T Saturation9_LowerSat;     // Computed Parameter: Saturation9_LowerSat\n                                        //  Referenced by: '<S18>/Saturation9'\n\n  real32_T DeadZone2_Start;            // Computed Parameter: DeadZone2_Start\n                                          //  Referenced by: '<S18>/Dead Zone2'\n\n  real32_T DeadZone2_End;              // Computed Parameter: DeadZone2_End\n                                          //  Referenced by: '<S18>/Dead Zone2'\n\n  real32_T Saturation3_UpperSat;     // Computed Parameter: Saturation3_UpperSat\n                                        //  Referenced by: '<S18>/Saturation3'\n\n  real32_T Saturation3_LowerSat;     // Computed Parameter: Saturation3_LowerSat\n                                        //  Referenced by: '<S18>/Saturation3'\n\n  real32_T DeadZone4_Start;            // Computed Parameter: DeadZone4_Start\n                                          //  Referenced by: '<S18>/Dead Zone4'\n\n  real32_T DeadZone4_End;              // Computed Parameter: DeadZone4_End\n                                          //  Referenced by: '<S18>/Dead Zone4'\n\n  real32_T Saturation10_UpperSat;   // Computed Parameter: Saturation10_UpperSat\n                                       //  Referenced by: '<S18>/Saturation10'\n\n  real32_T Saturation10_LowerSat;   // Computed Parameter: Saturation10_LowerSat\n                                       //  Referenced by: '<S18>/Saturation10'\n\n  real32_T Gain_Gain_e;                // Computed Parameter: Gain_Gain_e\n                                          //  Referenced by: '<S18>/Gain'\n\n  real32_T DeadZone1_Start;            // Computed Parameter: DeadZone1_Start\n                                          //  Referenced by: '<S18>/Dead Zone1'\n\n  real32_T DeadZone1_End;              // Computed Parameter: DeadZone1_End\n                                          //  Referenced by: '<S18>/Dead Zone1'\n\n  real32_T Saturation1_UpperSat_d; // Computed Parameter: Saturation1_UpperSat_d\n                                      //  Referenced by: '<S18>/Saturation1'\n\n  real32_T Saturation1_LowerSat_b; // Computed Parameter: Saturation1_LowerSat_b\n                                      //  Referenced by: '<S18>/Saturation1'\n\n  real32_T des_vz_Y0;                  // Computed Parameter: des_vz_Y0\n                                          //  Referenced by: '<S187>/des_vz'\n\n  real32_T throttle_Y0_o;              // Computed Parameter: throttle_Y0_o\n                                          //  Referenced by: '<S189>/throttle'\n\n  real32_T log_alt_Y0;                 // Computed Parameter: log_alt_Y0\n                                          //  Referenced by: '<S189>/log_alt'\n\n  real32_T Constant1_Value_m;          // Computed Parameter: Constant1_Value_m\n                                          //  Referenced by: '<S269>/Constant1'\n\n  real32_T Constant_Value_e;           // Computed Parameter: Constant_Value_e\n                                          //  Referenced by: '<S189>/Constant'\n\n  real32_T Gain_Gain_b;                // Computed Parameter: Gain_Gain_b\n                                          //  Referenced by: '<S189>/Gain'\n\n  real32_T Filter_gainval_h;           // Computed Parameter: Filter_gainval_h\n                                          //  Referenced by: '<S274>/Filter'\n\n  real32_T Integrator_gainval_l;     // Computed Parameter: Integrator_gainval_l\n                                        //  Referenced by: '<S279>/Integrator'\n\n  real32_T Saturation1_UpperSat_e; // Computed Parameter: Saturation1_UpperSat_e\n                                      //  Referenced by: '<S189>/Saturation1'\n\n  real32_T Saturation1_LowerSat_bn;\n                                  // Computed Parameter: Saturation1_LowerSat_bn\n                                     //  Referenced by: '<S189>/Saturation1'\n\n  real32_T Clamping_zero_Value_f;   // Computed Parameter: Clamping_zero_Value_f\n                                       //  Referenced by: '<S269>/Clamping_zero'\n\n  real32_T des_vxvy_Y0;                // Computed Parameter: des_vxvy_Y0\n                                          //  Referenced by: '<S190>/des_vxvy'\n\n  real32_T des_pitch_Y0;               // Computed Parameter: des_pitch_Y0\n                                          //  Referenced by: '<S191>/des_pitch'\n\n  real32_T des_roll_Y0;                // Computed Parameter: des_roll_Y0\n                                          //  Referenced by: '<S191>/des_roll'\n\n  real32_T Gain_Gain_a;                // Computed Parameter: Gain_Gain_a\n                                          //  Referenced by: '<S349>/Gain'\n\n  real32_T Saturation_UpperSat_e;   // Computed Parameter: Saturation_UpperSat_e\n                                       //  Referenced by: '<S191>/Saturation'\n\n  real32_T Saturation_LowerSat_a;   // Computed Parameter: Saturation_LowerSat_a\n                                       //  Referenced by: '<S191>/Saturation'\n\n  real32_T Gain1_Gain_i;               // Computed Parameter: Gain1_Gain_i\n                                          //  Referenced by: '<S191>/Gain1'\n\n  real32_T des_z_Y0;                   // Computed Parameter: des_z_Y0\n                                          //  Referenced by: '<S5>/des_z'\n\n  real32_T Constant_Value_k[2];        // Computed Parameter: Constant_Value_k\n                                          //  Referenced by: '<S5>/Constant'\n\n  real32_T DeadZone4_Start_d;          // Computed Parameter: DeadZone4_Start_d\n                                          //  Referenced by: '<S188>/Dead Zone4'\n\n  real32_T DeadZone4_End_l;            // Computed Parameter: DeadZone4_End_l\n                                          //  Referenced by: '<S188>/Dead Zone4'\n\n  real32_T Saturation10_UpperSat_m;\n                                  // Computed Parameter: Saturation10_UpperSat_m\n                                     //  Referenced by: '<S188>/Saturation10'\n\n  real32_T Saturation10_LowerSat_n;\n                                  // Computed Parameter: Saturation10_LowerSat_n\n                                     //  Referenced by: '<S188>/Saturation10'\n\n  real32_T Gain_Gain_o;                // Computed Parameter: Gain_Gain_o\n                                          //  Referenced by: '<S188>/Gain'\n\n  real32_T DeadZone2_Start_k;          // Computed Parameter: DeadZone2_Start_k\n                                          //  Referenced by: '<S188>/Dead Zone2'\n\n  real32_T DeadZone2_End_k;            // Computed Parameter: DeadZone2_End_k\n                                          //  Referenced by: '<S188>/Dead Zone2'\n\n  real32_T Saturation3_UpperSat_b; // Computed Parameter: Saturation3_UpperSat_b\n                                      //  Referenced by: '<S188>/Saturation3'\n\n  real32_T Saturation3_LowerSat_a; // Computed Parameter: Saturation3_LowerSat_a\n                                      //  Referenced by: '<S188>/Saturation3'\n\n  real32_T DeadZone3_Start_p;          // Computed Parameter: DeadZone3_Start_p\n                                          //  Referenced by: '<S10>/Dead Zone3'\n\n  real32_T DeadZone3_End_l;            // Computed Parameter: DeadZone3_End_l\n                                          //  Referenced by: '<S10>/Dead Zone3'\n\n  real32_T Saturation_UpperSat_o;   // Computed Parameter: Saturation_UpperSat_o\n                                       //  Referenced by: '<S10>/Saturation'\n\n  real32_T Saturation_LowerSat_el; // Computed Parameter: Saturation_LowerSat_el\n                                      //  Referenced by: '<S10>/Saturation'\n\n  real32_T Constant1_Value_l;          // Computed Parameter: Constant1_Value_l\n                                          //  Referenced by: '<S10>/Constant1'\n\n  real32_T Gain2_Gain;                 // Computed Parameter: Gain2_Gain\n                                          //  Referenced by: '<S10>/Gain2'\n\n  real32_T DeadZone2_Start_o;          // Computed Parameter: DeadZone2_Start_o\n                                          //  Referenced by: '<S10>/Dead Zone2'\n\n  real32_T DeadZone2_End_e;            // Computed Parameter: DeadZone2_End_e\n                                          //  Referenced by: '<S10>/Dead Zone2'\n\n  real32_T Saturation1_UpperSat_l; // Computed Parameter: Saturation1_UpperSat_l\n                                      //  Referenced by: '<S10>/Saturation1'\n\n  real32_T Saturation1_LowerSat_i; // Computed Parameter: Saturation1_LowerSat_i\n                                      //  Referenced by: '<S10>/Saturation1'\n\n  real32_T Constant2_Value_i;          // Computed Parameter: Constant2_Value_i\n                                          //  Referenced by: '<S10>/Constant2'\n\n  real32_T Gain1_Gain_m;               // Computed Parameter: Gain1_Gain_m\n                                          //  Referenced by: '<S10>/Gain1'\n\n  real32_T DeadZone1_Start_c;          // Computed Parameter: DeadZone1_Start_c\n                                          //  Referenced by: '<S10>/Dead Zone1'\n\n  real32_T DeadZone1_End_m;            // Computed Parameter: DeadZone1_End_m\n                                          //  Referenced by: '<S10>/Dead Zone1'\n\n  real32_T Saturation2_UpperSat;     // Computed Parameter: Saturation2_UpperSat\n                                        //  Referenced by: '<S10>/Saturation2'\n\n  real32_T Saturation2_LowerSat;     // Computed Parameter: Saturation2_LowerSat\n                                        //  Referenced by: '<S10>/Saturation2'\n\n  real32_T Constant3_Value_e;          // Computed Parameter: Constant3_Value_e\n                                          //  Referenced by: '<S10>/Constant3'\n\n  real32_T Gain3_Gain;                 // Computed Parameter: Gain3_Gain\n                                          //  Referenced by: '<S10>/Gain3'\n\n  real32_T DeadZone_Start;             // Computed Parameter: DeadZone_Start\n                                          //  Referenced by: '<S10>/Dead Zone'\n\n  real32_T DeadZone_End;               // Computed Parameter: DeadZone_End\n                                          //  Referenced by: '<S10>/Dead Zone'\n\n  real32_T Saturation3_UpperSat_b4;\n                                  // Computed Parameter: Saturation3_UpperSat_b4\n                                     //  Referenced by: '<S10>/Saturation3'\n\n  real32_T Saturation3_LowerSat_j; // Computed Parameter: Saturation3_LowerSat_j\n                                      //  Referenced by: '<S10>/Saturation3'\n\n  real32_T tau_roll_Y0;                // Computed Parameter: tau_roll_Y0\n                                          //  Referenced by: '<S9>/tau_roll'\n\n  real32_T tau_pitch_Y0;               // Computed Parameter: tau_pitch_Y0\n                                          //  Referenced by: '<S9>/tau_pitch'\n\n  real32_T tau_yaw_Y0;                 // Computed Parameter: tau_yaw_Y0\n                                          //  Referenced by: '<S9>/tau_yaw'\n\n  real32_T Constant_Value_j4;          // Computed Parameter: Constant_Value_j4\n                                          //  Referenced by: '<S9>/Constant'\n\n  real32_T Filter_gainval_o;           // Computed Parameter: Filter_gainval_o\n                                          //  Referenced by: '<S493>/Filter'\n\n  real32_T Integrator_gainval_i;     // Computed Parameter: Integrator_gainval_i\n                                        //  Referenced by: '<S498>/Integrator'\n\n  real32_T Constant1_Value_f;          // Computed Parameter: Constant1_Value_f\n                                          //  Referenced by: '<S9>/Constant1'\n\n  real32_T Filter_gainval_f;           // Computed Parameter: Filter_gainval_f\n                                          //  Referenced by: '<S443>/Filter'\n\n  real32_T Integrator_gainval_im;   // Computed Parameter: Integrator_gainval_im\n                                       //  Referenced by: '<S448>/Integrator'\n\n  real32_T Constant2_Value_m;          // Computed Parameter: Constant2_Value_m\n                                          //  Referenced by: '<S9>/Constant2'\n\n  real32_T Filter_gainval_m;           // Computed Parameter: Filter_gainval_m\n                                          //  Referenced by: '<S543>/Filter'\n\n  real32_T Integrator_gainval_e;     // Computed Parameter: Integrator_gainval_e\n                                        //  Referenced by: '<S548>/Integrator'\n\n  real32_T RateTransition_InitialCondition;\n                          // Computed Parameter: RateTransition_InitialCondition\n                             //  Referenced by: '<Root>/Rate Transition'\n\n  real32_T RateTransition1_InitialConditio;\n                          // Computed Parameter: RateTransition1_InitialConditio\n                             //  Referenced by: '<Root>/Rate Transition1'\n\n  real32_T RateTransition2_InitialConditio;\n                          // Computed Parameter: RateTransition2_InitialConditio\n                             //  Referenced by: '<Root>/Rate Transition2'\n\n  real32_T RateTransition3_InitialConditio;\n                          // Computed Parameter: RateTransition3_InitialConditio\n                             //  Referenced by: '<Root>/Rate Transition3'\n\n  real32_T Constant_Value_kf;          // Computed Parameter: Constant_Value_kf\n                                          //  Referenced by: '<S181>/Constant'\n\n  real32_T Constant_Value_ms;          // Computed Parameter: Constant_Value_ms\n                                          //  Referenced by: '<S182>/Constant'\n\n  real32_T Constant_Value_ii;          // Computed Parameter: Constant_Value_ii\n                                          //  Referenced by: '<S183>/Constant'\n\n  real32_T Constant_Value_j4x;         // Computed Parameter: Constant_Value_j4x\n                                          //  Referenced by: '<S184>/Constant'\n\n  real32_T Constant_Value_l;           // Computed Parameter: Constant_Value_l\n                                          //  Referenced by: '<S185>/Constant'\n\n  real32_T Constant_Value_o;           // Computed Parameter: Constant_Value_o\n                                          //  Referenced by: '<S186>/Constant'\n\n  real32_T Constant1_Value_i[6];       // Computed Parameter: Constant1_Value_i\n                                          //  Referenced by: '<S12>/Constant1'\n\n  real32_T Saturation_UpperSat_ep; // Computed Parameter: Saturation_UpperSat_ep\n                                      //  Referenced by: '<S568>/Saturation'\n\n  real32_T Saturation_LowerSat_p;   // Computed Parameter: Saturation_LowerSat_p\n                                       //  Referenced by: '<S568>/Saturation'\n\n  real32_T Constant_Value_ez;          // Computed Parameter: Constant_Value_ez\n                                          //  Referenced by: '<S568>/Constant'\n\n  real32_T Gain_Gain_mg;               // Computed Parameter: Gain_Gain_mg\n                                          //  Referenced by: '<S568>/Gain'\n\n  real32_T Constant_Value_bm[10];      // Computed Parameter: Constant_Value_bm\n                                          //  Referenced by: '<S12>/Constant'\n\n  real32_T Merge1_InitialOutput;     // Computed Parameter: Merge1_InitialOutput\n                                        //  Referenced by: '<Root>/Merge1'\n\n  real32_T Constant_Value_gq;          // Computed Parameter: Constant_Value_gq\n                                          //  Referenced by: '<S15>/Constant'\n\n  real32_T Constant_Value_a5;          // Computed Parameter: Constant_Value_a5\n                                          //  Referenced by: '<Root>/Constant'\n\n  real32_T u2_Gain;                    // Computed Parameter: u2_Gain\n                                          //  Referenced by: '<S579>/1//2'\n\n  real32_T Merge_InitialOutput;       // Computed Parameter: Merge_InitialOutput\n                                         //  Referenced by: '<Root>/Merge'\n\n  real32_T Constant_Value_ll;          // Computed Parameter: Constant_Value_ll\n                                          //  Referenced by: '<S17>/Constant'\n\n  uint32_T Constant2_Value_e;          // Computed Parameter: Constant2_Value_e\n                                          //  Referenced by: '<S12>/Constant2'\n\n  uint16_T PWM_Y0;                     // Computed Parameter: PWM_Y0\n                                          //  Referenced by: '<S6>/PWM'\n\n  uint16_T Output_Limits1_UpperSat;\n                                  // Computed Parameter: Output_Limits1_UpperSat\n                                     //  Referenced by: '<S6>/Output_Limits1'\n\n  uint16_T Output_Limits1_LowerSat;\n                                  // Computed Parameter: Output_Limits1_LowerSat\n                                     //  Referenced by: '<S6>/Output_Limits1'\n\n  uint16_T RateTransition4_InitialConditio;\n                          // Computed Parameter: RateTransition4_InitialConditio\n                             //  Referenced by: '<Root>/Rate Transition4'\n\n  boolean_T RateTransition5_InitialConditio;\n                          // Computed Parameter: RateTransition5_InitialConditio\n                             //  Referenced by: '<Root>/Rate Transition5'\n\n  boolean_T RateTransition6_InitialConditio;\n                          // Computed Parameter: RateTransition6_InitialConditio\n                             //  Referenced by: '<Root>/Rate Transition6'\n\n  int8_T Constant_Value_jc;            // Computed Parameter: Constant_Value_jc\n                                          //  Referenced by: '<S46>/Constant'\n\n  int8_T Constant2_Value_mj;           // Computed Parameter: Constant2_Value_mj\n                                          //  Referenced by: '<S46>/Constant2'\n\n  int8_T Constant3_Value_es;           // Computed Parameter: Constant3_Value_es\n                                          //  Referenced by: '<S46>/Constant3'\n\n  int8_T Constant4_Value_j;            // Computed Parameter: Constant4_Value_j\n                                          //  Referenced by: '<S46>/Constant4'\n\n  int8_T Constant_Value_mn;            // Computed Parameter: Constant_Value_mn\n                                          //  Referenced by: '<S269>/Constant'\n\n  int8_T Constant2_Value_p;            // Computed Parameter: Constant2_Value_p\n                                          //  Referenced by: '<S269>/Constant2'\n\n  int8_T Constant3_Value_n;            // Computed Parameter: Constant3_Value_n\n                                          //  Referenced by: '<S269>/Constant3'\n\n  int8_T Constant4_Value_i;            // Computed Parameter: Constant4_Value_i\n                                          //  Referenced by: '<S269>/Constant4'\n\n};\n\n// Real-time Model Data Structure\nstruct tag_RTM_FLIGHT_hexacopter_T {\n  const char_T * volatile errorStatus;\n\n  //\n  //  Timing:\n  //  The following substructure contains information regarding\n  //  the timing information for the model.\n\n  struct {\n    struct {\n      uint8_T TID[2];\n    } TaskCounters;\n\n    struct {\n      boolean_T TID0_1;\n    } RateInteraction;\n  } Timing;\n};\n\n// Block parameters (default storage)\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern P_FLIGHT_hexacopter_T FLIGHT_hexacopter_P;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n// Block signals (default storage)\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern struct B_FLIGHT_hexacopter_T FLIGHT_hexacopter_B;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n// Block states (default storage)\nextern struct DW_FLIGHT_hexacopter_T FLIGHT_hexacopter_DW;\n\n// External function called from main\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern void FLIGHT_hexacopter_SetEventsForThisBaseStep(boolean_T *eventFlags);\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  // Model entry point functions\n  extern void FLIGHT_hexacopter_initialize(void);\n  extern void FLIGHT_hexacopter_step0(void);\n  extern void FLIGHT_hexacopter_step1(void);\n  extern void FLIGHT_hexacopter_step(int_T tid);\n  extern void FLIGHT_hexacopter_terminate(void);\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n// Real-time Model object\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern RT_MODEL_FLIGHT_hexacopter_T *const FLIGHT_hexacopter_M;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\nextern volatile boolean_T stopRequested;\nextern volatile boolean_T runModel;\n\n//-\n//  These blocks were eliminated from the model due to optimizations:\n//\n//  Block '<S18>/Display' : Unused code path elimination\n//  Block '<S18>/Display1' : Unused code path elimination\n//  Block '<S18>/Display2' : Unused code path elimination\n//  Block '<S18>/Display3' : Unused code path elimination\n//  Block '<S118>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S118>/Data Type Propagation' : Unused code path elimination\n//  Block '<S169>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S169>/Data Type Propagation' : Unused code path elimination\n//  Block '<Root>/Display' : Unused code path elimination\n//  Block '<S188>/Data Type Conversion1' : Unused code path elimination\n//  Block '<S188>/Data Type Conversion2' : Unused code path elimination\n//  Block '<S188>/Dead Zone1' : Unused code path elimination\n//  Block '<S188>/Dead Zone3' : Unused code path elimination\n//  Block '<S188>/Display' : Unused code path elimination\n//  Block '<S188>/Display1' : Unused code path elimination\n//  Block '<S188>/Display2' : Unused code path elimination\n//  Block '<S188>/Display3' : Unused code path elimination\n//  Block '<S188>/Fcn1' : Unused code path elimination\n//  Block '<S188>/Fcn2' : Unused code path elimination\n//  Block '<S188>/Gain1' : Unused code path elimination\n//  Block '<S188>/Gain2' : Unused code path elimination\n//  Block '<S188>/Saturation1' : Unused code path elimination\n//  Block '<S188>/Saturation9' : Unused code path elimination\n//  Block '<S401>/NOT' : Unused code path elimination\n//  Block '<S404>/NOT' : Unused code path elimination\n//  Block '<S402>/Signal Copy' : Unused code path elimination\n//  Block '<S402>/Signal Copy1' : Unused code path elimination\n//  Block '<S402>/Signal Copy2' : Unused code path elimination\n//  Block '<S408>/Bitwise Operator' : Unused code path elimination\n//  Block '<S408>/Data Type Conversion' : Unused code path elimination\n//  Block '<S408>/Data Type Conversion1' : Unused code path elimination\n//  Block '<S408>/Data Type Conversion2' : Unused code path elimination\n//  Block '<S408>/Gain' : Unused code path elimination\n//  Block '<S408>/Gain1' : Unused code path elimination\n//  Block '<S410>/NOT' : Unused code path elimination\n//  Block '<Root>/Scope2' : Unused code path elimination\n//  Block '<S10>/Display' : Unused code path elimination\n//  Block '<S10>/Display1' : Unused code path elimination\n//  Block '<S10>/Display2' : Unused code path elimination\n//  Block '<S10>/Display3' : Unused code path elimination\n//  Block '<S10>/Display5' : Unused code path elimination\n//  Block '<S10>/Display6' : Unused code path elimination\n//  Block '<S10>/Display7' : Unused code path elimination\n//  Block '<S575>/NOT' : Unused code path elimination\n//  Block '<Root>/Scope' : Unused code path elimination\n//  Block '<S7>/Data Type Conversion' : Eliminate redundant data type conversion\n//  Block '<S7>/Data Type Conversion9' : Eliminate redundant data type conversion\n//  Block '<S12>/Data Type Conversion1' : Eliminate redundant data type conversion\n//  Block '<S12>/Data Type Conversion2' : Eliminate redundant data type conversion\n//  Block '<S12>/Data Type Conversion3' : Eliminate redundant data type conversion\n\n\n//-\n//  The generated code includes comments that allow you to trace directly\n//  back to the appropriate location in the model.  The basic format\n//  is <system>/block_name, where system is the system number (uniquely\n//  assigned by Simulink) and block_name is the name of the block.\n//\n//  Use the MATLAB hilite_system command to trace the generated code back\n//  to the model.  For example,\n//\n//  hilite_system('<S3>')    - opens system 3\n//  hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n//\n//  Here is the system hierarchy for this model\n//\n//  '<Root>' : 'FLIGHT_hexacopter'\n//  '<S1>'   : 'FLIGHT_hexacopter/Altitude_Mode'\n//  '<S2>'   : 'FLIGHT_hexacopter/CAS'\n//  '<S3>'   : 'FLIGHT_hexacopter/Doublet_Generator'\n//  '<S4>'   : 'FLIGHT_hexacopter/Fault_Injection'\n//  '<S5>'   : 'FLIGHT_hexacopter/If Action Subsystem'\n//  '<S6>'   : 'FLIGHT_hexacopter/Mixer'\n//  '<S7>'   : 'FLIGHT_hexacopter/Read uORB'\n//  '<S8>'   : 'FLIGHT_hexacopter/Remote Control'\n//  '<S9>'   : 'FLIGHT_hexacopter/SAS'\n//  '<S10>'  : 'FLIGHT_hexacopter/Stabilized_Mode'\n//  '<S11>'  : 'FLIGHT_hexacopter/actuator_controls'\n//  '<S12>'  : 'FLIGHT_hexacopter/actuator_outputs_motors'\n//  '<S13>'  : 'FLIGHT_hexacopter/quat2eul'\n//  '<S14>'  : 'FLIGHT_hexacopter/sub_vehicle_angular_velocity'\n//  '<S15>'  : 'FLIGHT_hexacopter/vehicle_attitude_setpoint'\n//  '<S16>'  : 'FLIGHT_hexacopter/vehicle_local_position_setpoint'\n//  '<S17>'  : 'FLIGHT_hexacopter/vehicle_rate_setpoint'\n//  '<S18>'  : 'FLIGHT_hexacopter/Altitude_Mode/Altitude_Mode_Stick2Command'\n//  '<S19>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller'\n//  '<S20>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4'\n//  '<S21>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Anti-windup'\n//  '<S22>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/D Gain'\n//  '<S23>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/External Derivative'\n//  '<S24>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Filter'\n//  '<S25>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Filter ICs'\n//  '<S26>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/I Gain'\n//  '<S27>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Ideal P Gain'\n//  '<S28>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Ideal P Gain Fdbk'\n//  '<S29>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Integrator'\n//  '<S30>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Integrator ICs'\n//  '<S31>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/N Copy'\n//  '<S32>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/N Gain'\n//  '<S33>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/P Copy'\n//  '<S34>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Parallel P Gain'\n//  '<S35>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Reset Signal'\n//  '<S36>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Saturation'\n//  '<S37>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Saturation Fdbk'\n//  '<S38>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Sum'\n//  '<S39>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Sum Fdbk'\n//  '<S40>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Tracking Mode'\n//  '<S41>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Tracking Mode Sum'\n//  '<S42>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Tsamp - Integral'\n//  '<S43>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Tsamp - Ngain'\n//  '<S44>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/postSat Signal'\n//  '<S45>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/preSat Signal'\n//  '<S46>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Anti-windup/Disc. Clamping Parallel'\n//  '<S47>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Anti-windup/Disc. Clamping Parallel/Dead Zone'\n//  '<S48>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\n//  '<S49>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/D Gain/External Parameters'\n//  '<S50>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/External Derivative/Error'\n//  '<S51>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Filter/Disc. Forward Euler Filter'\n//  '<S52>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Filter ICs/Internal IC - Filter'\n//  '<S53>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/I Gain/External Parameters'\n//  '<S54>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Ideal P Gain/Passthrough'\n//  '<S55>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Ideal P Gain Fdbk/Disabled'\n//  '<S56>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Integrator/Discrete'\n//  '<S57>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Integrator ICs/Internal IC'\n//  '<S58>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/N Copy/Disabled'\n//  '<S59>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/N Gain/External Parameters'\n//  '<S60>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/P Copy/Disabled'\n//  '<S61>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Parallel P Gain/External Parameters'\n//  '<S62>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Reset Signal/Disabled'\n//  '<S63>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Saturation/Enabled'\n//  '<S64>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Saturation Fdbk/Disabled'\n//  '<S65>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Sum/Sum_PID'\n//  '<S66>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Sum Fdbk/Disabled'\n//  '<S67>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Tracking Mode/Disabled'\n//  '<S68>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Tracking Mode Sum/Passthrough'\n//  '<S69>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Tsamp - Integral/TsSignalSpecification'\n//  '<S70>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/Tsamp - Ngain/Passthrough'\n//  '<S71>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/postSat Signal/Forward_Path'\n//  '<S72>'  : 'FLIGHT_hexacopter/Altitude_Mode/Vz Controller/PID Controller4/preSat Signal/Forward_Path'\n//  '<S73>'  : 'FLIGHT_hexacopter/CAS/Degrees to Radians'\n//  '<S74>'  : 'FLIGHT_hexacopter/CAS/Degrees to Radians1'\n//  '<S75>'  : 'FLIGHT_hexacopter/CAS/PID Controller3'\n//  '<S76>'  : 'FLIGHT_hexacopter/CAS/PID Controller4'\n//  '<S77>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Anti-windup'\n//  '<S78>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/D Gain'\n//  '<S79>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/External Derivative'\n//  '<S80>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Filter'\n//  '<S81>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Filter ICs'\n//  '<S82>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/I Gain'\n//  '<S83>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Ideal P Gain'\n//  '<S84>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Ideal P Gain Fdbk'\n//  '<S85>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Integrator'\n//  '<S86>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Integrator ICs'\n//  '<S87>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/N Copy'\n//  '<S88>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/N Gain'\n//  '<S89>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/P Copy'\n//  '<S90>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Parallel P Gain'\n//  '<S91>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Reset Signal'\n//  '<S92>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Saturation'\n//  '<S93>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Saturation Fdbk'\n//  '<S94>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Sum'\n//  '<S95>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Sum Fdbk'\n//  '<S96>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Tracking Mode'\n//  '<S97>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Tracking Mode Sum'\n//  '<S98>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Tsamp - Integral'\n//  '<S99>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Tsamp - Ngain'\n//  '<S100>' : 'FLIGHT_hexacopter/CAS/PID Controller3/postSat Signal'\n//  '<S101>' : 'FLIGHT_hexacopter/CAS/PID Controller3/preSat Signal'\n//  '<S102>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Anti-windup/Disabled'\n//  '<S103>' : 'FLIGHT_hexacopter/CAS/PID Controller3/D Gain/Disabled'\n//  '<S104>' : 'FLIGHT_hexacopter/CAS/PID Controller3/External Derivative/Disabled'\n//  '<S105>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Filter/Disabled'\n//  '<S106>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Filter ICs/Disabled'\n//  '<S107>' : 'FLIGHT_hexacopter/CAS/PID Controller3/I Gain/Disabled'\n//  '<S108>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Ideal P Gain/Passthrough'\n//  '<S109>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Ideal P Gain Fdbk/Disabled'\n//  '<S110>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Integrator/Disabled'\n//  '<S111>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Integrator ICs/Disabled'\n//  '<S112>' : 'FLIGHT_hexacopter/CAS/PID Controller3/N Copy/Disabled wSignal Specification'\n//  '<S113>' : 'FLIGHT_hexacopter/CAS/PID Controller3/N Gain/Disabled'\n//  '<S114>' : 'FLIGHT_hexacopter/CAS/PID Controller3/P Copy/Disabled'\n//  '<S115>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Parallel P Gain/External Parameters'\n//  '<S116>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Reset Signal/Disabled'\n//  '<S117>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Saturation/External'\n//  '<S118>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Saturation/External/Saturation Dynamic'\n//  '<S119>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Saturation Fdbk/Disabled'\n//  '<S120>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Sum/Passthrough_P'\n//  '<S121>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Sum Fdbk/Disabled'\n//  '<S122>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tracking Mode/Disabled'\n//  '<S123>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tracking Mode Sum/Passthrough'\n//  '<S124>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tsamp - Integral/TsSignalSpecification'\n//  '<S125>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tsamp - Ngain/Passthrough'\n//  '<S126>' : 'FLIGHT_hexacopter/CAS/PID Controller3/postSat Signal/Forward_Path'\n//  '<S127>' : 'FLIGHT_hexacopter/CAS/PID Controller3/preSat Signal/Forward_Path'\n//  '<S128>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Anti-windup'\n//  '<S129>' : 'FLIGHT_hexacopter/CAS/PID Controller4/D Gain'\n//  '<S130>' : 'FLIGHT_hexacopter/CAS/PID Controller4/External Derivative'\n//  '<S131>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Filter'\n//  '<S132>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Filter ICs'\n//  '<S133>' : 'FLIGHT_hexacopter/CAS/PID Controller4/I Gain'\n//  '<S134>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Ideal P Gain'\n//  '<S135>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Ideal P Gain Fdbk'\n//  '<S136>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Integrator'\n//  '<S137>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Integrator ICs'\n//  '<S138>' : 'FLIGHT_hexacopter/CAS/PID Controller4/N Copy'\n//  '<S139>' : 'FLIGHT_hexacopter/CAS/PID Controller4/N Gain'\n//  '<S140>' : 'FLIGHT_hexacopter/CAS/PID Controller4/P Copy'\n//  '<S141>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Parallel P Gain'\n//  '<S142>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Reset Signal'\n//  '<S143>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Saturation'\n//  '<S144>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Saturation Fdbk'\n//  '<S145>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Sum'\n//  '<S146>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Sum Fdbk'\n//  '<S147>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tracking Mode'\n//  '<S148>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tracking Mode Sum'\n//  '<S149>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tsamp - Integral'\n//  '<S150>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tsamp - Ngain'\n//  '<S151>' : 'FLIGHT_hexacopter/CAS/PID Controller4/postSat Signal'\n//  '<S152>' : 'FLIGHT_hexacopter/CAS/PID Controller4/preSat Signal'\n//  '<S153>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Anti-windup/Disabled'\n//  '<S154>' : 'FLIGHT_hexacopter/CAS/PID Controller4/D Gain/Disabled'\n//  '<S155>' : 'FLIGHT_hexacopter/CAS/PID Controller4/External Derivative/Disabled'\n//  '<S156>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Filter/Disabled'\n//  '<S157>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Filter ICs/Disabled'\n//  '<S158>' : 'FLIGHT_hexacopter/CAS/PID Controller4/I Gain/Disabled'\n//  '<S159>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Ideal P Gain/Passthrough'\n//  '<S160>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Ideal P Gain Fdbk/Disabled'\n//  '<S161>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Integrator/Disabled'\n//  '<S162>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Integrator ICs/Disabled'\n//  '<S163>' : 'FLIGHT_hexacopter/CAS/PID Controller4/N Copy/Disabled wSignal Specification'\n//  '<S164>' : 'FLIGHT_hexacopter/CAS/PID Controller4/N Gain/Disabled'\n//  '<S165>' : 'FLIGHT_hexacopter/CAS/PID Controller4/P Copy/Disabled'\n//  '<S166>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Parallel P Gain/External Parameters'\n//  '<S167>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Reset Signal/Disabled'\n//  '<S168>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Saturation/External'\n//  '<S169>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Saturation/External/Saturation Dynamic'\n//  '<S170>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Saturation Fdbk/Disabled'\n//  '<S171>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Sum/Passthrough_P'\n//  '<S172>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Sum Fdbk/Disabled'\n//  '<S173>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tracking Mode/Disabled'\n//  '<S174>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tracking Mode Sum/Passthrough'\n//  '<S175>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tsamp - Integral/TsSignalSpecification'\n//  '<S176>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tsamp - Ngain/Passthrough'\n//  '<S177>' : 'FLIGHT_hexacopter/CAS/PID Controller4/postSat Signal/Forward_Path'\n//  '<S178>' : 'FLIGHT_hexacopter/CAS/PID Controller4/preSat Signal/Forward_Path'\n//  '<S179>' : 'FLIGHT_hexacopter/Doublet_Generator/MATLAB Function'\n//  '<S180>' : 'FLIGHT_hexacopter/Fault_Injection/Compare To Constant'\n//  '<S181>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference'\n//  '<S182>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference1'\n//  '<S183>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference2'\n//  '<S184>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference3'\n//  '<S185>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference4'\n//  '<S186>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference5'\n//  '<S187>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller'\n//  '<S188>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude_Mode_Stick2Command'\n//  '<S189>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller'\n//  '<S190>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller'\n//  '<S191>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller'\n//  '<S192>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4'\n//  '<S193>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Anti-windup'\n//  '<S194>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/D Gain'\n//  '<S195>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/External Derivative'\n//  '<S196>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Filter'\n//  '<S197>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Filter ICs'\n//  '<S198>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/I Gain'\n//  '<S199>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Ideal P Gain'\n//  '<S200>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Ideal P Gain Fdbk'\n//  '<S201>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Integrator'\n//  '<S202>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Integrator ICs'\n//  '<S203>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/N Copy'\n//  '<S204>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/N Gain'\n//  '<S205>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/P Copy'\n//  '<S206>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Parallel P Gain'\n//  '<S207>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Reset Signal'\n//  '<S208>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Saturation'\n//  '<S209>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Saturation Fdbk'\n//  '<S210>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Sum'\n//  '<S211>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Sum Fdbk'\n//  '<S212>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Tracking Mode'\n//  '<S213>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Tracking Mode Sum'\n//  '<S214>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Tsamp - Integral'\n//  '<S215>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Tsamp - Ngain'\n//  '<S216>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/postSat Signal'\n//  '<S217>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/preSat Signal'\n//  '<S218>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Anti-windup/Disabled'\n//  '<S219>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/D Gain/Disabled'\n//  '<S220>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/External Derivative/Disabled'\n//  '<S221>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Filter/Disabled'\n//  '<S222>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Filter ICs/Disabled'\n//  '<S223>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/I Gain/Disabled'\n//  '<S224>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Ideal P Gain/Passthrough'\n//  '<S225>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Ideal P Gain Fdbk/Disabled'\n//  '<S226>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Integrator/Disabled'\n//  '<S227>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Integrator ICs/Disabled'\n//  '<S228>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/N Copy/Disabled wSignal Specification'\n//  '<S229>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/N Gain/Disabled'\n//  '<S230>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/P Copy/Disabled'\n//  '<S231>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Parallel P Gain/External Parameters'\n//  '<S232>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Reset Signal/Disabled'\n//  '<S233>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Saturation/Enabled'\n//  '<S234>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Saturation Fdbk/Disabled'\n//  '<S235>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Sum/Passthrough_P'\n//  '<S236>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Sum Fdbk/Disabled'\n//  '<S237>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Tracking Mode/Disabled'\n//  '<S238>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Tracking Mode Sum/Passthrough'\n//  '<S239>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Tsamp - Integral/TsSignalSpecification'\n//  '<S240>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/Tsamp - Ngain/Passthrough'\n//  '<S241>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/postSat Signal/Forward_Path'\n//  '<S242>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude Controller/PID Controller4/preSat Signal/Forward_Path'\n//  '<S243>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4'\n//  '<S244>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Anti-windup'\n//  '<S245>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/D Gain'\n//  '<S246>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/External Derivative'\n//  '<S247>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Filter'\n//  '<S248>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Filter ICs'\n//  '<S249>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/I Gain'\n//  '<S250>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Ideal P Gain'\n//  '<S251>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Ideal P Gain Fdbk'\n//  '<S252>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Integrator'\n//  '<S253>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Integrator ICs'\n//  '<S254>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/N Copy'\n//  '<S255>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/N Gain'\n//  '<S256>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/P Copy'\n//  '<S257>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Parallel P Gain'\n//  '<S258>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Reset Signal'\n//  '<S259>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Saturation'\n//  '<S260>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Saturation Fdbk'\n//  '<S261>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Sum'\n//  '<S262>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Sum Fdbk'\n//  '<S263>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Tracking Mode'\n//  '<S264>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Tracking Mode Sum'\n//  '<S265>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Tsamp - Integral'\n//  '<S266>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Tsamp - Ngain'\n//  '<S267>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/postSat Signal'\n//  '<S268>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/preSat Signal'\n//  '<S269>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Anti-windup/Disc. Clamping Parallel'\n//  '<S270>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Anti-windup/Disc. Clamping Parallel/Dead Zone'\n//  '<S271>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\n//  '<S272>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/D Gain/External Parameters'\n//  '<S273>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/External Derivative/Error'\n//  '<S274>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Filter/Disc. Forward Euler Filter'\n//  '<S275>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Filter ICs/Internal IC - Filter'\n//  '<S276>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/I Gain/External Parameters'\n//  '<S277>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Ideal P Gain/Passthrough'\n//  '<S278>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Ideal P Gain Fdbk/Disabled'\n//  '<S279>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Integrator/Discrete'\n//  '<S280>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Integrator ICs/Internal IC'\n//  '<S281>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/N Copy/Disabled'\n//  '<S282>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/N Gain/External Parameters'\n//  '<S283>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/P Copy/Disabled'\n//  '<S284>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Parallel P Gain/External Parameters'\n//  '<S285>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Reset Signal/External Reset'\n//  '<S286>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Saturation/Enabled'\n//  '<S287>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Saturation Fdbk/Disabled'\n//  '<S288>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Sum/Sum_PID'\n//  '<S289>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Sum Fdbk/Disabled'\n//  '<S290>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Tracking Mode/Disabled'\n//  '<S291>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Tracking Mode Sum/Passthrough'\n//  '<S292>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Tsamp - Integral/TsSignalSpecification'\n//  '<S293>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/Tsamp - Ngain/Passthrough'\n//  '<S294>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/postSat Signal/Forward_Path'\n//  '<S295>' : 'FLIGHT_hexacopter/If Action Subsystem/Vz Controller/PID Controller4/preSat Signal/Forward_Path'\n//  '<S296>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude'\n//  '<S297>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Anti-windup'\n//  '<S298>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/D Gain'\n//  '<S299>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/External Derivative'\n//  '<S300>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Filter'\n//  '<S301>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Filter ICs'\n//  '<S302>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/I Gain'\n//  '<S303>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Ideal P Gain'\n//  '<S304>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Ideal P Gain Fdbk'\n//  '<S305>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Integrator'\n//  '<S306>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Integrator ICs'\n//  '<S307>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/N Copy'\n//  '<S308>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/N Gain'\n//  '<S309>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/P Copy'\n//  '<S310>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Parallel P Gain'\n//  '<S311>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Reset Signal'\n//  '<S312>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Saturation'\n//  '<S313>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Saturation Fdbk'\n//  '<S314>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Sum'\n//  '<S315>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Sum Fdbk'\n//  '<S316>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tracking Mode'\n//  '<S317>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tracking Mode Sum'\n//  '<S318>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tsamp - Integral'\n//  '<S319>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tsamp - Ngain'\n//  '<S320>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/postSat Signal'\n//  '<S321>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/preSat Signal'\n//  '<S322>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Anti-windup/Disabled'\n//  '<S323>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/D Gain/Disabled'\n//  '<S324>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/External Derivative/Disabled'\n//  '<S325>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Filter/Disabled'\n//  '<S326>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Filter ICs/Disabled'\n//  '<S327>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/I Gain/Disabled'\n//  '<S328>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Ideal P Gain/Passthrough'\n//  '<S329>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Ideal P Gain Fdbk/Disabled'\n//  '<S330>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Integrator/Disabled'\n//  '<S331>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Integrator ICs/Disabled'\n//  '<S332>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/N Copy/Disabled wSignal Specification'\n//  '<S333>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/N Gain/Disabled'\n//  '<S334>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/P Copy/Disabled'\n//  '<S335>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Parallel P Gain/External Parameters'\n//  '<S336>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Reset Signal/Disabled'\n//  '<S337>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Saturation/Passthrough'\n//  '<S338>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Saturation Fdbk/Disabled'\n//  '<S339>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Sum/Passthrough_P'\n//  '<S340>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Sum Fdbk/Disabled'\n//  '<S341>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tracking Mode/Disabled'\n//  '<S342>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tracking Mode Sum/Passthrough'\n//  '<S343>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tsamp - Integral/TsSignalSpecification'\n//  '<S344>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tsamp - Ngain/Passthrough'\n//  '<S345>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/postSat Signal/Forward_Path'\n//  '<S346>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/preSat Signal/Forward_Path'\n//  '<S347>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/NED2Body1'\n//  '<S348>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude'\n//  '<S349>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/NED2Body1/Calculate Transformation Matrix'\n//  '<S350>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Anti-windup'\n//  '<S351>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/D Gain'\n//  '<S352>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/External Derivative'\n//  '<S353>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Filter'\n//  '<S354>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Filter ICs'\n//  '<S355>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/I Gain'\n//  '<S356>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Ideal P Gain'\n//  '<S357>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Ideal P Gain Fdbk'\n//  '<S358>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Integrator'\n//  '<S359>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Integrator ICs'\n//  '<S360>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/N Copy'\n//  '<S361>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/N Gain'\n//  '<S362>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/P Copy'\n//  '<S363>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Parallel P Gain'\n//  '<S364>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Reset Signal'\n//  '<S365>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Saturation'\n//  '<S366>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Saturation Fdbk'\n//  '<S367>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Sum'\n//  '<S368>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Sum Fdbk'\n//  '<S369>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tracking Mode'\n//  '<S370>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tracking Mode Sum'\n//  '<S371>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tsamp - Integral'\n//  '<S372>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tsamp - Ngain'\n//  '<S373>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/postSat Signal'\n//  '<S374>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/preSat Signal'\n//  '<S375>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Anti-windup/Disabled'\n//  '<S376>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/D Gain/Disabled'\n//  '<S377>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/External Derivative/Disabled'\n//  '<S378>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Filter/Disabled'\n//  '<S379>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Filter ICs/Disabled'\n//  '<S380>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/I Gain/Disabled'\n//  '<S381>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Ideal P Gain/Passthrough'\n//  '<S382>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Ideal P Gain Fdbk/Disabled'\n//  '<S383>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Integrator/Disabled'\n//  '<S384>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Integrator ICs/Disabled'\n//  '<S385>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/N Copy/Disabled wSignal Specification'\n//  '<S386>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/N Gain/Disabled'\n//  '<S387>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/P Copy/Disabled'\n//  '<S388>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Parallel P Gain/External Parameters'\n//  '<S389>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Reset Signal/Disabled'\n//  '<S390>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Saturation/Passthrough'\n//  '<S391>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Saturation Fdbk/Disabled'\n//  '<S392>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Sum/Passthrough_P'\n//  '<S393>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Sum Fdbk/Disabled'\n//  '<S394>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tracking Mode/Disabled'\n//  '<S395>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tracking Mode Sum/Passthrough'\n//  '<S396>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tsamp - Integral/TsSignalSpecification'\n//  '<S397>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tsamp - Ngain/Passthrough'\n//  '<S398>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/postSat Signal/Forward_Path'\n//  '<S399>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/preSat Signal/Forward_Path'\n//  '<S400>' : 'FLIGHT_hexacopter/Mixer/pwm_out2'\n//  '<S401>' : 'FLIGHT_hexacopter/Read uORB/PX4 uORB Read'\n//  '<S402>' : 'FLIGHT_hexacopter/Read uORB/Vehicle Attitude'\n//  '<S403>' : 'FLIGHT_hexacopter/Read uORB/PX4 uORB Read/Enabled Subsystem'\n//  '<S404>' : 'FLIGHT_hexacopter/Read uORB/Vehicle Attitude/PX4 uORB Read'\n//  '<S405>' : 'FLIGHT_hexacopter/Read uORB/Vehicle Attitude/PX4 uORB Read/Enabled Subsystem'\n//  '<S406>' : 'FLIGHT_hexacopter/Remote Control/Arm1'\n//  '<S407>' : 'FLIGHT_hexacopter/Remote Control/Compare To Constant'\n//  '<S408>' : 'FLIGHT_hexacopter/Remote Control/Radio Control Transmitter'\n//  '<S409>' : 'FLIGHT_hexacopter/Remote Control/Arm1/Compare To Constant3'\n//  '<S410>' : 'FLIGHT_hexacopter/Remote Control/Radio Control Transmitter/PX4 uORB Read'\n//  '<S411>' : 'FLIGHT_hexacopter/Remote Control/Radio Control Transmitter/PX4 uORB Read/Enabled Subsystem'\n//  '<S412>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate'\n//  '<S413>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate'\n//  '<S414>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate'\n//  '<S415>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Anti-windup'\n//  '<S416>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/D Gain'\n//  '<S417>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/External Derivative'\n//  '<S418>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Filter'\n//  '<S419>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Filter ICs'\n//  '<S420>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/I Gain'\n//  '<S421>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Ideal P Gain'\n//  '<S422>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Ideal P Gain Fdbk'\n//  '<S423>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Integrator'\n//  '<S424>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Integrator ICs'\n//  '<S425>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/N Copy'\n//  '<S426>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/N Gain'\n//  '<S427>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/P Copy'\n//  '<S428>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Parallel P Gain'\n//  '<S429>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Reset Signal'\n//  '<S430>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Saturation'\n//  '<S431>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Saturation Fdbk'\n//  '<S432>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Sum'\n//  '<S433>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Sum Fdbk'\n//  '<S434>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Tracking Mode'\n//  '<S435>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Tracking Mode Sum'\n//  '<S436>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Tsamp - Integral'\n//  '<S437>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Tsamp - Ngain'\n//  '<S438>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/postSat Signal'\n//  '<S439>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/preSat Signal'\n//  '<S440>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Anti-windup/Passthrough'\n//  '<S441>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/D Gain/External Parameters'\n//  '<S442>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/External Derivative/Error'\n//  '<S443>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Filter/Disc. Forward Euler Filter'\n//  '<S444>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Filter ICs/Internal IC - Filter'\n//  '<S445>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/I Gain/External Parameters'\n//  '<S446>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Ideal P Gain/Passthrough'\n//  '<S447>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Ideal P Gain Fdbk/Disabled'\n//  '<S448>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Integrator/Discrete'\n//  '<S449>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Integrator ICs/Internal IC'\n//  '<S450>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/N Copy/Disabled'\n//  '<S451>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/N Gain/External Parameters'\n//  '<S452>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/P Copy/Disabled'\n//  '<S453>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Parallel P Gain/External Parameters'\n//  '<S454>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Reset Signal/Disabled'\n//  '<S455>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Saturation/Passthrough'\n//  '<S456>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Saturation Fdbk/Disabled'\n//  '<S457>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Sum/Sum_PID'\n//  '<S458>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Sum Fdbk/Disabled'\n//  '<S459>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Tracking Mode/Disabled'\n//  '<S460>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Tracking Mode Sum/Passthrough'\n//  '<S461>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Tsamp - Integral/TsSignalSpecification'\n//  '<S462>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/Tsamp - Ngain/Passthrough'\n//  '<S463>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/postSat Signal/Forward_Path'\n//  '<S464>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_pitchrate/preSat Signal/Forward_Path'\n//  '<S465>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Anti-windup'\n//  '<S466>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/D Gain'\n//  '<S467>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/External Derivative'\n//  '<S468>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Filter'\n//  '<S469>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Filter ICs'\n//  '<S470>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/I Gain'\n//  '<S471>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Ideal P Gain'\n//  '<S472>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Ideal P Gain Fdbk'\n//  '<S473>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Integrator'\n//  '<S474>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Integrator ICs'\n//  '<S475>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/N Copy'\n//  '<S476>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/N Gain'\n//  '<S477>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/P Copy'\n//  '<S478>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Parallel P Gain'\n//  '<S479>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Reset Signal'\n//  '<S480>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Saturation'\n//  '<S481>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Saturation Fdbk'\n//  '<S482>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Sum'\n//  '<S483>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Sum Fdbk'\n//  '<S484>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Tracking Mode'\n//  '<S485>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Tracking Mode Sum'\n//  '<S486>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Tsamp - Integral'\n//  '<S487>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Tsamp - Ngain'\n//  '<S488>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/postSat Signal'\n//  '<S489>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/preSat Signal'\n//  '<S490>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Anti-windup/Passthrough'\n//  '<S491>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/D Gain/External Parameters'\n//  '<S492>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/External Derivative/Error'\n//  '<S493>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Filter/Disc. Forward Euler Filter'\n//  '<S494>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Filter ICs/Internal IC - Filter'\n//  '<S495>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/I Gain/External Parameters'\n//  '<S496>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Ideal P Gain/Passthrough'\n//  '<S497>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Ideal P Gain Fdbk/Disabled'\n//  '<S498>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Integrator/Discrete'\n//  '<S499>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Integrator ICs/Internal IC'\n//  '<S500>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/N Copy/Disabled'\n//  '<S501>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/N Gain/External Parameters'\n//  '<S502>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/P Copy/Disabled'\n//  '<S503>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Parallel P Gain/External Parameters'\n//  '<S504>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Reset Signal/Disabled'\n//  '<S505>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Saturation/Passthrough'\n//  '<S506>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Saturation Fdbk/Disabled'\n//  '<S507>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Sum/Sum_PID'\n//  '<S508>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Sum Fdbk/Disabled'\n//  '<S509>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Tracking Mode/Disabled'\n//  '<S510>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Tracking Mode Sum/Passthrough'\n//  '<S511>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Tsamp - Integral/TsSignalSpecification'\n//  '<S512>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/Tsamp - Ngain/Passthrough'\n//  '<S513>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/postSat Signal/Forward_Path'\n//  '<S514>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_rollrate/preSat Signal/Forward_Path'\n//  '<S515>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Anti-windup'\n//  '<S516>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/D Gain'\n//  '<S517>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/External Derivative'\n//  '<S518>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Filter'\n//  '<S519>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Filter ICs'\n//  '<S520>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/I Gain'\n//  '<S521>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Ideal P Gain'\n//  '<S522>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Ideal P Gain Fdbk'\n//  '<S523>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Integrator'\n//  '<S524>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Integrator ICs'\n//  '<S525>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/N Copy'\n//  '<S526>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/N Gain'\n//  '<S527>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/P Copy'\n//  '<S528>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Parallel P Gain'\n//  '<S529>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Reset Signal'\n//  '<S530>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Saturation'\n//  '<S531>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Saturation Fdbk'\n//  '<S532>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Sum'\n//  '<S533>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Sum Fdbk'\n//  '<S534>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Tracking Mode'\n//  '<S535>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Tracking Mode Sum'\n//  '<S536>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Tsamp - Integral'\n//  '<S537>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Tsamp - Ngain'\n//  '<S538>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/postSat Signal'\n//  '<S539>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/preSat Signal'\n//  '<S540>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Anti-windup/Passthrough'\n//  '<S541>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/D Gain/External Parameters'\n//  '<S542>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/External Derivative/Error'\n//  '<S543>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Filter/Disc. Forward Euler Filter'\n//  '<S544>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Filter ICs/Internal IC - Filter'\n//  '<S545>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/I Gain/External Parameters'\n//  '<S546>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Ideal P Gain/Passthrough'\n//  '<S547>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Ideal P Gain Fdbk/Disabled'\n//  '<S548>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Integrator/Discrete'\n//  '<S549>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Integrator ICs/Internal IC'\n//  '<S550>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/N Copy/Disabled'\n//  '<S551>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/N Gain/External Parameters'\n//  '<S552>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/P Copy/Disabled'\n//  '<S553>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Parallel P Gain/External Parameters'\n//  '<S554>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Reset Signal/Disabled'\n//  '<S555>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Saturation/Passthrough'\n//  '<S556>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Saturation Fdbk/Disabled'\n//  '<S557>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Sum/Sum_PID'\n//  '<S558>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Sum Fdbk/Disabled'\n//  '<S559>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Tracking Mode/Disabled'\n//  '<S560>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Tracking Mode Sum/Passthrough'\n//  '<S561>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Tsamp - Integral/TsSignalSpecification'\n//  '<S562>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/Tsamp - Ngain/Passthrough'\n//  '<S563>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/postSat Signal/Forward_Path'\n//  '<S564>' : 'FLIGHT_hexacopter/SAS/pid_ctrl_yawrate/preSat Signal/Forward_Path'\n//  '<S565>' : 'FLIGHT_hexacopter/actuator_controls/PX4 ULog'\n//  '<S566>' : 'FLIGHT_hexacopter/actuator_controls/PX4 ULog/PX4 uORB Message'\n//  '<S567>' : 'FLIGHT_hexacopter/actuator_controls/PX4 ULog/PX4_log_write'\n//  '<S568>' : 'FLIGHT_hexacopter/actuator_outputs_motors/Normalize_pwm6'\n//  '<S569>' : 'FLIGHT_hexacopter/actuator_outputs_motors/PX4 ULog'\n//  '<S570>' : 'FLIGHT_hexacopter/actuator_outputs_motors/PX4 ULog1'\n//  '<S571>' : 'FLIGHT_hexacopter/actuator_outputs_motors/PX4 ULog/PX4 uORB Message'\n//  '<S572>' : 'FLIGHT_hexacopter/actuator_outputs_motors/PX4 ULog/PX4_log_write'\n//  '<S573>' : 'FLIGHT_hexacopter/actuator_outputs_motors/PX4 ULog1/PX4 uORB Message'\n//  '<S574>' : 'FLIGHT_hexacopter/actuator_outputs_motors/PX4 ULog1/PX4_log_write'\n//  '<S575>' : 'FLIGHT_hexacopter/sub_vehicle_angular_velocity/PX4 uORB Read1'\n//  '<S576>' : 'FLIGHT_hexacopter/sub_vehicle_angular_velocity/PX4 uORB Read1/Enabled Subsystem'\n//  '<S577>' : 'FLIGHT_hexacopter/vehicle_attitude_setpoint/PX4 uORB Message'\n//  '<S578>' : 'FLIGHT_hexacopter/vehicle_attitude_setpoint/PX4 uORB Write'\n//  '<S579>' : 'FLIGHT_hexacopter/vehicle_attitude_setpoint/Rotation Angles to Quaternions'\n//  '<S580>' : 'FLIGHT_hexacopter/vehicle_local_position_setpoint/PX4 uORB Message'\n//  '<S581>' : 'FLIGHT_hexacopter/vehicle_local_position_setpoint/PX4 uORB Write'\n//  '<S582>' : 'FLIGHT_hexacopter/vehicle_rate_setpoint/PX4 uORB Message'\n//  '<S583>' : 'FLIGHT_hexacopter/vehicle_rate_setpoint/PX4 uORB Write'\n\n#endif                                 // FLIGHT_hexacopter_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"FLIGHT_hexacopter_private.h","type":"header","group":"model","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: FLIGHT_hexacopter_private.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.146\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu Apr 24 17:45:28 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef FLIGHT_hexacopter_private_h_\n#define FLIGHT_hexacopter_private_h_\n#include \"rtwtypes.h\"\n#include \"FLIGHT_hexacopter.h\"\n#include \"FLIGHT_hexacopter_types.h\"\n#ifndef UCHAR_MAX\n#include <limits.h>\n#endif\n\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\n#error Code was generated for compiler with different sized uchar/char. \\\nConsider adjusting Test hardware word size settings on the \\\nHardware Implementation pane to match your compiler word sizes as \\\ndefined in limits.h of the compiler. Alternatively, you can \\\nselect the Test hardware is the same as production hardware option and \\\nselect the Enable portable word sizes option on the Code Generation > \\\nVerification pane for ERT based targets, which will disable the \\\npreprocessor word size checks.\n#endif\n\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\n#error Code was generated for compiler with different sized ushort/short. \\\nConsider adjusting Test hardware word size settings on the \\\nHardware Implementation pane to match your compiler word sizes as \\\ndefined in limits.h of the compiler. Alternatively, you can \\\nselect the Test hardware is the same as production hardware option and \\\nselect the Enable portable word sizes option on the Code Generation > \\\nVerification pane for ERT based targets, which will disable the \\\npreprocessor word size checks.\n#endif\n\n#if ( UINT_MAX != (0xFFFFFFFFU) ) || ( INT_MAX != (0x7FFFFFFF) )\n#error Code was generated for compiler with different sized uint/int. \\\nConsider adjusting Test hardware word size settings on the \\\nHardware Implementation pane to match your compiler word sizes as \\\ndefined in limits.h of the compiler. Alternatively, you can \\\nselect the Test hardware is the same as production hardware option and \\\nselect the Enable portable word sizes option on the Code Generation > \\\nVerification pane for ERT based targets, which will disable the \\\npreprocessor word size checks.\n#endif\n\n#if ( ULONG_MAX != (0xFFFFFFFFU) ) || ( LONG_MAX != (0x7FFFFFFF) )\n#error Code was generated for compiler with different sized ulong/long. \\\nConsider adjusting Test hardware word size settings on the \\\nHardware Implementation pane to match your compiler word sizes as \\\ndefined in limits.h of the compiler. Alternatively, you can \\\nselect the Test hardware is the same as production hardware option and \\\nselect the Enable portable word sizes option on the Code Generation > \\\nVerification pane for ERT based targets, which will disable the \\\npreprocessor word size checks.\n#endif\n\n// Skipping ulong_long/long_long check: insufficient preprocessor integer range. \nextern real32_T rt_roundf_snf(real32_T u);\nextern real32_T rt_atan2f_snf(real32_T u0, real32_T u1);\nextern void FLIGHT_he_PX4Timestamp_Init(DW_PX4Timestamp_FLIGHT_hexaco_T *localDW);\nextern void FLIGHT_hexacop_PX4Timestamp(B_PX4Timestamp_FLIGHT_hexacop_T *localB);\nextern void FLIGHT_h_ReadParameter_Init(DW_ReadParameter_FLIGHT_hexac_T *localDW);\nextern void FLIGHT_hexaco_ReadParameter(B_ReadParameter_FLIGHT_hexaco_T *localB,\n  DW_ReadParameter_FLIGHT_hexac_T *localDW);\nextern void FLIGHT__ReadParameter1_Init(DW_ReadParameter1_FLIGHT_hexa_T *localDW);\nextern void FLIGHT_hexac_ReadParameter1(B_ReadParameter1_FLIGHT_hexac_T *localB,\n  DW_ReadParameter1_FLIGHT_hexa_T *localDW);\nextern void FLIGHT__ReadParameter2_Init(DW_ReadParameter2_FLIGHT_hexa_T *localDW);\nextern void FLIGHT_hexac_ReadParameter2(B_ReadParameter2_FLIGHT_hexac_T *localB,\n  DW_ReadParameter2_FLIGHT_hexa_T *localDW);\nextern void FLIGHT__ReadParameter3_Init(DW_ReadParameter3_FLIGHT_hexa_T *localDW);\nextern void FLIGHT_hexac_ReadParameter3(B_ReadParameter3_FLIGHT_hexac_T *localB,\n  DW_ReadParameter3_FLIGHT_hexa_T *localDW);\nextern void FLIGHT__PX4Timestamp_b_Init(DW_PX4Timestamp_FLIGHT_hexa_b_T *localDW);\nextern void FLIGHT_hexac_PX4Timestamp_o(B_PX4Timestamp_FLIGHT_hexac_l_T *localB);\nextern void FLIGHT__PX4Timestamp_l_Init(DW_PX4Timestamp_FLIGHT_hexa_f_T *localDW);\nextern void FLIGHT_hexac_PX4Timestamp_p(B_PX4Timestamp_FLIGHT_hexac_c_T *localB);\nextern void FLIGHT_he_PX4Timestamp_Term(DW_PX4Timestamp_FLIGHT_hexaco_T *localDW);\nextern void FLIGHT_h_ReadParameter_Term(DW_ReadParameter_FLIGHT_hexac_T *localDW);\nextern void FLIGHT__ReadParameter1_Term(DW_ReadParameter1_FLIGHT_hexa_T *localDW);\nextern void FLIGHT__ReadParameter2_Term(DW_ReadParameter2_FLIGHT_hexa_T *localDW);\nextern void FLIGHT__ReadParameter3_Term(DW_ReadParameter3_FLIGHT_hexa_T *localDW);\nextern void FLIGHT__PX4Timestamp_o_Term(DW_PX4Timestamp_FLIGHT_hexa_b_T *localDW);\nextern void FLIGHT__PX4Timestamp_b_Term(DW_PX4Timestamp_FLIGHT_hexa_f_T *localDW);\n\n#endif                                 // FLIGHT_hexacopter_private_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"FLIGHT_hexacopter_types.h","type":"header","group":"model","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: FLIGHT_hexacopter_types.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.146\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu Apr 24 17:45:28 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef FLIGHT_hexacopter_types_h_\n#define FLIGHT_hexacopter_types_h_\n#include \"rtwtypes.h\"\n#include \"MW_Parameter.h\"\n#include <uORB/topics/vehicle_local_position.h>\n#include <uORB/topics/vehicle_odometry.h>\n#include <uORB/topics/input_rc.h>\n#include <uORB/topics/actuator_controls_status.h>\n#include <uORB/topics/actuator_motors.h>\n#include <uORB/topics/actuator_outputs.h>\n#include <uORB/topics/vehicle_angular_velocity.h>\n#include <uORB/topics/vehicle_attitude_setpoint.h>\n#include <uORB/topics/vehicle_local_position_setpoint.h>\n#include <uORB/topics/vehicle_rates_setpoint.h>\n#ifndef struct_e_px4_internal_block_SampleTi_T\n#define struct_e_px4_internal_block_SampleTi_T\n\nstruct e_px4_internal_block_SampleTi_T\n{\n  int32_T __dummy;\n};\n\n#endif                                // struct_e_px4_internal_block_SampleTi_T\n\n#ifndef struct_px4_internal_block_getPX4Abso_T\n#define struct_px4_internal_block_getPX4Abso_T\n\nstruct px4_internal_block_getPX4Abso_T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  e_px4_internal_block_SampleTi_T SampleTimeHandler;\n};\n\n#endif                                // struct_px4_internal_block_getPX4Abso_T\n\n// Custom Type definition for MATLABSystem: '<S19>/Read Parameter'\n#include \"MW_Parameter.h\"\n#ifndef struct_px4_internal_block_ParameterU_T\n#define struct_px4_internal_block_ParameterU_T\n\nstruct px4_internal_block_ParameterU_T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  real_T SampleTime;\n  MW_Param_Handle MW_PARAMHANDLE;\n};\n\n#endif                                // struct_px4_internal_block_ParameterU_T\n\n#ifndef struct_px4_internal_block_PWM_FLIGHT_T\n#define struct_px4_internal_block_PWM_FLIGHT_T\n\nstruct px4_internal_block_PWM_FLIGHT_T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  unsigned int servoCount;\n  int channelMask;\n  boolean_T isMain;\n  orb_advert_t armAdvertiseObj;\n  orb_advert_t actuatorAdvertiseObj;\n  boolean_T isArmed;\n};\n\n#endif                                // struct_px4_internal_block_PWM_FLIGHT_T\n\n#ifndef struct_px4_internal_block_Publisher__T\n#define struct_px4_internal_block_Publisher__T\n\nstruct px4_internal_block_Publisher__T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  orb_advert_t orbAdvertiseObj;\n  orb_metadata_t * orbMetadataObj;\n};\n\n#endif                                // struct_px4_internal_block_Publisher__T\n\n#ifndef struct_px4_internal_block_Subscriber_T\n#define struct_px4_internal_block_Subscriber_T\n\nstruct px4_internal_block_Subscriber_T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  e_px4_internal_block_SampleTi_T SampleTimeHandler;\n  pollfd_t eventStructObj;\n  orb_metadata_t * orbMetadataObj;\n};\n\n#endif                                // struct_px4_internal_block_Subscriber_T\n\n// Parameters (default storage)\ntypedef struct P_FLIGHT_hexacopter_T_ P_FLIGHT_hexacopter_T;\n\n// Forward declaration for rtModel\ntypedef struct tag_RTM_FLIGHT_hexacopter_T RT_MODEL_FLIGHT_hexacopter_T;\n\n#endif                                 // FLIGHT_hexacopter_types_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"FLIGHT_hexacopter_data.cpp","type":"source","group":"data","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Data files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: FLIGHT_hexacopter_data.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.146\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu Apr 24 17:45:28 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include \"FLIGHT_hexacopter.h\"\n\n// Block parameters (default storage)\nP_FLIGHT_hexacopter_T FLIGHT_hexacopter_P = {\n  // Variable: SampleTime\n  //  Referenced by:\n  //    '<S2>/Read Parameter'\n  //    '<S2>/Read Parameter1'\n  //    '<S2>/Read Parameter10'\n  //    '<S2>/Read Parameter9'\n  //    '<S3>/Read Parameter'\n  //    '<S3>/Read Parameter1'\n  //    '<S3>/Read Parameter2'\n  //    '<S19>/Read Parameter'\n  //    '<S19>/Read Parameter1'\n  //    '<S19>/Read Parameter2'\n  //    '<S19>/Read Parameter3'\n  //    '<S187>/Read Parameter1'\n  //    '<S189>/Read Parameter'\n  //    '<S189>/Read Parameter1'\n  //    '<S189>/Read Parameter2'\n  //    '<S189>/Read Parameter3'\n  //    '<S190>/Read Parameter'\n  //    '<S191>/Read Parameter'\n\n  0.005,\n\n  // Variable: SampleTime_SAS\n  //  Referenced by:\n  //    '<S4>/Read Parameter1'\n  //    '<S4>/Read Parameter13'\n  //    '<S4>/Read Parameter2'\n  //    '<S4>/Read Parameter3'\n  //    '<S4>/Read Parameter4'\n  //    '<S4>/Read Parameter5'\n  //    '<S9>/Read Parameter1'\n  //    '<S9>/Read Parameter2'\n  //    '<S9>/Read Parameter3'\n  //    '<S9>/Read Parameter4'\n  //    '<S9>/Read Parameter5'\n  //    '<S9>/Read Parameter6'\n  //    '<S9>/Read Parameter7'\n  //    '<S9>/Read Parameter8'\n  //    '<S9>/Read Parameter9'\n  //    '<S9>/read_mc_rollrate_p'\n\n  0.001,\n\n  // Variable: MAX_CONTROL_ANGLE_PITCH\n  //  Referenced by:\n  //    '<S10>/Gain5'\n  //    '<S18>/Gain2'\n\n  0.34906584F,\n\n  // Variable: MAX_CONTROL_ANGLE_RATE_Y\n  //  Referenced by:\n  //    '<S10>/Gain6'\n  //    '<S18>/Gain3'\n  //    '<S188>/Gain3'\n\n  2.09439516F,\n\n  // Variable: MAX_CONTROL_ANGLE_ROLL\n  //  Referenced by:\n  //    '<S10>/Gain4'\n  //    '<S18>/Gain1'\n\n  0.34906584F,\n\n  // Mask Parameter: PIDController4_InitialCondition\n  //  Referenced by: '<S51>/Filter'\n\n  0.0F,\n\n  // Mask Parameter: PIDController4_InitialConditi_l\n  //  Referenced by: '<S274>/Filter'\n\n  0.0F,\n\n  // Mask Parameter: pid_ctrl_rollrate_InitialCondit\n  //  Referenced by: '<S493>/Filter'\n\n  0.0F,\n\n  // Mask Parameter: pid_ctrl_pitchrate_InitialCondi\n  //  Referenced by: '<S443>/Filter'\n\n  0.0F,\n\n  // Mask Parameter: pid_ctrl_yawrate_InitialConditi\n  //  Referenced by: '<S543>/Filter'\n\n  0.0F,\n\n  // Mask Parameter: PIDController4_InitialConditi_a\n  //  Referenced by: '<S56>/Integrator'\n\n  0.0F,\n\n  // Mask Parameter: PIDController4_InitialConditi_i\n  //  Referenced by: '<S279>/Integrator'\n\n  0.0F,\n\n  // Mask Parameter: pid_ctrl_rollrate_InitialCond_c\n  //  Referenced by: '<S498>/Integrator'\n\n  0.0F,\n\n  // Mask Parameter: pid_ctrl_pitchrate_InitialCon_c\n  //  Referenced by: '<S448>/Integrator'\n\n  0.0F,\n\n  // Mask Parameter: pid_ctrl_yawrate_InitialCondi_h\n  //  Referenced by: '<S548>/Integrator'\n\n  0.0F,\n\n  // Mask Parameter: PIDController4_LowerSaturationL\n  //  Referenced by:\n  //    '<S63>/Saturation'\n  //    '<S48>/DeadZone'\n\n  -1.0F,\n\n  // Mask Parameter: PIDController4_LowerSaturatio_a\n  //  Referenced by: '<S233>/Saturation'\n\n  -1.0F,\n\n  // Mask Parameter: PIDController4_LowerSaturatio_f\n  //  Referenced by:\n  //    '<S286>/Saturation'\n  //    '<S271>/DeadZone'\n\n  -1.0F,\n\n  // Mask Parameter: PIDController4_UpperSaturationL\n  //  Referenced by:\n  //    '<S63>/Saturation'\n  //    '<S48>/DeadZone'\n\n  1.0F,\n\n  // Mask Parameter: PIDController4_UpperSaturatio_h\n  //  Referenced by: '<S233>/Saturation'\n\n  1.0F,\n\n  // Mask Parameter: PIDController4_UpperSaturati_hy\n  //  Referenced by:\n  //    '<S286>/Saturation'\n  //    '<S271>/DeadZone'\n\n  1.0F,\n\n  // Mask Parameter: CompareToConstant_const\n  //  Referenced by: '<S180>/Constant'\n\n  1400U,\n\n  // Mask Parameter: CompareToConstant3_const\n  //  Referenced by: '<S409>/Constant'\n\n  1800U,\n\n  // Mask Parameter: CompareToConstant_const_n\n  //  Referenced by: '<S407>/Constant'\n\n  1800U,\n\n  // Computed Parameter: Out1_Y0\n  //  Referenced by: '<S403>/Out1'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n    (0ULL),                            // ref_timestamp\n    0.0,                               // ref_lat\n    0.0,                               // ref_lon\n    0.0F,                              // x\n    0.0F,                              // y\n    0.0F,                              // z\n\n    {\n      0.0F, 0.0F }\n    ,                                  // delta_xy\n    0.0F,                              // delta_z\n    0.0F,                              // vx\n    0.0F,                              // vy\n    0.0F,                              // vz\n    0.0F,                              // z_deriv\n\n    {\n      0.0F, 0.0F }\n    ,                                  // delta_vxy\n    0.0F,                              // delta_vz\n    0.0F,                              // ax\n    0.0F,                              // ay\n    0.0F,                              // az\n    0.0F,                              // heading\n    0.0F,                              // delta_heading\n    0.0F,                              // ref_alt\n    0.0F,                              // dist_bottom\n    0.0F,                              // eph\n    0.0F,                              // epv\n    0.0F,                              // evh\n    0.0F,                              // evv\n    0.0F,                              // vxy_max\n    0.0F,                              // vz_max\n    0.0F,                              // hagl_min\n    0.0F,                              // hagl_max\n    false,                             // xy_valid\n    false,                             // z_valid\n    false,                             // v_xy_valid\n    false,                             // v_z_valid\n    0U,                                // xy_reset_counter\n    0U,                                // z_reset_counter\n    0U,                                // vxy_reset_counter\n    0U,                                // vz_reset_counter\n    0U,                                // heading_reset_counter\n    false,                             // heading_good_for_control\n    false,                             // xy_global\n    false,                             // z_global\n    false,                             // dist_bottom_valid\n    0U,                                // dist_bottom_sensor_bitfield\n    false,                             // dead_reckoning\n    0U                                 // _padding0\n  },\n\n  // Computed Parameter: Constant_Value\n  //  Referenced by: '<S401>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n    (0ULL),                            // ref_timestamp\n    0.0,                               // ref_lat\n    0.0,                               // ref_lon\n    0.0F,                              // x\n    0.0F,                              // y\n    0.0F,                              // z\n\n    {\n      0.0F, 0.0F }\n    ,                                  // delta_xy\n    0.0F,                              // delta_z\n    0.0F,                              // vx\n    0.0F,                              // vy\n    0.0F,                              // vz\n    0.0F,                              // z_deriv\n\n    {\n      0.0F, 0.0F }\n    ,                                  // delta_vxy\n    0.0F,                              // delta_vz\n    0.0F,                              // ax\n    0.0F,                              // ay\n    0.0F,                              // az\n    0.0F,                              // heading\n    0.0F,                              // delta_heading\n    0.0F,                              // ref_alt\n    0.0F,                              // dist_bottom\n    0.0F,                              // eph\n    0.0F,                              // epv\n    0.0F,                              // evh\n    0.0F,                              // evv\n    0.0F,                              // vxy_max\n    0.0F,                              // vz_max\n    0.0F,                              // hagl_min\n    0.0F,                              // hagl_max\n    false,                             // xy_valid\n    false,                             // z_valid\n    false,                             // v_xy_valid\n    false,                             // v_z_valid\n    0U,                                // xy_reset_counter\n    0U,                                // z_reset_counter\n    0U,                                // vxy_reset_counter\n    0U,                                // vz_reset_counter\n    0U,                                // heading_reset_counter\n    false,                             // heading_good_for_control\n    false,                             // xy_global\n    false,                             // z_global\n    false,                             // dist_bottom_valid\n    0U,                                // dist_bottom_sensor_bitfield\n    false,                             // dead_reckoning\n    0U                                 // _padding0\n  },\n\n  // Computed Parameter: Out1_Y0_d\n  //  Referenced by: '<S405>/Out1'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // position\n\n    {\n      0.0F, 0.0F, 0.0F, 0.0F }\n    ,                                  // q\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // velocity\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // angular_velocity\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // position_variance\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // orientation_variance\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // velocity_variance\n    0U,                                // pose_frame\n    0U,                                // velocity_frame\n    0U,                                // reset_counter\n    0,                                 // quality\n\n    {\n      0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_g\n  //  Referenced by: '<S404>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // position\n\n    {\n      0.0F, 0.0F, 0.0F, 0.0F }\n    ,                                  // q\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // velocity\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // angular_velocity\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // position_variance\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // orientation_variance\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // velocity_variance\n    0U,                                // pose_frame\n    0U,                                // velocity_frame\n    0U,                                // reset_counter\n    0,                                 // quality\n\n    {\n      0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_f\n  //  Referenced by: '<S573>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    0U,                                // noutputs\n\n    {\n      0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,\n      0.0F, 0.0F, 0.0F, 0.0F }\n    ,                                  // output\n\n    {\n      0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_m\n  //  Referenced by: '<S571>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n\n    {\n      0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F }\n    ,                                  // control\n    0U,                                // reversible_flags\n\n    {\n      0U, 0U, 0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Out1_Y0_p\n  //  Referenced by: '<S411>/Out1'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_last_signal\n    0,                                 // rssi\n    0.0F,                              // rssi_dbm\n    0U,                                // rc_lost_frame_count\n    0U,                                // rc_total_frame_count\n    0U,                                // rc_ppm_frame_length\n\n    {\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U }\n    ,                                  // values\n    0U,                                // channel_count\n    false,                             // rc_failsafe\n    false,                             // rc_lost\n    0U,                                // input_source\n    0,                                 // link_quality\n    0U                                 // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_b\n  //  Referenced by: '<S410>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_last_signal\n    0,                                 // rssi\n    0.0F,                              // rssi_dbm\n    0U,                                // rc_lost_frame_count\n    0U,                                // rc_total_frame_count\n    0U,                                // rc_ppm_frame_length\n\n    {\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U }\n    ,                                  // values\n    0U,                                // channel_count\n    false,                             // rc_failsafe\n    false,                             // rc_lost\n    0U,                                // input_source\n    0,                                 // link_quality\n    0U                                 // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_n\n  //  Referenced by: '<S580>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    0.0F,                              // x\n    0.0F,                              // y\n    0.0F,                              // z\n    0.0F,                              // vx\n    0.0F,                              // vy\n    0.0F,                              // vz\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // acceleration\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // thrust\n    0.0F,                              // yaw\n    0.0F                               // yawspeed\n  },\n\n  // Computed Parameter: Constant_Value_j\n  //  Referenced by: '<S577>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    0.0F,                              // roll_body\n    0.0F,                              // pitch_body\n    0.0F,                              // yaw_body\n    0.0F,                              // yaw_sp_move_rate\n\n    {\n      0.0F, 0.0F, 0.0F, 0.0F }\n    ,                                  // q_d\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // thrust_body\n    false,                             // reset_integral\n    false,                             // fw_control_yaw_wheel\n\n    {\n      0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Out1_Y0_pn\n  //  Referenced by: '<S576>/Out1'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // xyz\n\n    {\n      0.0F, 0.0F, 0.0F }\n    // xyz_derivative\n  },\n\n  // Computed Parameter: Constant_Value_gk\n  //  Referenced by: '<S575>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // xyz\n\n    {\n      0.0F, 0.0F, 0.0F }\n    // xyz_derivative\n  },\n\n  // Computed Parameter: Constant_Value_i\n  //  Referenced by: '<S582>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    0.0F,                              // roll\n    0.0F,                              // pitch\n    0.0F,                              // yaw\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // thrust_body\n    false,                             // reset_integral\n\n    {\n      0U, 0U, 0U, 0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_a\n  //  Referenced by: '<S566>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // control_power\n\n    {\n      0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant1'\n\n  100.0,\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant2'\n\n  100.0,\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant3'\n\n  100.0,\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant4'\n\n  100.0,\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant5'\n\n  100.0,\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant'\n\n  100.0,\n\n  // Expression: 1094\n  //  Referenced by: '<S10>/Constant'\n\n  1094.0,\n\n  // Expression: 1/800\n  //  Referenced by: '<S10>/Gain'\n\n  0.00125,\n\n  // Expression: 0.01\n  //  Referenced by: '<S181>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S181>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S181>/Saturation'\n\n  0.0,\n\n  // Expression: 0.01\n  //  Referenced by: '<S182>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S182>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S182>/Saturation'\n\n  0.0,\n\n  // Expression: 0.01\n  //  Referenced by: '<S183>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S183>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S183>/Saturation'\n\n  0.0,\n\n  // Expression: 0.01\n  //  Referenced by: '<S184>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S184>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S184>/Saturation'\n\n  0.0,\n\n  // Expression: 0.01\n  //  Referenced by: '<S185>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S185>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S185>/Saturation'\n\n  0.0,\n\n  // Expression: 0.01\n  //  Referenced by: '<S186>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S186>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S186>/Saturation'\n\n  0.0,\n\n  // Computed Parameter: Gain1_Gain\n  //  Referenced by: '<S2>/Gain1'\n\n  -1.0F,\n\n  // Computed Parameter: Gain_Gain_m3\n  //  Referenced by: '<S2>/Gain'\n\n  -1.0F,\n\n  // Computed Parameter: des_p_Y0\n  //  Referenced by: '<S2>/des_p'\n\n  0.0F,\n\n  // Computed Parameter: des_q_Y0\n  //  Referenced by: '<S2>/des_q'\n\n  0.0F,\n\n  // Computed Parameter: Gain1_Gain_g\n  //  Referenced by: '<S73>/Gain1'\n\n  0.0174532924F,\n\n  // Computed Parameter: Gain1_Gain_c\n  //  Referenced by: '<S74>/Gain1'\n\n  0.0174532924F,\n\n  // Computed Parameter: throttle_Y0\n  //  Referenced by: '<S19>/throttle'\n\n  0.0F,\n\n  // Computed Parameter: Constant1_Value_n\n  //  Referenced by: '<S46>/Constant1'\n\n  0.0F,\n\n  // Computed Parameter: Constant_Value_bi\n  //  Referenced by: '<S19>/Constant'\n\n  50.0F,\n\n  // Computed Parameter: Gain_Gain_d\n  //  Referenced by: '<S19>/Gain'\n\n  -1.0F,\n\n  // Computed Parameter: Filter_gainval\n  //  Referenced by: '<S51>/Filter'\n\n  0.005F,\n\n  // Computed Parameter: Integrator_gainval\n  //  Referenced by: '<S56>/Integrator'\n\n  0.005F,\n\n  // Computed Parameter: Saturation1_UpperSat\n  //  Referenced by: '<S19>/Saturation1'\n\n  1.0F,\n\n  // Computed Parameter: Saturation1_LowerSat\n  //  Referenced by: '<S19>/Saturation1'\n\n  0.0F,\n\n  // Computed Parameter: Clamping_zero_Value\n  //  Referenced by: '<S46>/Clamping_zero'\n\n  0.0F,\n\n  // Computed Parameter: DeadZone3_Start\n  //  Referenced by: '<S18>/Dead Zone3'\n\n  -0.003F,\n\n  // Computed Parameter: DeadZone3_End\n  //  Referenced by: '<S18>/Dead Zone3'\n\n  0.003F,\n\n  // Computed Parameter: Saturation9_UpperSat\n  //  Referenced by: '<S18>/Saturation9'\n\n  1.0F,\n\n  // Computed Parameter: Saturation9_LowerSat\n  //  Referenced by: '<S18>/Saturation9'\n\n  -1.0F,\n\n  // Computed Parameter: DeadZone2_Start\n  //  Referenced by: '<S18>/Dead Zone2'\n\n  -0.005F,\n\n  // Computed Parameter: DeadZone2_End\n  //  Referenced by: '<S18>/Dead Zone2'\n\n  0.005F,\n\n  // Computed Parameter: Saturation3_UpperSat\n  //  Referenced by: '<S18>/Saturation3'\n\n  1.0F,\n\n  // Computed Parameter: Saturation3_LowerSat\n  //  Referenced by: '<S18>/Saturation3'\n\n  -1.0F,\n\n  // Computed Parameter: DeadZone4_Start\n  //  Referenced by: '<S18>/Dead Zone4'\n\n  -0.03F,\n\n  // Computed Parameter: DeadZone4_End\n  //  Referenced by: '<S18>/Dead Zone4'\n\n  0.03F,\n\n  // Computed Parameter: Saturation10_UpperSat\n  //  Referenced by: '<S18>/Saturation10'\n\n  1.0F,\n\n  // Computed Parameter: Saturation10_LowerSat\n  //  Referenced by: '<S18>/Saturation10'\n\n  -1.0F,\n\n  // Computed Parameter: Gain_Gain_e\n  //  Referenced by: '<S18>/Gain'\n\n  -1.0F,\n\n  // Computed Parameter: DeadZone1_Start\n  //  Referenced by: '<S18>/Dead Zone1'\n\n  -0.001F,\n\n  // Computed Parameter: DeadZone1_End\n  //  Referenced by: '<S18>/Dead Zone1'\n\n  0.001F,\n\n  // Computed Parameter: Saturation1_UpperSat_d\n  //  Referenced by: '<S18>/Saturation1'\n\n  1.0F,\n\n  // Computed Parameter: Saturation1_LowerSat_b\n  //  Referenced by: '<S18>/Saturation1'\n\n  -1.0F,\n\n  // Computed Parameter: des_vz_Y0\n  //  Referenced by: '<S187>/des_vz'\n\n  0.0F,\n\n  // Computed Parameter: throttle_Y0_o\n  //  Referenced by: '<S189>/throttle'\n\n  0.0F,\n\n  // Computed Parameter: log_alt_Y0\n  //  Referenced by: '<S189>/log_alt'\n\n  0.0F,\n\n  // Computed Parameter: Constant1_Value_m\n  //  Referenced by: '<S269>/Constant1'\n\n  0.0F,\n\n  // Computed Parameter: Constant_Value_e\n  //  Referenced by: '<S189>/Constant'\n\n  50.0F,\n\n  // Computed Parameter: Gain_Gain_b\n  //  Referenced by: '<S189>/Gain'\n\n  -1.0F,\n\n  // Computed Parameter: Filter_gainval_h\n  //  Referenced by: '<S274>/Filter'\n\n  0.005F,\n\n  // Computed Parameter: Integrator_gainval_l\n  //  Referenced by: '<S279>/Integrator'\n\n  0.005F,\n\n  // Computed Parameter: Saturation1_UpperSat_e\n  //  Referenced by: '<S189>/Saturation1'\n\n  1.0F,\n\n  // Computed Parameter: Saturation1_LowerSat_bn\n  //  Referenced by: '<S189>/Saturation1'\n\n  0.0F,\n\n  // Computed Parameter: Clamping_zero_Value_f\n  //  Referenced by: '<S269>/Clamping_zero'\n\n  0.0F,\n\n  // Computed Parameter: des_vxvy_Y0\n  //  Referenced by: '<S190>/des_vxvy'\n\n  0.0F,\n\n  // Computed Parameter: des_pitch_Y0\n  //  Referenced by: '<S191>/des_pitch'\n\n  0.0F,\n\n  // Computed Parameter: des_roll_Y0\n  //  Referenced by: '<S191>/des_roll'\n\n  0.0F,\n\n  // Computed Parameter: Gain_Gain_a\n  //  Referenced by: '<S349>/Gain'\n\n  -1.0F,\n\n  // Computed Parameter: Saturation_UpperSat_e\n  //  Referenced by: '<S191>/Saturation'\n\n  0.610865235F,\n\n  // Computed Parameter: Saturation_LowerSat_a\n  //  Referenced by: '<S191>/Saturation'\n\n  -0.610865235F,\n\n  // Computed Parameter: Gain1_Gain_i\n  //  Referenced by: '<S191>/Gain1'\n\n  -1.0F,\n\n  // Computed Parameter: des_z_Y0\n  //  Referenced by: '<S5>/des_z'\n\n  0.0F,\n\n  // Computed Parameter: Constant_Value_k\n  //  Referenced by: '<S5>/Constant'\n\n  { 0.0F, 0.0F },\n\n  // Computed Parameter: DeadZone4_Start_d\n  //  Referenced by: '<S188>/Dead Zone4'\n\n  -0.1F,\n\n  // Computed Parameter: DeadZone4_End_l\n  //  Referenced by: '<S188>/Dead Zone4'\n\n  0.1F,\n\n  // Computed Parameter: Saturation10_UpperSat_m\n  //  Referenced by: '<S188>/Saturation10'\n\n  1.0F,\n\n  // Computed Parameter: Saturation10_LowerSat_n\n  //  Referenced by: '<S188>/Saturation10'\n\n  -1.0F,\n\n  // Computed Parameter: Gain_Gain_o\n  //  Referenced by: '<S188>/Gain'\n\n  -1.0F,\n\n  // Computed Parameter: DeadZone2_Start_k\n  //  Referenced by: '<S188>/Dead Zone2'\n\n  -0.1F,\n\n  // Computed Parameter: DeadZone2_End_k\n  //  Referenced by: '<S188>/Dead Zone2'\n\n  0.1F,\n\n  // Computed Parameter: Saturation3_UpperSat_b\n  //  Referenced by: '<S188>/Saturation3'\n\n  1.0F,\n\n  // Computed Parameter: Saturation3_LowerSat_a\n  //  Referenced by: '<S188>/Saturation3'\n\n  -1.0F,\n\n  // Computed Parameter: DeadZone3_Start_p\n  //  Referenced by: '<S10>/Dead Zone3'\n\n  -0.05F,\n\n  // Computed Parameter: DeadZone3_End_l\n  //  Referenced by: '<S10>/Dead Zone3'\n\n  0.05F,\n\n  // Computed Parameter: Saturation_UpperSat_o\n  //  Referenced by: '<S10>/Saturation'\n\n  0.9F,\n\n  // Computed Parameter: Saturation_LowerSat_el\n  //  Referenced by: '<S10>/Saturation'\n\n  0.0F,\n\n  // Computed Parameter: Constant1_Value_l\n  //  Referenced by: '<S10>/Constant1'\n\n  1514.0F,\n\n  // Computed Parameter: Gain2_Gain\n  //  Referenced by: '<S10>/Gain2'\n\n  0.0025F,\n\n  // Computed Parameter: DeadZone2_Start_o\n  //  Referenced by: '<S10>/Dead Zone2'\n\n  -0.005F,\n\n  // Computed Parameter: DeadZone2_End_e\n  //  Referenced by: '<S10>/Dead Zone2'\n\n  0.005F,\n\n  // Computed Parameter: Saturation1_UpperSat_l\n  //  Referenced by: '<S10>/Saturation1'\n\n  1.0F,\n\n  // Computed Parameter: Saturation1_LowerSat_i\n  //  Referenced by: '<S10>/Saturation1'\n\n  -1.0F,\n\n  // Computed Parameter: Constant2_Value_i\n  //  Referenced by: '<S10>/Constant2'\n\n  1514.0F,\n\n  // Computed Parameter: Gain1_Gain_m\n  //  Referenced by: '<S10>/Gain1'\n\n  0.0025F,\n\n  // Computed Parameter: DeadZone1_Start_c\n  //  Referenced by: '<S10>/Dead Zone1'\n\n  -0.005F,\n\n  // Computed Parameter: DeadZone1_End_m\n  //  Referenced by: '<S10>/Dead Zone1'\n\n  0.005F,\n\n  // Computed Parameter: Saturation2_UpperSat\n  //  Referenced by: '<S10>/Saturation2'\n\n  1.0F,\n\n  // Computed Parameter: Saturation2_LowerSat\n  //  Referenced by: '<S10>/Saturation2'\n\n  -1.0F,\n\n  // Computed Parameter: Constant3_Value_e\n  //  Referenced by: '<S10>/Constant3'\n\n  1514.0F,\n\n  // Computed Parameter: Gain3_Gain\n  //  Referenced by: '<S10>/Gain3'\n\n  0.0025F,\n\n  // Computed Parameter: DeadZone_Start\n  //  Referenced by: '<S10>/Dead Zone'\n\n  -0.005F,\n\n  // Computed Parameter: DeadZone_End\n  //  Referenced by: '<S10>/Dead Zone'\n\n  0.005F,\n\n  // Computed Parameter: Saturation3_UpperSat_b4\n  //  Referenced by: '<S10>/Saturation3'\n\n  1.0F,\n\n  // Computed Parameter: Saturation3_LowerSat_j\n  //  Referenced by: '<S10>/Saturation3'\n\n  -1.0F,\n\n  // Computed Parameter: tau_roll_Y0\n  //  Referenced by: '<S9>/tau_roll'\n\n  0.0F,\n\n  // Computed Parameter: tau_pitch_Y0\n  //  Referenced by: '<S9>/tau_pitch'\n\n  0.0F,\n\n  // Computed Parameter: tau_yaw_Y0\n  //  Referenced by: '<S9>/tau_yaw'\n\n  0.0F,\n\n  // Computed Parameter: Constant_Value_j4\n  //  Referenced by: '<S9>/Constant'\n\n  50.0F,\n\n  // Computed Parameter: Filter_gainval_o\n  //  Referenced by: '<S493>/Filter'\n\n  0.001F,\n\n  // Computed Parameter: Integrator_gainval_i\n  //  Referenced by: '<S498>/Integrator'\n\n  0.001F,\n\n  // Computed Parameter: Constant1_Value_f\n  //  Referenced by: '<S9>/Constant1'\n\n  50.0F,\n\n  // Computed Parameter: Filter_gainval_f\n  //  Referenced by: '<S443>/Filter'\n\n  0.001F,\n\n  // Computed Parameter: Integrator_gainval_im\n  //  Referenced by: '<S448>/Integrator'\n\n  0.001F,\n\n  // Computed Parameter: Constant2_Value_m\n  //  Referenced by: '<S9>/Constant2'\n\n  50.0F,\n\n  // Computed Parameter: Filter_gainval_m\n  //  Referenced by: '<S543>/Filter'\n\n  0.001F,\n\n  // Computed Parameter: Integrator_gainval_e\n  //  Referenced by: '<S548>/Integrator'\n\n  0.001F,\n\n  // Computed Parameter: RateTransition_InitialCondition\n  //  Referenced by: '<Root>/Rate Transition'\n\n  0.0F,\n\n  // Computed Parameter: RateTransition1_InitialConditio\n  //  Referenced by: '<Root>/Rate Transition1'\n\n  0.0F,\n\n  // Computed Parameter: RateTransition2_InitialConditio\n  //  Referenced by: '<Root>/Rate Transition2'\n\n  0.0F,\n\n  // Computed Parameter: RateTransition3_InitialConditio\n  //  Referenced by: '<Root>/Rate Transition3'\n\n  0.0F,\n\n  // Computed Parameter: Constant_Value_kf\n  //  Referenced by: '<S181>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_ms\n  //  Referenced by: '<S182>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_ii\n  //  Referenced by: '<S183>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_j4x\n  //  Referenced by: '<S184>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_l\n  //  Referenced by: '<S185>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_o\n  //  Referenced by: '<S186>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Constant1_Value_i\n  //  Referenced by: '<S12>/Constant1'\n\n  { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F },\n\n  // Computed Parameter: Saturation_UpperSat_ep\n  //  Referenced by: '<S568>/Saturation'\n\n  2000.0F,\n\n  // Computed Parameter: Saturation_LowerSat_p\n  //  Referenced by: '<S568>/Saturation'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_ez\n  //  Referenced by: '<S568>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Gain_Gain_mg\n  //  Referenced by: '<S568>/Gain'\n\n  0.001F,\n\n  // Computed Parameter: Constant_Value_bm\n  //  Referenced by: '<S12>/Constant'\n\n  { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F },\n\n  // Computed Parameter: Merge1_InitialOutput\n  //  Referenced by: '<Root>/Merge1'\n\n  0.0F,\n\n  // Computed Parameter: Constant_Value_gq\n  //  Referenced by: '<S15>/Constant'\n\n  0.0F,\n\n  // Computed Parameter: Constant_Value_a5\n  //  Referenced by: '<Root>/Constant'\n\n  0.0F,\n\n  // Computed Parameter: u2_Gain\n  //  Referenced by: '<S579>/1//2'\n\n  0.5F,\n\n  // Computed Parameter: Merge_InitialOutput\n  //  Referenced by: '<Root>/Merge'\n\n  0.0F,\n\n  // Computed Parameter: Constant_Value_ll\n  //  Referenced by: '<S17>/Constant'\n\n  0.0F,\n\n  // Computed Parameter: Constant2_Value_e\n  //  Referenced by: '<S12>/Constant2'\n\n  12U,\n\n  // Computed Parameter: PWM_Y0\n  //  Referenced by: '<S6>/PWM'\n\n  0U,\n\n  // Computed Parameter: Output_Limits1_UpperSat\n  //  Referenced by: '<S6>/Output_Limits1'\n\n  2000U,\n\n  // Computed Parameter: Output_Limits1_LowerSat\n  //  Referenced by: '<S6>/Output_Limits1'\n\n  1000U,\n\n  // Computed Parameter: RateTransition4_InitialConditio\n  //  Referenced by: '<Root>/Rate Transition4'\n\n  0U,\n\n  // Computed Parameter: RateTransition5_InitialConditio\n  //  Referenced by: '<Root>/Rate Transition5'\n\n  false,\n\n  // Computed Parameter: RateTransition6_InitialConditio\n  //  Referenced by: '<Root>/Rate Transition6'\n\n  false,\n\n  // Computed Parameter: Constant_Value_jc\n  //  Referenced by: '<S46>/Constant'\n\n  1,\n\n  // Computed Parameter: Constant2_Value_mj\n  //  Referenced by: '<S46>/Constant2'\n\n  -1,\n\n  // Computed Parameter: Constant3_Value_es\n  //  Referenced by: '<S46>/Constant3'\n\n  1,\n\n  // Computed Parameter: Constant4_Value_j\n  //  Referenced by: '<S46>/Constant4'\n\n  -1,\n\n  // Computed Parameter: Constant_Value_mn\n  //  Referenced by: '<S269>/Constant'\n\n  1,\n\n  // Computed Parameter: Constant2_Value_p\n  //  Referenced by: '<S269>/Constant2'\n\n  -1,\n\n  // Computed Parameter: Constant3_Value_n\n  //  Referenced by: '<S269>/Constant3'\n\n  1,\n\n  // Computed Parameter: Constant4_Value_i\n  //  Referenced by: '<S269>/Constant4'\n\n  -1\n};\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtGetInf.cpp","type":"source","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtGetInf.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.146\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu Apr 24 17:45:28 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  //\n  // Initialize rtInf needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  real_T rtGetInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T inf = 0.0;\n    if (bitsPerReal == 32U) {\n      inf = rtGetInfF();\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.bitVal.words.wordH = 0x7FF00000U;\n      tmpVal.bitVal.words.wordL = 0x00000000U;\n      inf = tmpVal.fltVal;\n    }\n\n    return inf;\n  }\n\n  //\n  // Initialize rtInfF needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  real32_T rtGetInfF(void)\n  {\n    IEEESingle infF;\n    infF.wordL.wordLuint = 0x7F800000U;\n    return infF.wordL.wordLreal;\n  }\n\n  //\n  // Initialize rtMinusInf needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  real_T rtGetMinusInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T minf = 0.0;\n    if (bitsPerReal == 32U) {\n      minf = rtGetMinusInfF();\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.bitVal.words.wordH = 0xFFF00000U;\n      tmpVal.bitVal.words.wordL = 0x00000000U;\n      minf = tmpVal.fltVal;\n    }\n\n    return minf;\n  }\n\n  //\n  // Initialize rtMinusInfF needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  real32_T rtGetMinusInfF(void)\n  {\n    IEEESingle minfF;\n    minfF.wordL.wordLuint = 0xFF800000U;\n    return minfF.wordL.wordLreal;\n  }\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtGetInf.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.146\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu Apr 24 17:45:28 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef rtGetInf_h_\n#define rtGetInf_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetInf(void);\n  extern real32_T rtGetInfF(void);\n  extern real_T rtGetMinusInf(void);\n  extern real32_T rtGetMinusInfF(void);\n\n#ifdef __cplusplus\n\n}                                      // extern \"C\"\n\n#endif\n#endif                                 // rtGetInf_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtGetNaN.cpp","type":"source","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtGetNaN.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.146\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu Apr 24 17:45:28 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  //\n  // Initialize rtNaN needed by the generated code.\n  // NaN is initialized as non-signaling. Assumes IEEE.\n  //\n  real_T rtGetNaN(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T nan = 0.0;\n    if (bitsPerReal == 32U) {\n      nan = rtGetNaNF();\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.bitVal.words.wordH = 0xFFF80000U;\n      tmpVal.bitVal.words.wordL = 0x00000000U;\n      nan = tmpVal.fltVal;\n    }\n\n    return nan;\n  }\n\n  //\n  // Initialize rtNaNF needed by the generated code.\n  // NaN is initialized as non-signaling. Assumes IEEE.\n  //\n  real32_T rtGetNaNF(void)\n  {\n    IEEESingle nanF = { { 0.0F } };\n\n    nanF.wordL.wordLuint = 0xFFC00000U;\n    return nanF.wordL.wordLreal;\n  }\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtGetNaN.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.146\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu Apr 24 17:45:28 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef rtGetNaN_h_\n#define rtGetNaN_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetNaN(void);\n  extern real32_T rtGetNaNF(void);\n\n#ifdef __cplusplus\n\n}                                      // extern \"C\"\n\n#endif\n#endif                                 // rtGetNaN_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rt_defines.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.146\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu Apr 24 17:45:28 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef rt_defines_h_\n#define rt_defines_h_\n\n//===========*\n//  Constants *\n// ===========\n#define RT_PI                          3.14159265358979323846\n#define RT_PIF                         3.1415927F\n#define RT_LN_10                       2.30258509299404568402\n#define RT_LN_10F                      2.3025851F\n#define RT_LOG10E                      0.43429448190325182765\n#define RT_LOG10EF                     0.43429449F\n#define RT_E                           2.7182818284590452354\n#define RT_EF                          2.7182817F\n\n//\n//  UNUSED_PARAMETER(x)\n//    Used to specify that a function parameter (argument) is required but not\n//    accessed by the function body.\n\n#ifndef UNUSED_PARAMETER\n#if defined(__LCC__)\n#define UNUSED_PARAMETER(x)                                      // do nothing\n#else\n\n//\n//  This is the semi-ANSI standard way of indicating that an\n//  unused function parameter is required.\n\n#define UNUSED_PARAMETER(x)            (void) (x)\n#endif\n#endif\n#endif                                 // rt_defines_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rt_nonfinite.cpp","type":"source","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rt_nonfinite.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.146\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu Apr 24 17:45:28 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  real_T rtInf;\n  real_T rtMinusInf;\n  real_T rtNaN;\n  real32_T rtInfF;\n  real32_T rtMinusInfF;\n  real32_T rtNaNF;\n}\n\nextern \"C\"\n{\n  //\n  // Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n  // generated code. NaN is initialized as non-signaling. Assumes IEEE.\n  //\n  void rt_InitInfAndNaN(size_t realSize)\n  {\n    (void) (realSize);\n    rtNaN = rtGetNaN();\n    rtNaNF = rtGetNaNF();\n    rtInf = rtGetInf();\n    rtInfF = rtGetInfF();\n    rtMinusInf = rtGetMinusInf();\n    rtMinusInfF = rtGetMinusInfF();\n  }\n\n  // Test if value is infinite\n  boolean_T rtIsInf(real_T value)\n  {\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n  }\n\n  // Test if single-precision value is infinite\n  boolean_T rtIsInfF(real32_T value)\n  {\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n  }\n\n  // Test if value is not a number\n  boolean_T rtIsNaN(real_T value)\n  {\n    boolean_T result = (boolean_T) 0;\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    if (bitsPerReal == 32U) {\n      result = rtIsNaNF((real32_T)value);\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.fltVal = value;\n      result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                           0x7FF00000 &&\n                           ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                            (tmpVal.bitVal.words.wordL != 0) ));\n    }\n\n    return result;\n  }\n\n  // Test if single-precision value is not a number\n  boolean_T rtIsNaNF(real32_T value)\n  {\n    IEEESingle tmp;\n    tmp.wordL.wordLreal = value;\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n  }\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rt_nonfinite.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.146\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu Apr 24 17:45:28 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef rt_nonfinite_h_\n#define rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#define NOT_USING_NONFINITE_LITERALS   1\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtInf;\n  extern real_T rtMinusInf;\n  extern real_T rtNaN;\n  extern real32_T rtInfF;\n  extern real32_T rtMinusInfF;\n  extern real32_T rtNaNF;\n  extern void rt_InitInfAndNaN(size_t realSize);\n  extern boolean_T rtIsInf(real_T value);\n  extern boolean_T rtIsInfF(real32_T value);\n  extern boolean_T rtIsNaN(real_T value);\n  extern boolean_T rtIsNaNF(real32_T value);\n  struct BigEndianIEEEDouble {\n    struct {\n      uint32_T wordH;\n      uint32_T wordL;\n    } words;\n  };\n\n  struct LittleEndianIEEEDouble {\n    struct {\n      uint32_T wordL;\n      uint32_T wordH;\n    } words;\n  };\n\n  struct IEEESingle {\n    union {\n      real32_T wordLreal;\n      uint32_T wordLuint;\n    } wordL;\n  };\n\n#ifdef __cplusplus\n\n}                                      // extern \"C\"\n\n#endif\n#endif                                 // rt_nonfinite_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtwtypes.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.146\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu Apr 24 17:45:28 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n\n// Logical type definitions\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n//=======================================================================*\n//  Target hardware information\n//    Device type: ARM Compatible->ARM Cortex\n//    Number of bits:     char:   8    short:   16    int:  32\n//                        long:  32    long long:  64\n//                        native word size:  32\n//    Byte ordering: LittleEndian\n//    Signed integer division rounds to: Zero\n//    Shift right on a signed integer as arithmetic shift: on\n// =======================================================================\n\n//=======================================================================*\n//  Fixed width word size data types:                                     *\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n//    real32_T, real64_T           - 32 and 64 bit floating point numbers *\n// =======================================================================\ntypedef signed char int8_T;\ntypedef unsigned char uint8_T;\ntypedef short int16_T;\ntypedef unsigned short uint16_T;\ntypedef int int32_T;\ntypedef unsigned int uint32_T;\ntypedef long long int64_T;\ntypedef unsigned long long uint64_T;\ntypedef float real32_T;\ntypedef double real64_T;\n\n//===========================================================================*\n//  Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n//                            real_T, time_T, ulong_T, ulonglong_T.           *\n// ===========================================================================\ntypedef double real_T;\ntypedef double time_T;\ntypedef unsigned char boolean_T;\ntypedef int int_T;\ntypedef unsigned int uint_T;\ntypedef unsigned long ulong_T;\ntypedef unsigned long long ulonglong_T;\ntypedef char char_T;\ntypedef unsigned char uchar_T;\ntypedef char_T byte_T;\n\n//===========================================================================*\n//  Complex number type definitions                                           *\n// ===========================================================================\n#define CREAL_T\n\ntypedef struct {\n  real32_T re;\n  real32_T im;\n} creal32_T;\n\ntypedef struct {\n  real64_T re;\n  real64_T im;\n} creal64_T;\n\ntypedef struct {\n  real_T re;\n  real_T im;\n} creal_T;\n\n#define CINT8_T\n\ntypedef struct {\n  int8_T re;\n  int8_T im;\n} cint8_T;\n\n#define CUINT8_T\n\ntypedef struct {\n  uint8_T re;\n  uint8_T im;\n} cuint8_T;\n\n#define CINT16_T\n\ntypedef struct {\n  int16_T re;\n  int16_T im;\n} cint16_T;\n\n#define CUINT16_T\n\ntypedef struct {\n  uint16_T re;\n  uint16_T im;\n} cuint16_T;\n\n#define CINT32_T\n\ntypedef struct {\n  int32_T re;\n  int32_T im;\n} cint32_T;\n\n#define CUINT32_T\n\ntypedef struct {\n  uint32_T re;\n  uint32_T im;\n} cuint32_T;\n\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n//=======================================================================*\n//  Min and Max:                                                          *\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n// =======================================================================\n#define MAX_int8_T                     ((int8_T)(127))\n#define MIN_int8_T                     ((int8_T)(-128))\n#define MAX_uint8_T                    ((uint8_T)(255U))\n#define MAX_int16_T                    ((int16_T)(32767))\n#define MIN_int16_T                    ((int16_T)(-32768))\n#define MAX_uint16_T                   ((uint16_T)(65535U))\n#define MAX_int32_T                    ((int32_T)(2147483647))\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\n\n// Block D-Work pointer type\ntypedef void * pointer_T;\n\n#endif                                 // RTWTYPES_H\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Interface files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtmodel.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.146\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Thu Apr 24 17:45:28 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef rtmodel_h_\n#define rtmodel_h_\n#include \"FLIGHT_hexacopter.h\"\n\n// Macros generated for backwards compatibility\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((void*) 0)\n#endif\n#endif                                 // rtmodel_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"MW_PX4_PWM.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw/../../../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2024 The MathWorks, Inc. */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"MW_PX4_PWM.h\"\n#include \"MW_Parameter.h\"\n#include <uORB/Publication.hpp>\n\n#define DEBUG 0\n\nstatic constexpr uint16_t PWM_SIM_DISARMED = 900;\nstatic constexpr uint16_t PWM_SIM_FAILSAFE = 600;\nstatic constexpr uint16_t PWM_SIM_PWM_MIN = 1000;\nstatic constexpr uint16_t PWM_SIM_PWM_MAX = 2000;\n#if USE_ACTUATOR_TEST\nuORB::Publication<actuator_test_s> actuator_test_pub{ORB_ID(actuator_test)};\n#endif\n\nvoid pwm_open(orb_advert_t* actuatorObj, orb_advert_t* armObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"*     actuatorObj: %d * \", actuatorObj);\n    PX4_INFO(\"*     armObj: %d *\\n\", armObj);\n#endif\n\n#if USE_ACTUATOR_TEST\n    getMainDAPWMValues(mainDAPWMValue);\n    getAUXDAPWMValues(auxDAPWMValue);\n    getMainMinValues(mainMinPWMValue);\n    getAUXMinValues(auxMinPWMValue);\n    getMainMaxValues(mainMaxPWMValue);\n    getAUXMaxValues(auxMaxPWMValue);\n#else\n    /* advertise actuator_outputs topic */\n    struct actuator_outputs_s outputs;\n    memset(&outputs, 0, sizeof(outputs));\n    *actuatorObj = orb_advertise_queue(ORB_ID(actuator_outputs_sim), &outputs, 1);\n\n    /* advertise actuator_armed topic */\n    struct actuator_armed_s armPWM;\n    memset(&armPWM, 0, sizeof(armPWM));\n    *armObj = orb_advertise_queue(ORB_ID(actuator_armed), &armPWM, 1);\n#endif\n}\n\nvoid pwm_arm(orb_advert_t* armObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_arm: *isArmed (status = %d)* \", *isArmed);\n    PX4_INFO(\"*     armObj: %d *\\n\", armObj);\n#endif\n\n#if USE_ACTUATOR_TEST\n\n#else\n    struct actuator_armed_s armPWM;\n    memset(&armPWM, 0, sizeof(armPWM));\n    armPWM.armed = true;\n    orb_publish(ORB_ID(actuator_armed), *armObj, &armPWM);\n#endif\n}\n\nvoid pwm_disarm(orb_advert_t* armObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_disarm: *isArmed (status = %d)* \", *isArmed);\n    PX4_INFO(\"*     armObj: %d *\\n\", armObj);\n#endif\n\n#if USE_ACTUATOR_TEST\n#else\n    struct actuator_armed_s armPWM;\n    memset(&armPWM, 0, sizeof(armPWM));\n    armPWM.armed = false;\n    orb_publish(ORB_ID(actuator_armed), *armObj, &armPWM);\n\n#if defined(MW_PX4_POSIX_BUILD)\n    struct vehicle_status_s arm_vehicle_stat;\n    /* Subscribe to current vehicle_status*/\n    int vehicle_status_fd = orb_subscribe(ORB_ID(vehicle_status));\n    orb_copy(ORB_ID(vehicle_status), vehicle_status_fd, &arm_vehicle_stat);\n    /* Arm vehicle status to ARMING_STATE_SHUTDOWN = 4*/\n    arm_vehicle_stat.arming_state = 4;\n    static bool isAdvertised_disarm = false;\n    static orb_advert_t vehicle_status_pub;\n    if (!isAdvertised_disarm) {\n        isAdvertised_disarm = true;\n        vehicle_status_pub = orb_advertise_queue(ORB_ID(vehicle_status), &arm_vehicle_stat, 1);\n    }\n    orb_publish(ORB_ID(vehicle_status), vehicle_status_pub, &arm_vehicle_stat);\n\n    orb_unsubscribe(vehicle_status_fd);\n#endif\n\n#endif\n}\n\nvoid pwm_forceFailsafe(orb_advert_t* armObj) {\n\n    pwm_disarm(armObj);\n}\n\nvoid pwm_setServo(unsigned servo_count,\n                  int channelMask,\n                  uint16_t* pwm_value,\n                  boolean_T isMain,\n                  orb_advert_t* actuatorObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_setServo: servo_count %d* \", servo_count);\n    PX4_INFO(\"*     isMain %d* \", isMain);\n    PX4_INFO(\"*     actuatorObj %d* \\n\", actuatorObj);\n    uint32_T iPWM;\n    printf(\"* pwm_setServo: PWM values :\");\n    for (iPWM = 0; iPWM < 8; iPWM++) {\n        printf(\"[%d]\", pwm_value[iPWM]);\n    }\n    printf(\"\\n\");\n#endif\n#if USE_ACTUATOR_TEST\n    float output = 0;\n    if (isMain) {\n        for (unsigned i = 0; i < servo_count; ++i) {\n            output = (float)pwm_value[i];\n            output = (output - mainMinPWMValue[i]) / (mainMaxPWMValue[i] - mainMinPWMValue[i]);\n            send_actuator_test_output(actuator_test_s::FUNCTION_MOTOR1 + i, output, false);\n        }\n    } else {\n        for (unsigned i = 0; i < servo_count; ++i) {\n            output = (float)pwm_value[i];\n            output = (output - ((auxMaxPWMValue[i] + auxMinPWMValue[i]) / 2)) /\n                     ((auxMaxPWMValue[i] - auxMinPWMValue[i]) / 2);\n            send_actuator_test_output(actuator_test_s::FUNCTION_SERVO1 + i, output, false);\n        }\n    }\n#else\n    if (isMain) {\n        struct actuator_outputs_s outputs;\n        memset(&outputs, 0, sizeof(outputs));\n        outputs.noutputs = servo_count;\n        outputs.timestamp = hrt_absolute_time();\n        for (unsigned i = 0; i < servo_count; i++) {\n\n            if (pwm_value[i] != PWM_SIM_DISARMED && channelMask & 1 << i) {\n\n                float output = (float)pwm_value[i];\n                /* Scale the motors that are non - reversible to[0, 1]*/\n                outputs.output[i] =\n                    (output - PWM_SIM_PWM_MIN) / (PWM_SIM_PWM_MAX - PWM_SIM_PWM_MIN);\n            }\n        }\n        orb_publish(ORB_ID(actuator_outputs_sim), *actuatorObj, &outputs);\n\n#if defined(MW_PX4_POSIX_BUILD)\n        /*Only for Host target vehicle_status needs to be armed, not for HITL*/\n        struct vehicle_status_s arm_vehicle_stat;\n        /* Subscribe to current vehicle_status*/\n        int vehicle_status_fd = orb_subscribe(ORB_ID(vehicle_status));\n        orb_copy(ORB_ID(vehicle_status), vehicle_status_fd, &arm_vehicle_stat);\n        /* Arm vehicle status to ARMING_STATE_ARMED = 2*/\n        arm_vehicle_stat.arming_state = 2;\n        orb_advert_t vehicle_status_pub =\n            orb_advertise_queue(ORB_ID(vehicle_status), &arm_vehicle_stat, 1);\n        orb_publish(ORB_ID(vehicle_status), vehicle_status_pub, &arm_vehicle_stat);\n        orb_unsubscribe(vehicle_status_fd);\n#endif\n    }\n#endif\n}\n\nvoid pwm_resetServo(unsigned servo_count, boolean_T isMain, orb_advert_t* actuatorObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_setServo: servo_count %d* \", servo_count);\n    PX4_INFO(\"*     isMain %d* \", isMain);\n    PX4_INFO(\"*     actuatorObj %d* \\n\", actuatorObj);\n#endif\n\n#if USE_ACTUATOR_TEST\n    if (isMain) {\n        for (unsigned i = 0; i < servo_count; ++i) {\n            send_actuator_test_output(actuator_test_s::FUNCTION_MOTOR1 + i, 0, true);\n        }\n    } else {\n        for (unsigned i = 0; i < servo_count; ++i) {\n            send_actuator_test_output(actuator_test_s::FUNCTION_SERVO1 + i, 0, true);\n        }\n    }\n#else\n    if (isMain) {\n        struct actuator_outputs_s outputs;\n        memset(&outputs, 0, sizeof(outputs));\n        outputs.noutputs = servo_count;\n        outputs.timestamp = hrt_absolute_time();\n        orb_publish(ORB_ID(actuator_outputs_sim), *actuatorObj, &outputs);\n    }\n\n#endif\n}\n\nvoid pwm_close(unsigned servo_count, orb_advert_t* actuatorObj, orb_advert_t* armObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_close: armObj %d* \", armObj);\n    PX4_INFO(\"*     actuatorObj %d*\\n\", actuatorObj);\n#endif\n\n#if USE_ACTUATOR_TEST\n    for (unsigned i = 0; i < servo_count; ++i) {\n        send_actuator_test_output(actuator_test_s::FUNCTION_MOTOR1 + i, 0, true);\n    }\n\n    for (unsigned i = 0; i < servo_count; ++i) {\n        send_actuator_test_output(actuator_test_s::FUNCTION_SERVO1 + i, 0, true);\n    }\n#else\n    orb_unadvertise(*actuatorObj);\n    orb_unadvertise(*armObj);\n#endif\n}\n\nvoid send_actuator_test_output(int motorNum, float value, bool isArmed) {\n#if USE_ACTUATOR_TEST\n    actuator_test_s actuator_test{};\n    actuator_test.timestamp = hrt_absolute_time();\n    actuator_test.function = motorNum;\n    actuator_test.value = value;\n    actuator_test.action =\n        isArmed ? actuator_test_s::ACTION_RELEASE_CONTROL : actuator_test_s::ACTION_DO_CONTROL;\n    actuator_test.timeout_ms = 0;\n    actuator_test_pub.publish(actuator_test);\n#endif\n}\n\nvoid getMainDAPWMValues(int32_t* daPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS1\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS2\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS3\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS4\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS5\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS6\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS7\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS8\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        }\n    }\n}\n\nvoid getAUXDAPWMValues(int32_t* daPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS1\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS2\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS3\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS4\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS5\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS6\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS7\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS8\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        }\n    }\n}\n\nvoid getMainMinValues(int32_t* minPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN1\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN2\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN3\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN4\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN5\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN6\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN7\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN8\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        }\n    }\n}\n\nvoid getAUXMinValues(int32_t* minPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN1\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN2\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN3\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN4\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN5\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN6\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN7\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN8\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        }\n    }\n}\n\nvoid getMainMaxValues(int32_t* maxPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX1\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX2\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX3\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX4\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX5\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX6\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX7\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX8\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        }\n    }\n}\n\nvoid getAUXMaxValues(int32_t* maxPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX1\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX2\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX3\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX4\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX5\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX6\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX7\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX8\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        }\n    }\n}\n\nbool getSingleParamValue(const char* parameterName, float* paramValue_float) {\n\n    bool success = false;\n    MW_Param_Handle param_handle = PARAM_INVALID;\n    param_handle = param_find(parameterName);\n\n#if DEBUG\n    printf(\"Parameter name = %s.\\n\", parameterName);\n    if (param_handle != PARAM_INVALID) {\n        printf(\"Valid Parameter Handle = %u.\\n\", param_handle);\n    } else {\n        printf(\"Invalid Parameter Handle. \\n\");\n    }\n#endif\n\n    if (param_handle != PARAM_INVALID) {\n        if (!param_get(param_handle, paramValue_float)) {\n            success = true;\n#if DEBUG\n            printf(\"MW_SINGLE. Value = %4.4f\\n\", *paramValue_float);\n#endif\n        }\n    }\n\n    return success;\n}\n\nbool getIntegerParamValue(const char* parameterName, int32_t* paramValue_int) {\n\n    bool success = false;\n    MW_Param_Handle param_handle = PARAM_INVALID;\n    param_handle = param_find(parameterName);\n\n#if DEBUG\n    printf(\"Parameter name = %s.\\n\", parameterName);\n    if (param_handle != PARAM_INVALID) {\n        printf(\"Valid Parameter Handle = %u.\\n\", param_handle);\n    } else {\n        printf(\"Invalid Parameter Handle. \\n\");\n    }\n#endif\n\n    if (param_handle != PARAM_INVALID) {\n        if (!param_get(param_handle, paramValue_int)) {\n            success = true;\n#if DEBUG\n            printf(\"Value = %ld\\n\", *paramValue_int);\n#endif\n        }\n    }\n\n    return success;\n}\n"},{"name":"MW_PX4_TaskControl.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw/../../../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2018-2023 The MathWorks, Inc.\n *\n * File: MW_PX4_TaskControl.c\n *\n * Abstract:\n *  This file contains the main application for Simulink that is launched\n *  by PX4 stack at boot up. The main function spawns a new task and assigns\n *  the main function in ert_main.c as callback.\n *\n */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n/*Simulink model generated code specific headers*/\n\n#define MW_StringifyDefine(x) MW_StringifyDefineExpanded(x)\n#define MW_StringifyDefineExpanded(x) #x\n\n#define MW_StringifyDefineFunction(x, y) MW_StringifyDefineExpandedFunction(x, y)\n#define MW_StringifyDefineExpandedFunction(x, y) x##y\n\n#define MW_StringifyDefineX(x) MW_StringifyDefineExpandedX(x)\n#define MW_StringifyDefineExpandedX(x) x.##h\n\n#define MW_StringifyDefineTypesX(x) MW_StringifyDefineExpandedTypesX(x)\n#define MW_StringifyDefineExpandedTypesX(x) x##_types.h\n\n#define MW_StringifyDefinePrivateX(x) MW_StringifyDefineExpandedPrivateX(x)\n#define MW_StringifyDefineExpandedPrivateX(x) x##_private.h\n\n#include MW_StringifyDefine(MODEL.h)\n#include MW_StringifyDefine(MW_StringifyDefineTypesX(MODEL))\n#include MW_StringifyDefine(MW_StringifyDefinePrivateX(MODEL))\n\n#ifndef MW_PX4_DISABLE_MAVLINK\n#include \"mavlink_main.h\"\n#endif\n\n#define DEBUG 0\n\n#ifdef PIL\nextern int errorOccurred;\n#endif\n\nextern \"C\" __EXPORT int px4_simulink_app_main(int argc,\n                                              char* argv[]); /* sbcheck:ok:extern_c needed */\n\nextern struct hrt_call\n    BaseRate_HRT; /* Base-rate HRT-callback is used to post base-rate semaphore */\nextern int terminatingmodel;\nextern int baserate_sem_copy; /* used for checking HRT semaphore water-mark*/\nstatic bool g_baseRateLife =\n    false;                        /* global storage to contain the status of the px4_simulink_app */\nstatic int px4_simulink_app_task; /* Handle of daemon thread */\nchar mavlink_shell_started = 0;\n\n/* Print the correct usage. */\nvoid px4_app_usage(const char* reason) {\n    if (reason) {\n        PX4_INFO(\"px4_simulink_app : %s\\n\", reason);\n    }\n    errx(1, \"usage: px4_simulink_app {start|stop|status} [-p <additional params>]\\n\\n\");\n}\n\n#if defined(MW_PX4_DISABLE_MAVLINK)\nuint8_t buffer[100];\nMavlinkShell shell;\nvoid shellWait(MavlinkShell* shell_ptr, uint8_t buf[]) {\n    /*The shell wait here is to be used for commands which are expected to\n      return a few characters (a max. of 100 characters.)*/\n    int read = 0, readTotal = 0;\n    for (int i = 0; i < 100; i++) {\n        buf[i] = 0;\n    }\n    while (strstr((char*)buf, \"nsh>\") == NULL) {\n        read = shell_ptr->read(buf + readTotal, 100 - readTotal);\n        readTotal = readTotal + read;\n    }\n}\n#endif\n\nvoid px4_simulink_app_control_MAVLink() {\n    if (mavlink_shell_started == 0) {\n#ifdef MW_PX4_DISABLE_MAVLINK\n        shell.start();\n        shellWait(&shell, buffer);\n#endif\n    }\n\n#ifdef MW_PX4_DISABLE_MAVLINK\n    shell.write((uint8_t*)\"mavlink stop-all\\n\", sizeof(\"mavlink stop-all\\n\"));\n    usleep(100000);\n#endif\n}\n\nint px4_simulink_app_main(int argc, char* argv[]) {\n    if (argc < 2) {\n        px4_app_usage(\"missing command\");\n    }\n\n    if (!strcmp(argv[1], \"start\")) {\n        if (g_baseRateLife == false) {\n            /* Start the Simulink Tasks here */\n#if DEBUG\n            printf(\"px4_simulink_app : Starting the Simulink model\\n\");\n            fflush(stdout);\n#endif\n\n            /* Reset semaphore */\n            g_baseRateLife = true;\n            terminatingmodel =\n                0; // reset global variable. For more info on the rational behind this, please see:\n            // http://nuttx.org/doku.php?id=wiki:nxinternal:tasks-vs-processes#nuttx_flat-build_behavior\n\n            px4_simulink_app_task = px4_task_spawn_cmd(\n                \"px4_simulink_app_task\", /* Definition of px4_task_spawn_cmd :\n                                            C:\\px4\\Firmware\\src\\platforms\\nuttx\\px4_layer\\px4_nuttx_tasks.c\n                                          */\n                SCHED_DEFAULT,           /* For STM32 F4, NuttX has SCHED_DEFAULT as SCHED_RR */\n                SCHED_PRIORITY_MAX - 15, /* SCHED_PRIORITY_MAX: 255 */\n                2048, px4_simulink_app_task_main, (char* const*)NULL);\n\n        } else {\n            warnx(\"px4_simulink_app : Simulink model is already running\\n\");\n            fflush(stdout);\n        }\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    if (!strcmp(argv[1], \"stop\")) {\n        if (g_baseRateLife == true) {\n#ifdef PIL\n            errorOccurred = 1;\n#else\n            rtmSetErrorStatus(MW_StringifyDefineFunction(MODEL, _M), \"Module stopped by user\");\n            g_baseRateLife = false;\n            px4_sem_post(&baserateTaskSem);\n#endif\n#if DEBUG\n            PX4_INFO(\"px4_simulink_app : Exiting the Simulink model\\n\");\n#endif\n        } else {\n            warnx(\"px4_simulink_app : No Simulink model is running\\n\");\n        }\n\n        fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    if (!strcmp(argv[1], \"status\")) {\n        if (g_baseRateLife) {\n            PX4_INFO(\"px4_simulink_app : model is running\\n\");\n        } else {\n            PX4_INFO(\"px4_simulink_app : model is not started\\n\");\n        }\n        fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    px4_app_usage(\"unrecognized command\");\n#if defined(MW_PX4_NUTTX_BUILD)\n    exit(1);\n#else\n    return 1;\n#endif\n}\n\nvoid MW_PX4_Terminate() {\n    hrt_cancel(&BaseRate_HRT);\n    g_baseRateLife = false; // set status of PX4 Simulink App to stop\n\n#if defined(MW_HRT_CONSTRAINT) && (1 == MW_HRT_CONSTRAINT)\n    if (baserate_sem_copy > MW_SEM_WATERMARK) {\n        PX4_INFO(\"Hard real-time constraint violated, shutting down. Updating log file. \\n\");\n        FILE* fp_taskover_run = NULL;\n        char msg_watermark[100] = {0};\n        char msg_timestamp[50] = {0};\n        struct tm* sTm;\n        time_t now = time(NULL);\n        sTm = gmtime(&now);\n        sprintf(msg_watermark,\n                \"Base-rate semaphore exceeded water-mark value %d. Model base-rate = %.3f sec.\",\n                MW_SEM_WATERMARK, (float)MW_BASERATE_PERIOD);\n        strftime(msg_timestamp, sizeof(msg_timestamp), \"%Y-%m-%d %H:%M:%S\", sTm);\n        fp_taskover_run = fopen(\"/fs/microsd/log/task_overrun_log.txt\", \"a+\");\n        fprintf(fp_taskover_run, \"%s Timestamp=%s \\n\", msg_watermark, msg_timestamp);\n        fclose(fp_taskover_run);\n    }\n#endif\n\n#if DEBUG\n    PX4_INFO(\"px4_simulink_app : Received command to end the Simulink task \\n\");\n    fflush(stdout);\n#endif\n}\n\n// LocalWords:  HRT px nsh mavlink nuttx doku nxinternal Nutt SCHED fs microsd\n// LocalWords:  dev ACM tty\n"},{"name":"MW_ParameterRead.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw/../../../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2020 The MathWorks, Inc. */\n/* Reads the Parameter value and outputs the same.\n\n **/\n#include \"MW_ParameterRead.h\"\n\n//Below Macro can be enabled for debugging purposes\n#define DEBUG 0\n\n/*\n ****************************************************************************************************************************************************\n * Wrapper function For Initializing and getting the parameter handle\n * Input Params\n * isString  - Denotes if the Parameter is string or numeric\n * sampleTime - Sample time of the block\n \n * Output Params\n * param_handle  - Handle to the requested parameter.\n ****************************************************************************************************************************************************\n */\nMW_Param_Handle MW_Init_Param(void * ParameterName, uint8_T isString , double sampleTime)\n{\n\n    MW_Param_Handle param_handle = PARAM_INVALID;\n    char * parameterStr;\n    /* Check parameters */\n    if (0 == isString)\n    {\n        fprintf(stderr,\"Only string as ParameterName name is supported.\\n\");\n#if defined(MW_PX4_NUTTX_BUILD)\t\n\texit(1);\n#else\n\treturn 1;\n#endif\n    }\n    else\n    {\n        parameterStr = (char*)ParameterName;\n    }\n    param_handle = param_find(parameterStr);\n#if DEBUG\n    printf(\"In MW_Init_Param. Parameter name = %s.\\n\", parameterStr);\n#endif\n    if (param_handle != PARAM_INVALID)\n    {\n#if DEBUG\n        printf(\"In MW_Init_Param. Valid Parameter Handle = %u.\\n\", param_handle);\n#endif    \n    }\n    else\n    {\n#if DEBUG\n        printf(\"In MW_Init_Param. Invalid Parameter Handle. \\n\");\n#endif\n    }\n    return param_handle;\n}\n\n/*\n ****************************************************************************************************************************************************\n * Wrapper function For reading the parameter\n * Input Params\n * param_h  - Handle to the parameter requested\n * dataType - Data Type of the Parameter Requested\n * dataPtr - Pointer to the data, into which param_get is written to\n *\n * Output Params\n * status  - 0 for a valid Parameter Handle ; 1 for a valid Parameter Handle\n ****************************************************************************************************************************************************\n */\nbool MW_Param_Step(MW_Param_Handle param_h, MW_PARAM_DATA_TYPE dataType, void * dataPtr)\n{\n    //status - 0 for a valid Parameter Handle\n    //status - 1 for an invalid Parameter Handle\n    bool status = 1;\n    if (param_h != PARAM_INVALID)\n    {\n#if DEBUG\n        printf(\"In MW_Param_Step.Parameter Handle = %u.\\n\", param_h);\n#endif\n        int32_t  ReturnTmpInt;\n        float ReturnTmpFlt;\n        switch (dataType)\n        {\n            case MW_INT32:\n                if (!param_get(param_h, &ReturnTmpInt))\n                {\n                    *(int*)dataPtr  = ReturnTmpInt;\n#if DEBUG\n                    printf(\"In MW_Param_Step MW_INT32. Value = %ld\\n\", *(int*)dataPtr);\n#endif\n                }\n                break;\n            case MW_SINGLE:\n                if (!param_get(param_h, &ReturnTmpFlt))\n                {\n                    *(float*)dataPtr  = ReturnTmpFlt;\n#if DEBUG\n                    printf(\"In MW_Param_Step MW_SINGLE. Value = %4.4f\\n\", *(float*)dataPtr);\n#endif\n                }\n                break;\n            default:\n                break;\n        }\n         status = 0;\n    }\n    return status;\n}\n\nvoid MW_Param_terminate(void) \n{\n}\n"},{"name":"MW_custom_RTOS_header.h","type":"header","group":"other","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _MW_CUSTOM_RTOS_HEADER_H_\n#define _MW_CUSTOM_RTOS_HEADER_H_\n#define MW_BASERATE_PRIORITY           250\n#define MW_BASERATE_PERIOD             0.001\n#define MW_NUMBER_SUBRATES             1\n#define MW_NUMBER_APERIODIC_TASKS      0\n#define MW_IS_CONCURRENT               0\n#define MW_NUMBER_TIMER_DRIVEN_TASKS   0\n#define MW_HAS_MULTIPLE_RATES\n\nextern void exitFcn(int sig);\nextern void *terminateTask(void *arg);\nextern void *baseRateTask(void *arg);\nextern void *subrateTask(void *arg);\nextern pthread_t schedulerThread;\nextern pthread_t baseRateThread;\nextern pthread_t subRateThread[];\nextern px4_sem_t stopSem;\nextern px4_sem_t baserateTaskSem;\nextern px4_sem_t subrateTaskSem[];\nextern int taskId[];\nextern int subratePriority[];\n\n#endif\n\n#define MW_MAX_TASKNAME                16\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"MW_PX4_TaskControl.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE PX4 Pixhawk 6x\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERSIZE 1024\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_MAXCONTIGSAMPLES 10\n#define MW_CONNECTIONINFO_XCPONSERIAL_BAUDRATE codertarget.pixhawk.internal.getExternalModeBaudrate(hCS);\n#define MW_CONNECTIONINFO_XCPONSERIAL_COMPORT codertarget.pixhawk.internal.getExternalSerialPortName(hCS);\n#define MW_CONNECTIONINFO_XCPONSERIAL_VERBOSE 1\n#define MW_EXTMODE_CONFIGURATION XCP on Serial\n#define MW_RTOS NuttX\n#define MW_RTOSBASERATETASKPRIORITY 250\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_CMAKECONFIG px4_fmu-v6x_multicopter\n#define MW_CHANGECMAKECONFIG 48\n#define MW_AUTOMATIC_SERIAL_SCAN 1\n#define MW_COM_UPLOAD_STORAGE \n#define MW_NUTTX_SERIAL_PORT \n#define MW_ENABLE_HITL 0\n#define MW_SIMULATOR 1\n#define MW_CONNECTEDIOSERIALPORT /dev/ttyACM0\n#define MW_CONNECTEDIOSERIALPORT_CHECKBOX 1\n#define MW_CONNECTEDIOHOSTCOMPORT \n#define MW_SIMULINKIO_MODELTRANSPORTDATAFCN px4.internal.ConnectedIO.getConfigsetInfo\n#define MW_SIMULINKIO_SERVERDEPLOYFCN px4.internal.ConnectedIO.buildAndDeployPX4IOServer\n#define MW_CLOCKING_CPUCLOCKRATEMHZ 480\n#define MW_EXTSERIALPORT 0\n#define MW_EXTMODESERIALPORT_CHECKBOX 1\n#define MW_EXTMODEHOSTCOMPORT \n#define MW_PILSERIALPORT /dev/ttyACM0\n#define MW_PILSERIALPORT_CHECKBOX 1\n#define MW_PILHOSTCOMPORT COM6\n#define MW_I2C_BUS1SPEEDKHZ_INDEX 0\n#define MW_I2C_BUS2SPEEDKHZ_INDEX 0\n#define MW_I2C_BUS3SPEEDKHZ_INDEX 0\n#define MW_I2C_BUS1SPEEDKHZ 100\n#define MW_I2C_BUS2SPEEDKHZ 100\n#define MW_I2C_BUS3SPEEDKHZ 100\n#define MW_CAN_PORTINDEX 0\n#define MW_CAN_BAUDRATE_INDEX 2\n#define MW_CAN_BAUDRATE 500000\n#define MW_CAN_TESTMODE 0\n#define MW_ENABLEMAVLINKCHECKBOX 1\n#define MW_TTYACM0_BAUDRATE 27\n#define MW_TTYACM0_PARITY 0\n#define MW_TTYACM0_STOPBIT 0\n#define MW_TTYACM0_PORTMAP 48\n#define MW_TTYS0_BAUDRATE 27\n#define MW_TTYS0_PARITY 0\n#define MW_TTYS0_STOPBIT 0\n#define MW_TTYS0_PORTMAP 48\n#define MW_TTYS1_BAUDRATE 27\n#define MW_TTYS1_PARITY 0\n#define MW_TTYS1_STOPBIT 0\n#define MW_TTYS1_PORTMAP 48\n#define MW_TTYS1HWFLOWCONTROL_CHECKBOX 0\n#define MW_TTYS2_BAUDRATE 27\n#define MW_TTYS2_PARITY 0\n#define MW_TTYS2_STOPBIT 0\n#define MW_TTYS2_PORTMAP 48\n#define MW_TTYS2HWFLOWCONTROL_CHECKBOX 0\n#define MW_TTYS3_BAUDRATE 27\n#define MW_TTYS3_PARITY 0\n#define MW_TTYS3_STOPBIT 0\n#define MW_TTYS3_PORTMAP 48\n#define MW_TTYS3HWFLOWCONTROL_CHECKBOX 0\n#define MW_TTYS4_BAUDRATE 27\n#define MW_TTYS4_PARITY 0\n#define MW_TTYS4_STOPBIT 0\n#define MW_TTYS4_PORTMAP 48\n#define MW_TTYS5_BAUDRATE 27\n#define MW_TTYS5_PARITY 0\n#define MW_TTYS5_STOPBIT 0\n#define MW_TTYS5_PORTMAP 48\n#define MW_TTYS6_BAUDRATE 27\n#define MW_TTYS6_PARITY 0\n#define MW_TTYS6_STOPBIT 0\n#define MW_TTYS6_PORTMAP 48\n#define MW_TTYS7_BAUDRATE 27\n#define MW_TTYS7_PARITY 0\n#define MW_TTYS7_STOPBIT 0\n#define MW_TTYS7_PORTMAP 48\n#define MW_HRT_CONSTRAINT 0\n#define MW_SEM_WATERMARK 20\n#define MW_IOBLOCKSMODE deployed\n#define MW_DATAVERSION 2016.02\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"MW_uORB_Read.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw/../../../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2020 The MathWorks, Inc. */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"MW_uORB_Read.h\"\n\n#define DEBUG 0\n\nvoid uORB_read_initialize(orb_metadata_t* orbData, pollfd_t* eventStructObj) {\n    int fd = orb_subscribe(orbData);\n    eventStructObj->fd = fd;\n    eventStructObj->events = POLLIN;\n#if DEBUG\n    PX4_INFO(\"* Subscribed to topic: %s (fd = %d)*\\n\", orbData->o_name, fd);\n#endif\n}\n\nboolean_T uORB_read_step(orb_metadata_t* orbData,\n                         pollfd_t* eventStructObj,\n                         void* busData,\n                         boolean_T blockingMode,\n                         double blockingTimeout) {\n    boolean_T updated = 0;\n    bool isUpdated = false;\n    if (blockingMode) {\n#if defined(MW_PX4_NUTTX_BUILD)\n        int poll_ret = px4_poll(eventStructObj, 1, blockingTimeout);\n        static int error_counter = 0;\n        if (poll_ret == 0) {\n#if DEBUG\n            PX4_ERR(\"Got no data within %.9lf second\", blockingTimeout / 1000.0);\n#endif\n        } else if (poll_ret < 0) {\n            if (error_counter < 10 || error_counter % 500 == 0) {\n                /* use a counter to prevent flooding and slowing the system down */\n#if DEBUG\n                PX4_ERR(\"ERROR return value from poll(): %d\", poll_ret);\n#endif\n            }\n            error_counter++;\n\n        } else {\n            if (eventStructObj->revents & POLLIN) {\n                orb_copy(orbData, eventStructObj->fd, busData);\n                updated = 1;\n            }\n        }\n#elif defined(MW_PX4_POSIX_BUILD)\n        double count = 0;\n        /* The blocking timeout mentioned in the block mask is seconds but\n         * system object converts it to milliseconds*/\n        while (count < blockingTimeout) {\n            // Sleep for 1 ms and then again check if\n            // uORB topic is updated\n            usleep(1000);\n            orb_check(eventStructObj->fd, &isUpdated);\n            if (isUpdated) {\n                orb_copy(orbData, eventStructObj->fd, busData);\n                break;\n            }\n            count++;\n        }\n\n        updated = isUpdated ? 1 : 0;\n#endif\n    } else {\n        orb_check(eventStructObj->fd, &isUpdated);\n        if (isUpdated) {\n            orb_copy(orbData, eventStructObj->fd, busData);\n        }\n        updated = isUpdated ? 1 : 0;\n    }\n\n    return updated;\n}\n\nvoid uORB_read_terminate(const pollfd_t* eventStructObj) {\n    orb_unsubscribe(eventStructObj->fd);\n}\n"},{"name":"MW_uORB_Write.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw/../../../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018 The MathWorks, Inc. */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"MW_uORB_Write.h\"\n\n#define DEBUG 0\n\nvoid uORB_write_initialize(orb_metadata_t* orbData,\n                          orb_advert_t* orbAdvertObj,\n                          void* busData,\n                          int queueLen) {\n    *orbAdvertObj = orb_advertise_queue(orbData, busData, queueLen);    \n#if DEBUG\n    PX4_INFO(\"Started advertising topic: %s \\n\",  orbData->o_name);\n#endif    \n}\n\nvoid uORB_write_step(orb_metadata_t* orbData,\n                    orb_advert_t* orbAdvertObj,\n                    void* busData) {\n    orb_publish(orbData, *orbAdvertObj, busData);\n}\n\nvoid uORB_write_terminate(const orb_advert_t* orbAdvertObj) {\n    orb_unadvertise(*orbAdvertObj);\n}\n"},{"name":"MW_uORB_busstruct_conversion.h","type":"header","group":"other","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _MW_UORB_BUSSTRUCT_CONVERSION_H_\n#define _MW_UORB_BUSSTRUCT_CONVERSION_H_\n\n#include <uORB/topics/actuator_controls_status.h>\n#include <uORB/topics/actuator_motors.h>\n#include <uORB/topics/actuator_outputs.h>\n#include <uORB/topics/input_rc.h>\n#include <uORB/topics/vehicle_angular_velocity.h>\n#include <uORB/topics/vehicle_attitude_setpoint.h>\n#include <uORB/topics/vehicle_local_position.h>\n#include <uORB/topics/vehicle_local_position_setpoint.h>\n#include <uORB/topics/vehicle_odometry.h>\n#include <uORB/topics/vehicle_rates_setpoint.h>\n\ntypedef struct actuator_controls_status_s  px4_Bus_actuator_controls_status ;\ntypedef struct actuator_motors_s  px4_Bus_actuator_motors ;\ntypedef struct actuator_outputs_s  px4_Bus_actuator_outputs ;\ntypedef struct input_rc_s  px4_Bus_input_rc ;\ntypedef struct vehicle_angular_velocity_s  px4_Bus_vehicle_angular_velocity ;\ntypedef struct vehicle_attitude_setpoint_s  px4_Bus_vehicle_attitude_setpoint ;\ntypedef struct vehicle_local_position_s  px4_Bus_vehicle_local_position ;\ntypedef struct vehicle_local_position_setpoint_s  px4_Bus_vehicle_local_position_setpoint ;\ntypedef struct vehicle_odometry_s  px4_Bus_vehicle_odometry ;\ntypedef struct vehicle_rates_setpoint_s  px4_Bus_vehicle_rates_setpoint ;\n\n#endif\n"},{"name":"nuttxinitialize.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/work/code/FLIGHT_hexacopter_ert_rtw/../../../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2018-2022 The MathWorks, Inc.\n *\n * File: nuttxinitialize.c\n *\n * Abstract:\n *  This file contains RTOS thread creation functions\n *\n */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n\n/***********************************************\n * Added for Simulink Threads\n ************************************************/\npthread_attr_t attr;\nstatic baseRateInfo_t g_info;\nstruct sched_param g_sp;\n// extern volatile boolean_T runModel ;\n\n/***********************************************\n * Added for HRT\n ************************************************/\nstruct hrt_call BaseRate_HRT;\nint baserate_sem_copy;\n\n\n#define MW_RTOS_DEBUG 0\n\nbaseRateInfo_t EXT_sig_info;\nbaseRateInfo_t SDCard_sig_info;\nextern pthread_t backgroundThread;\nextern pthread_t loggingThread;\nextern void exitFcn(int sig);\n\nvoid setTaskPeriod(double periodInSeconds, int sigNo) {\n    timer_t timerId;\n    struct sigevent sev;\n    struct itimerspec its;\n    long stNanoSec;\n    int status;\n\n    /* Create a timer */\n    sev.sigev_notify = SIGEV_SIGNAL;\n    sev.sigev_signo = sigNo;\n    sev.sigev_value.sival_ptr = &timerId;\n    status = timer_create(CLOCK_REALTIME, &sev, &timerId);\n    CHECK_STATUS(status, 0, \"timer_create\");\n\n    /* Arm real-time scheduling timer */\n    stNanoSec = (long)(periodInSeconds * 1e9);\n    its.it_value.tv_sec = stNanoSec / 1000000000;\n    its.it_value.tv_nsec = stNanoSec % 1000000000;\n    its.it_interval.tv_sec = its.it_value.tv_sec;\n    its.it_interval.tv_nsec = its.it_value.tv_nsec;\n    status = timer_settime(timerId, 0, &its, NULL);\n    CHECK_STATUS(status, 0, \"timer_settime\");\n}\n\nvoid print_sem_value() {\n    PX4_WARN(\"Sem value = %d\", baserate_sem_copy);\n}\n\nstatic void Base_HRT_Callback(void* arg) {\n#ifndef PX4_CONNECTEDIO\n    int sem_value_check;\n\n    px4_sem_getvalue(&baserateTaskSem, &sem_value_check);\n    px4_sem_post(&baserateTaskSem);\n    baserate_sem_copy = sem_value_check;\n\n#endif\n}\n\n/* ---------------------------- */\n/* Externally visible functions */\n/* ---------------------------- */\nvoid myWaitForThisEvent(int sigNo) {\n    sigset_t sigMask;\n\n    sigemptyset(&sigMask);\n    sigaddset(&sigMask, sigNo);\n    sigwaitinfo(&sigMask, NULL);\n    //\tCHECK_STATUS_NOT(status, -1, \"sigwaitinfo\");\n}\n\nvoid MW_PX4_WaitForThisEvent(void* arg) {\n#ifdef EXT_MODE\n    /*pace External mode thread at 10 Hz*/\n    usleep(100000);\n\n    /*Signaling is causing issue when sample time is greater than 0.1\n     and model runs for more than 60 seconds. In this case model stop is not\n     stopping External mode. Using usleep for now to sleep the External Mode thread.*/\n\n    // baseRateInfo_t ext_info = *((baseRateInfo_t *)arg);\n    // static boolean_T isTaskPeriodSet = false;\n    // boolean_T rtmStopReq = rtmGetStopRequested(MW_StringifyDefineFunction(MODEL, _M));\n\n    // if (!isTaskPeriodSet) {\n    //     setTaskPeriod(ext_info.period, ext_info.sigNo);\n    //     isTaskPeriodSet = true;\n    // }\n\n    // if (!rtmStopReq) {\n    //     myWaitForThisEvent(ext_info.sigNo);\n    // }\n\n#endif\n}\n\nvoid myAddBlockForThisEvent(int sigNo) {\n    int status;\n    sigset_t sigMask;\n\n    sigemptyset(&sigMask);\n    sigaddset(&sigMask, sigNo);\n    status = pthread_sigmask(SIG_BLOCK, &sigMask, NULL);\n    CHECK_STATUS(status, 0, \"pthread_sigmask\");\n}\n\nvoid nuttxRTOSInit(double baseRatePeriod, int numSubrates) {\n    /* This is because in Daren's original Task callback ,a sleep was added before creating the\n     * threads*/\n    sleep(1);\n\n    int status;\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    size_t stackSize;\n    int baseRatePriority = MW_BASERATE_PRIORITY;\n#endif\n\n#ifdef MW_HAS_MULTIPLE_RATES\n    int i;\n    // char taskName[20];\n#endif\n#if defined(MW_PX4_NUTTX_BUILD)\n    sched_lock();\n#endif\n    // status = px4_sem_init(&termSem, 0, 0); PX4 PSP Dev: termSem no longer needed\n    // CHECK_STATUS(status, 0,\"px4_sem_init:termSem\");\n    status = px4_sem_init(&stopSem, 0, 0);\n    CHECK_STATUS(status, 0, \"px4_sem_init:stopSem\");\n    status = px4_sem_init(&baserateTaskSem, 0, 0);\n    CHECK_STATUS(status, 0, \"px4_sem_init:baserateTaskSem\");\n\n    // or you can use/check: _POSIX_PRIORITY_SCHEDULING\n    // _POSIX_THREAD_PRIORITY_SCHEDULING\n#if !defined(_POSIX_PRIORITY_SCHEDULING)\n    PX4_INFO(\"Priority scheduling is NOT supported by your system.\");\n    PX4_INFO(\"The generated code will not run correctly because your\");\n    PX4_INFO(\"model contains multiple rates and uses multi-tasking\");\n    PX4_INFO(\"code generation mode. You can only run the generated code\");\n    PX4_INFO(\"in single-tasking mode in your system. Open\");\n    PX4_INFO(\"Simulation -> Configuration Parameters -> Solver dialog\");\n    PX4_INFO(\"and set \\\"Tasking mode for periodic sample times\\\" parameter to SingleTasking.\");\n    PX4_INFO(\n        \"Re-build the Simulink model with the new settings and try executing the generated code \"\n        \"again.\");\n    fflush(stdout);\n    exit(-1);\n#endif\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    /* Set scheduling policy of the main thread to SCHED_FIFO */\n    g_sp.sched_priority = sched_get_priority_max(SCHED_FIFO) - 50;\n    status = sched_setscheduler(0, SCHED_FIFO, &g_sp);\n    CHECK_STATUS(status, 0, \"sched_setscheduler\");\n\n    /*Added init attribute and scheduler policy */\n    pthread_attr_init(&attr);\n    status = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n    CHECK_STATUS(status, 0, \"pthread_attr_setinheritsched\");\n    status = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedpolicy\");\n    // status = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n    // CHECK_STATUS(status, 0, \"pthread_attr_setdetachstate\");\n\n    /* PTHREAD_STACK_MIN is the minimum stack size required to start a thread */\n    stackSize = 8192 + PTHREAD_STACK_MIN;\n\n    /*added stack attribute back in */\n    status = pthread_attr_setstacksize(&attr, stackSize);\n    CHECK_STATUS(status, 0, \"pthread_attr_setstacksize\");\n#endif\n    /* set up info structure */\n    g_info.period = baseRatePeriod;\n    g_info.sigNo = BASERATE_TIMER_SIGNAL; // SIGRTMIN;\n\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"   stackSize = %d sched_priority = %d\", stackSize, g_sp.sched_priority);\n    PX4_INFO(\"   MW_BASERATE_PERIOD = %8.5f MW_BASERATE_PRIORITY = %d SIGRTMIN = 0x%08X\",\n             (double)baseRatePeriod, (int)baseRatePriority, SIGRTMIN);\n    PX4_INFO(\"   Init info.period = %8.5f sigNo = 0x%04X\", g_info.period, g_info.sigNo);\n    PX4_INFO(\"**creating the Base Rate thread before calling pthread_create**\");\n    fflush(stdout);\n#endif\n\n    /* Create the Base Rate Task here */\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = baseRatePriority;\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&baseRateThread, &attr, &baseRateTask, (void*)&g_info);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&baseRateThread, nullptr, &baseRateTask, (void*)&g_info);\n#endif\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"** Base Rate Task ID = %d with Priority = %d\\n\", baseRateThread, g_sp.sched_priority);\n    fflush(stdout);\n#endif\n\n/* Create sub-rate Tasks here */\n#ifdef MW_HAS_MULTIPLE_RATES\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"Creating sub-rate task threads\\n\");\n    PX4_INFO(\"Number of sub rate tasks: %d \\n\", MW_NUMBER_SUBRATES);\n    fflush(stdout);\n#endif\n\n    for (i = 0; i < MW_NUMBER_SUBRATES; i++) {\n        taskId[i] = i;\n        status = px4_sem_init(&subrateTaskSem[i], 0, 0);\n        CHECK_STATUS(status, 0, \"px4_sem_init: subrateTaskSem\");\n        // g_sp.sched_priority = MW_BASERATE_PRIORITY -40 + subratePriority[i] - 1;\n        g_sp.sched_priority = subratePriority[i];\n#if MW_RTOS_DEBUG\n        PX4_INFO(\"MW_SUBRATE_PRIORITY = %d \", (int)g_sp.sched_priority);\n#endif\n\n#if defined(MW_PX4_NUTTX_BUILD)\n        status = pthread_attr_setschedparam(&attr, &g_sp);\n        CHECK_STATUS(status, 0, \"pthread_attr_setschedparam\");\n        status = pthread_create(&subRateThread[i], &attr, &subrateTask, (void*)&taskId[i]);\n#elif defined(MW_PX4_POSIX_BUILD)\n        status = pthread_create(&subRateThread[i], nullptr, &subrateTask, (void*)&taskId[i]);\n#endif\n        CHECK_STATUS(status, 0, \"pthread_create\");\n\n#if MW_RTOS_DEBUG\n        PX4_INFO(\"** Sub Rate Task ID = %d \", subRateThread[i]);\n        fflush(stdout);\n#endif\n    }\n#endif // End of \"If Multiple Rates\" check\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = baseRatePriority;\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n#endif\n\n    /* Create the Scheduler Task here */\n    long stMicroSec;\n    stMicroSec = (long)(g_info.period * 1e6);\n    hrt_call_every(&BaseRate_HRT, stMicroSec, stMicroSec, Base_HRT_Callback,\n                   NULL); // timing callback to post base-rate semaphore\n\n/* Create the External Mode Task here */\n#ifdef EXT_MODE\n    /*---------- Creating EXT-mode Background Task ------------------*/\n    /* Setup signal info to block for EXT Mode */\n    EXT_sig_info.period = 0.1; // Sample rate at which we want Simulink to update w/ ext mode\n    EXT_sig_info.sigNo = SIGRTMIN;\n    /* Signaling the thread not working for low sample frequency*/\n    // sigemptyset(&EXT_sig_info.sigMask);\n    // sigaddset(&EXT_sig_info.sigMask, EXT_sig_info.sigNo);\n    // myAddBlockForThisEvent(EXT_sig_info.sigNo);\n\n    /* Setup thread for Custom Task */\n    fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = 40; // default is 100\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&backgroundThread, &attr, &backgroundTask, (void*)&EXT_sig_info);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&backgroundThread, nullptr, &backgroundTask, (void*)&EXT_sig_info);\n#endif\n    CHECK_STATUS(status, 0, \"EXT Mode Background pthread_create\");\n/*---------------------------------------------------------*/\n#endif\n\n/* Create the SD Card Task here */\n#if MAT_FILE\n    /*---------- Creating SD Card Background Task ------------------*/\n    fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = 40; // default is 100\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&loggingThread, &attr, &loggingThreadFcn, NULL);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&loggingThread, nullptr, &loggingThreadFcn, NULL);\n#endif\n    CHECK_STATUS(status, 0, \"SD Card Background pthread_create\");\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"** SD Card Background ID = %d \", loggingThread);\n    fflush(stdout);\n#endif\n\n/*---------------------------------------------------------*/\n#endif\n\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"px4_simulink_app : Created Simulink task threads successfully\\n\");\n    fflush(stdout);\n#endif\n#if defined(MW_PX4_NUTTX_BUILD)\n    sched_unlock();\n#endif\n}\n\n/*---------- Following function is added as a workaround for uavcan module build failure -------------\n  Original definition of the function is in the file <px4dir>\\Firmware\\Boards\\px4\\fmu-v5\\src\\can.c*/\n#if defined(MW_PX4_NUTTX_BUILD) && defined(CONFIG_CAN) && defined(UAVCAN_NUM_IFACES_RUNTIME)\n__EXPORT\nuint16_t board_get_can_interfaces(void)\n{\n\tuint16_t enabled_interfaces = 0x7;\n\n\tif (!PX4_MFT_HW_SUPPORTED(PX4_MFT_CAN2)) {\n\t\tenabled_interfaces &= ~(1 << 1);\n\t}\n\n\tif (!PX4_MFT_HW_SUPPORTED(PX4_MFT_CAN3)) {\n\t\tenabled_interfaces &= ~(1 << 2);\n\t}\n\n\treturn enabled_interfaces;\n }\n#endif\n/*---------------------------------------------------------*/\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};