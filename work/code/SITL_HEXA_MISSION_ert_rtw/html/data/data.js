var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"SITL_HEXA_MISSION","ref":false,"files":[{"name":"ert_main.cpp","type":"source","group":"main","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Main file","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: ert_main.cpp\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include \"SITL_HEXA_MISSION.h\"\r\n#include \"SITL_HEXA_MISSION_private.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"limits.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"MW_PX4_TaskControl.h\"\r\n#include \"nuttxinitialize.h\"\r\n#define UNUSED(x)                      x = x\r\n#define NAMELEN                        16\r\n\r\n// Function prototype declaration\r\nvoid exitFcn(int sig);\r\nvoid *terminateTask(void *arg);\r\nvoid *baseRateTask(void *arg);\r\nvoid *subrateTask(void *arg);\r\nvolatile boolean_T stopRequested = false;\r\nvolatile boolean_T runModel = true;\r\npx4_sem_t stopSem;\r\npx4_sem_t baserateTaskSem;\r\npthread_t schedulerThread;\r\npthread_t baseRateThread;\r\nvoid *threadJoinStatus;\r\nint terminatingmodel = 0;\r\nvoid *baseRateTask(void *arg)\r\n{\r\n  runModel = (rtmGetErrorStatus(SITL_HEXA_MISSION_M) == (NULL));\r\n  while (runModel) {\r\n    px4_sem_wait(&baserateTaskSem);\r\n    SITL_HEXA_MISSION_step();\r\n\r\n    // Get model outputs here\r\n    stopRequested = !((rtmGetErrorStatus(SITL_HEXA_MISSION_M) == (NULL)));\r\n  }\r\n\r\n  runModel = 0;\r\n  terminateTask(arg);\r\n  pthread_exit((void *)0);\r\n  return NULL;\r\n}\r\n\r\nvoid exitFcn(int sig)\r\n{\r\n  UNUSED(sig);\r\n  rtmSetErrorStatus(SITL_HEXA_MISSION_M, \"stopping the model\");\r\n  runModel = 0;\r\n}\r\n\r\nvoid *terminateTask(void *arg)\r\n{\r\n  UNUSED(arg);\r\n  terminatingmodel = 1;\r\n\r\n  {\r\n    runModel = 0;\r\n  }\r\n\r\n  MW_PX4_Terminate();\r\n\r\n  // Terminate model\r\n  SITL_HEXA_MISSION_terminate();\r\n  px4_sem_post(&stopSem);\r\n  return NULL;\r\n}\r\n\r\nint px4_simulink_app_task_main (int argc, char *argv[])\r\n{\r\n  rtmSetErrorStatus(SITL_HEXA_MISSION_M, 0);\r\n\r\n  // Initialize model\r\n  SITL_HEXA_MISSION_initialize();\r\n\r\n  // Call RTOS Initialization function\r\n  nuttxRTOSInit(0.004, 0);\r\n\r\n  // Wait for stop semaphore\r\n  px4_sem_wait(&stopSem);\r\n\r\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\r\n\r\n  {\r\n    int i;\r\n    for (i=0; i < MW_NUMBER_TIMER_DRIVEN_TASKS; i++) {\r\n      CHECK_STATUS(px4_sem_destroy(&timerTaskSem[i]), 0, \"px4_sem_destroy\");\r\n    }\r\n  }\r\n\r\n#endif\r\n\r\n  return 0;\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"SITL_HEXA_MISSION.cpp","type":"source","group":"model","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: SITL_HEXA_MISSION.cpp\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#include \"SITL_HEXA_MISSION.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"Navigation.h\"\r\n#include \"mc_pos_controller.h\"\r\n#include \"rt_sys_SITL_HEXA_MISSION_0.h\"\r\n#include <math.h>\r\n#include \"mc_att_controller.h\"\r\n#include \"mc_rate_controller.h\"\r\n#include \"actuatorOutputs.h\"\r\n#include \"rt_sys_SITL_HEXA_MISSION_2.h\"\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#include \"rt_defines.h\"\r\n#include \"SITL_HEXA_MISSION_private.h\"\r\n\r\n// Block signals (default storage)\r\nB_SITL_HEXA_MISSION_T SITL_HEXA_MISSION_B;\r\n\r\n// Block states (default storage)\r\nDW_SITL_HEXA_MISSION_T SITL_HEXA_MISSION_DW;\r\n\r\n// Real-time model\r\nRT_MODEL_SITL_HEXA_MISSION_T SITL_HEXA_MISSION_M_ = RT_MODEL_SITL_HEXA_MISSION_T\r\n  ();\r\nRT_MODEL_SITL_HEXA_MISSION_T *const SITL_HEXA_MISSION_M = &SITL_HEXA_MISSION_M_;\r\n\r\n// Forward declaration for local functions\r\nstatic real_T SITL_HEXA_MISSION_rt_atan2d_snf_i(real_T u0, real_T u1);\r\nstatic real_T SITL_HEXA_MISSION_rt_atan2d_snf_i(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\r\n    y = (rtNaN);\r\n  } else if (rtIsInf(u0) && rtIsInf(u1)) {\r\n    if (u0 > 0.0) {\r\n      SITL_HEXA_MISSION_B.i_p = 1;\r\n    } else {\r\n      SITL_HEXA_MISSION_B.i_p = -1;\r\n    }\r\n\r\n    if (u1 > 0.0) {\r\n      SITL_HEXA_MISSION_B.i1_cv = 1;\r\n    } else {\r\n      SITL_HEXA_MISSION_B.i1_cv = -1;\r\n    }\r\n\r\n    y = atan2(static_cast<real_T>(SITL_HEXA_MISSION_B.i_p), static_cast<real_T>\r\n              (SITL_HEXA_MISSION_B.i1_cv));\r\n  } else if (u1 == 0.0) {\r\n    if (u0 > 0.0) {\r\n      y = RT_PI / 2.0;\r\n    } else if (u0 < 0.0) {\r\n      y = -(RT_PI / 2.0);\r\n    } else {\r\n      y = 0.0;\r\n    }\r\n  } else {\r\n    y = atan2(u0, u1);\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n// Model step function\r\nvoid SITL_HEXA_MISSION_step(void)\r\n{\r\n  // MATLABSystem: '<S605>/SourceBlock'\r\n  SITL_HEXA_MISSION_B.b_varargout_1 = uORB_read_step\r\n    (SITL_HEXA_MISSION_DW.obj_m.orbMetadataObj,\r\n     &SITL_HEXA_MISSION_DW.obj_m.eventStructObj, &SITL_HEXA_MISSION_B.r_mb,\r\n     false, 1.0);\r\n\r\n  // Outputs for Enabled SubSystem: '<S605>/Enabled Subsystem' incorporates:\r\n  //   EnablePort: '<S609>/Enable'\r\n\r\n  // Start for MATLABSystem: '<S605>/SourceBlock'\r\n  if (SITL_HEXA_MISSION_B.b_varargout_1) {\r\n    // SignalConversion generated from: '<S609>/In1'\r\n    SITL_HEXA_MISSION_B.In1_c = SITL_HEXA_MISSION_B.r_mb;\r\n  }\r\n\r\n  // End of Outputs for SubSystem: '<S605>/Enabled Subsystem'\r\n\r\n  // DataTypeConversion: '<S4>/Data Type Conversion1'\r\n  SITL_HEXA_MISSION_B.DataTypeConversion1[0] = SITL_HEXA_MISSION_B.In1_c.x;\r\n  SITL_HEXA_MISSION_B.DataTypeConversion1[1] = SITL_HEXA_MISSION_B.In1_c.y;\r\n  SITL_HEXA_MISSION_B.DataTypeConversion1[2] = SITL_HEXA_MISSION_B.In1_c.z;\r\n  SITL_HEXA_MISSION_B.DataTypeConversion1[3] = SITL_HEXA_MISSION_B.In1_c.vx;\r\n  SITL_HEXA_MISSION_B.DataTypeConversion1[4] = SITL_HEXA_MISSION_B.In1_c.vy;\r\n  SITL_HEXA_MISSION_B.DataTypeConversion1[5] = SITL_HEXA_MISSION_B.In1_c.vz;\r\n  SITL_HEXA_MISSION_B.DataTypeConversion1[6] = SITL_HEXA_MISSION_B.In1_c.heading;\r\n\r\n  // Outputs for Atomic SubSystem: '<Root>/Navigation'\r\n  SITL_HEXA_MISSION_Navigation();\r\n\r\n  // End of Outputs for SubSystem: '<Root>/Navigation'\r\n\r\n  // MATLABSystem: '<S604>/SourceBlock'\r\n  SITL_HEXA_MISSION_B.b_varargout_1 = uORB_read_step\r\n    (SITL_HEXA_MISSION_DW.obj_gv.orbMetadataObj,\r\n     &SITL_HEXA_MISSION_DW.obj_gv.eventStructObj, &SITL_HEXA_MISSION_B.r1_c,\r\n     false, 1.0);\r\n\r\n  // Outputs for Enabled SubSystem: '<S604>/Enabled Subsystem' incorporates:\r\n  //   EnablePort: '<S608>/Enable'\r\n\r\n  // Start for MATLABSystem: '<S604>/SourceBlock'\r\n  if (SITL_HEXA_MISSION_B.b_varargout_1) {\r\n    // SignalConversion generated from: '<S608>/In1'\r\n    SITL_HEXA_MISSION_B.In1_m = SITL_HEXA_MISSION_B.r1_c;\r\n  }\r\n\r\n  // End of Outputs for SubSystem: '<S604>/Enabled Subsystem'\r\n\r\n  // DataTypeConversion: '<S4>/Data Type Conversion' incorporates:\r\n  //   Switch: '<S9>/Switch'\r\n\r\n  SITL_HEXA_MISSION_B.rtb_Switch_j_idx_0 = SITL_HEXA_MISSION_B.In1_m.q[0];\r\n  SITL_HEXA_MISSION_B.rtb_Switch_j_idx_1 = SITL_HEXA_MISSION_B.In1_m.q[1];\r\n  SITL_HEXA_MISSION_B.rtb_Switch_j_idx_2 = SITL_HEXA_MISSION_B.In1_m.q[2];\r\n  SITL_HEXA_MISSION_B.rtb_Switch_j_idx_3 = SITL_HEXA_MISSION_B.In1_m.q[3];\r\n\r\n  // Switch: '<S9>/Switch' incorporates:\r\n  //   Constant: '<S9>/Constant'\r\n  //   DataTypeConversion: '<S4>/Data Type Conversion'\r\n  //   Product: '<S20>/Product'\r\n  //   Product: '<S20>/Product1'\r\n  //   Product: '<S20>/Product2'\r\n  //   Product: '<S20>/Product3'\r\n  //   Sum: '<S20>/Sum'\r\n\r\n  if (!(((static_cast<real_T>(SITL_HEXA_MISSION_B.In1_m.q[0]) *\r\n          SITL_HEXA_MISSION_B.In1_m.q[0] + static_cast<real_T>\r\n          (SITL_HEXA_MISSION_B.In1_m.q[1]) * SITL_HEXA_MISSION_B.In1_m.q[1]) +\r\n         static_cast<real_T>(SITL_HEXA_MISSION_B.In1_m.q[2]) *\r\n         SITL_HEXA_MISSION_B.In1_m.q[2]) + static_cast<real_T>\r\n        (SITL_HEXA_MISSION_B.In1_m.q[3]) * SITL_HEXA_MISSION_B.In1_m.q[3] >\r\n        SITL_HEXA_MISSION_P.Switch_Threshold_l)) {\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_0 =\r\n      SITL_HEXA_MISSION_P.Constant_Value_im[0];\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_1 =\r\n      SITL_HEXA_MISSION_P.Constant_Value_im[1];\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_2 =\r\n      SITL_HEXA_MISSION_P.Constant_Value_im[2];\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_3 =\r\n      SITL_HEXA_MISSION_P.Constant_Value_im[3];\r\n  }\r\n\r\n  // End of Switch: '<S9>/Switch'\r\n\r\n  // MATLABSystem: '<S602>/SourceBlock'\r\n  SITL_HEXA_MISSION_B.b_varargout_1 = uORB_read_step\r\n    (SITL_HEXA_MISSION_DW.obj_p.orbMetadataObj,\r\n     &SITL_HEXA_MISSION_DW.obj_p.eventStructObj, &SITL_HEXA_MISSION_B.r2_k,\r\n     false, 1.0);\r\n\r\n  // Outputs for Enabled SubSystem: '<S602>/Enabled Subsystem' incorporates:\r\n  //   EnablePort: '<S606>/Enable'\r\n\r\n  // Start for MATLABSystem: '<S602>/SourceBlock'\r\n  if (SITL_HEXA_MISSION_B.b_varargout_1) {\r\n    // SignalConversion generated from: '<S606>/In1'\r\n    SITL_HEXA_MISSION_B.In1_l = SITL_HEXA_MISSION_B.r2_k;\r\n  }\r\n\r\n  // End of Outputs for SubSystem: '<S602>/Enabled Subsystem'\r\n\r\n  // DataTypeConversion: '<S4>/Data Type Conversion2'\r\n  SITL_HEXA_MISSION_B.DataTypeConversion2[0] = SITL_HEXA_MISSION_B.In1_l.xyz[0];\r\n  SITL_HEXA_MISSION_B.DataTypeConversion2[1] = SITL_HEXA_MISSION_B.In1_l.xyz[1];\r\n  SITL_HEXA_MISSION_B.DataTypeConversion2[2] = SITL_HEXA_MISSION_B.In1_l.xyz[2];\r\n\r\n  // Gain: '<S5>/Gain'\r\n  SITL_HEXA_MISSION_B.desiredZ = SITL_HEXA_MISSION_P.Gain_Gain_c *\r\n    SITL_HEXA_MISSION_B.Merge[2];\r\n\r\n  // MATLABSystem: '<S603>/SourceBlock'\r\n  SITL_HEXA_MISSION_B.b_varargout_1 = uORB_read_step\r\n    (SITL_HEXA_MISSION_DW.obj_d0.orbMetadataObj,\r\n     &SITL_HEXA_MISSION_DW.obj_d0.eventStructObj, &SITL_HEXA_MISSION_B.r3, false,\r\n     1.0);\r\n\r\n  // Outputs for Enabled SubSystem: '<S603>/Enabled Subsystem' incorporates:\r\n  //   EnablePort: '<S607>/Enable'\r\n\r\n  // Start for MATLABSystem: '<S603>/SourceBlock'\r\n  if (SITL_HEXA_MISSION_B.b_varargout_1) {\r\n    // SignalConversion generated from: '<S607>/In1'\r\n    SITL_HEXA_MISSION_B.In1_b = SITL_HEXA_MISSION_B.r3;\r\n  }\r\n\r\n  // End of Outputs for SubSystem: '<S603>/Enabled Subsystem'\r\n\r\n  // Outputs for Enabled SubSystem: '<S5>/mc_pos_controller'\r\n  SITL_HEXA_MISSION_mc_pos_controller();\r\n\r\n  // End of Outputs for SubSystem: '<S5>/mc_pos_controller'\r\n  SITL_HEXA_MISSION_PX4Timestamp(&SITL_HEXA_MISSION_B.PX4Timestamp_pn);\r\n\r\n  // Sqrt: '<S27>/sqrt' incorporates:\r\n  //   Product: '<S28>/Product'\r\n  //   Product: '<S28>/Product1'\r\n  //   Product: '<S28>/Product2'\r\n  //   Product: '<S28>/Product3'\r\n  //   Sum: '<S28>/Sum'\r\n\r\n  SITL_HEXA_MISSION_B.Sum_l = sqrt(((SITL_HEXA_MISSION_B.rtb_Switch_j_idx_0 *\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_0 +\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_1 *\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_1) +\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_2 *\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_2) +\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_3 *\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_3);\r\n\r\n  // Product: '<S22>/Product'\r\n  SITL_HEXA_MISSION_B.rtb_Switch_j_idx_0 /= SITL_HEXA_MISSION_B.Sum_l;\r\n\r\n  // Product: '<S22>/Product1'\r\n  SITL_HEXA_MISSION_B.rtb_Switch_j_idx_1 /= SITL_HEXA_MISSION_B.Sum_l;\r\n\r\n  // Product: '<S22>/Product2'\r\n  SITL_HEXA_MISSION_B.rtb_Switch_j_idx_2 /= SITL_HEXA_MISSION_B.Sum_l;\r\n\r\n  // Product: '<S22>/Product3'\r\n  SITL_HEXA_MISSION_B.Sum_l = SITL_HEXA_MISSION_B.rtb_Switch_j_idx_3 /\r\n    SITL_HEXA_MISSION_B.Sum_l;\r\n\r\n  // Fcn: '<S10>/fcn2' incorporates:\r\n  //   Fcn: '<S10>/fcn5'\r\n\r\n  SITL_HEXA_MISSION_B.rtb_Switch_j_idx_3 =\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_0 *\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_0;\r\n  SITL_HEXA_MISSION_B.VectorConcatenate_tmp =\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_1 *\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_1;\r\n  SITL_HEXA_MISSION_B.VectorConcatenate_tmp_c =\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_2 *\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_2;\r\n  SITL_HEXA_MISSION_B.VectorConcatenate_tmp_b = SITL_HEXA_MISSION_B.Sum_l *\r\n    SITL_HEXA_MISSION_B.Sum_l;\r\n\r\n  // Trigonometry: '<S21>/Trigonometric Function1' incorporates:\r\n  //   Fcn: '<S10>/fcn1'\r\n  //   Fcn: '<S10>/fcn2'\r\n\r\n  SITL_HEXA_MISSION_B.VectorConcatenate[0] = SITL_HEXA_MISSION_rt_atan2d_snf_i\r\n    ((SITL_HEXA_MISSION_B.rtb_Switch_j_idx_1 *\r\n      SITL_HEXA_MISSION_B.rtb_Switch_j_idx_2 +\r\n      SITL_HEXA_MISSION_B.rtb_Switch_j_idx_0 * SITL_HEXA_MISSION_B.Sum_l) * 2.0,\r\n     ((SITL_HEXA_MISSION_B.rtb_Switch_j_idx_3 +\r\n       SITL_HEXA_MISSION_B.VectorConcatenate_tmp) -\r\n      SITL_HEXA_MISSION_B.VectorConcatenate_tmp_c) -\r\n     SITL_HEXA_MISSION_B.VectorConcatenate_tmp_b);\r\n\r\n  // Fcn: '<S10>/fcn3'\r\n  SITL_HEXA_MISSION_B.fcn3 = (SITL_HEXA_MISSION_B.rtb_Switch_j_idx_1 *\r\n    SITL_HEXA_MISSION_B.Sum_l - SITL_HEXA_MISSION_B.rtb_Switch_j_idx_0 *\r\n    SITL_HEXA_MISSION_B.rtb_Switch_j_idx_2) * -2.0;\r\n\r\n  // If: '<S23>/If' incorporates:\r\n  //   Constant: '<S24>/Constant'\r\n  //   Constant: '<S25>/Constant'\r\n  //   Trigonometry: '<S21>/trigFcn'\r\n\r\n  if (SITL_HEXA_MISSION_B.fcn3 > 1.0) {\r\n    SITL_HEXA_MISSION_B.fcn3 = SITL_HEXA_MISSION_P.Constant_Value_be;\r\n  } else if (SITL_HEXA_MISSION_B.fcn3 < -1.0) {\r\n    SITL_HEXA_MISSION_B.fcn3 = SITL_HEXA_MISSION_P.Constant_Value_m;\r\n  }\r\n\r\n  if (SITL_HEXA_MISSION_B.fcn3 > 1.0) {\r\n    SITL_HEXA_MISSION_B.fcn3 = 1.0;\r\n  } else if (SITL_HEXA_MISSION_B.fcn3 < -1.0) {\r\n    SITL_HEXA_MISSION_B.fcn3 = -1.0;\r\n  }\r\n\r\n  // End of If: '<S23>/If'\r\n\r\n  // Trigonometry: '<S21>/trigFcn'\r\n  SITL_HEXA_MISSION_B.VectorConcatenate[1] = asin(SITL_HEXA_MISSION_B.fcn3);\r\n\r\n  // Trigonometry: '<S21>/Trigonometric Function3' incorporates:\r\n  //   Fcn: '<S10>/fcn4'\r\n  //   Fcn: '<S10>/fcn5'\r\n\r\n  SITL_HEXA_MISSION_B.VectorConcatenate[2] = SITL_HEXA_MISSION_rt_atan2d_snf_i\r\n    ((SITL_HEXA_MISSION_B.rtb_Switch_j_idx_2 * SITL_HEXA_MISSION_B.Sum_l +\r\n      SITL_HEXA_MISSION_B.rtb_Switch_j_idx_0 *\r\n      SITL_HEXA_MISSION_B.rtb_Switch_j_idx_1) * 2.0,\r\n     ((SITL_HEXA_MISSION_B.rtb_Switch_j_idx_3 -\r\n       SITL_HEXA_MISSION_B.VectorConcatenate_tmp) -\r\n      SITL_HEXA_MISSION_B.VectorConcatenate_tmp_c) +\r\n     SITL_HEXA_MISSION_B.VectorConcatenate_tmp_b);\r\n\r\n  // Outputs for Enabled SubSystem: '<S5>/mc_att_controller'\r\n  SITL_HEXA_MISSION_mc_att_controller();\r\n\r\n  // End of Outputs for SubSystem: '<S5>/mc_att_controller'\r\n\r\n  // BusAssignment: '<S8>/Bus Assignment' incorporates:\r\n  //   Constant: '<S18>/Constant'\r\n\r\n  SITL_HEXA_MISSION_B.BusAssignment_h4 = SITL_HEXA_MISSION_P.Constant_Value_j;\r\n\r\n  // BusAssignment: '<S8>/Bus Assignment' incorporates:\r\n  //   Constant: '<S8>/thrust_sp_bX'\r\n  //   Constant: '<S8>/thrust_sp_bY'\r\n  //   DataTypeConversion: '<S8>/Data Type Conversion'\r\n  //   DataTypeConversion: '<S8>/Data Type Conversion1'\r\n  //   DataTypeConversion: '<S8>/Data Type Conversion2'\r\n  //   DataTypeConversion: '<S8>/Data Type Conversion3'\r\n  //   MATLABSystem: '<S8>/PX4 Timestamp'\r\n\r\n  SITL_HEXA_MISSION_B.BusAssignment_h4.timestamp =\r\n    SITL_HEXA_MISSION_B.PX4Timestamp_pn.PX4Timestamp;\r\n  SITL_HEXA_MISSION_B.BusAssignment_h4.roll = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.Saturation_e);\r\n  SITL_HEXA_MISSION_B.BusAssignment_h4.pitch = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.ProportionalGain);\r\n  SITL_HEXA_MISSION_B.BusAssignment_h4.yaw = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.ProportionalGain_a);\r\n  SITL_HEXA_MISSION_B.BusAssignment_h4.thrust_body[0] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.thrust_sp_bX_Value_m);\r\n  SITL_HEXA_MISSION_B.BusAssignment_h4.thrust_body[1] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.thrust_sp_bY_Value_m);\r\n  SITL_HEXA_MISSION_B.BusAssignment_h4.thrust_body[2] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.Saturation_d);\r\n\r\n  // MATLABSystem: '<S19>/SinkBlock' incorporates:\r\n  //   BusAssignment: '<S8>/Bus Assignment'\r\n\r\n  uORB_write_step(SITL_HEXA_MISSION_DW.obj_dz.orbMetadataObj,\r\n                  &SITL_HEXA_MISSION_DW.obj_dz.orbAdvertiseObj,\r\n                  &SITL_HEXA_MISSION_B.BusAssignment_h4);\r\n\r\n  // Outputs for Enabled SubSystem: '<S5>/mc_rate_controller'\r\n  SITL_HEXA_MISSION_mc_rate_controller();\r\n\r\n  // End of Outputs for SubSystem: '<S5>/mc_rate_controller'\r\n\r\n  // Outputs for Atomic SubSystem: '<Root>/actuatorOutputs'\r\n  SITL_HEXA_MISSION_actuatorOutputs();\r\n\r\n  // End of Outputs for SubSystem: '<Root>/actuatorOutputs'\r\n  SITL_HEXA_MISSION_PX4Timestamp(&SITL_HEXA_MISSION_B.PX4Timestamp_p);\r\n\r\n  // BusAssignment: '<S7>/Bus Assignment' incorporates:\r\n  //   Constant: '<S16>/Constant'\r\n\r\n  SITL_HEXA_MISSION_B.BusAssignment_a = SITL_HEXA_MISSION_P.Constant_Value_l;\r\n\r\n  // BusAssignment: '<S7>/Bus Assignment' incorporates:\r\n  //   Constant: '<S7>/Constant'\r\n  //   DataTypeConversion: '<S7>/Data Type Conversion'\r\n  //   DataTypeConversion: '<S7>/Data Type Conversion1'\r\n  //   DataTypeConversion: '<S7>/Data Type Conversion2'\r\n  //   DataTypeConversion: '<S7>/Data Type Conversion3'\r\n  //   DataTypeConversion: '<S7>/Data Type Conversion4'\r\n  //   DataTypeConversion: '<S7>/Data Type Conversion5'\r\n  //   DataTypeConversion: '<S7>/Data Type Conversion6'\r\n  //   DataTypeConversion: '<S7>/Data Type Conversion7'\r\n  //   Gain: '<S5>/Gain1'\r\n  //   Gain: '<S5>/Gain2'\r\n  //   MATLABSystem: '<S7>/PX4 Timestamp'\r\n\r\n  SITL_HEXA_MISSION_B.BusAssignment_a.timestamp =\r\n    SITL_HEXA_MISSION_B.PX4Timestamp_p.PX4Timestamp;\r\n  SITL_HEXA_MISSION_B.BusAssignment_a.x = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.Merge[0]);\r\n  SITL_HEXA_MISSION_B.BusAssignment_a.y = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.Merge[1]);\r\n  SITL_HEXA_MISSION_B.BusAssignment_a.z = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.Gain1_Gain_j * SITL_HEXA_MISSION_B.desiredZ);\r\n  SITL_HEXA_MISSION_B.BusAssignment_a.vx = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.Saturation_bi[0]);\r\n  SITL_HEXA_MISSION_B.BusAssignment_a.vy = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.Saturation_bi[1]);\r\n  SITL_HEXA_MISSION_B.BusAssignment_a.vz = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.Gain2_Gain_n * SITL_HEXA_MISSION_B.Saturation_o);\r\n  SITL_HEXA_MISSION_B.BusAssignment_a.yaw = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.Merge[3]);\r\n  SITL_HEXA_MISSION_B.BusAssignment_a.thrust[0] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.Constant_Value_go);\r\n  SITL_HEXA_MISSION_B.BusAssignment_a.thrust[1] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.Constant_Value_go);\r\n  SITL_HEXA_MISSION_B.BusAssignment_a.thrust[2] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.Saturation_d);\r\n  SITL_HEXA_MISSION_SinkBlock(&SITL_HEXA_MISSION_B.BusAssignment_a,\r\n    &SITL_HEXA_MISSION_DW.SinkBlock_m);\r\n  SITL_HEXA_MISSION_PX4Timestamp(&SITL_HEXA_MISSION_B.PX4Timestamp);\r\n\r\n  // BusAssignment: '<S6>/Bus Assignment' incorporates:\r\n  //   Constant: '<S14>/Constant'\r\n\r\n  SITL_HEXA_MISSION_B.BusAssignment_h = SITL_HEXA_MISSION_P.Constant_Value_b;\r\n\r\n  // BusAssignment: '<S6>/Bus Assignment' incorporates:\r\n  //   Constant: '<S6>/thrust_sp_bX'\r\n  //   Constant: '<S6>/thrust_sp_bY'\r\n  //   DataTypeConversion: '<S6>/Data Type Conversion'\r\n  //   DataTypeConversion: '<S6>/Data Type Conversion1'\r\n  //   DataTypeConversion: '<S6>/Data Type Conversion2'\r\n  //   DataTypeConversion: '<S6>/Data Type Conversion3'\r\n  //   MATLABSystem: '<S6>/PX4 Timestamp'\r\n\r\n  SITL_HEXA_MISSION_B.BusAssignment_h.timestamp =\r\n    SITL_HEXA_MISSION_B.PX4Timestamp.PX4Timestamp;\r\n  SITL_HEXA_MISSION_B.BusAssignment_h.roll_body = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.Saturation_n[1]);\r\n  SITL_HEXA_MISSION_B.BusAssignment_h.pitch_body = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.Gain1);\r\n  SITL_HEXA_MISSION_B.BusAssignment_h.yaw_body = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.Merge[3]);\r\n  SITL_HEXA_MISSION_B.BusAssignment_h.thrust_body[0] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.thrust_sp_bX_Value);\r\n  SITL_HEXA_MISSION_B.BusAssignment_h.thrust_body[1] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.thrust_sp_bY_Value);\r\n  SITL_HEXA_MISSION_B.BusAssignment_h.thrust_body[2] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.Saturation_d);\r\n\r\n  // MATLABSystem: '<S15>/SinkBlock' incorporates:\r\n  //   BusAssignment: '<S6>/Bus Assignment'\r\n\r\n  uORB_write_step(SITL_HEXA_MISSION_DW.obj_mg.orbMetadataObj,\r\n                  &SITL_HEXA_MISSION_DW.obj_mg.orbAdvertiseObj,\r\n                  &SITL_HEXA_MISSION_B.BusAssignment_h);\r\n}\r\n\r\n// Model initialize function\r\nvoid SITL_HEXA_MISSION_initialize(void)\r\n{\r\n  // Registration code\r\n\r\n  // initialize non-finites\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  // non-finite (run-time) assignments\r\n  SITL_HEXA_MISSION_P.Constant1_Value_d[0] = rtNaNF;\r\n  SITL_HEXA_MISSION_P.Constant1_Value_d[1] = rtNaNF;\r\n  SITL_HEXA_MISSION_P.Constant_Value_f2 = rtNaNF;\r\n  SITL_HEXA_MISSION_P.Constant1_Value_k4[0] = rtNaNF;\r\n  SITL_HEXA_MISSION_P.Constant1_Value_k4[1] = rtNaNF;\r\n  SITL_HEXA_MISSION_P.Constant_Value_l4 = rtNaNF;\r\n  SITL_HEXA_MISSION_P.Constant_Value_fh[0] = rtNaNF;\r\n  SITL_HEXA_MISSION_P.Constant_Value_fh[1] = rtNaNF;\r\n  SITL_HEXA_MISSION_P.Constant_Value_fh[2] = rtNaNF;\r\n  SITL_HEXA_MISSION_P.Constant1_Value_h[0] = rtNaNF;\r\n  SITL_HEXA_MISSION_P.Constant1_Value_h[1] = rtNaNF;\r\n  SITL_HEXA_MISSION_P.Constant1_Value_h[2] = rtNaNF;\r\n  SITL_HEXA_MISSION_P.Constant2_Value[0] = rtNaNF;\r\n  SITL_HEXA_MISSION_P.Constant2_Value[1] = rtNaNF;\r\n  SITL_HEXA_MISSION_P.Constant2_Value[2] = rtNaNF;\r\n  SITL_HEXA_MISSION_P.Constant3_Value = rtNaNF;\r\n  SITL_HEXA_MISSION_P.Constant4_Value = rtNaNF;\r\n\r\n  // SystemInitialize for Enabled SubSystem: '<S605>/Enabled Subsystem'\r\n  // SystemInitialize for SignalConversion generated from: '<S609>/In1' incorporates:\r\n  //   Outport: '<S609>/Out1'\r\n\r\n  SITL_HEXA_MISSION_B.In1_c = SITL_HEXA_MISSION_P.Out1_Y0_p;\r\n\r\n  // End of SystemInitialize for SubSystem: '<S605>/Enabled Subsystem'\r\n\r\n  // SystemInitialize for Atomic SubSystem: '<Root>/Navigation'\r\n  SITL_HEXA_MISSION_Navigation_Init();\r\n\r\n  // End of SystemInitialize for SubSystem: '<Root>/Navigation'\r\n\r\n  // SystemInitialize for Enabled SubSystem: '<S604>/Enabled Subsystem'\r\n  // SystemInitialize for SignalConversion generated from: '<S608>/In1' incorporates:\r\n  //   Outport: '<S608>/Out1'\r\n\r\n  SITL_HEXA_MISSION_B.In1_m = SITL_HEXA_MISSION_P.Out1_Y0_k;\r\n\r\n  // End of SystemInitialize for SubSystem: '<S604>/Enabled Subsystem'\r\n\r\n  // SystemInitialize for Enabled SubSystem: '<S602>/Enabled Subsystem'\r\n  // SystemInitialize for SignalConversion generated from: '<S606>/In1' incorporates:\r\n  //   Outport: '<S606>/Out1'\r\n\r\n  SITL_HEXA_MISSION_B.In1_l = SITL_HEXA_MISSION_P.Out1_Y0_e;\r\n\r\n  // End of SystemInitialize for SubSystem: '<S602>/Enabled Subsystem'\r\n\r\n  // SystemInitialize for Enabled SubSystem: '<S603>/Enabled Subsystem'\r\n  // SystemInitialize for Outport: '<S607>/Out1' incorporates:\r\n  //   SignalConversion generated from: '<S607>/In1'\r\n\r\n  SITL_HEXA_MISSION_B.In1_b = SITL_HEXA_MISSION_P.Out1_Y0_d;\r\n\r\n  // End of SystemInitialize for SubSystem: '<S603>/Enabled Subsystem'\r\n\r\n  // SystemInitialize for Enabled SubSystem: '<S5>/mc_pos_controller'\r\n  SITL_HEXA_MISSION_mc_pos_controller_Init();\r\n\r\n  // End of SystemInitialize for SubSystem: '<S5>/mc_pos_controller'\r\n\r\n  // SystemInitialize for Enabled SubSystem: '<S5>/mc_att_controller'\r\n  SITL_HEXA_MISSION_mc_att_controller_Init();\r\n\r\n  // End of SystemInitialize for SubSystem: '<S5>/mc_att_controller'\r\n\r\n  // SystemInitialize for Enabled SubSystem: '<S5>/mc_rate_controller'\r\n  SITL_HEXA_MISSION_mc_rate_controller_Init();\r\n\r\n  // End of SystemInitialize for SubSystem: '<S5>/mc_rate_controller'\r\n\r\n  // SystemInitialize for Atomic SubSystem: '<Root>/actuatorOutputs'\r\n  SITL_HEXA_MISSION_actuatorOutputs_Init();\r\n\r\n  // End of SystemInitialize for SubSystem: '<Root>/actuatorOutputs'\r\n\r\n  // Start for MATLABSystem: '<S605>/SourceBlock'\r\n  SITL_HEXA_MISSION_DW.obj_m.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_m.isInitialized = 1;\r\n  SITL_HEXA_MISSION_DW.obj_m.orbMetadataObj = ORB_ID(vehicle_local_position);\r\n  uORB_read_initialize(SITL_HEXA_MISSION_DW.obj_m.orbMetadataObj,\r\n                       &SITL_HEXA_MISSION_DW.obj_m.eventStructObj);\r\n  SITL_HEXA_MISSION_DW.obj_m.isSetupComplete = true;\r\n\r\n  // Start for MATLABSystem: '<S604>/SourceBlock'\r\n  SITL_HEXA_MISSION_DW.obj_gv.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_gv.isInitialized = 1;\r\n  SITL_HEXA_MISSION_DW.obj_gv.orbMetadataObj = ORB_ID(vehicle_attitude);\r\n  uORB_read_initialize(SITL_HEXA_MISSION_DW.obj_gv.orbMetadataObj,\r\n                       &SITL_HEXA_MISSION_DW.obj_gv.eventStructObj);\r\n  SITL_HEXA_MISSION_DW.obj_gv.isSetupComplete = true;\r\n\r\n  // Start for MATLABSystem: '<S602>/SourceBlock'\r\n  SITL_HEXA_MISSION_DW.obj_p.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_p.isInitialized = 1;\r\n  SITL_HEXA_MISSION_DW.obj_p.orbMetadataObj = ORB_ID(vehicle_angular_velocity);\r\n  uORB_read_initialize(SITL_HEXA_MISSION_DW.obj_p.orbMetadataObj,\r\n                       &SITL_HEXA_MISSION_DW.obj_p.eventStructObj);\r\n  SITL_HEXA_MISSION_DW.obj_p.isSetupComplete = true;\r\n\r\n  // Start for MATLABSystem: '<S603>/SourceBlock'\r\n  SITL_HEXA_MISSION_DW.obj_d0.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_d0.isInitialized = 1;\r\n  SITL_HEXA_MISSION_DW.obj_d0.orbMetadataObj = ORB_ID(actuator_armed);\r\n  uORB_read_initialize(SITL_HEXA_MISSION_DW.obj_d0.orbMetadataObj,\r\n                       &SITL_HEXA_MISSION_DW.obj_d0.eventStructObj);\r\n  SITL_HEXA_MISSION_DW.obj_d0.isSetupComplete = true;\r\n  SITL_HEXA_MISSION_PX4Timestamp_Init(&SITL_HEXA_MISSION_DW.PX4Timestamp_pn);\r\n\r\n  // Start for MATLABSystem: '<S19>/SinkBlock' incorporates:\r\n  //   BusAssignment: '<S8>/Bus Assignment'\r\n\r\n  SITL_HEXA_MISSION_DW.obj_dz.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_dz.isInitialized = 1;\r\n  SITL_HEXA_MISSION_DW.obj_dz.orbMetadataObj = ORB_ID(vehicle_rates_setpoint);\r\n  uORB_write_initialize(SITL_HEXA_MISSION_DW.obj_dz.orbMetadataObj,\r\n                        &SITL_HEXA_MISSION_DW.obj_dz.orbAdvertiseObj,\r\n                        &SITL_HEXA_MISSION_B.BusAssignment_h4, 1);\r\n  SITL_HEXA_MISSION_DW.obj_dz.isSetupComplete = true;\r\n  SITL_HEXA_MISSION_PX4Timestamp_Init(&SITL_HEXA_MISSION_DW.PX4Timestamp_p);\r\n  SITL_HEXA_MISSION_SinkBlock_Init(&SITL_HEXA_MISSION_B.BusAssignment_a,\r\n    &SITL_HEXA_MISSION_DW.SinkBlock_m);\r\n  SITL_HEXA_MISSION_PX4Timestamp_Init(&SITL_HEXA_MISSION_DW.PX4Timestamp);\r\n\r\n  // Start for MATLABSystem: '<S15>/SinkBlock' incorporates:\r\n  //   BusAssignment: '<S6>/Bus Assignment'\r\n\r\n  SITL_HEXA_MISSION_DW.obj_mg.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_mg.isInitialized = 1;\r\n  SITL_HEXA_MISSION_DW.obj_mg.orbMetadataObj = ORB_ID(vehicle_attitude_setpoint);\r\n  uORB_write_initialize(SITL_HEXA_MISSION_DW.obj_mg.orbMetadataObj,\r\n                        &SITL_HEXA_MISSION_DW.obj_mg.orbAdvertiseObj,\r\n                        &SITL_HEXA_MISSION_B.BusAssignment_h, 1);\r\n  SITL_HEXA_MISSION_DW.obj_mg.isSetupComplete = true;\r\n}\r\n\r\n// Model terminate function\r\nvoid SITL_HEXA_MISSION_terminate(void)\r\n{\r\n  // Terminate for MATLABSystem: '<S605>/SourceBlock'\r\n  if (!SITL_HEXA_MISSION_DW.obj_m.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_m.matlabCodegenIsDeleted = true;\r\n    if ((SITL_HEXA_MISSION_DW.obj_m.isInitialized == 1) &&\r\n        SITL_HEXA_MISSION_DW.obj_m.isSetupComplete) {\r\n      uORB_read_terminate(&SITL_HEXA_MISSION_DW.obj_m.eventStructObj);\r\n    }\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S605>/SourceBlock'\r\n\r\n  // Terminate for Atomic SubSystem: '<Root>/Navigation'\r\n  SITL_HEXA_MISSION_Navigation_Term();\r\n\r\n  // End of Terminate for SubSystem: '<Root>/Navigation'\r\n\r\n  // Terminate for MATLABSystem: '<S604>/SourceBlock'\r\n  if (!SITL_HEXA_MISSION_DW.obj_gv.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_gv.matlabCodegenIsDeleted = true;\r\n    if ((SITL_HEXA_MISSION_DW.obj_gv.isInitialized == 1) &&\r\n        SITL_HEXA_MISSION_DW.obj_gv.isSetupComplete) {\r\n      uORB_read_terminate(&SITL_HEXA_MISSION_DW.obj_gv.eventStructObj);\r\n    }\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S604>/SourceBlock'\r\n\r\n  // Terminate for MATLABSystem: '<S602>/SourceBlock'\r\n  if (!SITL_HEXA_MISSION_DW.obj_p.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_p.matlabCodegenIsDeleted = true;\r\n    if ((SITL_HEXA_MISSION_DW.obj_p.isInitialized == 1) &&\r\n        SITL_HEXA_MISSION_DW.obj_p.isSetupComplete) {\r\n      uORB_read_terminate(&SITL_HEXA_MISSION_DW.obj_p.eventStructObj);\r\n    }\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S602>/SourceBlock'\r\n\r\n  // Terminate for MATLABSystem: '<S603>/SourceBlock'\r\n  if (!SITL_HEXA_MISSION_DW.obj_d0.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_d0.matlabCodegenIsDeleted = true;\r\n    if ((SITL_HEXA_MISSION_DW.obj_d0.isInitialized == 1) &&\r\n        SITL_HEXA_MISSION_DW.obj_d0.isSetupComplete) {\r\n      uORB_read_terminate(&SITL_HEXA_MISSION_DW.obj_d0.eventStructObj);\r\n    }\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S603>/SourceBlock'\r\n  SITL_HEXA_MISSION_PX4Timestamp_Term(&SITL_HEXA_MISSION_DW.PX4Timestamp_pn);\r\n\r\n  // Terminate for MATLABSystem: '<S19>/SinkBlock'\r\n  if (!SITL_HEXA_MISSION_DW.obj_dz.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_dz.matlabCodegenIsDeleted = true;\r\n    if ((SITL_HEXA_MISSION_DW.obj_dz.isInitialized == 1) &&\r\n        SITL_HEXA_MISSION_DW.obj_dz.isSetupComplete) {\r\n      uORB_write_terminate(&SITL_HEXA_MISSION_DW.obj_dz.orbAdvertiseObj);\r\n    }\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S19>/SinkBlock'\r\n\r\n  // Terminate for Atomic SubSystem: '<Root>/actuatorOutputs'\r\n  SITL_HEXA_MISSION_actuatorOutputs_Term();\r\n\r\n  // End of Terminate for SubSystem: '<Root>/actuatorOutputs'\r\n  SITL_HEXA_MISSION_PX4Timestamp_Term(&SITL_HEXA_MISSION_DW.PX4Timestamp_p);\r\n  SITL_HEXA_MISSION_SinkBlock_Term(&SITL_HEXA_MISSION_DW.SinkBlock_m);\r\n  SITL_HEXA_MISSION_PX4Timestamp_Term(&SITL_HEXA_MISSION_DW.PX4Timestamp);\r\n\r\n  // Terminate for MATLABSystem: '<S15>/SinkBlock'\r\n  if (!SITL_HEXA_MISSION_DW.obj_mg.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_mg.matlabCodegenIsDeleted = true;\r\n    if ((SITL_HEXA_MISSION_DW.obj_mg.isInitialized == 1) &&\r\n        SITL_HEXA_MISSION_DW.obj_mg.isSetupComplete) {\r\n      uORB_write_terminate(&SITL_HEXA_MISSION_DW.obj_mg.orbAdvertiseObj);\r\n    }\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S15>/SinkBlock'\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"SITL_HEXA_MISSION.h","type":"header","group":"model","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: SITL_HEXA_MISSION.h\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef SITL_HEXA_MISSION_h_\r\n#define SITL_HEXA_MISSION_h_\r\n#include <drivers/drv_hrt.h>\r\n#include <poll.h>\r\n#include <uORB/uORB.h>\r\n#include \"rtwtypes.h\"\r\n#include \"MW_uORB_Write.h\"\r\n#include \"MW_Parameter.h\"\r\n#include \"MW_ParameterRead.h\"\r\n#include \"MW_uORB_Read.h\"\r\n#include \"SITL_HEXA_MISSION_types.h\"\r\n#include <uORB/topics/vehicle_trajectory_waypoint.h>\r\n#include <uORB/topics/position_setpoint_triplet.h>\r\n#include <uORB/topics/vehicle_local_position.h>\r\n#include <uORB/topics/input_rc.h>\r\n#include <uORB/topics/actuator_motors.h>\r\n#include <uORB/topics/vehicle_local_position_setpoint.h>\r\n#include <uORB/topics/vehicle_attitude_setpoint.h>\r\n#include <uORB/topics/trajectory_waypoint.h>\r\n#include <uORB/topics/vehicle_attitude.h>\r\n#include <uORB/topics/home_position.h>\r\n#include <uORB/topics/vehicle_rates_setpoint.h>\r\n#include <uORB/topics/vehicle_angular_velocity.h>\r\n#include <uORB/topics/actuator_armed.h>\r\n#include \"rt_sys_SITL_HEXA_MISSION_0.h\"\r\n#include \"Navigation.h\"\r\n#include \"rt_sys_SITL_HEXA_MISSION_2.h\"\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rtGetNaN.h\"\r\n\r\n}\r\n\r\n#include <stddef.h>\r\n\r\n// Macros for accessing real-time model data structure\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n// Block signals (default storage)\r\nstruct B_SITL_HEXA_MISSION_T {\r\n  px4_Bus_vehicle_trajectory_waypoint BusAssignment1;// '<S572>/Bus Assignment1' \r\n  px4_Bus_vehicle_trajectory_waypoint In1;// '<S577>/In1'\r\n  px4_Bus_vehicle_trajectory_waypoint r;\r\n  px4_Bus_position_setpoint_triplet In1_p;// '<S589>/In1'\r\n  px4_Bus_position_setpoint_triplet r1;\r\n  px4_Bus_vehicle_local_position In1_c;// '<S609>/In1'\r\n  px4_Bus_vehicle_local_position r_mb;\r\n  px4_Bus_input_rc r_m;\r\n  px4_Bus_actuator_motors BusAssignment;// '<S595>/Bus Assignment'\r\n  real_T b_waypointsIn_data[9];\r\n  real_T MatrixConcatenate_p[9];       // '<S559>/Matrix Concatenate'\r\n  px4_Bus_vehicle_local_position_setpoint BusAssignment_a;// '<S7>/Bus Assignment' \r\n  px4_Bus_vehicle_local_position_setpoint BusAssignment_m;// '<S552>/Bus Assignment' \r\n  px4_Bus_vehicle_attitude_setpoint BusAssignment_h;// '<S6>/Bus Assignment'\r\n  px4_Bus_trajectory_waypoint BusAssignment1_f;// '<S580>/Bus Assignment1'\r\n  px4_Bus_vehicle_attitude In1_m;      // '<S608>/In1'\r\n  px4_Bus_vehicle_attitude r1_c;\r\n  px4_Bus_home_position In1_f;         // '<S588>/In1'\r\n  px4_Bus_home_position r2;\r\n  px4_Bus_vehicle_rates_setpoint BusAssignment_h4;// '<S8>/Bus Assignment'\r\n  px4_Bus_vehicle_angular_velocity In1_l;// '<S606>/In1'\r\n  px4_Bus_vehicle_angular_velocity r2_k;\r\n  real_T DataTypeConversion2[3];       // '<S4>/Data Type Conversion2'\r\n  real_T VectorConcatenate[3];         // '<S21>/Vector Concatenate'\r\n  real_T Merge[4];                     // '<S554>/Merge'\r\n  real_T lla0[3];\r\n  real_T virtualWaypoint[3];\r\n  real_T MatrixConcatenate1[3];        // '<S578>/Matrix Concatenate1'\r\n  real_T MatrixConcatenate1_k[3];      // '<S572>/Matrix Concatenate1'\r\n  real_T dv[3];\r\n  px4_Bus_actuator_armed In1_b;        // '<S607>/In1'\r\n  real_T DataTypeConversion1[7];       // '<S4>/Data Type Conversion1'\r\n  px4_Bus_actuator_armed r3;\r\n  real_T desiredZ;                     // '<S5>/Gain'\r\n  real_T yaw_In;                       // '<S561>/yaw_In'\r\n  real_T yaw_In_i;                     // '<S565>/yaw_In'\r\n  real_T In;                           // '<S564>/In'\r\n  real_T yaw_In_ik;                    // '<S568>/yaw_In'\r\n  real_T Saturation;                   // '<S437>/Saturation'\r\n  real_T Saturation_c;                 // '<S489>/Saturation'\r\n  real_T Saturation_b;                 // '<S541>/Saturation'\r\n  real_T Saturation_o;                 // '<S330>/Saturation'\r\n  real_T Saturation_d;                 // '<S382>/Saturation'\r\n  real_T Saturation_bi[2];             // '<S280>/Saturation'\r\n  real_T Saturation_n[2];              // '<S230>/Saturation'\r\n  real_T Gain1;                        // '<S12>/Gain1'\r\n  real_T Saturation_e;                 // '<S173>/Saturation'\r\n  real_T ProportionalGain;             // '<S71>/Proportional Gain'\r\n  real_T ProportionalGain_a;           // '<S121>/Proportional Gain'\r\n  real_T Filter_j;                     // '<S425>/Filter'\r\n  real_T flat;\r\n  real_T absx;\r\n  real_T Gain_i;                       // '<S566>/Gain'\r\n  real_T Sum_f;                        // '<S566>/Sum'\r\n  real_T b_xyzNED_idx_1;\r\n  real_T u0;\r\n  real_T rtb_Sum_f_tmp;\r\n  real_T lla0_tmp;\r\n  real_T dLat;\r\n  real_T dLon;\r\n  real_T flat_m;\r\n  real_T absx_c;\r\n  real_T r_k;\r\n  real_T flat_tmp;\r\n  real_T absx_cx;\r\n  real_T q;\r\n  real_T scale;\r\n  real_T absxk;\r\n  real_T t;\r\n  real_T Saturation3;                  // '<S3>/Saturation3'\r\n  real_T Saturation2;                  // '<S3>/Saturation2'\r\n  real_T Saturation1;                  // '<S3>/Saturation1'\r\n  real_T Saturation_cl;                // '<S3>/Saturation'\r\n  real_T u0_k;\r\n  real_T Sum_l;                        // '<S20>/Sum'\r\n  real_T fcn3;                         // '<S10>/fcn3'\r\n  real_T rtb_Switch_j_idx_0;\r\n  real_T rtb_Switch_j_idx_1;\r\n  real_T rtb_Switch_j_idx_2;\r\n  real_T rtb_Switch_j_idx_3;\r\n  real_T VectorConcatenate_tmp;\r\n  real_T VectorConcatenate_tmp_c;\r\n  real_T VectorConcatenate_tmp_b;\r\n  boolean_T x[6];\r\n  real32_T ParamStep;\r\n  int32_T ParamStep_b;\r\n  int32_T iy;\r\n  int32_T i1;\r\n  int32_T j;\r\n  int32_T ix;\r\n  int32_T b_exponent;\r\n  int32_T b_exponent_p;\r\n  int32_T b_k;\r\n  int32_T i;\r\n  int32_T i1_c;\r\n  int32_T i_p;\r\n  int32_T i1_cv;\r\n  int8_T tmp_data[3];\r\n  boolean_T distinctWptsIdx[3];\r\n  boolean_T b[3];\r\n  boolean_T IsNaN_l[2];                // '<S557>/IsNaN'\r\n  int8_T rtPrevAction;\r\n  int8_T rtAction;\r\n  boolean_T latp2;\r\n  boolean_T OR_g;                      // '<S557>/OR'\r\n  boolean_T latp2_f;\r\n  boolean_T b_varargout_1;\r\n  B_PX4Timestamp_SITL_HEXA_MISSION_T PX4Timestamp1;// '<S6>/PX4 Timestamp'\r\n  B_PX4Timestamp_SITL_HEXA_MISSION_T PX4Timestamp_pna;// '<S6>/PX4 Timestamp'\r\n  B_MATLABSystem_SITL_HEXA_MISSION_T MATLABSystem_b;// '<S578>/MATLAB System'\r\n  B_MATLABSystem_SITL_HEXA_MISSION_T MATLABSystem;// '<S578>/MATLAB System'\r\n  B_PX4Timestamp_SITL_HEXA_MISSION_T PX4Timestamp_o;// '<S6>/PX4 Timestamp'\r\n  B_PX4Timestamp_SITL_HEXA_MISSION_T PX4Timestamp_pn;// '<S6>/PX4 Timestamp'\r\n  B_PX4Timestamp_SITL_HEXA_MISSION_T PX4Timestamp_p;// '<S6>/PX4 Timestamp'\r\n  B_PX4Timestamp_SITL_HEXA_MISSION_T PX4Timestamp;// '<S6>/PX4 Timestamp'\r\n};\r\n\r\n// Block states (default storage) for system '<Root>'\r\nstruct DW_SITL_HEXA_MISSION_T {\r\n  uav_sluav_internal_system_WaypointFollower_SITL_HEXA_MISSION_T obj;// '<S559>/UAV Waypoint Follower' \r\n  px4_internal_block_ParameterUpdate_SITL_HEXA_MISSION_T obj_o;// '<S596>/Read Parameter4' \r\n  px4_internal_block_ParameterUpdate_SITL_HEXA_MISSION_T obj_g;// '<S596>/Read Parameter3' \r\n  px4_internal_block_ParameterUpdate_SITL_HEXA_MISSION_T obj_d;// '<S596>/Read Parameter2' \r\n  px4_internal_block_ParameterUpdate_SITL_HEXA_MISSION_T obj_j;// '<S596>/Read Parameter13' \r\n  px4_internal_block_ParameterUpdate_SITL_HEXA_MISSION_T obj_i;// '<S596>/Read Parameter1' \r\n  px4_internal_block_ParameterUpdate_SITL_HEXA_MISSION_T obj_jb;// '<S596>/Read Parameter' \r\n  px4_internal_block_ParameterUpdate_SITL_HEXA_MISSION_T obj_b;// '<S586>/Read Parameter' \r\n  px4_internal_block_ParameterUpdate_SITL_HEXA_MISSION_T obj_ga;// '<S587>/Read Parameter' \r\n  px4_internal_block_ParameterUpdate_SITL_HEXA_MISSION_T obj_k;// '<S555>/Read Parameter' \r\n  px4_internal_block_Subscriber_SITL_HEXA_MISSION_T obj_m;// '<S605>/SourceBlock' \r\n  px4_internal_block_Subscriber_SITL_HEXA_MISSION_T obj_gv;// '<S604>/SourceBlock' \r\n  px4_internal_block_Subscriber_SITL_HEXA_MISSION_T obj_d0;// '<S603>/SourceBlock' \r\n  px4_internal_block_Subscriber_SITL_HEXA_MISSION_T obj_p;// '<S602>/SourceBlock' \r\n  px4_internal_block_Subscriber_SITL_HEXA_MISSION_T obj_kd;// '<S598>/SourceBlock' \r\n  px4_internal_block_Subscriber_SITL_HEXA_MISSION_T obj_kz;// '<S574>/SourceBlock' \r\n  px4_internal_block_Subscriber_SITL_HEXA_MISSION_T obj_gf;// '<S573>/SourceBlock' \r\n  px4_internal_block_Subscriber_SITL_HEXA_MISSION_T obj_e;// '<S576>/SourceBlock' \r\n  px4_internal_block_Publisher_SITL_HEXA_MISSION_T obj_kg;// '<S601>/SinkBlock'\r\n  px4_internal_block_Publisher_SITL_HEXA_MISSION_T obj_mc;// '<S583>/SinkBlock'\r\n  px4_internal_block_Publisher_SITL_HEXA_MISSION_T obj_dz;// '<S19>/SinkBlock'\r\n  px4_internal_block_Publisher_SITL_HEXA_MISSION_T obj_mg;// '<S15>/SinkBlock'\r\n  px4_internal_block_LLA2LocalCoordinates_SITL_HEXA_MISSION_T obj_mr;// '<S555>/LLA2LocalCoordinates' \r\n  real_T Delay_DSTATE;                 // '<S560>/Delay'\r\n  real_T Delay_DSTATE_l[2];            // '<S557>/Delay'\r\n  real_T Delay_DSTATE_n;               // '<S562>/Delay'\r\n  real_T Delay_DSTATE_b;               // '<S563>/Delay'\r\n  real_T Delay_DSTATE_c;               // '<S566>/Delay'\r\n  real_T Delay_DSTATE_d;               // '<S567>/Delay'\r\n  real_T Integrator_DSTATE;            // '<S430>/Integrator'\r\n  real_T Filter_DSTATE;                // '<S425>/Filter'\r\n  real_T Integrator_DSTATE_d;          // '<S482>/Integrator'\r\n  real_T Filter_DSTATE_h;              // '<S477>/Filter'\r\n  real_T Integrator_DSTATE_dd;         // '<S534>/Integrator'\r\n  real_T Filter_DSTATE_l;              // '<S529>/Filter'\r\n  real_T Filter_DSTATE_m;              // '<S370>/Filter'\r\n  real_T Integrator_DSTATE_c;          // '<S375>/Integrator'\r\n  real_T PrevY;                        // '<S11>/Rate Limiter2'\r\n  real_T PrevY_f;                      // '<S11>/Rate Limiter1'\r\n  px4_internal_block_LLA2LocalCoordinatesNED_SITL_HEXA_MISSION_T obj_mu;// '<S581>/MATLAB System' \r\n  int8_T If_ActiveSubsystem;           // '<S554>/If'\r\n  DW_PX4Timestamp_SITL_HEXA_MISSION_T PX4Timestamp1;// '<S6>/PX4 Timestamp'\r\n  DW_SinkBlock_SITL_HEXA_MISSION_T SinkBlock_a;// '<S17>/SinkBlock'\r\n  DW_PX4Timestamp_SITL_HEXA_MISSION_T PX4Timestamp_pna;// '<S6>/PX4 Timestamp'\r\n  DW_MATLABSystem_SITL_HEXA_MISSION_T MATLABSystem_b;// '<S578>/MATLAB System'\r\n  DW_MATLABSystem_SITL_HEXA_MISSION_T MATLABSystem;// '<S578>/MATLAB System'\r\n  DW_PX4Timestamp_SITL_HEXA_MISSION_T PX4Timestamp_o;// '<S6>/PX4 Timestamp'\r\n  DW_PX4Timestamp_SITL_HEXA_MISSION_T PX4Timestamp_pn;// '<S6>/PX4 Timestamp'\r\n  DW_SinkBlock_SITL_HEXA_MISSION_T SinkBlock_m;// '<S17>/SinkBlock'\r\n  DW_PX4Timestamp_SITL_HEXA_MISSION_T PX4Timestamp_p;// '<S6>/PX4 Timestamp'\r\n  DW_PX4Timestamp_SITL_HEXA_MISSION_T PX4Timestamp;// '<S6>/PX4 Timestamp'\r\n};\r\n\r\n// Parameters (default storage)\r\nstruct P_SITL_HEXA_MISSION_T_ {\r\n  real_T MC_PITCHRATE_D;               // Variable: MC_PITCHRATE_D\r\n                                          //  Referenced by: '<S475>/Derivative Gain'\r\n\r\n  real_T MC_PITCHRATE_I;               // Variable: MC_PITCHRATE_I\r\n                                          //  Referenced by: '<S479>/Integral Gain'\r\n\r\n  real_T MC_PITCHRATE_P;               // Variable: MC_PITCHRATE_P\r\n                                          //  Referenced by: '<S487>/Proportional Gain'\r\n\r\n  real_T MC_PITCH_P;                   // Variable: MC_PITCH_P\r\n                                          //  Referenced by: '<S71>/Proportional Gain'\r\n\r\n  real_T MC_ROLLRATE_D;                // Variable: MC_ROLLRATE_D\r\n                                          //  Referenced by: '<S527>/Derivative Gain'\r\n\r\n  real_T MC_ROLLRATE_I;                // Variable: MC_ROLLRATE_I\r\n                                          //  Referenced by: '<S531>/Integral Gain'\r\n\r\n  real_T MC_ROLLRATE_P;                // Variable: MC_ROLLRATE_P\r\n                                          //  Referenced by: '<S539>/Proportional Gain'\r\n\r\n  real_T MC_ROLL_P;                    // Variable: MC_ROLL_P\r\n                                          //  Referenced by: '<S121>/Proportional Gain'\r\n\r\n  real_T MC_YAWRATE_D;                 // Variable: MC_YAWRATE_D\r\n                                          //  Referenced by: '<S423>/Derivative Gain'\r\n\r\n  real_T MC_YAWRATE_I;                 // Variable: MC_YAWRATE_I\r\n                                          //  Referenced by: '<S427>/Integral Gain'\r\n\r\n  real_T MC_YAWRATE_P;                 // Variable: MC_YAWRATE_P\r\n                                          //  Referenced by: '<S435>/Proportional Gain'\r\n\r\n  real_T MC_YAW_P;                     // Variable: MC_YAW_P\r\n                                          //  Referenced by: '<S171>/Proportional Gain'\r\n\r\n  real_T MPC_XY_P;                     // Variable: MPC_XY_P\r\n                                          //  Referenced by: '<S278>/Proportional Gain'\r\n\r\n  real_T MPC_XY_VEL_MAX;               // Variable: MPC_XY_VEL_MAX\r\n                                          //  Referenced by: '<S280>/Saturation'\r\n\r\n  real_T MPC_Z_P;                      // Variable: MPC_Z_P\r\n                                          //  Referenced by: '<S328>/Proportional Gain'\r\n\r\n  real_T MPC_Z_VEL_D_ACC;              // Variable: MPC_Z_VEL_D_ACC\r\n                                          //  Referenced by: '<S368>/Derivative Gain'\r\n\r\n  real_T MPC_Z_VEL_I_ACC;              // Variable: MPC_Z_VEL_I_ACC\r\n                                          //  Referenced by: '<S372>/Integral Gain'\r\n\r\n  real_T MPC_Z_VEL_MAX_DN;             // Variable: MPC_Z_VEL_MAX_DN\r\n                                          //  Referenced by: '<S330>/Saturation'\r\n\r\n  real_T MPC_Z_VEL_MAX_UP;             // Variable: MPC_Z_VEL_MAX_UP\r\n                                          //  Referenced by: '<S330>/Saturation'\r\n\r\n  real_T MPC_Z_VEL_P_ACC;              // Variable: MPC_Z_VEL_P_ACC\r\n                                          //  Referenced by: '<S380>/Proportional Gain'\r\n\r\n  real_T PID_vz_InitialConditionForFilter;\r\n                             // Mask Parameter: PID_vz_InitialConditionForFilter\r\n                                //  Referenced by: '<S370>/Filter'\r\n\r\n  real_T PIDController_InitialConditionForFilter;\r\n                      // Mask Parameter: PIDController_InitialConditionForFilter\r\n                         //  Referenced by: '<S425>/Filter'\r\n\r\n  real_T PIDController1_InitialConditionForFilter;\r\n                     // Mask Parameter: PIDController1_InitialConditionForFilter\r\n                        //  Referenced by: '<S477>/Filter'\r\n\r\n  real_T PIDController2_InitialConditionForFilter;\r\n                     // Mask Parameter: PIDController2_InitialConditionForFilter\r\n                        //  Referenced by: '<S529>/Filter'\r\n\r\n  real_T PID_vz_InitialConditionForIntegrator;\r\n                         // Mask Parameter: PID_vz_InitialConditionForIntegrator\r\n                            //  Referenced by: '<S375>/Integrator'\r\n\r\n  real_T PIDController_InitialConditionForIntegrator;\r\n                  // Mask Parameter: PIDController_InitialConditionForIntegrator\r\n                     //  Referenced by: '<S430>/Integrator'\r\n\r\n  real_T PIDController1_InitialConditionForIntegrator;\r\n                 // Mask Parameter: PIDController1_InitialConditionForIntegrator\r\n                    //  Referenced by: '<S482>/Integrator'\r\n\r\n  real_T PIDController2_InitialConditionForIntegrator;\r\n                 // Mask Parameter: PIDController2_InitialConditionForIntegrator\r\n                    //  Referenced by: '<S534>/Integrator'\r\n\r\n  real_T PIDController5_LowerSaturationLimit;\r\n                          // Mask Parameter: PIDController5_LowerSaturationLimit\r\n                             //  Referenced by: '<S173>/Saturation'\r\n\r\n  real_T PID_vz_LowerSaturationLimit;\r\n                                  // Mask Parameter: PID_vz_LowerSaturationLimit\r\n                                     //  Referenced by:\r\n                                     //    '<S382>/Saturation'\r\n                                     //    '<S367>/DeadZone'\r\n\r\n  real_T PIDController_LowerSaturationLimit;\r\n                           // Mask Parameter: PIDController_LowerSaturationLimit\r\n                              //  Referenced by: '<S230>/Saturation'\r\n\r\n  real_T PIDController_LowerSaturationLimit_b;\r\n                         // Mask Parameter: PIDController_LowerSaturationLimit_b\r\n                            //  Referenced by:\r\n                            //    '<S437>/Saturation'\r\n                            //    '<S422>/DeadZone'\r\n\r\n  real_T PIDController1_LowerSaturationLimit;\r\n                          // Mask Parameter: PIDController1_LowerSaturationLimit\r\n                             //  Referenced by:\r\n                             //    '<S489>/Saturation'\r\n                             //    '<S474>/DeadZone'\r\n\r\n  real_T PIDController2_LowerSaturationLimit;\r\n                          // Mask Parameter: PIDController2_LowerSaturationLimit\r\n                             //  Referenced by:\r\n                             //    '<S541>/Saturation'\r\n                             //    '<S526>/DeadZone'\r\n\r\n  real_T PID_vz_N;                     // Mask Parameter: PID_vz_N\r\n                                          //  Referenced by: '<S378>/Filter Coefficient'\r\n\r\n  real_T PIDController_N;              // Mask Parameter: PIDController_N\r\n                                          //  Referenced by: '<S433>/Filter Coefficient'\r\n\r\n  real_T PIDController1_N;             // Mask Parameter: PIDController1_N\r\n                                          //  Referenced by: '<S485>/Filter Coefficient'\r\n\r\n  real_T PIDController2_N;             // Mask Parameter: PIDController2_N\r\n                                          //  Referenced by: '<S537>/Filter Coefficient'\r\n\r\n  real_T PIDController_P;              // Mask Parameter: PIDController_P\r\n                                          //  Referenced by: '<S228>/Proportional Gain'\r\n\r\n  real_T PIDController5_UpperSaturationLimit;\r\n                          // Mask Parameter: PIDController5_UpperSaturationLimit\r\n                             //  Referenced by: '<S173>/Saturation'\r\n\r\n  real_T PID_vz_UpperSaturationLimit;\r\n                                  // Mask Parameter: PID_vz_UpperSaturationLimit\r\n                                     //  Referenced by:\r\n                                     //    '<S382>/Saturation'\r\n                                     //    '<S367>/DeadZone'\r\n\r\n  real_T PIDController_UpperSaturationLimit;\r\n                           // Mask Parameter: PIDController_UpperSaturationLimit\r\n                              //  Referenced by: '<S230>/Saturation'\r\n\r\n  real_T PIDController_UpperSaturationLimit_p;\r\n                         // Mask Parameter: PIDController_UpperSaturationLimit_p\r\n                            //  Referenced by:\r\n                            //    '<S437>/Saturation'\r\n                            //    '<S422>/DeadZone'\r\n\r\n  real_T PIDController1_UpperSaturationLimit;\r\n                          // Mask Parameter: PIDController1_UpperSaturationLimit\r\n                             //  Referenced by:\r\n                             //    '<S489>/Saturation'\r\n                             //    '<S474>/DeadZone'\r\n\r\n  real_T PIDController2_UpperSaturationLimit;\r\n                          // Mask Parameter: PIDController2_UpperSaturationLimit\r\n                             //  Referenced by:\r\n                             //    '<S541>/Saturation'\r\n                             //    '<S526>/DeadZone'\r\n\r\n  uint8_T CompareToConstant_const;    // Mask Parameter: CompareToConstant_const\r\n                                         //  Referenced by: '<S570>/Constant'\r\n\r\n  px4_Bus_vehicle_trajectory_waypoint Out1_Y0;// Computed Parameter: Out1_Y0\r\n                                                 //  Referenced by: '<S577>/Out1'\r\n\r\n  px4_Bus_vehicle_trajectory_waypoint Constant_Value;// Computed Parameter: Constant_Value\r\n                                                        //  Referenced by: '<S582>/Constant'\r\n\r\n  px4_Bus_vehicle_trajectory_waypoint Constant_Value_g;// Computed Parameter: Constant_Value_g\r\n                                                          //  Referenced by: '<S576>/Constant'\r\n\r\n  px4_Bus_position_setpoint_triplet Out1_Y0_h;// Computed Parameter: Out1_Y0_h\r\n                                                 //  Referenced by: '<S589>/Out1'\r\n\r\n  px4_Bus_position_setpoint_triplet Constant_Value_d;// Computed Parameter: Constant_Value_d\r\n                                                        //  Referenced by: '<S574>/Constant'\r\n\r\n  px4_Bus_vehicle_local_position Out1_Y0_p;// Computed Parameter: Out1_Y0_p\r\n                                              //  Referenced by: '<S609>/Out1'\r\n\r\n  px4_Bus_vehicle_local_position Constant_Value_e;// Computed Parameter: Constant_Value_e\r\n                                                     //  Referenced by: '<S605>/Constant'\r\n\r\n  px4_Bus_actuator_motors Constant_Value_a;// Computed Parameter: Constant_Value_a\r\n                                              //  Referenced by: '<S600>/Constant'\r\n\r\n  px4_Bus_input_rc Out1_Y0_f;          // Computed Parameter: Out1_Y0_f\r\n                                          //  Referenced by: '<S599>/Out1'\r\n\r\n  px4_Bus_input_rc Constant_Value_k;   // Computed Parameter: Constant_Value_k\r\n                                          //  Referenced by: '<S598>/Constant'\r\n\r\n  px4_Bus_vehicle_local_position_setpoint Constant_Value_i;// Computed Parameter: Constant_Value_i\r\n                                                              //  Referenced by: '<S590>/Constant'\r\n\r\n  px4_Bus_vehicle_local_position_setpoint Constant_Value_l;// Computed Parameter: Constant_Value_l\r\n                                                              //  Referenced by: '<S16>/Constant'\r\n\r\n  px4_Bus_vehicle_attitude Out1_Y0_k;  // Computed Parameter: Out1_Y0_k\r\n                                          //  Referenced by: '<S608>/Out1'\r\n\r\n  px4_Bus_vehicle_attitude Constant_Value_lh;// Computed Parameter: Constant_Value_lh\r\n                                                //  Referenced by: '<S604>/Constant'\r\n\r\n  px4_Bus_vehicle_attitude_setpoint Constant_Value_b;// Computed Parameter: Constant_Value_b\r\n                                                        //  Referenced by: '<S14>/Constant'\r\n\r\n  px4_Bus_home_position Out1_Y0_o;     // Computed Parameter: Out1_Y0_o\r\n                                          //  Referenced by: '<S588>/Out1'\r\n\r\n  px4_Bus_home_position Constant_Value_b0;// Computed Parameter: Constant_Value_b0\r\n                                             //  Referenced by: '<S573>/Constant'\r\n\r\n  px4_Bus_vehicle_angular_velocity Out1_Y0_e;// Computed Parameter: Out1_Y0_e\r\n                                                //  Referenced by: '<S606>/Out1'\r\n\r\n  px4_Bus_vehicle_angular_velocity Constant_Value_n;// Computed Parameter: Constant_Value_n\r\n                                                       //  Referenced by: '<S602>/Constant'\r\n\r\n  px4_Bus_vehicle_rates_setpoint Constant_Value_j;// Computed Parameter: Constant_Value_j\r\n                                                     //  Referenced by: '<S18>/Constant'\r\n\r\n  px4_Bus_actuator_armed Out1_Y0_d;    // Computed Parameter: Out1_Y0_d\r\n                                          //  Referenced by: '<S607>/Out1'\r\n\r\n  px4_Bus_actuator_armed Constant_Value_jl;// Computed Parameter: Constant_Value_jl\r\n                                              //  Referenced by: '<S603>/Constant'\r\n\r\n  real_T Constant_Value_im[4];         // Expression: [1 0 0 0]\r\n                                          //  Referenced by: '<S9>/Constant'\r\n\r\n  real_T Constant_Value_be;            // Expression: 1\r\n                                          //  Referenced by: '<S24>/Constant'\r\n\r\n  real_T Constant_Value_m;             // Expression: 1\r\n                                          //  Referenced by: '<S25>/Constant'\r\n\r\n  real_T Switch1_Threshold;            // Expression: 0\r\n                                          //  Referenced by: '<S29>/Switch1'\r\n\r\n  real_T Yawrate_sp_Y0;                // Computed Parameter: Yawrate_sp_Y0\r\n                                          //  Referenced by: '<S11>/Yawrate_sp'\r\n\r\n  real_T Pitchrate_sp_Y0;              // Computed Parameter: Pitchrate_sp_Y0\r\n                                          //  Referenced by: '<S11>/Pitchrate_sp'\r\n\r\n  real_T Rollrate_spl_Y0;              // Computed Parameter: Rollrate_spl_Y0\r\n                                          //  Referenced by: '<S11>/Rollrate_spl'\r\n\r\n  real_T Constant_Value_p;             // Expression: 2*pi\r\n                                          //  Referenced by: '<S29>/Constant'\r\n\r\n  real_T Switch_Threshold;             // Expression: pi\r\n                                          //  Referenced by: '<S29>/Switch'\r\n\r\n  real_T RateLimiter2_RisingLim;       // Expression: 180*pi/180\r\n                                          //  Referenced by: '<S11>/Rate Limiter2'\r\n\r\n  real_T RateLimiter2_FallingLim;      // Expression: -180*pi/180\r\n                                          //  Referenced by: '<S11>/Rate Limiter2'\r\n\r\n  real_T RateLimiter2_IC;              // Expression: 0\r\n                                          //  Referenced by: '<S11>/Rate Limiter2'\r\n\r\n  real_T RateLimiter1_RisingLim;       // Expression: 180*pi/180\r\n                                          //  Referenced by: '<S11>/Rate Limiter1'\r\n\r\n  real_T RateLimiter1_FallingLim;      // Expression: -180*pi/180\r\n                                          //  Referenced by: '<S11>/Rate Limiter1'\r\n\r\n  real_T RateLimiter1_IC;              // Expression: 0\r\n                                          //  Referenced by: '<S11>/Rate Limiter1'\r\n\r\n  real_T Constant_Value_j4;            // Expression: 0\r\n                                          //  Referenced by: '<S183>/Constant'\r\n\r\n  real_T tau_Thrust_Y0;                // Computed Parameter: tau_Thrust_Y0\r\n                                          //  Referenced by: '<S12>/tau_Thrust'\r\n\r\n  real_T des_pitch_Y0;                 // Computed Parameter: des_pitch_Y0\r\n                                          //  Referenced by: '<S12>/des_pitch'\r\n\r\n  real_T des_roll_Y0;                  // Computed Parameter: des_roll_Y0\r\n                                          //  Referenced by: '<S12>/des_roll'\r\n\r\n  real_T XY_velocity_setpoint_Y0; // Computed Parameter: XY_velocity_setpoint_Y0\r\n                                     //  Referenced by: '<S12>/XY_velocity_setpoint'\r\n\r\n  real_T Z_velocity_setpoint_Y0;   // Computed Parameter: Z_velocity_setpoint_Y0\r\n                                      //  Referenced by: '<S12>/Z_velocity_setpoint'\r\n\r\n  real_T Constant1_Value;              // Expression: 0\r\n                                          //  Referenced by: '<S365>/Constant1'\r\n\r\n  real_T Gain1_Gain;                   // Expression: -1\r\n                                          //  Referenced by: '<S183>/Gain1'\r\n\r\n  real_T Clamping_zero_Value;          // Expression: 0\r\n                                          //  Referenced by: '<S365>/Clamping_zero'\r\n\r\n  real_T Filter_gainval;               // Computed Parameter: Filter_gainval\r\n                                          //  Referenced by: '<S370>/Filter'\r\n\r\n  real_T Integrator_gainval;           // Computed Parameter: Integrator_gainval\r\n                                          //  Referenced by: '<S375>/Integrator'\r\n\r\n  real_T Gain_Gain;                    // Expression: -1\r\n                                          //  Referenced by: '<S184>/Gain'\r\n\r\n  real_T Gain1_Gain_f;                 // Expression: -1\r\n                                          //  Referenced by: '<S12>/Gain1'\r\n\r\n  real_T tau_yaw_Y0;                   // Computed Parameter: tau_yaw_Y0\r\n                                          //  Referenced by: '<S13>/tau_yaw'\r\n\r\n  real_T tau_pitch_Y0;                 // Computed Parameter: tau_pitch_Y0\r\n                                          //  Referenced by: '<S13>/tau_pitch'\r\n\r\n  real_T tau_roll_Y0;                  // Computed Parameter: tau_roll_Y0\r\n                                          //  Referenced by: '<S13>/tau_roll'\r\n\r\n  real_T Constant1_Value_k;            // Expression: 0\r\n                                          //  Referenced by: '<S420>/Constant1'\r\n\r\n  real_T Constant1_Value_j;            // Expression: 0\r\n                                          //  Referenced by: '<S472>/Constant1'\r\n\r\n  real_T Constant1_Value_ka;           // Expression: 0\r\n                                          //  Referenced by: '<S524>/Constant1'\r\n\r\n  real_T Clamping_zero_Value_i;        // Expression: 0\r\n                                          //  Referenced by: '<S420>/Clamping_zero'\r\n\r\n  real_T Integrator_gainval_h;       // Computed Parameter: Integrator_gainval_h\r\n                                        //  Referenced by: '<S430>/Integrator'\r\n\r\n  real_T Filter_gainval_f;             // Computed Parameter: Filter_gainval_f\r\n                                          //  Referenced by: '<S425>/Filter'\r\n\r\n  real_T Clamping_zero_Value_d;        // Expression: 0\r\n                                          //  Referenced by: '<S472>/Clamping_zero'\r\n\r\n  real_T Integrator_gainval_b;       // Computed Parameter: Integrator_gainval_b\r\n                                        //  Referenced by: '<S482>/Integrator'\r\n\r\n  real_T Filter_gainval_l;             // Computed Parameter: Filter_gainval_l\r\n                                          //  Referenced by: '<S477>/Filter'\r\n\r\n  real_T Clamping_zero_Value_e;        // Expression: 0\r\n                                          //  Referenced by: '<S524>/Clamping_zero'\r\n\r\n  real_T Integrator_gainval_n;       // Computed Parameter: Integrator_gainval_n\r\n                                        //  Referenced by: '<S534>/Integrator'\r\n\r\n  real_T Filter_gainval_a;             // Computed Parameter: Filter_gainval_a\r\n                                          //  Referenced by: '<S529>/Filter'\r\n\r\n  real_T yaw_Out_Y0;                   // Computed Parameter: yaw_Out_Y0\r\n                                          //  Referenced by: '<S568>/yaw_Out'\r\n\r\n  real_T Delay_InitialCondition;       // Expression: 0.0\r\n                                          //  Referenced by: '<S566>/Delay'\r\n\r\n  real_T Rate_Value;                   // Expression: 0.01\r\n                                          //  Referenced by: '<S566>/Rate'\r\n\r\n  real_T Gain1_Gain_b;                 // Expression: -1\r\n                                          //  Referenced by: '<S566>/Gain1'\r\n\r\n  real_T Gain_Gain_e;                  // Expression: -1\r\n                                          //  Referenced by: '<S566>/Gain'\r\n\r\n  real_T Delay_InitialCondition_g;     // Expression: 1\r\n                                          //  Referenced by: '<S567>/Delay'\r\n\r\n  real_T Constant_Value_f;             // Expression: 0\r\n                                          //  Referenced by: '<S567>/Constant'\r\n\r\n  real_T Out_Y0;                       // Computed Parameter: Out_Y0\r\n                                          //  Referenced by: '<S564>/Out'\r\n\r\n  real_T Gain_Gain_l;                  // Expression: -1\r\n                                          //  Referenced by: '<S562>/Gain'\r\n\r\n  real_T yaw_Out_Y0_f;                 // Computed Parameter: yaw_Out_Y0_f\r\n                                          //  Referenced by: '<S565>/yaw_Out'\r\n\r\n  real_T Delay_InitialCondition_n;     // Expression: 0.0\r\n                                          //  Referenced by: '<S557>/Delay'\r\n\r\n  real_T Delay_InitialCondition_m;     // Expression: 0.0\r\n                                          //  Referenced by: '<S562>/Delay'\r\n\r\n  real_T Switch_Threshold_j;           // Expression: 0\r\n                                          //  Referenced by: '<S562>/Switch'\r\n\r\n  real_T Rateofdescent_Value;          // Expression: 0.02\r\n                                          //  Referenced by: '<S562>/Rate of descent'\r\n\r\n  real_T Gain2_Gain;                   // Expression: -1\r\n                                          //  Referenced by: '<S562>/Gain2'\r\n\r\n  real_T Gain1_Gain_a;                 // Expression: -1\r\n                                          //  Referenced by: '<S562>/Gain1'\r\n\r\n  real_T Delay_InitialCondition_j;     // Expression: 1\r\n                                          //  Referenced by: '<S563>/Delay'\r\n\r\n  real_T Constant_Value_nn;            // Expression: 0\r\n                                          //  Referenced by: '<S563>/Constant'\r\n\r\n  real_T Constant_Value_jd;            // Expression: 0\r\n                                          //  Referenced by: '<S569>/Constant'\r\n\r\n  real_T Constant_Value_gw;            // Expression: 6\r\n                                          //  Referenced by: '<S559>/Constant'\r\n\r\n  real_T yaw_Out_Y0_p;                 // Computed Parameter: yaw_Out_Y0_p\r\n                                          //  Referenced by: '<S561>/yaw_Out'\r\n\r\n  real_T Delay_InitialCondition_g0;    // Expression: 1\r\n                                          //  Referenced by: '<S560>/Delay'\r\n\r\n  real_T Constant_Value_ic;            // Expression: 0\r\n                                          //  Referenced by: '<S560>/Constant'\r\n\r\n  real_T ReadParameter_SampleTime;     // Expression: -1\r\n                                          //  Referenced by: '<S555>/Read Parameter'\r\n\r\n  real_T ReadParameter_SampleTime_c;   // Expression: -1\r\n                                          //  Referenced by: '<S587>/Read Parameter'\r\n\r\n  real_T ReadParameter_SampleTime_g;   // Expression: -1\r\n                                          //  Referenced by: '<S586>/Read Parameter'\r\n\r\n  real_T ReadParameter_SampleTime_n;   // Expression: -1\r\n                                          //  Referenced by: '<S596>/Read Parameter'\r\n\r\n  real_T ReadParameter1_SampleTime;    // Expression: -1\r\n                                          //  Referenced by: '<S596>/Read Parameter1'\r\n\r\n  real_T ReadParameter13_SampleTime;   // Expression: -1\r\n                                          //  Referenced by: '<S596>/Read Parameter13'\r\n\r\n  real_T ReadParameter2_SampleTime;    // Expression: -1\r\n                                          //  Referenced by: '<S596>/Read Parameter2'\r\n\r\n  real_T ReadParameter3_SampleTime;    // Expression: -1\r\n                                          //  Referenced by: '<S596>/Read Parameter3'\r\n\r\n  real_T ReadParameter4_SampleTime;    // Expression: -1\r\n                                          //  Referenced by: '<S596>/Read Parameter4'\r\n\r\n  real_T Gain_Gain_h;                  // Expression: 5\r\n                                          //  Referenced by: '<S3>/Gain'\r\n\r\n  real_T Saturation3_UpperSat;         // Expression: 1\r\n                                          //  Referenced by: '<S3>/Saturation3'\r\n\r\n  real_T Saturation3_LowerSat;         // Expression: -1\r\n                                          //  Referenced by: '<S3>/Saturation3'\r\n\r\n  real_T Gain1_Gain_e;                 // Expression: 5\r\n                                          //  Referenced by: '<S3>/Gain1'\r\n\r\n  real_T Saturation2_UpperSat;         // Expression: 1\r\n                                          //  Referenced by: '<S3>/Saturation2'\r\n\r\n  real_T Saturation2_LowerSat;         // Expression: -1\r\n                                          //  Referenced by: '<S3>/Saturation2'\r\n\r\n  real_T Gain2_Gain_h;                 // Expression: 10\r\n                                          //  Referenced by: '<S3>/Gain2'\r\n\r\n  real_T Saturation1_UpperSat;         // Expression: 1\r\n                                          //  Referenced by: '<S3>/Saturation1'\r\n\r\n  real_T Saturation1_LowerSat;         // Expression: -1\r\n                                          //  Referenced by: '<S3>/Saturation1'\r\n\r\n  real_T Saturation_UpperSat;          // Expression: 1\r\n                                          //  Referenced by: '<S3>/Saturation'\r\n\r\n  real_T Saturation_LowerSat;          // Expression: 0\r\n                                          //  Referenced by: '<S3>/Saturation'\r\n\r\n  real_T Saturation4_UpperSat;         // Expression: 1\r\n                                          //  Referenced by: '<S3>/Saturation4'\r\n\r\n  real_T Saturation4_LowerSat;         // Expression: 0\r\n                                          //  Referenced by: '<S3>/Saturation4'\r\n\r\n  real_T Gain_Gain_b;                  // Expression: 0.01\r\n                                          //  Referenced by: '<S596>/Gain'\r\n\r\n  real_T Gain1_Gain_o;                 // Expression: 0.01\r\n                                          //  Referenced by: '<S596>/Gain1'\r\n\r\n  real_T Gain2_Gain_d;                 // Expression: 0.01\r\n                                          //  Referenced by: '<S596>/Gain2'\r\n\r\n  real_T Gain3_Gain;                   // Expression: 0.01\r\n                                          //  Referenced by: '<S596>/Gain3'\r\n\r\n  real_T Gain4_Gain;                   // Expression: 0.01\r\n                                          //  Referenced by: '<S596>/Gain4'\r\n\r\n  real_T Gain5_Gain;                   // Expression: 0.01\r\n                                          //  Referenced by: '<S596>/Gain5'\r\n\r\n  real_T Constant_Value_a0;            // Expression: 0\r\n                                          //  Referenced by: '<S595>/Constant'\r\n\r\n  real_T Switch_Threshold_l;           // Expression: 0\r\n                                          //  Referenced by: '<S9>/Switch'\r\n\r\n  real_T Gain_Gain_c;                  // Expression: -1\r\n                                          //  Referenced by: '<S5>/Gain'\r\n\r\n  real_T thrust_sp_bX_Value;           // Expression: 0\r\n                                          //  Referenced by: '<S6>/thrust_sp_bX'\r\n\r\n  real_T thrust_sp_bY_Value;           // Expression: 0\r\n                                          //  Referenced by: '<S6>/thrust_sp_bY'\r\n\r\n  real_T Constant_Value_go;            // Expression: 0\r\n                                          //  Referenced by: '<S7>/Constant'\r\n\r\n  real_T thrust_sp_bX_Value_m;         // Expression: 0\r\n                                          //  Referenced by: '<S8>/thrust_sp_bX'\r\n\r\n  real_T thrust_sp_bY_Value_m;         // Expression: 0\r\n                                          //  Referenced by: '<S8>/thrust_sp_bY'\r\n\r\n  real_T Gain1_Gain_j;                 // Expression: -1\r\n                                          //  Referenced by: '<S5>/Gain1'\r\n\r\n  real_T Gain2_Gain_n;                 // Expression: -1\r\n                                          //  Referenced by: '<S5>/Gain2'\r\n\r\n  uint64_T Constant7_Value;            // Computed Parameter: Constant7_Value\r\n                                          //  Referenced by: '<S580>/Constant7'\r\n\r\n  real32_T Constant1_Value_d[2];       // Computed Parameter: Constant1_Value_d\r\n                                          //  Referenced by: '<S587>/Constant1'\r\n\r\n  real32_T Constant_Value_f2;          // Computed Parameter: Constant_Value_f2\r\n                                          //  Referenced by: '<S587>/Constant'\r\n\r\n  real32_T Gain_Gain_hp;               // Computed Parameter: Gain_Gain_hp\r\n                                          //  Referenced by: '<S586>/Gain'\r\n\r\n  real32_T Constant1_Value_k4[2];      // Computed Parameter: Constant1_Value_k4\r\n                                          //  Referenced by: '<S586>/Constant1'\r\n\r\n  real32_T Constant_Value_l4;          // Computed Parameter: Constant_Value_l4\r\n                                          //  Referenced by: '<S586>/Constant'\r\n\r\n  real32_T Constant_Value_fh[3];       // Computed Parameter: Constant_Value_fh\r\n                                          //  Referenced by: '<S580>/Constant'\r\n\r\n  real32_T Constant1_Value_h[3];       // Computed Parameter: Constant1_Value_h\r\n                                          //  Referenced by: '<S580>/Constant1'\r\n\r\n  real32_T Constant2_Value[3];         // Computed Parameter: Constant2_Value\r\n                                          //  Referenced by: '<S580>/Constant2'\r\n\r\n  real32_T Constant3_Value;            // Computed Parameter: Constant3_Value\r\n                                          //  Referenced by: '<S580>/Constant3'\r\n\r\n  real32_T Constant4_Value;            // Computed Parameter: Constant4_Value\r\n                                          //  Referenced by: '<S580>/Constant4'\r\n\r\n  boolean_T Constant5_Value;           // Computed Parameter: Constant5_Value\r\n                                          //  Referenced by: '<S578>/Constant5'\r\n\r\n  boolean_T Constant5_Value_k;         // Computed Parameter: Constant5_Value_k\r\n                                          //  Referenced by: '<S579>/Constant5'\r\n\r\n  boolean_T Constant1_Value_dl;        // Computed Parameter: Constant1_Value_dl\r\n                                          //  Referenced by: '<S581>/Constant1'\r\n\r\n  boolean_T Constant5_Value_h;         // Computed Parameter: Constant5_Value_h\r\n                                          //  Referenced by: '<S581>/Constant5'\r\n\r\n  boolean_T Constant5_Value_l;         // Computed Parameter: Constant5_Value_l\r\n                                          //  Referenced by: '<S580>/Constant5'\r\n\r\n  int8_T Constant_Value_mp;            // Computed Parameter: Constant_Value_mp\r\n                                          //  Referenced by: '<S365>/Constant'\r\n\r\n  int8_T Constant2_Value_k;            // Computed Parameter: Constant2_Value_k\r\n                                          //  Referenced by: '<S365>/Constant2'\r\n\r\n  int8_T Constant3_Value_i;            // Computed Parameter: Constant3_Value_i\r\n                                          //  Referenced by: '<S365>/Constant3'\r\n\r\n  int8_T Constant4_Value_j;            // Computed Parameter: Constant4_Value_j\r\n                                          //  Referenced by: '<S365>/Constant4'\r\n\r\n  int8_T Constant_Value_dt;            // Computed Parameter: Constant_Value_dt\r\n                                          //  Referenced by: '<S420>/Constant'\r\n\r\n  int8_T Constant2_Value_l;            // Computed Parameter: Constant2_Value_l\r\n                                          //  Referenced by: '<S420>/Constant2'\r\n\r\n  int8_T Constant3_Value_j;            // Computed Parameter: Constant3_Value_j\r\n                                          //  Referenced by: '<S420>/Constant3'\r\n\r\n  int8_T Constant4_Value_c;            // Computed Parameter: Constant4_Value_c\r\n                                          //  Referenced by: '<S420>/Constant4'\r\n\r\n  int8_T Constant_Value_d5;            // Computed Parameter: Constant_Value_d5\r\n                                          //  Referenced by: '<S472>/Constant'\r\n\r\n  int8_T Constant2_Value_e;            // Computed Parameter: Constant2_Value_e\r\n                                          //  Referenced by: '<S472>/Constant2'\r\n\r\n  int8_T Constant3_Value_k;            // Computed Parameter: Constant3_Value_k\r\n                                          //  Referenced by: '<S472>/Constant3'\r\n\r\n  int8_T Constant4_Value_n;            // Computed Parameter: Constant4_Value_n\r\n                                          //  Referenced by: '<S472>/Constant4'\r\n\r\n  int8_T Constant_Value_km;            // Computed Parameter: Constant_Value_km\r\n                                          //  Referenced by: '<S524>/Constant'\r\n\r\n  int8_T Constant2_Value_m;            // Computed Parameter: Constant2_Value_m\r\n                                          //  Referenced by: '<S524>/Constant2'\r\n\r\n  int8_T Constant3_Value_d;            // Computed Parameter: Constant3_Value_d\r\n                                          //  Referenced by: '<S524>/Constant3'\r\n\r\n  int8_T Constant4_Value_b;            // Computed Parameter: Constant4_Value_b\r\n                                          //  Referenced by: '<S524>/Constant4'\r\n\r\n  uint8_T Constant_Value_fm;           // Computed Parameter: Constant_Value_fm\r\n                                          //  Referenced by: '<S572>/Constant'\r\n\r\n  uint8_T Constant6_Value;             // Computed Parameter: Constant6_Value\r\n                                          //  Referenced by: '<S580>/Constant6'\r\n\r\n};\r\n\r\n// Real-time Model Data Structure\r\nstruct tag_RTM_SITL_HEXA_MISSION_T {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n// Block parameters (default storage)\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern P_SITL_HEXA_MISSION_T SITL_HEXA_MISSION_P;\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n\r\n// Block signals (default storage)\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern struct B_SITL_HEXA_MISSION_T SITL_HEXA_MISSION_B;\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n\r\n// Block states (default storage)\r\nextern struct DW_SITL_HEXA_MISSION_T SITL_HEXA_MISSION_DW;\r\n\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  // Model entry point functions\r\n  extern void SITL_HEXA_MISSION_initialize(void);\r\n  extern void SITL_HEXA_MISSION_step(void);\r\n  extern void SITL_HEXA_MISSION_terminate(void);\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n\r\n// Real-time Model object\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern RT_MODEL_SITL_HEXA_MISSION_T *const SITL_HEXA_MISSION_M;\r\n\r\n#ifdef __cplusplus\r\n\r\n}\r\n\r\n#endif\r\n\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n//-\r\n//  These blocks were eliminated from the model due to optimizations:\r\n//\r\n//  Block '<S189>/Data Type Duplicate' : Unused code path elimination\r\n//  Block '<S189>/Data Type Propagation' : Unused code path elimination\r\n//  Block '<S575>/Compare' : Unused code path elimination\r\n//  Block '<S575>/Constant' : Unused code path elimination\r\n//  Block '<S576>/NOT' : Unused code path elimination\r\n//  Block '<S571>/Subtract' : Unused code path elimination\r\n//  Block '<S573>/NOT' : Unused code path elimination\r\n//  Block '<S574>/NOT' : Unused code path elimination\r\n//  Block '<S597>/Compare' : Unused code path elimination\r\n//  Block '<S597>/Constant' : Unused code path elimination\r\n//  Block '<S594>/Bitwise Operator' : Unused code path elimination\r\n//  Block '<S594>/Data Type Conversion' : Unused code path elimination\r\n//  Block '<S594>/Data Type Conversion1' : Unused code path elimination\r\n//  Block '<S594>/Data Type Conversion2' : Unused code path elimination\r\n//  Block '<S594>/Gain' : Unused code path elimination\r\n//  Block '<S594>/Gain1' : Unused code path elimination\r\n//  Block '<S598>/NOT' : Unused code path elimination\r\n//  Block '<S602>/NOT' : Unused code path elimination\r\n//  Block '<S603>/NOT' : Unused code path elimination\r\n//  Block '<S604>/NOT' : Unused code path elimination\r\n//  Block '<S605>/NOT' : Unused code path elimination\r\n//  Block '<S5>/Data Type Conversion' : Eliminate redundant data type conversion\r\n//  Block '<S557>/Reshape1' : Reshape block reduction\r\n//  Block '<S4>/Data Type Conversion3' : Eliminate redundant data type conversion\r\n\r\n\r\n//-\r\n//  The generated code includes comments that allow you to trace directly\r\n//  back to the appropriate location in the model.  The basic format\r\n//  is <system>/block_name, where system is the system number (uniquely\r\n//  assigned by Simulink) and block_name is the name of the block.\r\n//\r\n//  Use the MATLAB hilite_system command to trace the generated code back\r\n//  to the model.  For example,\r\n//\r\n//  hilite_system('<S3>')    - opens system 3\r\n//  hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n//\r\n//  Here is the system hierarchy for this model\r\n//\r\n//  '<Root>' : 'SITL_HEXA_MISSION'\r\n//  '<S1>'   : 'SITL_HEXA_MISSION/CLAW'\r\n//  '<S2>'   : 'SITL_HEXA_MISSION/Navigation'\r\n//  '<S3>'   : 'SITL_HEXA_MISSION/actuatorOutputs'\r\n//  '<S4>'   : 'SITL_HEXA_MISSION/uORBInput'\r\n//  '<S5>'   : 'SITL_HEXA_MISSION/CLAW/Controller'\r\n//  '<S6>'   : 'SITL_HEXA_MISSION/CLAW/Controller/Publish vehicle_attitude_setpoint'\r\n//  '<S7>'   : 'SITL_HEXA_MISSION/CLAW/Controller/Publish vehicle_local_position_setpoint'\r\n//  '<S8>'   : 'SITL_HEXA_MISSION/CLAW/Controller/Publish vehicle_rate_setpoint'\r\n//  '<S9>'   : 'SITL_HEXA_MISSION/CLAW/Controller/Quaternion Validity Check'\r\n//  '<S10>'  : 'SITL_HEXA_MISSION/CLAW/Controller/Quaternions to Rotation Angles'\r\n//  '<S11>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller'\r\n//  '<S12>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller'\r\n//  '<S13>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller'\r\n//  '<S14>'  : 'SITL_HEXA_MISSION/CLAW/Controller/Publish vehicle_attitude_setpoint/PX4 uORB Message'\r\n//  '<S15>'  : 'SITL_HEXA_MISSION/CLAW/Controller/Publish vehicle_attitude_setpoint/PX4 uORB Write'\r\n//  '<S16>'  : 'SITL_HEXA_MISSION/CLAW/Controller/Publish vehicle_local_position_setpoint/PX4 uORB Message'\r\n//  '<S17>'  : 'SITL_HEXA_MISSION/CLAW/Controller/Publish vehicle_local_position_setpoint/PX4 uORB Write'\r\n//  '<S18>'  : 'SITL_HEXA_MISSION/CLAW/Controller/Publish vehicle_rate_setpoint/PX4 uORB Message'\r\n//  '<S19>'  : 'SITL_HEXA_MISSION/CLAW/Controller/Publish vehicle_rate_setpoint/PX4 uORB Write'\r\n//  '<S20>'  : 'SITL_HEXA_MISSION/CLAW/Controller/Quaternion Validity Check/Quaternion Norm'\r\n//  '<S21>'  : 'SITL_HEXA_MISSION/CLAW/Controller/Quaternions to Rotation Angles/Angle Calculation'\r\n//  '<S22>'  : 'SITL_HEXA_MISSION/CLAW/Controller/Quaternions to Rotation Angles/Quaternion Normalize'\r\n//  '<S23>'  : 'SITL_HEXA_MISSION/CLAW/Controller/Quaternions to Rotation Angles/Angle Calculation/Protect asincos input'\r\n//  '<S24>'  : 'SITL_HEXA_MISSION/CLAW/Controller/Quaternions to Rotation Angles/Angle Calculation/Protect asincos input/If Action Subsystem'\r\n//  '<S25>'  : 'SITL_HEXA_MISSION/CLAW/Controller/Quaternions to Rotation Angles/Angle Calculation/Protect asincos input/If Action Subsystem1'\r\n//  '<S26>'  : 'SITL_HEXA_MISSION/CLAW/Controller/Quaternions to Rotation Angles/Angle Calculation/Protect asincos input/If Action Subsystem2'\r\n//  '<S27>'  : 'SITL_HEXA_MISSION/CLAW/Controller/Quaternions to Rotation Angles/Quaternion Normalize/Quaternion Modulus'\r\n//  '<S28>'  : 'SITL_HEXA_MISSION/CLAW/Controller/Quaternions to Rotation Angles/Quaternion Normalize/Quaternion Modulus/Quaternion Norm'\r\n//  '<S29>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/Calculate minimum Turn'\r\n//  '<S30>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3'\r\n//  '<S31>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4'\r\n//  '<S32>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5'\r\n//  '<S33>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Anti-windup'\r\n//  '<S34>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/D Gain'\r\n//  '<S35>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/External Derivative'\r\n//  '<S36>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Filter'\r\n//  '<S37>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Filter ICs'\r\n//  '<S38>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/I Gain'\r\n//  '<S39>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Ideal P Gain'\r\n//  '<S40>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Ideal P Gain Fdbk'\r\n//  '<S41>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Integrator'\r\n//  '<S42>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Integrator ICs'\r\n//  '<S43>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/N Copy'\r\n//  '<S44>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/N Gain'\r\n//  '<S45>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/P Copy'\r\n//  '<S46>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Parallel P Gain'\r\n//  '<S47>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Reset Signal'\r\n//  '<S48>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Saturation'\r\n//  '<S49>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Saturation Fdbk'\r\n//  '<S50>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Sum'\r\n//  '<S51>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Sum Fdbk'\r\n//  '<S52>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Tracking Mode'\r\n//  '<S53>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Tracking Mode Sum'\r\n//  '<S54>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Tsamp - Integral'\r\n//  '<S55>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Tsamp - Ngain'\r\n//  '<S56>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/postSat Signal'\r\n//  '<S57>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/preSat Signal'\r\n//  '<S58>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Anti-windup/Disabled'\r\n//  '<S59>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/D Gain/Disabled'\r\n//  '<S60>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/External Derivative/Disabled'\r\n//  '<S61>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Filter/Disabled'\r\n//  '<S62>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Filter ICs/Disabled'\r\n//  '<S63>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/I Gain/Disabled'\r\n//  '<S64>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Ideal P Gain/Passthrough'\r\n//  '<S65>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Ideal P Gain Fdbk/Disabled'\r\n//  '<S66>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Integrator/Disabled'\r\n//  '<S67>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Integrator ICs/Disabled'\r\n//  '<S68>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/N Copy/Disabled wSignal Specification'\r\n//  '<S69>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/N Gain/Disabled'\r\n//  '<S70>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/P Copy/Disabled'\r\n//  '<S71>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Parallel P Gain/Internal Parameters'\r\n//  '<S72>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Reset Signal/Disabled'\r\n//  '<S73>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Saturation/Passthrough'\r\n//  '<S74>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Saturation Fdbk/Disabled'\r\n//  '<S75>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Sum/Passthrough_P'\r\n//  '<S76>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Sum Fdbk/Disabled'\r\n//  '<S77>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Tracking Mode/Disabled'\r\n//  '<S78>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Tracking Mode Sum/Passthrough'\r\n//  '<S79>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Tsamp - Integral/TsSignalSpecification'\r\n//  '<S80>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/Tsamp - Ngain/Passthrough'\r\n//  '<S81>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/postSat Signal/Forward_Path'\r\n//  '<S82>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller3/preSat Signal/Forward_Path'\r\n//  '<S83>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Anti-windup'\r\n//  '<S84>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/D Gain'\r\n//  '<S85>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/External Derivative'\r\n//  '<S86>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Filter'\r\n//  '<S87>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Filter ICs'\r\n//  '<S88>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/I Gain'\r\n//  '<S89>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Ideal P Gain'\r\n//  '<S90>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Ideal P Gain Fdbk'\r\n//  '<S91>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Integrator'\r\n//  '<S92>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Integrator ICs'\r\n//  '<S93>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/N Copy'\r\n//  '<S94>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/N Gain'\r\n//  '<S95>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/P Copy'\r\n//  '<S96>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Parallel P Gain'\r\n//  '<S97>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Reset Signal'\r\n//  '<S98>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Saturation'\r\n//  '<S99>'  : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Saturation Fdbk'\r\n//  '<S100>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Sum'\r\n//  '<S101>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Sum Fdbk'\r\n//  '<S102>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Tracking Mode'\r\n//  '<S103>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Tracking Mode Sum'\r\n//  '<S104>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Tsamp - Integral'\r\n//  '<S105>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Tsamp - Ngain'\r\n//  '<S106>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/postSat Signal'\r\n//  '<S107>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/preSat Signal'\r\n//  '<S108>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Anti-windup/Disabled'\r\n//  '<S109>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/D Gain/Disabled'\r\n//  '<S110>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/External Derivative/Disabled'\r\n//  '<S111>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Filter/Disabled'\r\n//  '<S112>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Filter ICs/Disabled'\r\n//  '<S113>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/I Gain/Disabled'\r\n//  '<S114>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Ideal P Gain/Passthrough'\r\n//  '<S115>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Ideal P Gain Fdbk/Disabled'\r\n//  '<S116>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Integrator/Disabled'\r\n//  '<S117>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Integrator ICs/Disabled'\r\n//  '<S118>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/N Copy/Disabled wSignal Specification'\r\n//  '<S119>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/N Gain/Disabled'\r\n//  '<S120>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/P Copy/Disabled'\r\n//  '<S121>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Parallel P Gain/Internal Parameters'\r\n//  '<S122>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Reset Signal/Disabled'\r\n//  '<S123>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Saturation/Passthrough'\r\n//  '<S124>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Saturation Fdbk/Disabled'\r\n//  '<S125>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Sum/Passthrough_P'\r\n//  '<S126>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Sum Fdbk/Disabled'\r\n//  '<S127>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Tracking Mode/Disabled'\r\n//  '<S128>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Tracking Mode Sum/Passthrough'\r\n//  '<S129>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Tsamp - Integral/TsSignalSpecification'\r\n//  '<S130>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/Tsamp - Ngain/Passthrough'\r\n//  '<S131>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/postSat Signal/Forward_Path'\r\n//  '<S132>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller4/preSat Signal/Forward_Path'\r\n//  '<S133>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Anti-windup'\r\n//  '<S134>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/D Gain'\r\n//  '<S135>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/External Derivative'\r\n//  '<S136>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Filter'\r\n//  '<S137>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Filter ICs'\r\n//  '<S138>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/I Gain'\r\n//  '<S139>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Ideal P Gain'\r\n//  '<S140>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Ideal P Gain Fdbk'\r\n//  '<S141>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Integrator'\r\n//  '<S142>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Integrator ICs'\r\n//  '<S143>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/N Copy'\r\n//  '<S144>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/N Gain'\r\n//  '<S145>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/P Copy'\r\n//  '<S146>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Parallel P Gain'\r\n//  '<S147>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Reset Signal'\r\n//  '<S148>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Saturation'\r\n//  '<S149>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Saturation Fdbk'\r\n//  '<S150>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Sum'\r\n//  '<S151>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Sum Fdbk'\r\n//  '<S152>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Tracking Mode'\r\n//  '<S153>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Tracking Mode Sum'\r\n//  '<S154>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Tsamp - Integral'\r\n//  '<S155>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Tsamp - Ngain'\r\n//  '<S156>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/postSat Signal'\r\n//  '<S157>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/preSat Signal'\r\n//  '<S158>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Anti-windup/Disabled'\r\n//  '<S159>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/D Gain/Disabled'\r\n//  '<S160>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/External Derivative/Disabled'\r\n//  '<S161>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Filter/Disabled'\r\n//  '<S162>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Filter ICs/Disabled'\r\n//  '<S163>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/I Gain/Disabled'\r\n//  '<S164>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Ideal P Gain/Passthrough'\r\n//  '<S165>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Ideal P Gain Fdbk/Disabled'\r\n//  '<S166>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Integrator/Disabled'\r\n//  '<S167>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Integrator ICs/Disabled'\r\n//  '<S168>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/N Copy/Disabled wSignal Specification'\r\n//  '<S169>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/N Gain/Disabled'\r\n//  '<S170>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/P Copy/Disabled'\r\n//  '<S171>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Parallel P Gain/Internal Parameters'\r\n//  '<S172>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Reset Signal/Disabled'\r\n//  '<S173>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Saturation/Enabled'\r\n//  '<S174>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Saturation Fdbk/Disabled'\r\n//  '<S175>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Sum/Passthrough_P'\r\n//  '<S176>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Sum Fdbk/Disabled'\r\n//  '<S177>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Tracking Mode/Disabled'\r\n//  '<S178>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Tracking Mode Sum/Passthrough'\r\n//  '<S179>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Tsamp - Integral/TsSignalSpecification'\r\n//  '<S180>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/Tsamp - Ngain/Passthrough'\r\n//  '<S181>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/postSat Signal/Forward_Path'\r\n//  '<S182>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_att_controller/PID Controller5/preSat Signal/Forward_Path'\r\n//  '<S183>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/Altitude Signal conditioning'\r\n//  '<S184>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/Calculate Transformation Matrix'\r\n//  '<S185>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller'\r\n//  '<S186>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1'\r\n//  '<S187>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude'\r\n//  '<S188>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz'\r\n//  '<S189>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/Altitude Signal conditioning/Saturation Dynamic'\r\n//  '<S190>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Anti-windup'\r\n//  '<S191>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/D Gain'\r\n//  '<S192>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/External Derivative'\r\n//  '<S193>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Filter'\r\n//  '<S194>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Filter ICs'\r\n//  '<S195>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/I Gain'\r\n//  '<S196>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Ideal P Gain'\r\n//  '<S197>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Ideal P Gain Fdbk'\r\n//  '<S198>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Integrator'\r\n//  '<S199>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Integrator ICs'\r\n//  '<S200>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/N Copy'\r\n//  '<S201>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/N Gain'\r\n//  '<S202>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/P Copy'\r\n//  '<S203>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Parallel P Gain'\r\n//  '<S204>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Reset Signal'\r\n//  '<S205>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Saturation'\r\n//  '<S206>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Saturation Fdbk'\r\n//  '<S207>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Sum'\r\n//  '<S208>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Sum Fdbk'\r\n//  '<S209>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Tracking Mode'\r\n//  '<S210>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Tracking Mode Sum'\r\n//  '<S211>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Tsamp - Integral'\r\n//  '<S212>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Tsamp - Ngain'\r\n//  '<S213>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/postSat Signal'\r\n//  '<S214>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/preSat Signal'\r\n//  '<S215>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Anti-windup/Disabled'\r\n//  '<S216>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/D Gain/Disabled'\r\n//  '<S217>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/External Derivative/Disabled'\r\n//  '<S218>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Filter/Disabled'\r\n//  '<S219>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Filter ICs/Disabled'\r\n//  '<S220>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/I Gain/Disabled'\r\n//  '<S221>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Ideal P Gain/Passthrough'\r\n//  '<S222>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Ideal P Gain Fdbk/Disabled'\r\n//  '<S223>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Integrator/Disabled'\r\n//  '<S224>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Integrator ICs/Disabled'\r\n//  '<S225>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/N Copy/Disabled wSignal Specification'\r\n//  '<S226>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/N Gain/Disabled'\r\n//  '<S227>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/P Copy/Disabled'\r\n//  '<S228>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Parallel P Gain/Internal Parameters'\r\n//  '<S229>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Reset Signal/Disabled'\r\n//  '<S230>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Saturation/Enabled'\r\n//  '<S231>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Saturation Fdbk/Disabled'\r\n//  '<S232>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Sum/Passthrough_P'\r\n//  '<S233>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Sum Fdbk/Disabled'\r\n//  '<S234>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Tracking Mode/Disabled'\r\n//  '<S235>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Tracking Mode Sum/Passthrough'\r\n//  '<S236>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Tsamp - Integral/TsSignalSpecification'\r\n//  '<S237>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/Tsamp - Ngain/Passthrough'\r\n//  '<S238>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/postSat Signal/Forward_Path'\r\n//  '<S239>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller/preSat Signal/Forward_Path'\r\n//  '<S240>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Anti-windup'\r\n//  '<S241>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/D Gain'\r\n//  '<S242>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/External Derivative'\r\n//  '<S243>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Filter'\r\n//  '<S244>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Filter ICs'\r\n//  '<S245>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/I Gain'\r\n//  '<S246>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Ideal P Gain'\r\n//  '<S247>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Ideal P Gain Fdbk'\r\n//  '<S248>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Integrator'\r\n//  '<S249>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Integrator ICs'\r\n//  '<S250>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/N Copy'\r\n//  '<S251>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/N Gain'\r\n//  '<S252>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/P Copy'\r\n//  '<S253>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Parallel P Gain'\r\n//  '<S254>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Reset Signal'\r\n//  '<S255>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Saturation'\r\n//  '<S256>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Saturation Fdbk'\r\n//  '<S257>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Sum'\r\n//  '<S258>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Sum Fdbk'\r\n//  '<S259>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Tracking Mode'\r\n//  '<S260>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Tracking Mode Sum'\r\n//  '<S261>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Tsamp - Integral'\r\n//  '<S262>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Tsamp - Ngain'\r\n//  '<S263>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/postSat Signal'\r\n//  '<S264>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/preSat Signal'\r\n//  '<S265>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Anti-windup/Disabled'\r\n//  '<S266>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/D Gain/Disabled'\r\n//  '<S267>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/External Derivative/Disabled'\r\n//  '<S268>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Filter/Disabled'\r\n//  '<S269>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Filter ICs/Disabled'\r\n//  '<S270>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/I Gain/Disabled'\r\n//  '<S271>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Ideal P Gain/Passthrough'\r\n//  '<S272>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Ideal P Gain Fdbk/Disabled'\r\n//  '<S273>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Integrator/Disabled'\r\n//  '<S274>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Integrator ICs/Disabled'\r\n//  '<S275>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/N Copy/Disabled wSignal Specification'\r\n//  '<S276>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/N Gain/Disabled'\r\n//  '<S277>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/P Copy/Disabled'\r\n//  '<S278>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Parallel P Gain/Internal Parameters'\r\n//  '<S279>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Reset Signal/Disabled'\r\n//  '<S280>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Saturation/Enabled'\r\n//  '<S281>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Saturation Fdbk/Disabled'\r\n//  '<S282>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Sum/Passthrough_P'\r\n//  '<S283>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Sum Fdbk/Disabled'\r\n//  '<S284>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Tracking Mode/Disabled'\r\n//  '<S285>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Tracking Mode Sum/Passthrough'\r\n//  '<S286>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Tsamp - Integral/TsSignalSpecification'\r\n//  '<S287>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/Tsamp - Ngain/Passthrough'\r\n//  '<S288>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/postSat Signal/Forward_Path'\r\n//  '<S289>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID Controller1/preSat Signal/Forward_Path'\r\n//  '<S290>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Anti-windup'\r\n//  '<S291>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/D Gain'\r\n//  '<S292>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/External Derivative'\r\n//  '<S293>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Filter'\r\n//  '<S294>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Filter ICs'\r\n//  '<S295>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/I Gain'\r\n//  '<S296>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Ideal P Gain'\r\n//  '<S297>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Ideal P Gain Fdbk'\r\n//  '<S298>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Integrator'\r\n//  '<S299>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Integrator ICs'\r\n//  '<S300>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/N Copy'\r\n//  '<S301>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/N Gain'\r\n//  '<S302>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/P Copy'\r\n//  '<S303>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Parallel P Gain'\r\n//  '<S304>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Reset Signal'\r\n//  '<S305>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Saturation'\r\n//  '<S306>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Saturation Fdbk'\r\n//  '<S307>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Sum'\r\n//  '<S308>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Sum Fdbk'\r\n//  '<S309>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Tracking Mode'\r\n//  '<S310>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Tracking Mode Sum'\r\n//  '<S311>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Tsamp - Integral'\r\n//  '<S312>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Tsamp - Ngain'\r\n//  '<S313>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/postSat Signal'\r\n//  '<S314>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/preSat Signal'\r\n//  '<S315>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Anti-windup/Disabled'\r\n//  '<S316>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/D Gain/Disabled'\r\n//  '<S317>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/External Derivative/Disabled'\r\n//  '<S318>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Filter/Disabled'\r\n//  '<S319>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Filter ICs/Disabled'\r\n//  '<S320>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/I Gain/Disabled'\r\n//  '<S321>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Ideal P Gain/Passthrough'\r\n//  '<S322>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Ideal P Gain Fdbk/Disabled'\r\n//  '<S323>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Integrator/Disabled'\r\n//  '<S324>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Integrator ICs/Disabled'\r\n//  '<S325>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/N Copy/Disabled wSignal Specification'\r\n//  '<S326>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/N Gain/Disabled'\r\n//  '<S327>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/P Copy/Disabled'\r\n//  '<S328>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Parallel P Gain/Internal Parameters'\r\n//  '<S329>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Reset Signal/Disabled'\r\n//  '<S330>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Saturation/Enabled'\r\n//  '<S331>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Saturation Fdbk/Disabled'\r\n//  '<S332>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Sum/Passthrough_P'\r\n//  '<S333>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Sum Fdbk/Disabled'\r\n//  '<S334>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Tracking Mode/Disabled'\r\n//  '<S335>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Tracking Mode Sum/Passthrough'\r\n//  '<S336>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Tsamp - Integral/TsSignalSpecification'\r\n//  '<S337>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/Tsamp - Ngain/Passthrough'\r\n//  '<S338>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/postSat Signal/Forward_Path'\r\n//  '<S339>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_Altitude/preSat Signal/Forward_Path'\r\n//  '<S340>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Anti-windup'\r\n//  '<S341>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/D Gain'\r\n//  '<S342>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/External Derivative'\r\n//  '<S343>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Filter'\r\n//  '<S344>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Filter ICs'\r\n//  '<S345>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/I Gain'\r\n//  '<S346>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Ideal P Gain'\r\n//  '<S347>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Ideal P Gain Fdbk'\r\n//  '<S348>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Integrator'\r\n//  '<S349>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Integrator ICs'\r\n//  '<S350>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/N Copy'\r\n//  '<S351>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/N Gain'\r\n//  '<S352>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/P Copy'\r\n//  '<S353>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Parallel P Gain'\r\n//  '<S354>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Reset Signal'\r\n//  '<S355>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Saturation'\r\n//  '<S356>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Saturation Fdbk'\r\n//  '<S357>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Sum'\r\n//  '<S358>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Sum Fdbk'\r\n//  '<S359>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Tracking Mode'\r\n//  '<S360>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Tracking Mode Sum'\r\n//  '<S361>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Tsamp - Integral'\r\n//  '<S362>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Tsamp - Ngain'\r\n//  '<S363>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/postSat Signal'\r\n//  '<S364>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/preSat Signal'\r\n//  '<S365>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Anti-windup/Disc. Clamping Parallel'\r\n//  '<S366>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n//  '<S367>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n//  '<S368>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/D Gain/Internal Parameters'\r\n//  '<S369>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/External Derivative/Error'\r\n//  '<S370>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Filter/Disc. Forward Euler Filter'\r\n//  '<S371>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Filter ICs/Internal IC - Filter'\r\n//  '<S372>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/I Gain/Internal Parameters'\r\n//  '<S373>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Ideal P Gain/Passthrough'\r\n//  '<S374>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Ideal P Gain Fdbk/Passthrough'\r\n//  '<S375>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Integrator/Discrete'\r\n//  '<S376>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Integrator ICs/Internal IC'\r\n//  '<S377>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/N Copy/Disabled'\r\n//  '<S378>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/N Gain/Internal Parameters'\r\n//  '<S379>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/P Copy/Disabled'\r\n//  '<S380>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Parallel P Gain/Internal Parameters'\r\n//  '<S381>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Reset Signal/Disabled'\r\n//  '<S382>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Saturation/Enabled'\r\n//  '<S383>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Saturation Fdbk/Passthrough'\r\n//  '<S384>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Sum/Sum_PID'\r\n//  '<S385>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Sum Fdbk/Enabled'\r\n//  '<S386>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Tracking Mode/Disabled'\r\n//  '<S387>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Tracking Mode Sum/Passthrough'\r\n//  '<S388>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Tsamp - Integral/TsSignalSpecification'\r\n//  '<S389>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/Tsamp - Ngain/Passthrough'\r\n//  '<S390>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/postSat Signal/Feedback_Path'\r\n//  '<S391>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_pos_controller/PID_vz/preSat Signal/Feedback_Path'\r\n//  '<S392>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller'\r\n//  '<S393>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1'\r\n//  '<S394>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2'\r\n//  '<S395>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Anti-windup'\r\n//  '<S396>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/D Gain'\r\n//  '<S397>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/External Derivative'\r\n//  '<S398>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Filter'\r\n//  '<S399>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Filter ICs'\r\n//  '<S400>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/I Gain'\r\n//  '<S401>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Ideal P Gain'\r\n//  '<S402>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Ideal P Gain Fdbk'\r\n//  '<S403>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Integrator'\r\n//  '<S404>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Integrator ICs'\r\n//  '<S405>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/N Copy'\r\n//  '<S406>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/N Gain'\r\n//  '<S407>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/P Copy'\r\n//  '<S408>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Parallel P Gain'\r\n//  '<S409>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Reset Signal'\r\n//  '<S410>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Saturation'\r\n//  '<S411>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Saturation Fdbk'\r\n//  '<S412>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Sum'\r\n//  '<S413>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Sum Fdbk'\r\n//  '<S414>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Tracking Mode'\r\n//  '<S415>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Tracking Mode Sum'\r\n//  '<S416>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Tsamp - Integral'\r\n//  '<S417>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Tsamp - Ngain'\r\n//  '<S418>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/postSat Signal'\r\n//  '<S419>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/preSat Signal'\r\n//  '<S420>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Anti-windup/Disc. Clamping Parallel'\r\n//  '<S421>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n//  '<S422>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n//  '<S423>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/D Gain/Internal Parameters'\r\n//  '<S424>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/External Derivative/Error'\r\n//  '<S425>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Filter/Disc. Forward Euler Filter'\r\n//  '<S426>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Filter ICs/Internal IC - Filter'\r\n//  '<S427>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/I Gain/Internal Parameters'\r\n//  '<S428>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Ideal P Gain/Passthrough'\r\n//  '<S429>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Ideal P Gain Fdbk/Disabled'\r\n//  '<S430>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Integrator/Discrete'\r\n//  '<S431>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Integrator ICs/Internal IC'\r\n//  '<S432>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/N Copy/Disabled'\r\n//  '<S433>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/N Gain/Internal Parameters'\r\n//  '<S434>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/P Copy/Disabled'\r\n//  '<S435>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Parallel P Gain/Internal Parameters'\r\n//  '<S436>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Reset Signal/Disabled'\r\n//  '<S437>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Saturation/Enabled'\r\n//  '<S438>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Saturation Fdbk/Disabled'\r\n//  '<S439>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Sum/Sum_PID'\r\n//  '<S440>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Sum Fdbk/Disabled'\r\n//  '<S441>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Tracking Mode/Disabled'\r\n//  '<S442>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Tracking Mode Sum/Passthrough'\r\n//  '<S443>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Tsamp - Integral/TsSignalSpecification'\r\n//  '<S444>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/Tsamp - Ngain/Passthrough'\r\n//  '<S445>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/postSat Signal/Forward_Path'\r\n//  '<S446>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller/preSat Signal/Forward_Path'\r\n//  '<S447>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Anti-windup'\r\n//  '<S448>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/D Gain'\r\n//  '<S449>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/External Derivative'\r\n//  '<S450>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Filter'\r\n//  '<S451>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Filter ICs'\r\n//  '<S452>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/I Gain'\r\n//  '<S453>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Ideal P Gain'\r\n//  '<S454>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Ideal P Gain Fdbk'\r\n//  '<S455>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Integrator'\r\n//  '<S456>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Integrator ICs'\r\n//  '<S457>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/N Copy'\r\n//  '<S458>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/N Gain'\r\n//  '<S459>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/P Copy'\r\n//  '<S460>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Parallel P Gain'\r\n//  '<S461>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Reset Signal'\r\n//  '<S462>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Saturation'\r\n//  '<S463>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Saturation Fdbk'\r\n//  '<S464>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Sum'\r\n//  '<S465>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Sum Fdbk'\r\n//  '<S466>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Tracking Mode'\r\n//  '<S467>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Tracking Mode Sum'\r\n//  '<S468>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Tsamp - Integral'\r\n//  '<S469>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Tsamp - Ngain'\r\n//  '<S470>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/postSat Signal'\r\n//  '<S471>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/preSat Signal'\r\n//  '<S472>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Anti-windup/Disc. Clamping Parallel'\r\n//  '<S473>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n//  '<S474>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n//  '<S475>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/D Gain/Internal Parameters'\r\n//  '<S476>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/External Derivative/Error'\r\n//  '<S477>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Filter/Disc. Forward Euler Filter'\r\n//  '<S478>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Filter ICs/Internal IC - Filter'\r\n//  '<S479>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/I Gain/Internal Parameters'\r\n//  '<S480>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Ideal P Gain/Passthrough'\r\n//  '<S481>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Ideal P Gain Fdbk/Disabled'\r\n//  '<S482>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Integrator/Discrete'\r\n//  '<S483>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Integrator ICs/Internal IC'\r\n//  '<S484>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/N Copy/Disabled'\r\n//  '<S485>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/N Gain/Internal Parameters'\r\n//  '<S486>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/P Copy/Disabled'\r\n//  '<S487>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Parallel P Gain/Internal Parameters'\r\n//  '<S488>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Reset Signal/Disabled'\r\n//  '<S489>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Saturation/Enabled'\r\n//  '<S490>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Saturation Fdbk/Disabled'\r\n//  '<S491>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Sum/Sum_PID'\r\n//  '<S492>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Sum Fdbk/Disabled'\r\n//  '<S493>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Tracking Mode/Disabled'\r\n//  '<S494>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Tracking Mode Sum/Passthrough'\r\n//  '<S495>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Tsamp - Integral/TsSignalSpecification'\r\n//  '<S496>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/Tsamp - Ngain/Passthrough'\r\n//  '<S497>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/postSat Signal/Forward_Path'\r\n//  '<S498>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller1/preSat Signal/Forward_Path'\r\n//  '<S499>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Anti-windup'\r\n//  '<S500>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/D Gain'\r\n//  '<S501>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/External Derivative'\r\n//  '<S502>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Filter'\r\n//  '<S503>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Filter ICs'\r\n//  '<S504>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/I Gain'\r\n//  '<S505>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Ideal P Gain'\r\n//  '<S506>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Ideal P Gain Fdbk'\r\n//  '<S507>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Integrator'\r\n//  '<S508>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Integrator ICs'\r\n//  '<S509>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/N Copy'\r\n//  '<S510>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/N Gain'\r\n//  '<S511>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/P Copy'\r\n//  '<S512>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Parallel P Gain'\r\n//  '<S513>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Reset Signal'\r\n//  '<S514>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Saturation'\r\n//  '<S515>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Saturation Fdbk'\r\n//  '<S516>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Sum'\r\n//  '<S517>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Sum Fdbk'\r\n//  '<S518>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Tracking Mode'\r\n//  '<S519>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Tracking Mode Sum'\r\n//  '<S520>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Tsamp - Integral'\r\n//  '<S521>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Tsamp - Ngain'\r\n//  '<S522>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/postSat Signal'\r\n//  '<S523>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/preSat Signal'\r\n//  '<S524>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Anti-windup/Disc. Clamping Parallel'\r\n//  '<S525>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Anti-windup/Disc. Clamping Parallel/Dead Zone'\r\n//  '<S526>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\r\n//  '<S527>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/D Gain/Internal Parameters'\r\n//  '<S528>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/External Derivative/Error'\r\n//  '<S529>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Filter/Disc. Forward Euler Filter'\r\n//  '<S530>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Filter ICs/Internal IC - Filter'\r\n//  '<S531>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/I Gain/Internal Parameters'\r\n//  '<S532>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Ideal P Gain/Passthrough'\r\n//  '<S533>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Ideal P Gain Fdbk/Disabled'\r\n//  '<S534>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Integrator/Discrete'\r\n//  '<S535>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Integrator ICs/Internal IC'\r\n//  '<S536>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/N Copy/Disabled'\r\n//  '<S537>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/N Gain/Internal Parameters'\r\n//  '<S538>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/P Copy/Disabled'\r\n//  '<S539>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Parallel P Gain/Internal Parameters'\r\n//  '<S540>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Reset Signal/Disabled'\r\n//  '<S541>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Saturation/Enabled'\r\n//  '<S542>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Saturation Fdbk/Disabled'\r\n//  '<S543>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Sum/Sum_PID'\r\n//  '<S544>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Sum Fdbk/Disabled'\r\n//  '<S545>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Tracking Mode/Disabled'\r\n//  '<S546>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Tracking Mode Sum/Passthrough'\r\n//  '<S547>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Tsamp - Integral/TsSignalSpecification'\r\n//  '<S548>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/Tsamp - Ngain/Passthrough'\r\n//  '<S549>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/postSat Signal/Forward_Path'\r\n//  '<S550>' : 'SITL_HEXA_MISSION/CLAW/Controller/mc_rate_controller/PID Controller2/preSat Signal/Forward_Path'\r\n//  '<S551>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm'\r\n//  '<S552>' : 'SITL_HEXA_MISSION/Navigation/uORB Publish'\r\n//  '<S553>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission'\r\n//  '<S554>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Guidance Subsystem'\r\n//  '<S555>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC'\r\n//  '<S556>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Guidance Subsystem/IDLE'\r\n//  '<S557>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Guidance Subsystem/Land'\r\n//  '<S558>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Guidance Subsystem/Take-off'\r\n//  '<S559>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Guidance Subsystem/Waypoint'\r\n//  '<S560>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Guidance Subsystem/IDLE/Maintain Current Yaw during IDLE'\r\n//  '<S561>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Guidance Subsystem/IDLE/Maintain Current Yaw during IDLE/Enabled Subsystem2'\r\n//  '<S562>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Guidance Subsystem/Land/Ensure Smooth descend during Land'\r\n//  '<S563>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Guidance Subsystem/Land/Maintain Current Yaw during Land'\r\n//  '<S564>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Guidance Subsystem/Land/Ensure Smooth descend during Land/Enabled Subsystem'\r\n//  '<S565>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Guidance Subsystem/Land/Maintain Current Yaw during Land/Enabled Subsystem2'\r\n//  '<S566>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Guidance Subsystem/Take-off/Ensure smooth ascend during Takeoff'\r\n//  '<S567>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Guidance Subsystem/Take-off/Maintain Current Yaw during TakeOff'\r\n//  '<S568>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Guidance Subsystem/Take-off/Maintain Current Yaw during TakeOff/Enabled Subsystem2'\r\n//  '<S569>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Guidance Subsystem/Waypoint/Output signal conditioning'\r\n//  '<S570>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Guidance Subsystem/Waypoint/Output signal conditioning/Compare To Constant'\r\n//  '<S571>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/Read waypoints from OBC'\r\n//  '<S572>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/Send waypoints to OBC'\r\n//  '<S573>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/homePositionRead'\r\n//  '<S574>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/positionSetpointRead'\r\n//  '<S575>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/Read waypoints from OBC/Compare To Constant'\r\n//  '<S576>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/Read waypoints from OBC/PX4 uORB Read'\r\n//  '<S577>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/Read waypoints from OBC/PX4 uORB Read/Enabled Subsystem'\r\n//  '<S578>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/Send waypoints to OBC/Current_Type_Adapted_WayPoint'\r\n//  '<S579>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/Send waypoints to OBC/Current_WayPoint'\r\n//  '<S580>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/Send waypoints to OBC/Empty_WayPoint'\r\n//  '<S581>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/Send waypoints to OBC/Next_WayPoint'\r\n//  '<S582>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/Send waypoints to OBC/PX4 uORB Message'\r\n//  '<S583>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/Send waypoints to OBC/PX4 uORB Write'\r\n//  '<S584>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/Send waypoints to OBC/Current_Type_Adapted_WayPoint/Convert_to_type_adapted_WP'\r\n//  '<S585>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/Send waypoints to OBC/Current_Type_Adapted_WayPoint/Convert_to_type_adapted_WP/If Action Subsystem'\r\n//  '<S586>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/Send waypoints to OBC/Current_Type_Adapted_WayPoint/Convert_to_type_adapted_WP/If Action Subsystem1'\r\n//  '<S587>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/Send waypoints to OBC/Current_Type_Adapted_WayPoint/Convert_to_type_adapted_WP/If Action Subsystem2'\r\n//  '<S588>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/homePositionRead/Enabled Subsystem'\r\n//  '<S589>' : 'SITL_HEXA_MISSION/Navigation/Quadcopter Navigation Algorithm/Read waypoint from QGroundControl Mission/Read Position Setpoint from Mission set in QGC/positionSetpointRead/Enabled Subsystem'\r\n//  '<S590>' : 'SITL_HEXA_MISSION/Navigation/uORB Publish/PX4 uORB Message'\r\n//  '<S591>' : 'SITL_HEXA_MISSION/Navigation/uORB Publish/PX4 uORB Write'\r\n//  '<S592>' : 'SITL_HEXA_MISSION/actuatorOutputs/Fault Injection Module'\r\n//  '<S593>' : 'SITL_HEXA_MISSION/actuatorOutputs/MATLAB Function'\r\n//  '<S594>' : 'SITL_HEXA_MISSION/actuatorOutputs/Radio Control Transmitter'\r\n//  '<S595>' : 'SITL_HEXA_MISSION/actuatorOutputs/uORB_actuator_outputs'\r\n//  '<S596>' : 'SITL_HEXA_MISSION/actuatorOutputs/Fault Injection Module/Fault_Injection_SIL'\r\n//  '<S597>' : 'SITL_HEXA_MISSION/actuatorOutputs/Fault Injection Module/Fault_Injection_SIL/Compare To Constant'\r\n//  '<S598>' : 'SITL_HEXA_MISSION/actuatorOutputs/Radio Control Transmitter/PX4 uORB Read'\r\n//  '<S599>' : 'SITL_HEXA_MISSION/actuatorOutputs/Radio Control Transmitter/PX4 uORB Read/Enabled Subsystem'\r\n//  '<S600>' : 'SITL_HEXA_MISSION/actuatorOutputs/uORB_actuator_outputs/PX4 uORB Message'\r\n//  '<S601>' : 'SITL_HEXA_MISSION/actuatorOutputs/uORB_actuator_outputs/PX4 uORB Write'\r\n//  '<S602>' : 'SITL_HEXA_MISSION/uORBInput/PX4 uORB Read1'\r\n//  '<S603>' : 'SITL_HEXA_MISSION/uORBInput/PX4 uORB Read2'\r\n//  '<S604>' : 'SITL_HEXA_MISSION/uORBInput/vehicle_attitude'\r\n//  '<S605>' : 'SITL_HEXA_MISSION/uORBInput/vehicle_local_pos'\r\n//  '<S606>' : 'SITL_HEXA_MISSION/uORBInput/PX4 uORB Read1/Enabled Subsystem'\r\n//  '<S607>' : 'SITL_HEXA_MISSION/uORBInput/PX4 uORB Read2/Enabled Subsystem'\r\n//  '<S608>' : 'SITL_HEXA_MISSION/uORBInput/vehicle_attitude/Enabled Subsystem'\r\n//  '<S609>' : 'SITL_HEXA_MISSION/uORBInput/vehicle_local_pos/Enabled Subsystem'\r\n\r\n#endif                                 // SITL_HEXA_MISSION_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"SITL_HEXA_MISSION_private.h","type":"header","group":"model","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: SITL_HEXA_MISSION_private.h\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef SITL_HEXA_MISSION_private_h_\r\n#define SITL_HEXA_MISSION_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"SITL_HEXA_MISSION_types.h\"\r\n#ifndef PORTABLE_WORDSIZES\r\n#ifndef UCHAR_MAX\r\n#include <limits.h>\r\n#endif\r\n\r\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\r\n#error Code was generated for compiler with different sized uchar/char. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized ushort/short. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( UINT_MAX != (0xFFFFFFFFU) ) || ( INT_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized uint/int. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( ULONG_MAX != (0xFFFFFFFFU) ) || ( LONG_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized ulong/long. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n// Skipping ulong_long/long_long check: insufficient preprocessor integer range. \r\n#endif                                 // PORTABLE_WORDSIZES\r\n\r\nextern real_T rt_remd_snf(real_T u0, real_T u1);\r\nextern real_T rt_atan2d_snf(real_T u0, real_T u1);\r\n\r\n#endif                                 // SITL_HEXA_MISSION_private_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"SITL_HEXA_MISSION_types.h","type":"header","group":"model","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: SITL_HEXA_MISSION_types.h\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef SITL_HEXA_MISSION_types_h_\r\n#define SITL_HEXA_MISSION_types_h_\r\n#include \"rtwtypes.h\"\r\n#include \"MW_Parameter.h\"\r\n#include <uORB/topics/vehicle_attitude_setpoint.h>\r\n#include <uORB/topics/vehicle_local_position_setpoint.h>\r\n#include <uORB/topics/vehicle_rates_setpoint.h>\r\n#include <uORB/topics/trajectory_waypoint.h>\r\n#include <uORB/topics/vehicle_trajectory_waypoint.h>\r\n#include <uORB/topics/home_position.h>\r\n#include <uORB/topics/position_setpoint.h>\r\n#include <uORB/topics/position_setpoint_triplet.h>\r\n#include <uORB/topics/input_rc.h>\r\n#include <uORB/topics/actuator_motors.h>\r\n#include <uORB/topics/vehicle_angular_velocity.h>\r\n#include <uORB/topics/actuator_armed.h>\r\n#include <uORB/topics/vehicle_attitude.h>\r\n#include <uORB/topics/vehicle_local_position.h>\r\n#ifndef struct_b_px4_internal_block_SampleTimeImpl_SITL_HEXA_MISSION_T\r\n#define struct_b_px4_internal_block_SampleTimeImpl_SITL_HEXA_MISSION_T\r\n\r\nstruct b_px4_internal_block_SampleTimeImpl_SITL_HEXA_MISSION_T\r\n{\r\n  int32_T __dummy;\r\n};\r\n\r\n#endif        // struct_b_px4_internal_block_SampleTimeImpl_SITL_HEXA_MISSION_T\r\n\r\n#ifndef struct_px4_internal_block_getPX4AbsoluteTime_SITL_HEXA_MISSION_T\r\n#define struct_px4_internal_block_getPX4AbsoluteTime_SITL_HEXA_MISSION_T\r\n\r\nstruct px4_internal_block_getPX4AbsoluteTime_SITL_HEXA_MISSION_T\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  b_px4_internal_block_SampleTimeImpl_SITL_HEXA_MISSION_T SampleTimeHandler;\r\n};\r\n\r\n#endif      // struct_px4_internal_block_getPX4AbsoluteTime_SITL_HEXA_MISSION_T\r\n\r\n#ifndef struct_px4_internal_block_Publisher_SITL_HEXA_MISSION_T\r\n#define struct_px4_internal_block_Publisher_SITL_HEXA_MISSION_T\r\n\r\nstruct px4_internal_block_Publisher_SITL_HEXA_MISSION_T\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  orb_advert_t orbAdvertiseObj;\r\n  orb_metadata_t * orbMetadataObj;\r\n};\r\n\r\n#endif               // struct_px4_internal_block_Publisher_SITL_HEXA_MISSION_T\r\n\r\n#ifndef struct_px4_internal_block_LLA2LocalCoordinatesNED_SITL_HEXA_MISSION_T\r\n#define struct_px4_internal_block_LLA2LocalCoordinatesNED_SITL_HEXA_MISSION_T\r\n\r\nstruct px4_internal_block_LLA2LocalCoordinatesNED_SITL_HEXA_MISSION_T\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  boolean_T isSetupComplete;\r\n};\r\n\r\n#endif // struct_px4_internal_block_LLA2LocalCoordinatesNED_SITL_HEXA_MISSION_T\r\n\r\n#ifndef struct_px4_internal_block_LLA2LocalCoordinates_SITL_HEXA_MISSION_T\r\n#define struct_px4_internal_block_LLA2LocalCoordinates_SITL_HEXA_MISSION_T\r\n\r\nstruct px4_internal_block_LLA2LocalCoordinates_SITL_HEXA_MISSION_T\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  boolean_T previousValidReceived;\r\n  boolean_T nextValidReceived;\r\n};\r\n\r\n#endif    // struct_px4_internal_block_LLA2LocalCoordinates_SITL_HEXA_MISSION_T\r\n\r\n// Custom Type definition for MATLABSystem: '<S586>/Read Parameter'\r\n#include \"MW_Parameter.h\"\r\n#ifndef struct_px4_internal_block_ParameterUpdate_SITL_HEXA_MISSION_T\r\n#define struct_px4_internal_block_ParameterUpdate_SITL_HEXA_MISSION_T\r\n\r\nstruct px4_internal_block_ParameterUpdate_SITL_HEXA_MISSION_T\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  real_T SampleTime;\r\n  MW_Param_Handle MW_PARAMHANDLE;\r\n};\r\n\r\n#endif         // struct_px4_internal_block_ParameterUpdate_SITL_HEXA_MISSION_T\r\n\r\n#ifndef struct_cell_wrap_SITL_HEXA_MISSION_T\r\n#define struct_cell_wrap_SITL_HEXA_MISSION_T\r\n\r\nstruct cell_wrap_SITL_HEXA_MISSION_T\r\n{\r\n  uint32_T f1[8];\r\n};\r\n\r\n#endif                                 // struct_cell_wrap_SITL_HEXA_MISSION_T\r\n\r\n#ifndef struct_uav_sluav_internal_system_WaypointFollower_SITL_HEXA_MISSION_T\r\n#define struct_uav_sluav_internal_system_WaypointFollower_SITL_HEXA_MISSION_T\r\n\r\nstruct uav_sluav_internal_system_WaypointFollower_SITL_HEXA_MISSION_T\r\n{\r\n  int32_T isInitialized;\r\n  cell_wrap_SITL_HEXA_MISSION_T inputVarSize[3];\r\n  real_T LookaheadDistance;\r\n  real_T WaypointIndex;\r\n  real_T NumWaypoints;\r\n  real_T WaypointsInternal[9];\r\n  boolean_T LastWaypointFlag;\r\n  boolean_T StartFlag;\r\n  real_T InitialPose[4];\r\n  real_T LookaheadFactor;\r\n  uint8_T LookaheadDistFlag;\r\n};\r\n\r\n#endif // struct_uav_sluav_internal_system_WaypointFollower_SITL_HEXA_MISSION_T\r\n\r\n#ifndef struct_px4_internal_block_Subscriber_SITL_HEXA_MISSION_T\r\n#define struct_px4_internal_block_Subscriber_SITL_HEXA_MISSION_T\r\n\r\nstruct px4_internal_block_Subscriber_SITL_HEXA_MISSION_T\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  b_px4_internal_block_SampleTimeImpl_SITL_HEXA_MISSION_T SampleTimeHandler;\r\n  pollfd_t eventStructObj;\r\n  orb_metadata_t * orbMetadataObj;\r\n};\r\n\r\n#endif              // struct_px4_internal_block_Subscriber_SITL_HEXA_MISSION_T\r\n\r\n// Parameters (default storage)\r\ntypedef struct P_SITL_HEXA_MISSION_T_ P_SITL_HEXA_MISSION_T;\r\n\r\n// Forward declaration for rtModel\r\ntypedef struct tag_RTM_SITL_HEXA_MISSION_T RT_MODEL_SITL_HEXA_MISSION_T;\r\n\r\n#endif                                 // SITL_HEXA_MISSION_types_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"Navigation.cpp","type":"source","group":"subsystem","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: Navigation.cpp\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#include \"Navigation.h\"\r\n#include \"rtwtypes.h\"\r\n#include <math.h>\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#include \"SITL_HEXA_MISSION_private.h\"\r\n#include <string.h>\r\n#include \"rt_sys_SITL_HEXA_MISSION_0.h\"\r\n#include \"rt_sys_SITL_HEXA_MISSION_2.h\"\r\n#include \"SITL_HEXA_MISSION.h\"\r\n#include <float.h>\r\n#include \"rt_defines.h\"\r\n\r\n// Forward declaration for local functions\r\nstatic real_T SITL_HEXA_MISSION_sind(real_T x);\r\n\r\n// Forward declaration for local functions\r\nstatic real_T SITL_HEXA_MISSION_rt_remd_snf(real_T u0, real_T u1);\r\nstatic real_T SITL_HEXA_MISSION_sind_d(real_T x);\r\nstatic real_T SITL_HEXA_MISSION_rt_atan2d_snf(real_T u0, real_T u1);\r\nstatic void SITL_HEXA_MISSION_lla2ned(const real_T lla[3], const real_T lla0[3],\r\n  real_T xyzNED[3]);\r\nstatic real_T SITL_HEXA_MISSION_norm(const real_T x[3]);\r\nreal_T rt_remd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  if (rtIsNaN(u0) || rtIsNaN(u1) || rtIsInf(u0)) {\r\n    y = (rtNaN);\r\n  } else if (rtIsInf(u1)) {\r\n    y = u0;\r\n  } else {\r\n    real_T q;\r\n    if (u1 < 0.0) {\r\n      q = ceil(u1);\r\n    } else {\r\n      q = floor(u1);\r\n    }\r\n\r\n    if ((u1 != 0.0) && (u1 != q)) {\r\n      q = fabs(u0 / u1);\r\n      if (!(fabs(q - floor(q + 0.5)) > DBL_EPSILON * q)) {\r\n        y = 0.0 * u0;\r\n      } else {\r\n        y = fmod(u0, u1);\r\n      }\r\n    } else {\r\n      y = fmod(u0, u1);\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\nstatic real_T SITL_HEXA_MISSION_sind(real_T x)\r\n{\r\n  real_T absx;\r\n  real_T b_x;\r\n\r\n  // Start for MATLABSystem: '<S578>/MATLAB System'\r\n  if (rtIsInf(x) || rtIsNaN(x)) {\r\n    b_x = (rtNaN);\r\n  } else {\r\n    b_x = rt_remd_snf(x, 360.0);\r\n    absx = fabs(b_x);\r\n    if (absx > 180.0) {\r\n      if (b_x > 0.0) {\r\n        b_x -= 360.0;\r\n      } else {\r\n        b_x += 360.0;\r\n      }\r\n\r\n      absx = fabs(b_x);\r\n    }\r\n\r\n    if (absx <= 45.0) {\r\n      b_x *= 0.017453292519943295;\r\n      b_x = sin(b_x);\r\n    } else if (absx <= 135.0) {\r\n      if (b_x > 0.0) {\r\n        b_x = (b_x - 90.0) * 0.017453292519943295;\r\n        b_x = cos(b_x);\r\n      } else {\r\n        b_x = (b_x + 90.0) * 0.017453292519943295;\r\n        b_x = -cos(b_x);\r\n      }\r\n    } else {\r\n      if (b_x > 0.0) {\r\n        b_x = (b_x - 180.0) * 0.017453292519943295;\r\n      } else {\r\n        b_x = (b_x + 180.0) * 0.017453292519943295;\r\n      }\r\n\r\n      b_x = -sin(b_x);\r\n    }\r\n  }\r\n\r\n  // End of Start for MATLABSystem: '<S578>/MATLAB System'\r\n  return b_x;\r\n}\r\n\r\nreal_T rt_atan2d_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\r\n    y = (rtNaN);\r\n  } else if (rtIsInf(u0) && rtIsInf(u1)) {\r\n    int32_T tmp;\r\n    int32_T tmp_0;\r\n    if (u0 > 0.0) {\r\n      tmp = 1;\r\n    } else {\r\n      tmp = -1;\r\n    }\r\n\r\n    if (u1 > 0.0) {\r\n      tmp_0 = 1;\r\n    } else {\r\n      tmp_0 = -1;\r\n    }\r\n\r\n    y = atan2(static_cast<real_T>(tmp), static_cast<real_T>(tmp_0));\r\n  } else if (u1 == 0.0) {\r\n    if (u0 > 0.0) {\r\n      y = RT_PI / 2.0;\r\n    } else if (u0 < 0.0) {\r\n      y = -(RT_PI / 2.0);\r\n    } else {\r\n      y = 0.0;\r\n    }\r\n  } else {\r\n    y = atan2(u0, u1);\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n// System initialize for atomic system:\r\nvoid SITL_HEXA_MISSION_MATLABSystem_Init(DW_MATLABSystem_SITL_HEXA_MISSION_T\r\n  *localDW)\r\n{\r\n  // Start for MATLABSystem: '<S578>/MATLAB System'\r\n  localDW->obj.matlabCodegenIsDeleted = false;\r\n  localDW->objisempty = true;\r\n  localDW->obj.isSetupComplete = true;\r\n}\r\n\r\n// Output and update for atomic system:\r\nvoid SITL_HEXA_MISSION_MATLABSystem(const real_T rtu_0[3], const real_T rtu_1[3],\r\n  boolean_T rtu_2, uint8_T rtu_3, B_MATLABSystem_SITL_HEXA_MISSION_T *localB)\r\n{\r\n  real_T absx;\r\n  real_T dLon;\r\n  real_T flat;\r\n  real_T flat_tmp;\r\n  real_T r;\r\n  int32_T b_k;\r\n  boolean_T b[3];\r\n  boolean_T exitg1;\r\n  boolean_T latp2;\r\n\r\n  // MATLABSystem: '<S578>/MATLAB System'\r\n  if (rtu_2 && (rtu_3 != 5)) {\r\n    localB->dLat = rtu_0[0] - rtu_1[0];\r\n    dLon = rtu_0[1] - rtu_1[1];\r\n    flat = fabs(localB->dLat);\r\n    if (flat > 180.0) {\r\n      if (rtIsNaN(localB->dLat + 180.0) || rtIsInf(localB->dLat + 180.0)) {\r\n        r = (rtNaN);\r\n      } else if (localB->dLat + 180.0 == 0.0) {\r\n        r = 0.0;\r\n      } else {\r\n        r = fmod(localB->dLat + 180.0, 360.0);\r\n        if (r == 0.0) {\r\n          r = 0.0;\r\n        } else if (localB->dLat + 180.0 < 0.0) {\r\n          r += 360.0;\r\n        }\r\n      }\r\n\r\n      localB->dLat = localB->dLat * 0.0 + (r - 180.0);\r\n      flat = fabs(localB->dLat);\r\n    }\r\n\r\n    if (flat > 90.0) {\r\n      flat = fabs(localB->dLat);\r\n      latp2 = (flat > 90.0);\r\n      dLon += 180.0;\r\n      r = localB->dLat * static_cast<real_T>(latp2);\r\n      if (rtIsNaN(r)) {\r\n        r = (rtNaN);\r\n      } else if (r < 0.0) {\r\n        r = -1.0;\r\n      } else {\r\n        r = (r > 0.0);\r\n      }\r\n\r\n      localB->dLat = (90.0 - (flat * static_cast<real_T>(latp2) - 90.0)) * r *\r\n        static_cast<real_T>(latp2) + localB->dLat * static_cast<real_T>(!latp2);\r\n    }\r\n\r\n    if ((dLon > 180.0) || (dLon < -180.0)) {\r\n      flat = rt_remd_snf(dLon, 360.0);\r\n      r = flat / 180.0;\r\n      if (r < 0.0) {\r\n        r = ceil(r);\r\n      } else {\r\n        r = floor(r);\r\n      }\r\n\r\n      dLon = (flat - 360.0 * r) + dLon * 0.0;\r\n    }\r\n\r\n    flat = SITL_HEXA_MISSION_sind(rtu_1[0]);\r\n    flat_tmp = 1.0 - 0.0066943799901413165 * flat * flat;\r\n    flat = 6.378137E+6 / sqrt(flat_tmp);\r\n    if (rtIsInf(rtu_1[0]) || rtIsNaN(rtu_1[0])) {\r\n      r = (rtNaN);\r\n    } else {\r\n      r = rt_remd_snf(rtu_1[0], 360.0);\r\n      absx = fabs(r);\r\n      if (absx > 180.0) {\r\n        if (r > 0.0) {\r\n          r -= 360.0;\r\n        } else {\r\n          r += 360.0;\r\n        }\r\n\r\n        absx = fabs(r);\r\n      }\r\n\r\n      if (absx <= 45.0) {\r\n        r = cos(0.017453292519943295 * r);\r\n      } else if (absx <= 135.0) {\r\n        if (r > 0.0) {\r\n          r = -sin((r - 90.0) * 0.017453292519943295);\r\n        } else {\r\n          r = sin((r + 90.0) * 0.017453292519943295);\r\n        }\r\n      } else {\r\n        if (r > 0.0) {\r\n          r = (r - 180.0) * 0.017453292519943295;\r\n        } else {\r\n          r = (r + 180.0) * 0.017453292519943295;\r\n        }\r\n\r\n        r = -cos(r);\r\n      }\r\n    }\r\n\r\n    localB->dLat /= rt_atan2d_snf(1.0, 0.99330562000985867 / flat_tmp * flat) *\r\n      57.295779513082323;\r\n    dLon /= rt_atan2d_snf(1.0, flat * r) * 57.295779513082323;\r\n    flat = -rtu_0[2] + rtu_1[2];\r\n    b[0] = rtIsNaN(localB->dLat);\r\n    b[1] = rtIsNaN(dLon);\r\n    b[2] = rtIsNaN(flat);\r\n    latp2 = false;\r\n    b_k = 0;\r\n    exitg1 = false;\r\n    while ((!exitg1) && (b_k < 3)) {\r\n      if (b[b_k]) {\r\n        latp2 = true;\r\n        exitg1 = true;\r\n      } else {\r\n        b_k++;\r\n      }\r\n    }\r\n\r\n    r = 0.0 / static_cast<real_T>(!latp2);\r\n\r\n    // MATLABSystem: '<S578>/MATLAB System'\r\n    localB->MATLABSystem[0] = static_cast<real32_T>(r + localB->dLat);\r\n    localB->MATLABSystem[1] = static_cast<real32_T>(r + dLon);\r\n    localB->MATLABSystem[2] = static_cast<real32_T>(r + flat);\r\n  } else {\r\n    // MATLABSystem: '<S578>/MATLAB System'\r\n    localB->MATLABSystem[0] = 0.0F;\r\n    localB->MATLABSystem[1] = 0.0F;\r\n    localB->MATLABSystem[2] = 0.0F;\r\n  }\r\n\r\n  // End of MATLABSystem: '<S578>/MATLAB System'\r\n}\r\n\r\n// Termination for atomic system:\r\nvoid SITL_HEXA_MISSION_MATLABSystem_Term(DW_MATLABSystem_SITL_HEXA_MISSION_T\r\n  *localDW)\r\n{\r\n  // Terminate for MATLABSystem: '<S578>/MATLAB System'\r\n  if (!localDW->obj.matlabCodegenIsDeleted) {\r\n    localDW->obj.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S578>/MATLAB System'\r\n}\r\n\r\nstatic real_T SITL_HEXA_MISSION_rt_remd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  if (rtIsNaN(u0) || rtIsNaN(u1) || rtIsInf(u0)) {\r\n    y = (rtNaN);\r\n  } else if (rtIsInf(u1)) {\r\n    y = u0;\r\n  } else {\r\n    if (u1 < 0.0) {\r\n      SITL_HEXA_MISSION_B.q = ceil(u1);\r\n    } else {\r\n      SITL_HEXA_MISSION_B.q = floor(u1);\r\n    }\r\n\r\n    if ((u1 != 0.0) && (u1 != SITL_HEXA_MISSION_B.q)) {\r\n      SITL_HEXA_MISSION_B.q = fabs(u0 / u1);\r\n      if (!(fabs(SITL_HEXA_MISSION_B.q - floor(SITL_HEXA_MISSION_B.q + 0.5)) >\r\n            DBL_EPSILON * SITL_HEXA_MISSION_B.q)) {\r\n        y = 0.0 * u0;\r\n      } else {\r\n        y = fmod(u0, u1);\r\n      }\r\n    } else {\r\n      y = fmod(u0, u1);\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\nstatic real_T SITL_HEXA_MISSION_sind_d(real_T x)\r\n{\r\n  real_T b_x;\r\n\r\n  // Start for MATLABSystem: '<S555>/LLA2LocalCoordinates' incorporates:\r\n  //   MATLABSystem: '<S581>/MATLAB System'\r\n\r\n  if (rtIsInf(x) || rtIsNaN(x)) {\r\n    b_x = (rtNaN);\r\n  } else {\r\n    b_x = SITL_HEXA_MISSION_rt_remd_snf(x, 360.0);\r\n    SITL_HEXA_MISSION_B.absx_cx = fabs(b_x);\r\n    if (SITL_HEXA_MISSION_B.absx_cx > 180.0) {\r\n      if (b_x > 0.0) {\r\n        b_x -= 360.0;\r\n      } else {\r\n        b_x += 360.0;\r\n      }\r\n\r\n      SITL_HEXA_MISSION_B.absx_cx = fabs(b_x);\r\n    }\r\n\r\n    if (SITL_HEXA_MISSION_B.absx_cx <= 45.0) {\r\n      b_x *= 0.017453292519943295;\r\n      b_x = sin(b_x);\r\n    } else if (SITL_HEXA_MISSION_B.absx_cx <= 135.0) {\r\n      if (b_x > 0.0) {\r\n        b_x = (b_x - 90.0) * 0.017453292519943295;\r\n        b_x = cos(b_x);\r\n      } else {\r\n        b_x = (b_x + 90.0) * 0.017453292519943295;\r\n        b_x = -cos(b_x);\r\n      }\r\n    } else {\r\n      if (b_x > 0.0) {\r\n        b_x = (b_x - 180.0) * 0.017453292519943295;\r\n      } else {\r\n        b_x = (b_x + 180.0) * 0.017453292519943295;\r\n      }\r\n\r\n      b_x = -sin(b_x);\r\n    }\r\n  }\r\n\r\n  // End of Start for MATLABSystem: '<S555>/LLA2LocalCoordinates'\r\n  return b_x;\r\n}\r\n\r\nstatic real_T SITL_HEXA_MISSION_rt_atan2d_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\r\n    y = (rtNaN);\r\n  } else if (rtIsInf(u0) && rtIsInf(u1)) {\r\n    if (u0 > 0.0) {\r\n      SITL_HEXA_MISSION_B.i = 1;\r\n    } else {\r\n      SITL_HEXA_MISSION_B.i = -1;\r\n    }\r\n\r\n    if (u1 > 0.0) {\r\n      SITL_HEXA_MISSION_B.i1_c = 1;\r\n    } else {\r\n      SITL_HEXA_MISSION_B.i1_c = -1;\r\n    }\r\n\r\n    y = atan2(static_cast<real_T>(SITL_HEXA_MISSION_B.i), static_cast<real_T>\r\n              (SITL_HEXA_MISSION_B.i1_c));\r\n  } else if (u1 == 0.0) {\r\n    if (u0 > 0.0) {\r\n      y = RT_PI / 2.0;\r\n    } else if (u0 < 0.0) {\r\n      y = -(RT_PI / 2.0);\r\n    } else {\r\n      y = 0.0;\r\n    }\r\n  } else {\r\n    y = atan2(u0, u1);\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\nstatic void SITL_HEXA_MISSION_lla2ned(const real_T lla[3], const real_T lla0[3],\r\n  real_T xyzNED[3])\r\n{\r\n  boolean_T exitg1;\r\n\r\n  // Start for MATLABSystem: '<S555>/LLA2LocalCoordinates'\r\n  SITL_HEXA_MISSION_B.dLat = lla[0] - lla0[0];\r\n  SITL_HEXA_MISSION_B.dLon = lla[1] - lla0[1];\r\n  SITL_HEXA_MISSION_B.flat_m = fabs(SITL_HEXA_MISSION_B.dLat);\r\n  if (SITL_HEXA_MISSION_B.flat_m > 180.0) {\r\n    // Start for MATLABSystem: '<S555>/LLA2LocalCoordinates'\r\n    if (rtIsNaN(SITL_HEXA_MISSION_B.dLat + 180.0) || rtIsInf\r\n        (SITL_HEXA_MISSION_B.dLat + 180.0)) {\r\n      SITL_HEXA_MISSION_B.r_k = (rtNaN);\r\n    } else if (SITL_HEXA_MISSION_B.dLat + 180.0 == 0.0) {\r\n      SITL_HEXA_MISSION_B.r_k = 0.0;\r\n    } else {\r\n      SITL_HEXA_MISSION_B.r_k = fmod(SITL_HEXA_MISSION_B.dLat + 180.0, 360.0);\r\n      if (SITL_HEXA_MISSION_B.r_k == 0.0) {\r\n        SITL_HEXA_MISSION_B.r_k = 0.0;\r\n      } else if (SITL_HEXA_MISSION_B.dLat + 180.0 < 0.0) {\r\n        SITL_HEXA_MISSION_B.r_k += 360.0;\r\n      }\r\n    }\r\n\r\n    SITL_HEXA_MISSION_B.dLat = SITL_HEXA_MISSION_B.dLat * 0.0 +\r\n      (SITL_HEXA_MISSION_B.r_k - 180.0);\r\n    SITL_HEXA_MISSION_B.flat_m = fabs(SITL_HEXA_MISSION_B.dLat);\r\n  }\r\n\r\n  if (SITL_HEXA_MISSION_B.flat_m > 90.0) {\r\n    // Start for MATLABSystem: '<S555>/LLA2LocalCoordinates'\r\n    SITL_HEXA_MISSION_B.flat_m = fabs(SITL_HEXA_MISSION_B.dLat);\r\n    SITL_HEXA_MISSION_B.latp2_f = (SITL_HEXA_MISSION_B.flat_m > 90.0);\r\n\r\n    // Start for MATLABSystem: '<S555>/LLA2LocalCoordinates'\r\n    SITL_HEXA_MISSION_B.dLon += 180.0;\r\n    SITL_HEXA_MISSION_B.r_k = SITL_HEXA_MISSION_B.dLat * static_cast<real_T>\r\n      (SITL_HEXA_MISSION_B.latp2_f);\r\n    if (rtIsNaN(SITL_HEXA_MISSION_B.r_k)) {\r\n      SITL_HEXA_MISSION_B.r_k = (rtNaN);\r\n    } else if (SITL_HEXA_MISSION_B.r_k < 0.0) {\r\n      SITL_HEXA_MISSION_B.r_k = -1.0;\r\n    } else {\r\n      SITL_HEXA_MISSION_B.r_k = (SITL_HEXA_MISSION_B.r_k > 0.0);\r\n    }\r\n\r\n    SITL_HEXA_MISSION_B.dLat = (90.0 - (SITL_HEXA_MISSION_B.flat_m *\r\n      static_cast<real_T>(SITL_HEXA_MISSION_B.latp2_f) - 90.0)) *\r\n      SITL_HEXA_MISSION_B.r_k * static_cast<real_T>(SITL_HEXA_MISSION_B.latp2_f)\r\n      + SITL_HEXA_MISSION_B.dLat * static_cast<real_T>\r\n      (!SITL_HEXA_MISSION_B.latp2_f);\r\n  }\r\n\r\n  // Start for MATLABSystem: '<S555>/LLA2LocalCoordinates'\r\n  if ((SITL_HEXA_MISSION_B.dLon > 180.0) || (SITL_HEXA_MISSION_B.dLon < -180.0))\r\n  {\r\n    SITL_HEXA_MISSION_B.flat_m = SITL_HEXA_MISSION_rt_remd_snf\r\n      (SITL_HEXA_MISSION_B.dLon, 360.0);\r\n    SITL_HEXA_MISSION_B.r_k = SITL_HEXA_MISSION_B.flat_m / 180.0;\r\n    if (SITL_HEXA_MISSION_B.r_k < 0.0) {\r\n      SITL_HEXA_MISSION_B.r_k = ceil(SITL_HEXA_MISSION_B.r_k);\r\n    } else {\r\n      SITL_HEXA_MISSION_B.r_k = floor(SITL_HEXA_MISSION_B.r_k);\r\n    }\r\n\r\n    SITL_HEXA_MISSION_B.dLon = (SITL_HEXA_MISSION_B.flat_m - 360.0 *\r\n      SITL_HEXA_MISSION_B.r_k) + SITL_HEXA_MISSION_B.dLon * 0.0;\r\n  }\r\n\r\n  SITL_HEXA_MISSION_B.flat_m = SITL_HEXA_MISSION_sind_d(lla0[0]);\r\n  SITL_HEXA_MISSION_B.flat_tmp = 1.0 - 0.0066943799901413165 *\r\n    SITL_HEXA_MISSION_B.flat_m * SITL_HEXA_MISSION_B.flat_m;\r\n  SITL_HEXA_MISSION_B.flat_m = 6.378137E+6 / sqrt(SITL_HEXA_MISSION_B.flat_tmp);\r\n  if (rtIsInf(lla0[0]) || rtIsNaN(lla0[0])) {\r\n    SITL_HEXA_MISSION_B.r_k = (rtNaN);\r\n  } else {\r\n    SITL_HEXA_MISSION_B.r_k = SITL_HEXA_MISSION_rt_remd_snf(lla0[0], 360.0);\r\n    SITL_HEXA_MISSION_B.absx_c = fabs(SITL_HEXA_MISSION_B.r_k);\r\n    if (SITL_HEXA_MISSION_B.absx_c > 180.0) {\r\n      if (SITL_HEXA_MISSION_B.r_k > 0.0) {\r\n        SITL_HEXA_MISSION_B.r_k -= 360.0;\r\n      } else {\r\n        SITL_HEXA_MISSION_B.r_k += 360.0;\r\n      }\r\n\r\n      SITL_HEXA_MISSION_B.absx_c = fabs(SITL_HEXA_MISSION_B.r_k);\r\n    }\r\n\r\n    if (SITL_HEXA_MISSION_B.absx_c <= 45.0) {\r\n      SITL_HEXA_MISSION_B.r_k = cos(0.017453292519943295 *\r\n        SITL_HEXA_MISSION_B.r_k);\r\n    } else if (SITL_HEXA_MISSION_B.absx_c <= 135.0) {\r\n      if (SITL_HEXA_MISSION_B.r_k > 0.0) {\r\n        SITL_HEXA_MISSION_B.r_k = -sin((SITL_HEXA_MISSION_B.r_k - 90.0) *\r\n          0.017453292519943295);\r\n      } else {\r\n        SITL_HEXA_MISSION_B.r_k = sin((SITL_HEXA_MISSION_B.r_k + 90.0) *\r\n          0.017453292519943295);\r\n      }\r\n    } else {\r\n      if (SITL_HEXA_MISSION_B.r_k > 0.0) {\r\n        SITL_HEXA_MISSION_B.r_k = (SITL_HEXA_MISSION_B.r_k - 180.0) *\r\n          0.017453292519943295;\r\n      } else {\r\n        SITL_HEXA_MISSION_B.r_k = (SITL_HEXA_MISSION_B.r_k + 180.0) *\r\n          0.017453292519943295;\r\n      }\r\n\r\n      SITL_HEXA_MISSION_B.r_k = -cos(SITL_HEXA_MISSION_B.r_k);\r\n    }\r\n  }\r\n\r\n  xyzNED[0] = SITL_HEXA_MISSION_B.dLat / (SITL_HEXA_MISSION_rt_atan2d_snf(1.0,\r\n    0.99330562000985867 / SITL_HEXA_MISSION_B.flat_tmp *\r\n    SITL_HEXA_MISSION_B.flat_m) * 57.295779513082323);\r\n  xyzNED[1] = SITL_HEXA_MISSION_B.dLon / (SITL_HEXA_MISSION_rt_atan2d_snf(1.0,\r\n    SITL_HEXA_MISSION_B.flat_m * SITL_HEXA_MISSION_B.r_k) * 57.295779513082323);\r\n  xyzNED[2] = -lla[2] + lla0[2];\r\n  SITL_HEXA_MISSION_B.b[0] = rtIsNaN(xyzNED[0]);\r\n  SITL_HEXA_MISSION_B.b[1] = rtIsNaN(xyzNED[1]);\r\n  SITL_HEXA_MISSION_B.b[2] = rtIsNaN(xyzNED[2]);\r\n  SITL_HEXA_MISSION_B.latp2_f = false;\r\n  SITL_HEXA_MISSION_B.b_k = 0;\r\n  exitg1 = false;\r\n  while ((!exitg1) && (SITL_HEXA_MISSION_B.b_k < 3)) {\r\n    if (SITL_HEXA_MISSION_B.b[SITL_HEXA_MISSION_B.b_k]) {\r\n      SITL_HEXA_MISSION_B.latp2_f = true;\r\n      exitg1 = true;\r\n    } else {\r\n      SITL_HEXA_MISSION_B.b_k++;\r\n    }\r\n  }\r\n\r\n  // Start for MATLABSystem: '<S555>/LLA2LocalCoordinates'\r\n  SITL_HEXA_MISSION_B.dLat = 0.0 / static_cast<real_T>\r\n    (!SITL_HEXA_MISSION_B.latp2_f);\r\n  xyzNED[0] += SITL_HEXA_MISSION_B.dLat;\r\n  xyzNED[1] += SITL_HEXA_MISSION_B.dLat;\r\n  xyzNED[2] += SITL_HEXA_MISSION_B.dLat;\r\n}\r\n\r\nstatic real_T SITL_HEXA_MISSION_norm(const real_T x[3])\r\n{\r\n  real_T y;\r\n  SITL_HEXA_MISSION_B.scale = 3.3121686421112381E-170;\r\n\r\n  // Start for MATLABSystem: '<S559>/UAV Waypoint Follower'\r\n  SITL_HEXA_MISSION_B.absxk = fabs(x[0]);\r\n  if (SITL_HEXA_MISSION_B.absxk > 3.3121686421112381E-170) {\r\n    y = 1.0;\r\n    SITL_HEXA_MISSION_B.scale = SITL_HEXA_MISSION_B.absxk;\r\n  } else {\r\n    SITL_HEXA_MISSION_B.t = SITL_HEXA_MISSION_B.absxk / 3.3121686421112381E-170;\r\n    y = SITL_HEXA_MISSION_B.t * SITL_HEXA_MISSION_B.t;\r\n  }\r\n\r\n  // Start for MATLABSystem: '<S559>/UAV Waypoint Follower'\r\n  SITL_HEXA_MISSION_B.absxk = fabs(x[1]);\r\n  if (SITL_HEXA_MISSION_B.absxk > SITL_HEXA_MISSION_B.scale) {\r\n    SITL_HEXA_MISSION_B.t = SITL_HEXA_MISSION_B.scale /\r\n      SITL_HEXA_MISSION_B.absxk;\r\n    y = y * SITL_HEXA_MISSION_B.t * SITL_HEXA_MISSION_B.t + 1.0;\r\n    SITL_HEXA_MISSION_B.scale = SITL_HEXA_MISSION_B.absxk;\r\n  } else {\r\n    SITL_HEXA_MISSION_B.t = SITL_HEXA_MISSION_B.absxk /\r\n      SITL_HEXA_MISSION_B.scale;\r\n    y += SITL_HEXA_MISSION_B.t * SITL_HEXA_MISSION_B.t;\r\n  }\r\n\r\n  // Start for MATLABSystem: '<S559>/UAV Waypoint Follower'\r\n  SITL_HEXA_MISSION_B.absxk = fabs(x[2]);\r\n  if (SITL_HEXA_MISSION_B.absxk > SITL_HEXA_MISSION_B.scale) {\r\n    SITL_HEXA_MISSION_B.t = SITL_HEXA_MISSION_B.scale /\r\n      SITL_HEXA_MISSION_B.absxk;\r\n    y = y * SITL_HEXA_MISSION_B.t * SITL_HEXA_MISSION_B.t + 1.0;\r\n    SITL_HEXA_MISSION_B.scale = SITL_HEXA_MISSION_B.absxk;\r\n  } else {\r\n    SITL_HEXA_MISSION_B.t = SITL_HEXA_MISSION_B.absxk /\r\n      SITL_HEXA_MISSION_B.scale;\r\n    y += SITL_HEXA_MISSION_B.t * SITL_HEXA_MISSION_B.t;\r\n  }\r\n\r\n  return SITL_HEXA_MISSION_B.scale * sqrt(y);\r\n}\r\n\r\n// System initialize for atomic system: '<Root>/Navigation'\r\nvoid SITL_HEXA_MISSION_Navigation_Init(void)\r\n{\r\n  static const char_T ParameterNameStr[15] = \"MPC_LAND_SPEED\";\r\n  static const char_T ParameterNameStr_0[14] = \"MPC_TKO_SPEED\";\r\n  static const char_T ParameterNameStr_1[14] = \"COM_OBS_AVOID\";\r\n  real_T tmp;\r\n\r\n  // Start for If: '<S554>/If'\r\n  SITL_HEXA_MISSION_DW.If_ActiveSubsystem = -1;\r\n\r\n  // SystemInitialize for Enabled SubSystem: '<S576>/Enabled Subsystem'\r\n  // SystemInitialize for SignalConversion generated from: '<S577>/In1' incorporates:\r\n  //   Outport: '<S577>/Out1'\r\n\r\n  SITL_HEXA_MISSION_B.In1 = SITL_HEXA_MISSION_P.Out1_Y0;\r\n\r\n  // End of SystemInitialize for SubSystem: '<S576>/Enabled Subsystem'\r\n\r\n  // SystemInitialize for Enabled SubSystem: '<S574>/Enabled Subsystem'\r\n  // SystemInitialize for SignalConversion generated from: '<S589>/In1' incorporates:\r\n  //   Outport: '<S589>/Out1'\r\n\r\n  SITL_HEXA_MISSION_B.In1_p = SITL_HEXA_MISSION_P.Out1_Y0_h;\r\n\r\n  // End of SystemInitialize for SubSystem: '<S574>/Enabled Subsystem'\r\n\r\n  // SystemInitialize for Enabled SubSystem: '<S573>/Enabled Subsystem'\r\n  // SystemInitialize for SignalConversion generated from: '<S588>/In1' incorporates:\r\n  //   Outport: '<S588>/Out1'\r\n\r\n  SITL_HEXA_MISSION_B.In1_f = SITL_HEXA_MISSION_P.Out1_Y0_o;\r\n\r\n  // End of SystemInitialize for SubSystem: '<S573>/Enabled Subsystem'\r\n\r\n  // SystemInitialize for IfAction SubSystem: '<S554>/Take-off'\r\n  // InitializeConditions for Delay: '<S566>/Delay'\r\n  SITL_HEXA_MISSION_DW.Delay_DSTATE_c =\r\n    SITL_HEXA_MISSION_P.Delay_InitialCondition;\r\n\r\n  // InitializeConditions for Delay: '<S567>/Delay'\r\n  SITL_HEXA_MISSION_DW.Delay_DSTATE_d =\r\n    SITL_HEXA_MISSION_P.Delay_InitialCondition_g;\r\n\r\n  // SystemInitialize for Enabled SubSystem: '<S567>/Enabled Subsystem2'\r\n  // SystemInitialize for SignalConversion generated from: '<S568>/yaw_In' incorporates:\r\n  //   Outport: '<S568>/yaw_Out'\r\n\r\n  SITL_HEXA_MISSION_B.yaw_In_ik = SITL_HEXA_MISSION_P.yaw_Out_Y0;\r\n\r\n  // End of SystemInitialize for SubSystem: '<S567>/Enabled Subsystem2'\r\n  // End of SystemInitialize for SubSystem: '<S554>/Take-off'\r\n\r\n  // SystemInitialize for IfAction SubSystem: '<S554>/Land'\r\n  // InitializeConditions for Delay: '<S557>/Delay'\r\n  SITL_HEXA_MISSION_DW.Delay_DSTATE_l[0] =\r\n    SITL_HEXA_MISSION_P.Delay_InitialCondition_n;\r\n  SITL_HEXA_MISSION_DW.Delay_DSTATE_l[1] =\r\n    SITL_HEXA_MISSION_P.Delay_InitialCondition_n;\r\n\r\n  // InitializeConditions for Delay: '<S562>/Delay'\r\n  SITL_HEXA_MISSION_DW.Delay_DSTATE_n =\r\n    SITL_HEXA_MISSION_P.Delay_InitialCondition_m;\r\n\r\n  // InitializeConditions for Delay: '<S563>/Delay'\r\n  SITL_HEXA_MISSION_DW.Delay_DSTATE_b =\r\n    SITL_HEXA_MISSION_P.Delay_InitialCondition_j;\r\n\r\n  // SystemInitialize for Enabled SubSystem: '<S563>/Enabled Subsystem2'\r\n  // SystemInitialize for SignalConversion generated from: '<S565>/yaw_In' incorporates:\r\n  //   Outport: '<S565>/yaw_Out'\r\n\r\n  SITL_HEXA_MISSION_B.yaw_In_i = SITL_HEXA_MISSION_P.yaw_Out_Y0_f;\r\n\r\n  // End of SystemInitialize for SubSystem: '<S563>/Enabled Subsystem2'\r\n\r\n  // SystemInitialize for Enabled SubSystem: '<S562>/Enabled Subsystem'\r\n  // SystemInitialize for SignalConversion generated from: '<S564>/In' incorporates:\r\n  //   Outport: '<S564>/Out'\r\n\r\n  SITL_HEXA_MISSION_B.In = SITL_HEXA_MISSION_P.Out_Y0;\r\n\r\n  // End of SystemInitialize for SubSystem: '<S562>/Enabled Subsystem'\r\n  // End of SystemInitialize for SubSystem: '<S554>/Land'\r\n\r\n  // SystemInitialize for IfAction SubSystem: '<S554>/Waypoint'\r\n  // Start for MATLABSystem: '<S559>/UAV Waypoint Follower'\r\n  SITL_HEXA_MISSION_DW.obj.LastWaypointFlag = false;\r\n  SITL_HEXA_MISSION_DW.obj.StartFlag = true;\r\n  SITL_HEXA_MISSION_DW.obj.LookaheadFactor = 1.01;\r\n  SITL_HEXA_MISSION_DW.obj.isInitialized = 1;\r\n  SITL_HEXA_MISSION_DW.obj.NumWaypoints = 0.0;\r\n\r\n  // InitializeConditions for MATLABSystem: '<S559>/UAV Waypoint Follower'\r\n  SITL_HEXA_MISSION_DW.obj.WaypointIndex = 1.0;\r\n  memset(&SITL_HEXA_MISSION_DW.obj.WaypointsInternal[0], 0, 9U * sizeof(real_T));\r\n\r\n  // End of SystemInitialize for SubSystem: '<S554>/Waypoint'\r\n\r\n  // SystemInitialize for IfAction SubSystem: '<S554>/IDLE'\r\n  // InitializeConditions for Delay: '<S560>/Delay'\r\n  SITL_HEXA_MISSION_DW.Delay_DSTATE =\r\n    SITL_HEXA_MISSION_P.Delay_InitialCondition_g0;\r\n\r\n  // SystemInitialize for Enabled SubSystem: '<S560>/Enabled Subsystem2'\r\n  // SystemInitialize for SignalConversion generated from: '<S561>/yaw_In' incorporates:\r\n  //   Outport: '<S561>/yaw_Out'\r\n\r\n  SITL_HEXA_MISSION_B.yaw_In = SITL_HEXA_MISSION_P.yaw_Out_Y0_p;\r\n\r\n  // End of SystemInitialize for SubSystem: '<S560>/Enabled Subsystem2'\r\n  // End of SystemInitialize for SubSystem: '<S554>/IDLE'\r\n\r\n  // SystemInitialize for Enabled SubSystem: '<S555>/Send waypoints to OBC'\r\n  // SystemInitialize for IfAction SubSystem: '<S584>/If Action Subsystem2'\r\n  // Start for MATLABSystem: '<S587>/Read Parameter'\r\n  SITL_HEXA_MISSION_DW.obj_ga.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_ga.SampleTime =\r\n    SITL_HEXA_MISSION_P.ReadParameter_SampleTime_c;\r\n  SITL_HEXA_MISSION_DW.obj_ga.isInitialized = 1;\r\n  if (SITL_HEXA_MISSION_DW.obj_ga.SampleTime == -1.0) {\r\n    tmp = 0.2;\r\n  } else {\r\n    tmp = SITL_HEXA_MISSION_DW.obj_ga.SampleTime;\r\n  }\r\n\r\n  SITL_HEXA_MISSION_DW.obj_ga.MW_PARAMHANDLE = MW_Init_Param(&ParameterNameStr[0],\r\n    true, tmp * 1000.0);\r\n  SITL_HEXA_MISSION_DW.obj_ga.isSetupComplete = true;\r\n\r\n  // End of Start for MATLABSystem: '<S587>/Read Parameter'\r\n  // End of SystemInitialize for SubSystem: '<S584>/If Action Subsystem2'\r\n\r\n  // SystemInitialize for IfAction SubSystem: '<S584>/If Action Subsystem1'\r\n  // Start for MATLABSystem: '<S586>/Read Parameter'\r\n  SITL_HEXA_MISSION_DW.obj_b.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_b.SampleTime =\r\n    SITL_HEXA_MISSION_P.ReadParameter_SampleTime_g;\r\n  SITL_HEXA_MISSION_DW.obj_b.isInitialized = 1;\r\n  if (SITL_HEXA_MISSION_DW.obj_b.SampleTime == -1.0) {\r\n    tmp = 0.2;\r\n  } else {\r\n    tmp = SITL_HEXA_MISSION_DW.obj_b.SampleTime;\r\n  }\r\n\r\n  SITL_HEXA_MISSION_DW.obj_b.MW_PARAMHANDLE = MW_Init_Param(&ParameterNameStr_0\r\n    [0], true, tmp * 1000.0);\r\n  SITL_HEXA_MISSION_DW.obj_b.isSetupComplete = true;\r\n\r\n  // End of Start for MATLABSystem: '<S586>/Read Parameter'\r\n  // End of SystemInitialize for SubSystem: '<S584>/If Action Subsystem1'\r\n  SITL_HEXA_MISSION_MATLABSystem_Init(&SITL_HEXA_MISSION_DW.MATLABSystem);\r\n  SITL_HEXA_MISSION_MATLABSystem_Init(&SITL_HEXA_MISSION_DW.MATLABSystem_b);\r\n\r\n  // Start for MATLABSystem: '<S581>/MATLAB System'\r\n  SITL_HEXA_MISSION_DW.obj_mu.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_mu.isSetupComplete = true;\r\n\r\n  // Start for MATLABSystem: '<S583>/SinkBlock' incorporates:\r\n  //   BusAssignment: '<S572>/Bus Assignment1'\r\n\r\n  SITL_HEXA_MISSION_DW.obj_mc.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_mc.isInitialized = 1;\r\n  SITL_HEXA_MISSION_DW.obj_mc.orbMetadataObj = ORB_ID\r\n    (vehicle_trajectory_waypoint_desired);\r\n  uORB_write_initialize(SITL_HEXA_MISSION_DW.obj_mc.orbMetadataObj,\r\n                        &SITL_HEXA_MISSION_DW.obj_mc.orbAdvertiseObj,\r\n                        &SITL_HEXA_MISSION_B.BusAssignment1, 1);\r\n  SITL_HEXA_MISSION_DW.obj_mc.isSetupComplete = true;\r\n\r\n  // End of SystemInitialize for SubSystem: '<S555>/Send waypoints to OBC'\r\n\r\n  // Start for MATLABSystem: '<S555>/Read Parameter'\r\n  SITL_HEXA_MISSION_DW.obj_k.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_k.SampleTime =\r\n    SITL_HEXA_MISSION_P.ReadParameter_SampleTime;\r\n  SITL_HEXA_MISSION_DW.obj_k.isInitialized = 1;\r\n  if (SITL_HEXA_MISSION_DW.obj_k.SampleTime == -1.0) {\r\n    tmp = 0.2;\r\n  } else {\r\n    tmp = SITL_HEXA_MISSION_DW.obj_k.SampleTime;\r\n  }\r\n\r\n  SITL_HEXA_MISSION_DW.obj_k.MW_PARAMHANDLE = MW_Init_Param(&ParameterNameStr_1\r\n    [0], true, tmp * 1000.0);\r\n  SITL_HEXA_MISSION_DW.obj_k.isSetupComplete = true;\r\n\r\n  // End of Start for MATLABSystem: '<S555>/Read Parameter'\r\n\r\n  // Start for MATLABSystem: '<S576>/SourceBlock'\r\n  SITL_HEXA_MISSION_DW.obj_e.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_e.isInitialized = 1;\r\n  SITL_HEXA_MISSION_DW.obj_e.orbMetadataObj = ORB_ID(vehicle_trajectory_waypoint);\r\n  uORB_read_initialize(SITL_HEXA_MISSION_DW.obj_e.orbMetadataObj,\r\n                       &SITL_HEXA_MISSION_DW.obj_e.eventStructObj);\r\n  SITL_HEXA_MISSION_DW.obj_e.isSetupComplete = true;\r\n\r\n  // Start for MATLABSystem: '<S574>/SourceBlock'\r\n  SITL_HEXA_MISSION_DW.obj_kz.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_kz.isInitialized = 1;\r\n  SITL_HEXA_MISSION_DW.obj_kz.orbMetadataObj = ORB_ID(position_setpoint_triplet);\r\n  uORB_read_initialize(SITL_HEXA_MISSION_DW.obj_kz.orbMetadataObj,\r\n                       &SITL_HEXA_MISSION_DW.obj_kz.eventStructObj);\r\n  SITL_HEXA_MISSION_DW.obj_kz.isSetupComplete = true;\r\n\r\n  // Start for MATLABSystem: '<S573>/SourceBlock'\r\n  SITL_HEXA_MISSION_DW.obj_gf.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_gf.isInitialized = 1;\r\n  SITL_HEXA_MISSION_DW.obj_gf.orbMetadataObj = ORB_ID(home_position);\r\n  uORB_read_initialize(SITL_HEXA_MISSION_DW.obj_gf.orbMetadataObj,\r\n                       &SITL_HEXA_MISSION_DW.obj_gf.eventStructObj);\r\n  SITL_HEXA_MISSION_DW.obj_gf.isSetupComplete = true;\r\n\r\n  // Start for MATLABSystem: '<S555>/LLA2LocalCoordinates'\r\n  SITL_HEXA_MISSION_DW.obj_mr.previousValidReceived = false;\r\n  SITL_HEXA_MISSION_DW.obj_mr.nextValidReceived = false;\r\n  SITL_HEXA_MISSION_DW.obj_mr.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_mr.isInitialized = 1;\r\n  SITL_HEXA_MISSION_DW.obj_mr.isSetupComplete = true;\r\n  SITL_HEXA_MISSION_PX4Timestamp_Init(&SITL_HEXA_MISSION_DW.PX4Timestamp_pna);\r\n  SITL_HEXA_MISSION_SinkBlock_Init(&SITL_HEXA_MISSION_B.BusAssignment_m,\r\n    &SITL_HEXA_MISSION_DW.SinkBlock_a);\r\n  SITL_HEXA_MISSION_PX4Timestamp_Init(&SITL_HEXA_MISSION_DW.PX4Timestamp_o);\r\n}\r\n\r\n// Output and update for atomic system: '<Root>/Navigation'\r\nvoid SITL_HEXA_MISSION_Navigation(void)\r\n{\r\n  boolean_T exitg1;\r\n  boolean_T guard1;\r\n  boolean_T guard2;\r\n\r\n  // MATLABSystem: '<S555>/Read Parameter'\r\n  if (SITL_HEXA_MISSION_DW.obj_k.SampleTime !=\r\n      SITL_HEXA_MISSION_P.ReadParameter_SampleTime) {\r\n    SITL_HEXA_MISSION_DW.obj_k.SampleTime =\r\n      SITL_HEXA_MISSION_P.ReadParameter_SampleTime;\r\n  }\r\n\r\n  SITL_HEXA_MISSION_B.OR_g = MW_Param_Step\r\n    (SITL_HEXA_MISSION_DW.obj_k.MW_PARAMHANDLE, MW_INT32,\r\n     &SITL_HEXA_MISSION_B.ParamStep_b);\r\n  if (SITL_HEXA_MISSION_B.OR_g) {\r\n    SITL_HEXA_MISSION_B.ParamStep_b = 0;\r\n  }\r\n\r\n  // MATLABSystem: '<S576>/SourceBlock'\r\n  SITL_HEXA_MISSION_B.OR_g = uORB_read_step\r\n    (SITL_HEXA_MISSION_DW.obj_e.orbMetadataObj,\r\n     &SITL_HEXA_MISSION_DW.obj_e.eventStructObj, &SITL_HEXA_MISSION_B.r, false,\r\n     1.0);\r\n\r\n  // Outputs for Enabled SubSystem: '<S576>/Enabled Subsystem' incorporates:\r\n  //   EnablePort: '<S577>/Enable'\r\n\r\n  // Start for MATLABSystem: '<S576>/SourceBlock'\r\n  if (SITL_HEXA_MISSION_B.OR_g) {\r\n    // SignalConversion generated from: '<S577>/In1'\r\n    SITL_HEXA_MISSION_B.In1 = SITL_HEXA_MISSION_B.r;\r\n  }\r\n\r\n  // End of Outputs for SubSystem: '<S576>/Enabled Subsystem'\r\n\r\n  // MATLABSystem: '<S574>/SourceBlock'\r\n  SITL_HEXA_MISSION_B.OR_g = uORB_read_step\r\n    (SITL_HEXA_MISSION_DW.obj_kz.orbMetadataObj,\r\n     &SITL_HEXA_MISSION_DW.obj_kz.eventStructObj, &SITL_HEXA_MISSION_B.r1, false,\r\n     1.0);\r\n\r\n  // Outputs for Enabled SubSystem: '<S574>/Enabled Subsystem' incorporates:\r\n  //   EnablePort: '<S589>/Enable'\r\n\r\n  // Start for MATLABSystem: '<S574>/SourceBlock'\r\n  if (SITL_HEXA_MISSION_B.OR_g) {\r\n    // SignalConversion generated from: '<S589>/In1'\r\n    SITL_HEXA_MISSION_B.In1_p = SITL_HEXA_MISSION_B.r1;\r\n  }\r\n\r\n  // End of Outputs for SubSystem: '<S574>/Enabled Subsystem'\r\n\r\n  // MATLABSystem: '<S573>/SourceBlock'\r\n  SITL_HEXA_MISSION_B.OR_g = uORB_read_step\r\n    (SITL_HEXA_MISSION_DW.obj_gf.orbMetadataObj,\r\n     &SITL_HEXA_MISSION_DW.obj_gf.eventStructObj, &SITL_HEXA_MISSION_B.r2, false,\r\n     1.0);\r\n\r\n  // Outputs for Enabled SubSystem: '<S573>/Enabled Subsystem' incorporates:\r\n  //   EnablePort: '<S588>/Enable'\r\n\r\n  // Start for MATLABSystem: '<S573>/SourceBlock'\r\n  if (SITL_HEXA_MISSION_B.OR_g) {\r\n    // SignalConversion generated from: '<S588>/In1'\r\n    SITL_HEXA_MISSION_B.In1_f = SITL_HEXA_MISSION_B.r2;\r\n  }\r\n\r\n  // End of Outputs for SubSystem: '<S573>/Enabled Subsystem'\r\n\r\n  // MATLABSystem: '<S555>/LLA2LocalCoordinates' incorporates:\r\n  //   MATLABSystem: '<S555>/Read Parameter'\r\n  //   SignalConversion generated from: '<S588>/In1'\r\n  //\r\n  SITL_HEXA_MISSION_B.MatrixConcatenate1_k[0] = 0.0;\r\n  SITL_HEXA_MISSION_B.MatrixConcatenate1[0] = 0.0;\r\n  SITL_HEXA_MISSION_B.virtualWaypoint[0] = 0.0;\r\n  SITL_HEXA_MISSION_B.MatrixConcatenate1_k[1] = 0.0;\r\n  SITL_HEXA_MISSION_B.MatrixConcatenate1[1] = 0.0;\r\n  SITL_HEXA_MISSION_B.virtualWaypoint[1] = 0.0;\r\n  SITL_HEXA_MISSION_B.MatrixConcatenate1_k[2] = 0.0;\r\n  SITL_HEXA_MISSION_B.MatrixConcatenate1[2] = 0.0;\r\n  SITL_HEXA_MISSION_B.virtualWaypoint[2] = 0.0;\r\n  SITL_HEXA_MISSION_B.lla0[0] = SITL_HEXA_MISSION_B.In1_f.lat;\r\n  SITL_HEXA_MISSION_B.lla0[1] = SITL_HEXA_MISSION_B.In1_f.lon;\r\n  SITL_HEXA_MISSION_B.lla0[2] = SITL_HEXA_MISSION_B.In1_f.alt;\r\n  if (SITL_HEXA_MISSION_B.In1_p.previous.valid &&\r\n      (!SITL_HEXA_MISSION_DW.obj_mr.previousValidReceived)) {\r\n    SITL_HEXA_MISSION_DW.obj_mr.previousValidReceived = true;\r\n  }\r\n\r\n  if (SITL_HEXA_MISSION_B.In1_p.next.valid &&\r\n      (!SITL_HEXA_MISSION_DW.obj_mr.nextValidReceived)) {\r\n    SITL_HEXA_MISSION_DW.obj_mr.nextValidReceived = true;\r\n  }\r\n\r\n  if (SITL_HEXA_MISSION_B.In1_f.valid_hpos &&\r\n      SITL_HEXA_MISSION_B.In1_p.current.valid &&\r\n      (SITL_HEXA_MISSION_B.In1_p.current.type != 5)) {\r\n    if (SITL_HEXA_MISSION_B.ParamStep_b != 0) {\r\n      SITL_HEXA_MISSION_B.MatrixConcatenate1[0] =\r\n        SITL_HEXA_MISSION_B.In1.waypoints[0].position[0];\r\n      SITL_HEXA_MISSION_B.MatrixConcatenate1[1] =\r\n        SITL_HEXA_MISSION_B.In1.waypoints[0].position[1];\r\n      SITL_HEXA_MISSION_B.MatrixConcatenate1[2] =\r\n        SITL_HEXA_MISSION_B.In1.waypoints[0].position[2];\r\n    } else {\r\n      SITL_HEXA_MISSION_B.dv[0] = SITL_HEXA_MISSION_B.In1_p.current.lat;\r\n      SITL_HEXA_MISSION_B.dv[1] = SITL_HEXA_MISSION_B.In1_p.current.lon;\r\n      SITL_HEXA_MISSION_B.dv[2] = SITL_HEXA_MISSION_B.In1_p.current.alt;\r\n      SITL_HEXA_MISSION_lla2ned(SITL_HEXA_MISSION_B.dv, SITL_HEXA_MISSION_B.lla0,\r\n        SITL_HEXA_MISSION_B.MatrixConcatenate1);\r\n    }\r\n  }\r\n\r\n  if (SITL_HEXA_MISSION_B.In1_f.valid_hpos &&\r\n      (SITL_HEXA_MISSION_B.In1_p.previous.valid ||\r\n       SITL_HEXA_MISSION_DW.obj_mr.previousValidReceived)) {\r\n    SITL_HEXA_MISSION_B.dv[0] = SITL_HEXA_MISSION_B.In1_p.previous.lat;\r\n    SITL_HEXA_MISSION_B.dv[1] = SITL_HEXA_MISSION_B.In1_p.previous.lon;\r\n    SITL_HEXA_MISSION_B.dv[2] = SITL_HEXA_MISSION_B.In1_p.previous.alt;\r\n    SITL_HEXA_MISSION_lla2ned(SITL_HEXA_MISSION_B.dv, SITL_HEXA_MISSION_B.lla0,\r\n      SITL_HEXA_MISSION_B.MatrixConcatenate1_k);\r\n  }\r\n\r\n  if (SITL_HEXA_MISSION_B.In1_f.valid_hpos &&\r\n      (SITL_HEXA_MISSION_B.In1_p.next.valid ||\r\n       SITL_HEXA_MISSION_DW.obj_mr.nextValidReceived)) {\r\n    SITL_HEXA_MISSION_B.dv[0] = SITL_HEXA_MISSION_B.In1_p.next.lat;\r\n    SITL_HEXA_MISSION_B.dv[1] = SITL_HEXA_MISSION_B.In1_p.next.lon;\r\n    SITL_HEXA_MISSION_B.dv[2] = SITL_HEXA_MISSION_B.In1_p.next.alt;\r\n    SITL_HEXA_MISSION_lla2ned(SITL_HEXA_MISSION_B.dv, SITL_HEXA_MISSION_B.lla0,\r\n      SITL_HEXA_MISSION_B.virtualWaypoint);\r\n  }\r\n\r\n  // If: '<S554>/If' incorporates:\r\n  //   Delay: '<S560>/Delay'\r\n  //   Delay: '<S563>/Delay'\r\n  //   Delay: '<S567>/Delay'\r\n  //   MATLABSystem: '<S555>/LLA2LocalCoordinates'\r\n  //\r\n  SITL_HEXA_MISSION_B.rtPrevAction = SITL_HEXA_MISSION_DW.If_ActiveSubsystem;\r\n  if (SITL_HEXA_MISSION_B.In1_p.current.type == 3) {\r\n    SITL_HEXA_MISSION_B.rtAction = 0;\r\n  } else if (SITL_HEXA_MISSION_B.In1_p.current.type == 4) {\r\n    SITL_HEXA_MISSION_B.rtAction = 1;\r\n  } else if (SITL_HEXA_MISSION_B.In1_p.current.type == 0) {\r\n    SITL_HEXA_MISSION_B.rtAction = 2;\r\n  } else {\r\n    SITL_HEXA_MISSION_B.rtAction = 3;\r\n  }\r\n\r\n  SITL_HEXA_MISSION_DW.If_ActiveSubsystem = SITL_HEXA_MISSION_B.rtAction;\r\n  switch (SITL_HEXA_MISSION_B.rtAction) {\r\n   case 0:\r\n    if (SITL_HEXA_MISSION_B.rtAction != SITL_HEXA_MISSION_B.rtPrevAction) {\r\n      // InitializeConditions for IfAction SubSystem: '<S554>/Take-off' incorporates:\r\n      //   ActionPort: '<S558>/Action Port'\r\n\r\n      // InitializeConditions for If: '<S554>/If' incorporates:\r\n      //   Delay: '<S566>/Delay'\r\n      //   Delay: '<S567>/Delay'\r\n\r\n      SITL_HEXA_MISSION_DW.Delay_DSTATE_c =\r\n        SITL_HEXA_MISSION_P.Delay_InitialCondition;\r\n      SITL_HEXA_MISSION_DW.Delay_DSTATE_d =\r\n        SITL_HEXA_MISSION_P.Delay_InitialCondition_g;\r\n\r\n      // End of InitializeConditions for SubSystem: '<S554>/Take-off'\r\n    }\r\n\r\n    // Outputs for IfAction SubSystem: '<S554>/Take-off' incorporates:\r\n    //   ActionPort: '<S558>/Action Port'\r\n\r\n    // Sum: '<S566>/Sum' incorporates:\r\n    //   Constant: '<S566>/Rate'\r\n    //   Delay: '<S566>/Delay'\r\n\r\n    SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_P.Rate_Value +\r\n      SITL_HEXA_MISSION_DW.Delay_DSTATE_c;\r\n\r\n    // Gain: '<S566>/Gain1'\r\n    SITL_HEXA_MISSION_B.Gain_i = SITL_HEXA_MISSION_P.Gain1_Gain_b *\r\n      SITL_HEXA_MISSION_B.MatrixConcatenate1[2];\r\n\r\n    // Outputs for Enabled SubSystem: '<S567>/Enabled Subsystem2' incorporates:\r\n    //   EnablePort: '<S568>/Enable'\r\n\r\n    if (SITL_HEXA_MISSION_DW.Delay_DSTATE_d > 0.0) {\r\n      // SignalConversion generated from: '<S568>/yaw_In'\r\n      SITL_HEXA_MISSION_B.yaw_In_ik = SITL_HEXA_MISSION_B.DataTypeConversion1[6];\r\n    }\r\n\r\n    // End of Outputs for SubSystem: '<S567>/Enabled Subsystem2'\r\n\r\n    // Reshape: '<S558>/Reshape' incorporates:\r\n    //   Delay: '<S567>/Delay'\r\n    //   Merge: '<S554>/Merge'\r\n\r\n    SITL_HEXA_MISSION_B.Merge[0] = SITL_HEXA_MISSION_B.MatrixConcatenate1[0];\r\n    SITL_HEXA_MISSION_B.Merge[1] = SITL_HEXA_MISSION_B.MatrixConcatenate1[1];\r\n\r\n    // Gain: '<S566>/Gain' incorporates:\r\n    //   RelationalOperator: '<S566>/Relational Operator'\r\n    //   Switch: '<S566>/Switch'\r\n\r\n    if (!(SITL_HEXA_MISSION_B.Gain_i <= SITL_HEXA_MISSION_B.Sum_f)) {\r\n      SITL_HEXA_MISSION_B.Gain_i = SITL_HEXA_MISSION_B.Sum_f;\r\n    }\r\n\r\n    // Reshape: '<S558>/Reshape' incorporates:\r\n    //   Gain: '<S566>/Gain'\r\n    //   Merge: '<S554>/Merge'\r\n    //   Switch: '<S566>/Switch'\r\n\r\n    SITL_HEXA_MISSION_B.Merge[2] = SITL_HEXA_MISSION_P.Gain_Gain_e *\r\n      SITL_HEXA_MISSION_B.Gain_i;\r\n    SITL_HEXA_MISSION_B.Merge[3] = SITL_HEXA_MISSION_B.yaw_In_ik;\r\n\r\n    // Update for Delay: '<S566>/Delay'\r\n    SITL_HEXA_MISSION_DW.Delay_DSTATE_c = SITL_HEXA_MISSION_B.Sum_f;\r\n\r\n    // Update for Delay: '<S567>/Delay' incorporates:\r\n    //   Constant: '<S567>/Constant'\r\n\r\n    SITL_HEXA_MISSION_DW.Delay_DSTATE_d = SITL_HEXA_MISSION_P.Constant_Value_f;\r\n\r\n    // End of Outputs for SubSystem: '<S554>/Take-off'\r\n    break;\r\n\r\n   case 1:\r\n    if (SITL_HEXA_MISSION_B.rtAction != SITL_HEXA_MISSION_B.rtPrevAction) {\r\n      // InitializeConditions for IfAction SubSystem: '<S554>/Land' incorporates:\r\n      //   ActionPort: '<S557>/Action Port'\r\n\r\n      // InitializeConditions for If: '<S554>/If' incorporates:\r\n      //   Delay: '<S557>/Delay'\r\n      //   Delay: '<S562>/Delay'\r\n      //   Delay: '<S563>/Delay'\r\n\r\n      SITL_HEXA_MISSION_DW.Delay_DSTATE_l[0] =\r\n        SITL_HEXA_MISSION_P.Delay_InitialCondition_n;\r\n      SITL_HEXA_MISSION_DW.Delay_DSTATE_l[1] =\r\n        SITL_HEXA_MISSION_P.Delay_InitialCondition_n;\r\n      SITL_HEXA_MISSION_DW.Delay_DSTATE_n =\r\n        SITL_HEXA_MISSION_P.Delay_InitialCondition_m;\r\n      SITL_HEXA_MISSION_DW.Delay_DSTATE_b =\r\n        SITL_HEXA_MISSION_P.Delay_InitialCondition_j;\r\n\r\n      // End of InitializeConditions for SubSystem: '<S554>/Land'\r\n    }\r\n\r\n    // Outputs for IfAction SubSystem: '<S554>/Land' incorporates:\r\n    //   ActionPort: '<S557>/Action Port'\r\n\r\n    // Delay: '<S562>/Delay'\r\n    SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_DW.Delay_DSTATE_n;\r\n\r\n    // Switch: '<S562>/Switch' incorporates:\r\n    //   Delay: '<S562>/Delay'\r\n    //   Gain: '<S562>/Gain'\r\n\r\n    if (!(SITL_HEXA_MISSION_DW.Delay_DSTATE_n >\r\n          SITL_HEXA_MISSION_P.Switch_Threshold_j)) {\r\n      SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_P.Gain_Gain_l *\r\n        SITL_HEXA_MISSION_B.MatrixConcatenate1_k[2];\r\n    }\r\n\r\n    // End of Switch: '<S562>/Switch'\r\n\r\n    // Sum: '<S562>/Subtract' incorporates:\r\n    //   Constant: '<S562>/Rate of descent'\r\n\r\n    SITL_HEXA_MISSION_B.Gain_i = SITL_HEXA_MISSION_B.Sum_f -\r\n      SITL_HEXA_MISSION_P.Rateofdescent_Value;\r\n\r\n    // Gain: '<S562>/Gain2'\r\n    SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_P.Gain2_Gain *\r\n      SITL_HEXA_MISSION_B.MatrixConcatenate1[2];\r\n\r\n    // Outputs for Enabled SubSystem: '<S563>/Enabled Subsystem2' incorporates:\r\n    //   EnablePort: '<S565>/Enable'\r\n\r\n    if (SITL_HEXA_MISSION_DW.Delay_DSTATE_b > 0.0) {\r\n      // SignalConversion generated from: '<S565>/yaw_In'\r\n      SITL_HEXA_MISSION_B.yaw_In_i = SITL_HEXA_MISSION_B.DataTypeConversion1[6];\r\n    }\r\n\r\n    // End of Outputs for SubSystem: '<S563>/Enabled Subsystem2'\r\n\r\n    // Switch: '<S557>/Switch' incorporates:\r\n    //   Delay: '<S563>/Delay'\r\n    //   Logic: '<S557>/OR'\r\n    //   RelationalOperator: '<S557>/IsNaN'\r\n\r\n    if (rtIsNaN(SITL_HEXA_MISSION_B.MatrixConcatenate1[0]) || rtIsNaN\r\n        (SITL_HEXA_MISSION_B.MatrixConcatenate1[1])) {\r\n      // Reshape: '<S557>/Reshape' incorporates:\r\n      //   Delay: '<S557>/Delay'\r\n      //   Merge: '<S554>/Merge'\r\n\r\n      SITL_HEXA_MISSION_B.Merge[0] = SITL_HEXA_MISSION_DW.Delay_DSTATE_l[0];\r\n      SITL_HEXA_MISSION_B.Merge[1] = SITL_HEXA_MISSION_DW.Delay_DSTATE_l[1];\r\n    } else {\r\n      // Reshape: '<S557>/Reshape' incorporates:\r\n      //   Delay: '<S557>/Delay'\r\n      //   Merge: '<S554>/Merge'\r\n\r\n      SITL_HEXA_MISSION_B.Merge[0] = SITL_HEXA_MISSION_B.MatrixConcatenate1[0];\r\n      SITL_HEXA_MISSION_B.Merge[1] = SITL_HEXA_MISSION_B.MatrixConcatenate1[1];\r\n    }\r\n\r\n    // End of Switch: '<S557>/Switch'\r\n\r\n    // Reshape: '<S557>/Reshape' incorporates:\r\n    //   Gain: '<S562>/Gain1'\r\n    //   Merge: '<S554>/Merge'\r\n    //   RelationalOperator: '<S562>/GreaterThan'\r\n    //   Switch: '<S562>/Switch1'\r\n\r\n    if (!(SITL_HEXA_MISSION_B.Sum_f > SITL_HEXA_MISSION_B.Gain_i)) {\r\n      SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_B.Gain_i;\r\n    }\r\n\r\n    SITL_HEXA_MISSION_B.Merge[2] = SITL_HEXA_MISSION_P.Gain1_Gain_a *\r\n      SITL_HEXA_MISSION_B.Sum_f;\r\n    SITL_HEXA_MISSION_B.Merge[3] = SITL_HEXA_MISSION_B.yaw_In_i;\r\n\r\n    // Outputs for Enabled SubSystem: '<S562>/Enabled Subsystem' incorporates:\r\n    //   EnablePort: '<S564>/Enable'\r\n\r\n    if (SITL_HEXA_MISSION_B.Gain_i > 0.0) {\r\n      // SignalConversion generated from: '<S564>/In'\r\n      SITL_HEXA_MISSION_B.In = SITL_HEXA_MISSION_B.Gain_i;\r\n    }\r\n\r\n    // End of Outputs for SubSystem: '<S562>/Enabled Subsystem'\r\n\r\n    // Update for Delay: '<S557>/Delay'\r\n    SITL_HEXA_MISSION_DW.Delay_DSTATE_l[0] =\r\n      SITL_HEXA_MISSION_B.DataTypeConversion1[0];\r\n    SITL_HEXA_MISSION_DW.Delay_DSTATE_l[1] =\r\n      SITL_HEXA_MISSION_B.DataTypeConversion1[1];\r\n\r\n    // Update for Delay: '<S562>/Delay'\r\n    SITL_HEXA_MISSION_DW.Delay_DSTATE_n = SITL_HEXA_MISSION_B.In;\r\n\r\n    // Update for Delay: '<S563>/Delay' incorporates:\r\n    //   Constant: '<S563>/Constant'\r\n\r\n    SITL_HEXA_MISSION_DW.Delay_DSTATE_b = SITL_HEXA_MISSION_P.Constant_Value_nn;\r\n\r\n    // End of Outputs for SubSystem: '<S554>/Land'\r\n    break;\r\n\r\n   case 2:\r\n    if (SITL_HEXA_MISSION_B.rtAction != SITL_HEXA_MISSION_B.rtPrevAction) {\r\n      // SystemReset for IfAction SubSystem: '<S554>/Waypoint' incorporates:\r\n      //   ActionPort: '<S559>/Action Port'\r\n\r\n      // SystemReset for If: '<S554>/If' incorporates:\r\n      //   MATLABSystem: '<S559>/UAV Waypoint Follower'\r\n      //\r\n      SITL_HEXA_MISSION_DW.obj.WaypointIndex = 1.0;\r\n      for (SITL_HEXA_MISSION_B.i1 = 0; SITL_HEXA_MISSION_B.i1 < 9;\r\n           SITL_HEXA_MISSION_B.i1++) {\r\n        SITL_HEXA_MISSION_DW.obj.WaypointsInternal[SITL_HEXA_MISSION_B.i1] *=\r\n          0.0;\r\n      }\r\n\r\n      // End of SystemReset for If: '<S554>/If'\r\n      // End of SystemReset for SubSystem: '<S554>/Waypoint'\r\n    }\r\n\r\n    // Outputs for IfAction SubSystem: '<S554>/Waypoint' incorporates:\r\n    //   ActionPort: '<S559>/Action Port'\r\n\r\n    // Concatenate: '<S559>/Matrix Concatenate'\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate_p[0] =\r\n      SITL_HEXA_MISSION_B.MatrixConcatenate1_k[0];\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate_p[1] =\r\n      SITL_HEXA_MISSION_B.MatrixConcatenate1[0];\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate_p[2] =\r\n      SITL_HEXA_MISSION_B.virtualWaypoint[0];\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate_p[3] =\r\n      SITL_HEXA_MISSION_B.MatrixConcatenate1_k[1];\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate_p[4] =\r\n      SITL_HEXA_MISSION_B.MatrixConcatenate1[1];\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate_p[5] =\r\n      SITL_HEXA_MISSION_B.virtualWaypoint[1];\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate_p[6] =\r\n      SITL_HEXA_MISSION_B.MatrixConcatenate1_k[2];\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate_p[7] =\r\n      SITL_HEXA_MISSION_B.MatrixConcatenate1[2];\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate_p[8] =\r\n      SITL_HEXA_MISSION_B.virtualWaypoint[2];\r\n\r\n    // MATLABSystem: '<S559>/UAV Waypoint Follower' incorporates:\r\n    //   Concatenate: '<S559>/Matrix Concatenate'\r\n    //   Constant: '<S559>/Constant'\r\n\r\n    SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_P.Constant_Value_gw;\r\n    SITL_HEXA_MISSION_DW.obj.LookaheadDistFlag = 0U;\r\n    if (SITL_HEXA_MISSION_P.Constant_Value_gw < 0.3) {\r\n      SITL_HEXA_MISSION_B.Sum_f = 0.3;\r\n      SITL_HEXA_MISSION_DW.obj.LookaheadDistFlag = 1U;\r\n    }\r\n\r\n    SITL_HEXA_MISSION_DW.obj.InitialPose[0] = 0.0;\r\n    SITL_HEXA_MISSION_DW.obj.InitialPose[1] = 0.0;\r\n    SITL_HEXA_MISSION_DW.obj.InitialPose[2] = 0.0;\r\n    SITL_HEXA_MISSION_DW.obj.InitialPose[3] = 0.0;\r\n    SITL_HEXA_MISSION_DW.obj.NumWaypoints = 3.0;\r\n    SITL_HEXA_MISSION_B.OR_g = false;\r\n    SITL_HEXA_MISSION_B.latp2 = true;\r\n    SITL_HEXA_MISSION_B.iy = 0;\r\n    exitg1 = false;\r\n    while ((!exitg1) && (SITL_HEXA_MISSION_B.iy <= 8)) {\r\n      SITL_HEXA_MISSION_B.i1 = SITL_HEXA_MISSION_B.iy / 3 * 3 +\r\n        SITL_HEXA_MISSION_B.iy % 3;\r\n      if (!(SITL_HEXA_MISSION_DW.obj.WaypointsInternal[SITL_HEXA_MISSION_B.i1] ==\r\n            SITL_HEXA_MISSION_B.MatrixConcatenate_p[SITL_HEXA_MISSION_B.i1])) {\r\n        SITL_HEXA_MISSION_B.latp2 = false;\r\n        exitg1 = true;\r\n      } else {\r\n        SITL_HEXA_MISSION_B.iy++;\r\n      }\r\n    }\r\n\r\n    if (SITL_HEXA_MISSION_B.latp2) {\r\n      SITL_HEXA_MISSION_B.OR_g = true;\r\n    }\r\n\r\n    if (!SITL_HEXA_MISSION_B.OR_g) {\r\n      memcpy(&SITL_HEXA_MISSION_DW.obj.WaypointsInternal[0],\r\n             &SITL_HEXA_MISSION_B.MatrixConcatenate_p[0], 9U * sizeof(real_T));\r\n      SITL_HEXA_MISSION_DW.obj.WaypointIndex = 1.0;\r\n    }\r\n\r\n    SITL_HEXA_MISSION_B.i1 = 0;\r\n    SITL_HEXA_MISSION_B.iy = 0;\r\n    for (SITL_HEXA_MISSION_B.j = 0; SITL_HEXA_MISSION_B.j < 3;\r\n         SITL_HEXA_MISSION_B.j++) {\r\n      SITL_HEXA_MISSION_B.distinctWptsIdx[SITL_HEXA_MISSION_B.j] = true;\r\n      SITL_HEXA_MISSION_B.b_xyzNED_idx_1 =\r\n        SITL_HEXA_MISSION_B.MatrixConcatenate_p[SITL_HEXA_MISSION_B.i1 + 1];\r\n      SITL_HEXA_MISSION_B.x[SITL_HEXA_MISSION_B.iy] =\r\n        (SITL_HEXA_MISSION_B.b_xyzNED_idx_1 !=\r\n         SITL_HEXA_MISSION_B.MatrixConcatenate_p[SITL_HEXA_MISSION_B.i1]);\r\n      SITL_HEXA_MISSION_B.x[SITL_HEXA_MISSION_B.iy + 1] =\r\n        (SITL_HEXA_MISSION_B.MatrixConcatenate_p[SITL_HEXA_MISSION_B.i1 + 2] !=\r\n         SITL_HEXA_MISSION_B.b_xyzNED_idx_1);\r\n      SITL_HEXA_MISSION_B.i1 += 3;\r\n      SITL_HEXA_MISSION_B.iy += 2;\r\n    }\r\n\r\n    SITL_HEXA_MISSION_B.IsNaN_l[0] = false;\r\n    SITL_HEXA_MISSION_B.IsNaN_l[1] = false;\r\n    SITL_HEXA_MISSION_B.i1 = 0;\r\n    SITL_HEXA_MISSION_B.iy = 4;\r\n    for (SITL_HEXA_MISSION_B.j = 0; SITL_HEXA_MISSION_B.j < 2;\r\n         SITL_HEXA_MISSION_B.j++) {\r\n      SITL_HEXA_MISSION_B.i1++;\r\n      SITL_HEXA_MISSION_B.iy++;\r\n      SITL_HEXA_MISSION_B.ix = SITL_HEXA_MISSION_B.i1;\r\n      exitg1 = false;\r\n      while ((!exitg1) && (SITL_HEXA_MISSION_B.ix <= SITL_HEXA_MISSION_B.iy)) {\r\n        if (SITL_HEXA_MISSION_B.x[SITL_HEXA_MISSION_B.ix - 1]) {\r\n          SITL_HEXA_MISSION_B.IsNaN_l[SITL_HEXA_MISSION_B.j] = true;\r\n          exitg1 = true;\r\n        } else {\r\n          SITL_HEXA_MISSION_B.ix += 2;\r\n        }\r\n      }\r\n    }\r\n\r\n    SITL_HEXA_MISSION_B.distinctWptsIdx[0] = SITL_HEXA_MISSION_B.IsNaN_l[0];\r\n    SITL_HEXA_MISSION_B.distinctWptsIdx[1] = SITL_HEXA_MISSION_B.IsNaN_l[1];\r\n\r\n    // End of Outputs for SubSystem: '<S554>/Waypoint'\r\n    SITL_HEXA_MISSION_B.iy = 0;\r\n    for (SITL_HEXA_MISSION_B.i1 = 0; SITL_HEXA_MISSION_B.i1 < 3;\r\n         SITL_HEXA_MISSION_B.i1++) {\r\n      // Outputs for IfAction SubSystem: '<S554>/Waypoint' incorporates:\r\n      //   ActionPort: '<S559>/Action Port'\r\n\r\n      if (SITL_HEXA_MISSION_B.distinctWptsIdx[SITL_HEXA_MISSION_B.i1]) {\r\n        SITL_HEXA_MISSION_B.iy++;\r\n      }\r\n\r\n      // End of Outputs for SubSystem: '<S554>/Waypoint'\r\n    }\r\n\r\n    SITL_HEXA_MISSION_B.j = SITL_HEXA_MISSION_B.iy;\r\n    SITL_HEXA_MISSION_B.iy = 0;\r\n    for (SITL_HEXA_MISSION_B.i1 = 0; SITL_HEXA_MISSION_B.i1 < 3;\r\n         SITL_HEXA_MISSION_B.i1++) {\r\n      // Outputs for IfAction SubSystem: '<S554>/Waypoint' incorporates:\r\n      //   ActionPort: '<S559>/Action Port'\r\n\r\n      if (SITL_HEXA_MISSION_B.distinctWptsIdx[SITL_HEXA_MISSION_B.i1]) {\r\n        // Start for MATLABSystem: '<S559>/UAV Waypoint Follower'\r\n        SITL_HEXA_MISSION_B.tmp_data[SITL_HEXA_MISSION_B.iy] =\r\n          static_cast<int8_T>(SITL_HEXA_MISSION_B.i1);\r\n        SITL_HEXA_MISSION_B.iy++;\r\n      }\r\n\r\n      // End of Outputs for SubSystem: '<S554>/Waypoint'\r\n    }\r\n\r\n    // Outputs for IfAction SubSystem: '<S554>/Waypoint' incorporates:\r\n    //   ActionPort: '<S559>/Action Port'\r\n\r\n    // MATLABSystem: '<S559>/UAV Waypoint Follower' incorporates:\r\n    //   Concatenate: '<S559>/Matrix Concatenate'\r\n    //   Reshape: '<S559>/Reshape1'\r\n\r\n    for (SITL_HEXA_MISSION_B.i1 = 0; SITL_HEXA_MISSION_B.i1 < 3;\r\n         SITL_HEXA_MISSION_B.i1++) {\r\n      for (SITL_HEXA_MISSION_B.iy = 0; SITL_HEXA_MISSION_B.iy <\r\n           SITL_HEXA_MISSION_B.j; SITL_HEXA_MISSION_B.iy++) {\r\n        SITL_HEXA_MISSION_B.b_waypointsIn_data[SITL_HEXA_MISSION_B.iy +\r\n          SITL_HEXA_MISSION_B.j * SITL_HEXA_MISSION_B.i1] =\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate_p[3 * SITL_HEXA_MISSION_B.i1 +\r\n          SITL_HEXA_MISSION_B.tmp_data[SITL_HEXA_MISSION_B.iy]];\r\n      }\r\n    }\r\n\r\n    SITL_HEXA_MISSION_DW.obj.LookaheadDistance = SITL_HEXA_MISSION_B.Sum_f;\r\n    if (SITL_HEXA_MISSION_B.j == 0) {\r\n      SITL_HEXA_MISSION_B.MatrixConcatenate1[0] =\r\n        SITL_HEXA_MISSION_B.DataTypeConversion1[0];\r\n      SITL_HEXA_MISSION_B.MatrixConcatenate1[1] =\r\n        SITL_HEXA_MISSION_B.DataTypeConversion1[1];\r\n      SITL_HEXA_MISSION_B.MatrixConcatenate1[2] =\r\n        SITL_HEXA_MISSION_B.DataTypeConversion1[2];\r\n      SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_B.DataTypeConversion1[6];\r\n    } else {\r\n      guard1 = false;\r\n      if (SITL_HEXA_MISSION_B.j == 1) {\r\n        if (SITL_HEXA_MISSION_DW.obj.StartFlag) {\r\n          SITL_HEXA_MISSION_DW.obj.InitialPose[0] =\r\n            SITL_HEXA_MISSION_B.DataTypeConversion1[0];\r\n          SITL_HEXA_MISSION_DW.obj.InitialPose[1] =\r\n            SITL_HEXA_MISSION_B.DataTypeConversion1[1];\r\n          SITL_HEXA_MISSION_DW.obj.InitialPose[2] =\r\n            SITL_HEXA_MISSION_B.DataTypeConversion1[2];\r\n          SITL_HEXA_MISSION_DW.obj.InitialPose[3] =\r\n            SITL_HEXA_MISSION_B.DataTypeConversion1[6];\r\n        }\r\n\r\n        SITL_HEXA_MISSION_B.MatrixConcatenate1_k[0] =\r\n          SITL_HEXA_MISSION_B.b_waypointsIn_data[0] -\r\n          SITL_HEXA_MISSION_B.DataTypeConversion1[0];\r\n        SITL_HEXA_MISSION_B.MatrixConcatenate1_k[1] =\r\n          SITL_HEXA_MISSION_B.b_waypointsIn_data[1] -\r\n          SITL_HEXA_MISSION_B.DataTypeConversion1[1];\r\n        SITL_HEXA_MISSION_B.MatrixConcatenate1_k[2] =\r\n          SITL_HEXA_MISSION_B.b_waypointsIn_data[2] -\r\n          SITL_HEXA_MISSION_B.DataTypeConversion1[2];\r\n        if (SITL_HEXA_MISSION_norm(SITL_HEXA_MISSION_B.MatrixConcatenate1_k) <\r\n            1.4901161193847656E-8) {\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate1[0] =\r\n            SITL_HEXA_MISSION_B.DataTypeConversion1[0];\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate1[1] =\r\n            SITL_HEXA_MISSION_B.DataTypeConversion1[1];\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate1[2] =\r\n            SITL_HEXA_MISSION_B.DataTypeConversion1[2];\r\n          SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_B.DataTypeConversion1[6];\r\n          SITL_HEXA_MISSION_DW.obj.StartFlag = false;\r\n        } else {\r\n          SITL_HEXA_MISSION_DW.obj.StartFlag = false;\r\n          SITL_HEXA_MISSION_DW.obj.NumWaypoints = 2.0;\r\n          SITL_HEXA_MISSION_B.ix = SITL_HEXA_MISSION_B.j + 1;\r\n          for (SITL_HEXA_MISSION_B.i1 = 0; SITL_HEXA_MISSION_B.i1 < 3;\r\n               SITL_HEXA_MISSION_B.i1++) {\r\n            SITL_HEXA_MISSION_B.MatrixConcatenate_p[(SITL_HEXA_MISSION_B.j + 1) *\r\n              SITL_HEXA_MISSION_B.i1] =\r\n              SITL_HEXA_MISSION_DW.obj.InitialPose[SITL_HEXA_MISSION_B.i1];\r\n            for (SITL_HEXA_MISSION_B.iy = 0; SITL_HEXA_MISSION_B.iy <\r\n                 SITL_HEXA_MISSION_B.j; SITL_HEXA_MISSION_B.iy++) {\r\n              SITL_HEXA_MISSION_B.MatrixConcatenate_p[(SITL_HEXA_MISSION_B.iy +\r\n                (SITL_HEXA_MISSION_B.j + 1) * SITL_HEXA_MISSION_B.i1) + 1] =\r\n                SITL_HEXA_MISSION_B.b_waypointsIn_data[SITL_HEXA_MISSION_B.j *\r\n                SITL_HEXA_MISSION_B.i1 + SITL_HEXA_MISSION_B.iy];\r\n            }\r\n          }\r\n\r\n          guard1 = true;\r\n        }\r\n      } else {\r\n        SITL_HEXA_MISSION_B.ix = SITL_HEXA_MISSION_B.j;\r\n        SITL_HEXA_MISSION_B.iy = SITL_HEXA_MISSION_B.j * 3;\r\n        if (SITL_HEXA_MISSION_B.iy - 1 >= 0) {\r\n          memcpy(&SITL_HEXA_MISSION_B.MatrixConcatenate_p[0],\r\n                 &SITL_HEXA_MISSION_B.b_waypointsIn_data[0],\r\n                 static_cast<uint32_T>(SITL_HEXA_MISSION_B.iy) * sizeof(real_T));\r\n        }\r\n\r\n        guard1 = true;\r\n      }\r\n\r\n      if (guard1) {\r\n        SITL_HEXA_MISSION_B.OR_g = false;\r\n        if (SITL_HEXA_MISSION_DW.obj.WaypointIndex ==\r\n            SITL_HEXA_MISSION_DW.obj.NumWaypoints) {\r\n          SITL_HEXA_MISSION_B.OR_g = true;\r\n        }\r\n\r\n        if (SITL_HEXA_MISSION_B.OR_g) {\r\n          SITL_HEXA_MISSION_DW.obj.LastWaypointFlag = true;\r\n          SITL_HEXA_MISSION_DW.obj.WaypointIndex--;\r\n        }\r\n\r\n        SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_B.MatrixConcatenate_p[\r\n          static_cast<int32_T>(SITL_HEXA_MISSION_DW.obj.WaypointIndex) - 1];\r\n        SITL_HEXA_MISSION_B.MatrixConcatenate1_k[0] = SITL_HEXA_MISSION_B.Sum_f;\r\n        SITL_HEXA_MISSION_B.b_xyzNED_idx_1 =\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate_p[static_cast<int32_T>\r\n          (SITL_HEXA_MISSION_DW.obj.WaypointIndex + 1.0) - 1];\r\n        SITL_HEXA_MISSION_B.MatrixConcatenate1[0] =\r\n          SITL_HEXA_MISSION_B.b_xyzNED_idx_1;\r\n        SITL_HEXA_MISSION_B.virtualWaypoint[0] =\r\n          SITL_HEXA_MISSION_B.DataTypeConversion1[0] -\r\n          SITL_HEXA_MISSION_B.b_xyzNED_idx_1;\r\n        SITL_HEXA_MISSION_B.MatrixConcatenate1_k[1] =\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate_p[(static_cast<int32_T>\r\n          (SITL_HEXA_MISSION_DW.obj.WaypointIndex) + SITL_HEXA_MISSION_B.ix) - 1];\r\n        SITL_HEXA_MISSION_B.Gain_i = SITL_HEXA_MISSION_B.MatrixConcatenate_p[(\r\n          static_cast<int32_T>(SITL_HEXA_MISSION_DW.obj.WaypointIndex + 1.0) +\r\n          SITL_HEXA_MISSION_B.ix) - 1];\r\n        SITL_HEXA_MISSION_B.MatrixConcatenate1[1] = SITL_HEXA_MISSION_B.Gain_i;\r\n        SITL_HEXA_MISSION_B.virtualWaypoint[1] =\r\n          SITL_HEXA_MISSION_B.DataTypeConversion1[1] -\r\n          SITL_HEXA_MISSION_B.Gain_i;\r\n        SITL_HEXA_MISSION_B.MatrixConcatenate1_k[2] =\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate_p[((SITL_HEXA_MISSION_B.ix << 1)\r\n          + static_cast<int32_T>(SITL_HEXA_MISSION_DW.obj.WaypointIndex)) - 1];\r\n        SITL_HEXA_MISSION_B.Gain_i = SITL_HEXA_MISSION_B.MatrixConcatenate_p[(\r\n          static_cast<int32_T>(SITL_HEXA_MISSION_DW.obj.WaypointIndex + 1.0) +\r\n          (SITL_HEXA_MISSION_B.ix << 1)) - 1];\r\n        SITL_HEXA_MISSION_B.MatrixConcatenate1[2] = SITL_HEXA_MISSION_B.Gain_i;\r\n        SITL_HEXA_MISSION_B.virtualWaypoint[2] =\r\n          SITL_HEXA_MISSION_B.DataTypeConversion1[2] -\r\n          SITL_HEXA_MISSION_B.Gain_i;\r\n        SITL_HEXA_MISSION_B.absx = SITL_HEXA_MISSION_norm\r\n          (SITL_HEXA_MISSION_B.virtualWaypoint);\r\n        guard2 = false;\r\n        if (SITL_HEXA_MISSION_B.absx <= 2.0) {\r\n          guard2 = true;\r\n        } else {\r\n          SITL_HEXA_MISSION_B.lla0[0] = SITL_HEXA_MISSION_B.b_xyzNED_idx_1 -\r\n            SITL_HEXA_MISSION_B.Sum_f;\r\n          SITL_HEXA_MISSION_B.lla0[1] = SITL_HEXA_MISSION_B.MatrixConcatenate_p\r\n            [(static_cast<int32_T>(SITL_HEXA_MISSION_DW.obj.WaypointIndex + 1.0)\r\n              + SITL_HEXA_MISSION_B.ix) - 1] -\r\n            SITL_HEXA_MISSION_B.MatrixConcatenate_p[(static_cast<int32_T>\r\n            (SITL_HEXA_MISSION_DW.obj.WaypointIndex) + SITL_HEXA_MISSION_B.ix) -\r\n            1];\r\n          SITL_HEXA_MISSION_B.b_xyzNED_idx_1 =\r\n            SITL_HEXA_MISSION_B.MatrixConcatenate_p[(static_cast<int32_T>\r\n            (SITL_HEXA_MISSION_DW.obj.WaypointIndex + 1.0) +\r\n            (SITL_HEXA_MISSION_B.ix << 1)) - 1];\r\n          SITL_HEXA_MISSION_B.lla0[2] = SITL_HEXA_MISSION_B.b_xyzNED_idx_1 -\r\n            SITL_HEXA_MISSION_B.MatrixConcatenate_p[((SITL_HEXA_MISSION_B.ix <<\r\n            1) + static_cast<int32_T>(SITL_HEXA_MISSION_DW.obj.WaypointIndex)) -\r\n            1];\r\n          SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_norm\r\n            (SITL_HEXA_MISSION_B.lla0);\r\n          SITL_HEXA_MISSION_B.Sum_f = ((SITL_HEXA_MISSION_B.DataTypeConversion1\r\n            [0] - SITL_HEXA_MISSION_B.MatrixConcatenate_p[static_cast<int32_T>\r\n            (SITL_HEXA_MISSION_DW.obj.WaypointIndex + 1.0) - 1]) /\r\n            SITL_HEXA_MISSION_B.absx * (SITL_HEXA_MISSION_B.lla0[0] /\r\n            SITL_HEXA_MISSION_B.Sum_f) + SITL_HEXA_MISSION_B.lla0[1] /\r\n            SITL_HEXA_MISSION_B.Sum_f * (SITL_HEXA_MISSION_B.virtualWaypoint[1] /\r\n            SITL_HEXA_MISSION_B.absx)) +\r\n            (SITL_HEXA_MISSION_B.DataTypeConversion1[2] -\r\n             SITL_HEXA_MISSION_B.b_xyzNED_idx_1) / SITL_HEXA_MISSION_B.absx *\r\n            (SITL_HEXA_MISSION_B.lla0[2] / SITL_HEXA_MISSION_B.Sum_f);\r\n          if (rtIsNaN(SITL_HEXA_MISSION_B.Sum_f) || (SITL_HEXA_MISSION_B.Sum_f <\r\n               0.0)) {\r\n          } else {\r\n            guard2 = true;\r\n          }\r\n        }\r\n\r\n        if (guard2) {\r\n          SITL_HEXA_MISSION_DW.obj.WaypointIndex++;\r\n          SITL_HEXA_MISSION_B.OR_g = false;\r\n          if (SITL_HEXA_MISSION_DW.obj.WaypointIndex ==\r\n              SITL_HEXA_MISSION_DW.obj.NumWaypoints) {\r\n            SITL_HEXA_MISSION_B.OR_g = true;\r\n          }\r\n\r\n          if (SITL_HEXA_MISSION_B.OR_g) {\r\n            SITL_HEXA_MISSION_DW.obj.LastWaypointFlag = true;\r\n            SITL_HEXA_MISSION_DW.obj.WaypointIndex--;\r\n          }\r\n\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate1_k[0] =\r\n            SITL_HEXA_MISSION_B.MatrixConcatenate_p[static_cast<int32_T>\r\n            (SITL_HEXA_MISSION_DW.obj.WaypointIndex) - 1];\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate1[0] =\r\n            SITL_HEXA_MISSION_B.MatrixConcatenate_p[static_cast<int32_T>\r\n            (SITL_HEXA_MISSION_DW.obj.WaypointIndex + 1.0) - 1];\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate1_k[1] =\r\n            SITL_HEXA_MISSION_B.MatrixConcatenate_p[(static_cast<int32_T>\r\n            (SITL_HEXA_MISSION_DW.obj.WaypointIndex) + SITL_HEXA_MISSION_B.ix) -\r\n            1];\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate1[1] =\r\n            SITL_HEXA_MISSION_B.MatrixConcatenate_p[(static_cast<int32_T>\r\n            (SITL_HEXA_MISSION_DW.obj.WaypointIndex + 1.0) +\r\n            SITL_HEXA_MISSION_B.ix) - 1];\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate1_k[2] =\r\n            SITL_HEXA_MISSION_B.MatrixConcatenate_p[((SITL_HEXA_MISSION_B.ix <<\r\n            1) + static_cast<int32_T>(SITL_HEXA_MISSION_DW.obj.WaypointIndex)) -\r\n            1];\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate1[2] =\r\n            SITL_HEXA_MISSION_B.MatrixConcatenate_p[(static_cast<int32_T>\r\n            (SITL_HEXA_MISSION_DW.obj.WaypointIndex + 1.0) +\r\n            (SITL_HEXA_MISSION_B.ix << 1)) - 1];\r\n        }\r\n\r\n        SITL_HEXA_MISSION_B.Gain_i = SITL_HEXA_MISSION_B.DataTypeConversion1[0]\r\n          - SITL_HEXA_MISSION_B.MatrixConcatenate1_k[0];\r\n        SITL_HEXA_MISSION_B.virtualWaypoint[0] = SITL_HEXA_MISSION_B.Gain_i;\r\n        SITL_HEXA_MISSION_B.b_xyzNED_idx_1 =\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate1[0] -\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate1_k[0];\r\n        SITL_HEXA_MISSION_B.flat = SITL_HEXA_MISSION_B.DataTypeConversion1[1] -\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate1_k[1];\r\n        SITL_HEXA_MISSION_B.virtualWaypoint[1] = SITL_HEXA_MISSION_B.flat;\r\n        SITL_HEXA_MISSION_B.absx = SITL_HEXA_MISSION_B.MatrixConcatenate1[1] -\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate1_k[1];\r\n        SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_B.DataTypeConversion1[2] -\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate1_k[2];\r\n        SITL_HEXA_MISSION_B.virtualWaypoint[2] = SITL_HEXA_MISSION_B.Sum_f;\r\n        SITL_HEXA_MISSION_B.lla0_tmp = SITL_HEXA_MISSION_B.MatrixConcatenate1[2]\r\n          - SITL_HEXA_MISSION_B.MatrixConcatenate1_k[2];\r\n        SITL_HEXA_MISSION_B.rtb_Sum_f_tmp = (SITL_HEXA_MISSION_B.absx *\r\n          SITL_HEXA_MISSION_B.absx + SITL_HEXA_MISSION_B.b_xyzNED_idx_1 *\r\n          SITL_HEXA_MISSION_B.b_xyzNED_idx_1) + SITL_HEXA_MISSION_B.lla0_tmp *\r\n          SITL_HEXA_MISSION_B.lla0_tmp;\r\n        SITL_HEXA_MISSION_B.Sum_f = ((SITL_HEXA_MISSION_B.flat *\r\n          SITL_HEXA_MISSION_B.absx + SITL_HEXA_MISSION_B.Gain_i *\r\n          SITL_HEXA_MISSION_B.b_xyzNED_idx_1) + SITL_HEXA_MISSION_B.Sum_f *\r\n          SITL_HEXA_MISSION_B.lla0_tmp) / SITL_HEXA_MISSION_B.rtb_Sum_f_tmp;\r\n        if (SITL_HEXA_MISSION_B.Sum_f < 0.0) {\r\n          SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_norm\r\n            (SITL_HEXA_MISSION_B.virtualWaypoint);\r\n        } else if (SITL_HEXA_MISSION_B.Sum_f > 1.0) {\r\n          SITL_HEXA_MISSION_B.virtualWaypoint[0] =\r\n            SITL_HEXA_MISSION_B.DataTypeConversion1[0] -\r\n            SITL_HEXA_MISSION_B.MatrixConcatenate1[0];\r\n          SITL_HEXA_MISSION_B.virtualWaypoint[1] =\r\n            SITL_HEXA_MISSION_B.DataTypeConversion1[1] -\r\n            SITL_HEXA_MISSION_B.MatrixConcatenate1[1];\r\n          SITL_HEXA_MISSION_B.virtualWaypoint[2] =\r\n            SITL_HEXA_MISSION_B.DataTypeConversion1[2] -\r\n            SITL_HEXA_MISSION_B.MatrixConcatenate1[2];\r\n          SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_norm\r\n            (SITL_HEXA_MISSION_B.virtualWaypoint);\r\n        } else {\r\n          SITL_HEXA_MISSION_B.virtualWaypoint[0] =\r\n            SITL_HEXA_MISSION_B.DataTypeConversion1[0] -\r\n            (SITL_HEXA_MISSION_B.Sum_f * SITL_HEXA_MISSION_B.b_xyzNED_idx_1 +\r\n             SITL_HEXA_MISSION_B.MatrixConcatenate1_k[0]);\r\n          SITL_HEXA_MISSION_B.virtualWaypoint[1] =\r\n            SITL_HEXA_MISSION_B.DataTypeConversion1[1] -\r\n            (SITL_HEXA_MISSION_B.Sum_f * SITL_HEXA_MISSION_B.absx +\r\n             SITL_HEXA_MISSION_B.MatrixConcatenate1_k[1]);\r\n          SITL_HEXA_MISSION_B.virtualWaypoint[2] =\r\n            SITL_HEXA_MISSION_B.DataTypeConversion1[2] -\r\n            (SITL_HEXA_MISSION_B.Sum_f * SITL_HEXA_MISSION_B.lla0_tmp +\r\n             SITL_HEXA_MISSION_B.MatrixConcatenate1_k[2]);\r\n          SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_norm\r\n            (SITL_HEXA_MISSION_B.virtualWaypoint);\r\n        }\r\n\r\n        if (SITL_HEXA_MISSION_DW.obj.LastWaypointFlag) {\r\n          SITL_HEXA_MISSION_B.Sum_f = ((SITL_HEXA_MISSION_B.Gain_i *\r\n            SITL_HEXA_MISSION_B.b_xyzNED_idx_1 + SITL_HEXA_MISSION_B.flat *\r\n            SITL_HEXA_MISSION_B.absx) +\r\n            (SITL_HEXA_MISSION_B.DataTypeConversion1[2] -\r\n             SITL_HEXA_MISSION_B.MatrixConcatenate1_k[2]) *\r\n            SITL_HEXA_MISSION_B.lla0_tmp) / SITL_HEXA_MISSION_B.rtb_Sum_f_tmp;\r\n          SITL_HEXA_MISSION_B.virtualWaypoint[0] =\r\n            SITL_HEXA_MISSION_B.DataTypeConversion1[0] -\r\n            (SITL_HEXA_MISSION_B.Sum_f * SITL_HEXA_MISSION_B.b_xyzNED_idx_1 +\r\n             SITL_HEXA_MISSION_B.MatrixConcatenate1_k[0]);\r\n          SITL_HEXA_MISSION_B.virtualWaypoint[1] =\r\n            SITL_HEXA_MISSION_B.DataTypeConversion1[1] -\r\n            (SITL_HEXA_MISSION_B.Sum_f * SITL_HEXA_MISSION_B.absx +\r\n             SITL_HEXA_MISSION_B.MatrixConcatenate1_k[1]);\r\n          SITL_HEXA_MISSION_B.virtualWaypoint[2] =\r\n            SITL_HEXA_MISSION_B.DataTypeConversion1[2] -\r\n            (SITL_HEXA_MISSION_B.Sum_f * SITL_HEXA_MISSION_B.lla0_tmp +\r\n             SITL_HEXA_MISSION_B.MatrixConcatenate1_k[2]);\r\n          SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_norm\r\n            (SITL_HEXA_MISSION_B.virtualWaypoint);\r\n        }\r\n\r\n        SITL_HEXA_MISSION_B.Gain_i = fabs(SITL_HEXA_MISSION_B.Sum_f);\r\n        if (rtIsInf(SITL_HEXA_MISSION_B.Gain_i) || rtIsNaN\r\n            (SITL_HEXA_MISSION_B.Gain_i)) {\r\n          SITL_HEXA_MISSION_B.flat = (rtNaN);\r\n          SITL_HEXA_MISSION_B.Gain_i = (rtNaN);\r\n        } else if (SITL_HEXA_MISSION_B.Gain_i < 4.4501477170144028E-308) {\r\n          SITL_HEXA_MISSION_B.flat = 4.94065645841247E-324;\r\n          SITL_HEXA_MISSION_B.Gain_i = 4.94065645841247E-324;\r\n        } else {\r\n          frexp(SITL_HEXA_MISSION_B.Gain_i, &SITL_HEXA_MISSION_B.b_exponent);\r\n          SITL_HEXA_MISSION_B.flat = ldexp(1.0, SITL_HEXA_MISSION_B.b_exponent -\r\n            53);\r\n          frexp(SITL_HEXA_MISSION_B.Gain_i, &SITL_HEXA_MISSION_B.b_exponent_p);\r\n          SITL_HEXA_MISSION_B.Gain_i = ldexp(1.0,\r\n            SITL_HEXA_MISSION_B.b_exponent_p - 53);\r\n        }\r\n\r\n        SITL_HEXA_MISSION_B.u0 = sqrt(SITL_HEXA_MISSION_B.flat);\r\n        SITL_HEXA_MISSION_B.Gain_i *= 5.0;\r\n        if ((SITL_HEXA_MISSION_B.u0 >= SITL_HEXA_MISSION_B.Gain_i) || rtIsNaN\r\n            (SITL_HEXA_MISSION_B.Gain_i)) {\r\n          SITL_HEXA_MISSION_B.Gain_i = SITL_HEXA_MISSION_B.u0;\r\n        }\r\n\r\n        if (SITL_HEXA_MISSION_DW.obj.LookaheadDistance <=\r\n            SITL_HEXA_MISSION_B.Sum_f + SITL_HEXA_MISSION_B.Gain_i) {\r\n          SITL_HEXA_MISSION_DW.obj.LookaheadDistance =\r\n            SITL_HEXA_MISSION_DW.obj.LookaheadFactor * SITL_HEXA_MISSION_B.Sum_f;\r\n        }\r\n\r\n        SITL_HEXA_MISSION_B.lla0[0] = SITL_HEXA_MISSION_B.MatrixConcatenate1_k[0]\r\n          - SITL_HEXA_MISSION_B.DataTypeConversion1[0];\r\n        SITL_HEXA_MISSION_B.lla0[1] = SITL_HEXA_MISSION_B.MatrixConcatenate1_k[1]\r\n          - SITL_HEXA_MISSION_B.DataTypeConversion1[1];\r\n        SITL_HEXA_MISSION_B.lla0[2] = SITL_HEXA_MISSION_B.MatrixConcatenate1_k[2]\r\n          - SITL_HEXA_MISSION_B.DataTypeConversion1[2];\r\n        SITL_HEXA_MISSION_B.Gain_i = ((SITL_HEXA_MISSION_B.b_xyzNED_idx_1 *\r\n          SITL_HEXA_MISSION_B.lla0[0] + SITL_HEXA_MISSION_B.absx *\r\n          SITL_HEXA_MISSION_B.lla0[1]) + SITL_HEXA_MISSION_B.lla0_tmp *\r\n          SITL_HEXA_MISSION_B.lla0[2]) * 2.0;\r\n        SITL_HEXA_MISSION_B.flat = sqrt(SITL_HEXA_MISSION_B.Gain_i *\r\n          SITL_HEXA_MISSION_B.Gain_i - (((SITL_HEXA_MISSION_B.lla0[0] *\r\n          SITL_HEXA_MISSION_B.lla0[0] + SITL_HEXA_MISSION_B.lla0[1] *\r\n          SITL_HEXA_MISSION_B.lla0[1]) + SITL_HEXA_MISSION_B.lla0[2] *\r\n          SITL_HEXA_MISSION_B.lla0[2]) -\r\n          SITL_HEXA_MISSION_DW.obj.LookaheadDistance *\r\n          SITL_HEXA_MISSION_DW.obj.LookaheadDistance) * (4.0 *\r\n          SITL_HEXA_MISSION_B.rtb_Sum_f_tmp));\r\n        SITL_HEXA_MISSION_B.u0 = (-SITL_HEXA_MISSION_B.Gain_i +\r\n          SITL_HEXA_MISSION_B.flat) / 2.0 / SITL_HEXA_MISSION_B.rtb_Sum_f_tmp;\r\n        SITL_HEXA_MISSION_B.Sum_f = (-SITL_HEXA_MISSION_B.Gain_i -\r\n          SITL_HEXA_MISSION_B.flat) / 2.0 / SITL_HEXA_MISSION_B.rtb_Sum_f_tmp;\r\n        if ((SITL_HEXA_MISSION_B.u0 >= SITL_HEXA_MISSION_B.Sum_f) || rtIsNaN\r\n            (SITL_HEXA_MISSION_B.Sum_f)) {\r\n          SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_B.u0;\r\n        }\r\n\r\n        SITL_HEXA_MISSION_B.MatrixConcatenate1[0] = (1.0 -\r\n          SITL_HEXA_MISSION_B.Sum_f) * SITL_HEXA_MISSION_B.MatrixConcatenate1_k\r\n          [0] + SITL_HEXA_MISSION_B.Sum_f *\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate1[0];\r\n        SITL_HEXA_MISSION_B.MatrixConcatenate1[1] = (1.0 -\r\n          SITL_HEXA_MISSION_B.Sum_f) * SITL_HEXA_MISSION_B.MatrixConcatenate1_k\r\n          [1] + SITL_HEXA_MISSION_B.Sum_f *\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate1[1];\r\n        SITL_HEXA_MISSION_B.MatrixConcatenate1[2] = (1.0 -\r\n          SITL_HEXA_MISSION_B.Sum_f) * SITL_HEXA_MISSION_B.MatrixConcatenate1_k\r\n          [2] + SITL_HEXA_MISSION_B.Sum_f *\r\n          SITL_HEXA_MISSION_B.MatrixConcatenate1[2];\r\n        SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_rt_atan2d_snf\r\n          (SITL_HEXA_MISSION_B.MatrixConcatenate1[1] -\r\n           SITL_HEXA_MISSION_B.DataTypeConversion1[1],\r\n           SITL_HEXA_MISSION_B.MatrixConcatenate1[0] -\r\n           SITL_HEXA_MISSION_B.DataTypeConversion1[0]);\r\n        SITL_HEXA_MISSION_DW.obj.LastWaypointFlag = false;\r\n      }\r\n    }\r\n\r\n    // Switch: '<S569>/Switch1' incorporates:\r\n    //   Constant: '<S570>/Constant'\r\n    //   Logic: '<S569>/OR'\r\n    //   Logic: '<S569>/OR1'\r\n    //   MATLABSystem: '<S559>/UAV Waypoint Follower'\r\n    //   Merge: '<S554>/Merge'\r\n    //   RelationalOperator: '<S569>/IsNaN'\r\n    //   RelationalOperator: '<S569>/IsNaN1'\r\n    //   RelationalOperator: '<S570>/Compare'\r\n    //   Reshape: '<S569>/Reshape3'\r\n    //   Switch: '<S569>/Switch'\r\n    //\r\n    if (rtIsNaN(SITL_HEXA_MISSION_B.MatrixConcatenate1[0]) || rtIsNaN\r\n        (SITL_HEXA_MISSION_B.MatrixConcatenate1[1]) || rtIsNaN\r\n        (SITL_HEXA_MISSION_B.MatrixConcatenate1[2]) ||\r\n        (SITL_HEXA_MISSION_B.In1_p.current.type ==\r\n         SITL_HEXA_MISSION_P.CompareToConstant_const)) {\r\n      SITL_HEXA_MISSION_B.Merge[0] = SITL_HEXA_MISSION_B.DataTypeConversion1[0];\r\n      SITL_HEXA_MISSION_B.Merge[1] = SITL_HEXA_MISSION_B.DataTypeConversion1[1];\r\n      SITL_HEXA_MISSION_B.Merge[2] = SITL_HEXA_MISSION_B.DataTypeConversion1[2];\r\n      SITL_HEXA_MISSION_B.Merge[3] = SITL_HEXA_MISSION_B.DataTypeConversion1[6];\r\n    } else {\r\n      if (rtIsNaN(SITL_HEXA_MISSION_B.Sum_f)) {\r\n        // Switch: '<S569>/Switch' incorporates:\r\n        //   Constant: '<S569>/Constant'\r\n        //   Merge: '<S554>/Merge'\r\n        //   Reshape: '<S569>/Reshape2'\r\n\r\n        SITL_HEXA_MISSION_B.Merge[3] = SITL_HEXA_MISSION_P.Constant_Value_jd;\r\n      } else {\r\n        // Reshape: '<S569>/Reshape2' incorporates:\r\n        //   MATLABSystem: '<S559>/UAV Waypoint Follower'\r\n        //   Merge: '<S554>/Merge'\r\n        //   Switch: '<S569>/Switch'\r\n\r\n        SITL_HEXA_MISSION_B.Merge[3] = SITL_HEXA_MISSION_B.Sum_f;\r\n      }\r\n\r\n      // Math: '<S569>/Transpose1' incorporates:\r\n      //   Merge: '<S554>/Merge'\r\n\r\n      SITL_HEXA_MISSION_B.Merge[0] = SITL_HEXA_MISSION_B.MatrixConcatenate1[0];\r\n      SITL_HEXA_MISSION_B.Merge[1] = SITL_HEXA_MISSION_B.MatrixConcatenate1[1];\r\n      SITL_HEXA_MISSION_B.Merge[2] = SITL_HEXA_MISSION_B.MatrixConcatenate1[2];\r\n    }\r\n\r\n    // End of Switch: '<S569>/Switch1'\r\n    // End of Outputs for SubSystem: '<S554>/Waypoint'\r\n    break;\r\n\r\n   default:\r\n    if (SITL_HEXA_MISSION_B.rtAction != SITL_HEXA_MISSION_B.rtPrevAction) {\r\n      // InitializeConditions for IfAction SubSystem: '<S554>/IDLE' incorporates:\r\n      //   ActionPort: '<S556>/Action Port'\r\n\r\n      // InitializeConditions for If: '<S554>/If' incorporates:\r\n      //   Delay: '<S560>/Delay'\r\n\r\n      SITL_HEXA_MISSION_DW.Delay_DSTATE =\r\n        SITL_HEXA_MISSION_P.Delay_InitialCondition_g0;\r\n\r\n      // End of InitializeConditions for SubSystem: '<S554>/IDLE'\r\n    }\r\n\r\n    // Outputs for IfAction SubSystem: '<S554>/IDLE' incorporates:\r\n    //   ActionPort: '<S556>/Action Port'\r\n\r\n    // Outputs for Enabled SubSystem: '<S560>/Enabled Subsystem2' incorporates:\r\n    //   EnablePort: '<S561>/Enable'\r\n\r\n    if (SITL_HEXA_MISSION_DW.Delay_DSTATE > 0.0) {\r\n      // SignalConversion generated from: '<S561>/yaw_In'\r\n      SITL_HEXA_MISSION_B.yaw_In = SITL_HEXA_MISSION_B.DataTypeConversion1[6];\r\n    }\r\n\r\n    // End of Outputs for SubSystem: '<S560>/Enabled Subsystem2'\r\n\r\n    // Reshape: '<S556>/Reshape1' incorporates:\r\n    //   Delay: '<S560>/Delay'\r\n    //   Merge: '<S554>/Merge'\r\n\r\n    SITL_HEXA_MISSION_B.Merge[0] = SITL_HEXA_MISSION_B.DataTypeConversion1[0];\r\n    SITL_HEXA_MISSION_B.Merge[1] = SITL_HEXA_MISSION_B.DataTypeConversion1[1];\r\n    SITL_HEXA_MISSION_B.Merge[2] = SITL_HEXA_MISSION_B.DataTypeConversion1[2];\r\n    SITL_HEXA_MISSION_B.Merge[3] = SITL_HEXA_MISSION_B.yaw_In;\r\n\r\n    // Update for Delay: '<S560>/Delay' incorporates:\r\n    //   Constant: '<S560>/Constant'\r\n\r\n    SITL_HEXA_MISSION_DW.Delay_DSTATE = SITL_HEXA_MISSION_P.Constant_Value_ic;\r\n\r\n    // End of Outputs for SubSystem: '<S554>/IDLE'\r\n    break;\r\n  }\r\n\r\n  // End of If: '<S554>/If'\r\n\r\n  // Outputs for Enabled SubSystem: '<S555>/Send waypoints to OBC' incorporates:\r\n  //   EnablePort: '<S572>/Enable'\r\n\r\n  // Start for MATLABSystem: '<S555>/Read Parameter'\r\n  if (SITL_HEXA_MISSION_B.ParamStep_b > 0) {\r\n    // BusAssignment: '<S572>/Bus Assignment1' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment'\r\n    //   Constant: '<S582>/Constant'\r\n    //   SignalConversion generated from: '<S578>/Bus Assignment1'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0] =\r\n      SITL_HEXA_MISSION_P.Constant_Value.waypoints[0];\r\n\r\n    // SignalConversion generated from: '<S578>/Matrix Concatenate1'\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate1[0] =\r\n      SITL_HEXA_MISSION_B.In1_p.current.lat;\r\n\r\n    // SignalConversion generated from: '<S578>/Matrix Concatenate1'\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate1[1] =\r\n      SITL_HEXA_MISSION_B.In1_p.current.lon;\r\n\r\n    // DataTypeConversion: '<S578>/Data Type Conversion'\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate1[2] =\r\n      SITL_HEXA_MISSION_B.In1_p.current.alt;\r\n\r\n    // SignalConversion generated from: '<S572>/Matrix Concatenate1'\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate1_k[0] = SITL_HEXA_MISSION_B.In1_f.lat;\r\n\r\n    // SignalConversion generated from: '<S572>/Matrix Concatenate1'\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate1_k[1] = SITL_HEXA_MISSION_B.In1_f.lon;\r\n\r\n    // DataTypeConversion: '<S572>/Data Type Conversion'\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate1_k[2] = SITL_HEXA_MISSION_B.In1_f.alt;\r\n    SITL_HEXA_MISSION_MATLABSystem(SITL_HEXA_MISSION_B.MatrixConcatenate1,\r\n      SITL_HEXA_MISSION_B.MatrixConcatenate1_k,\r\n      SITL_HEXA_MISSION_B.In1_p.current.valid,\r\n      SITL_HEXA_MISSION_B.In1_p.current.type, &SITL_HEXA_MISSION_B.MATLABSystem);\r\n\r\n    // SignalConversion generated from: '<S584>/Matrix Concatenate' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment1'\r\n    //   BusAssignment: '<S578>/Bus Assignment1'\r\n    //   MATLABSystem: '<S578>/MATLAB System'\r\n    //   SignalConversion generated from: '<S578>/MATLAB System'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].position[0] =\r\n      SITL_HEXA_MISSION_B.MATLABSystem.MATLABSystem[0];\r\n\r\n    // SignalConversion generated from: '<S584>/Matrix Concatenate' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment1'\r\n    //   BusAssignment: '<S578>/Bus Assignment1'\r\n    //   MATLABSystem: '<S578>/MATLAB System'\r\n    //   SignalConversion generated from: '<S578>/MATLAB System'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].position[1] =\r\n      SITL_HEXA_MISSION_B.MATLABSystem.MATLABSystem[1];\r\n\r\n    // If: '<S584>/If' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment1'\r\n    //   BusAssignment: '<S578>/Bus Assignment1'\r\n    //   Constant: '<S586>/Constant'\r\n    //   Constant: '<S586>/Constant1'\r\n    //   Constant: '<S587>/Constant'\r\n    //   Constant: '<S587>/Constant1'\r\n\r\n    if (SITL_HEXA_MISSION_B.In1_p.current.type == 4) {\r\n      // Outputs for IfAction SubSystem: '<S584>/If Action Subsystem2' incorporates:\r\n      //   ActionPort: '<S587>/Action Port'\r\n\r\n      // MATLABSystem: '<S587>/Read Parameter' incorporates:\r\n      //   BusAssignment: '<S572>/Bus Assignment1'\r\n      //   BusAssignment: '<S578>/Bus Assignment1'\r\n      //   SignalConversion generated from: '<S587>/Read Parameter'\r\n\r\n      if (SITL_HEXA_MISSION_DW.obj_ga.SampleTime !=\r\n          SITL_HEXA_MISSION_P.ReadParameter_SampleTime_c) {\r\n        SITL_HEXA_MISSION_DW.obj_ga.SampleTime =\r\n          SITL_HEXA_MISSION_P.ReadParameter_SampleTime_c;\r\n      }\r\n\r\n      SITL_HEXA_MISSION_B.OR_g = MW_Param_Step\r\n        (SITL_HEXA_MISSION_DW.obj_ga.MW_PARAMHANDLE, MW_SINGLE,\r\n         &SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].velocity[2]);\r\n      if (SITL_HEXA_MISSION_B.OR_g) {\r\n        SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].velocity[2] = 0.0F;\r\n      }\r\n\r\n      // End of MATLABSystem: '<S587>/Read Parameter'\r\n      SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].velocity[0] =\r\n        SITL_HEXA_MISSION_P.Constant1_Value_d[0];\r\n      SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].velocity[1] =\r\n        SITL_HEXA_MISSION_P.Constant1_Value_d[1];\r\n      SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].position[2] =\r\n        SITL_HEXA_MISSION_P.Constant_Value_f2;\r\n\r\n      // End of Outputs for SubSystem: '<S584>/If Action Subsystem2'\r\n    } else if (SITL_HEXA_MISSION_B.In1_p.current.type == 3) {\r\n      // Outputs for IfAction SubSystem: '<S584>/If Action Subsystem1' incorporates:\r\n      //   ActionPort: '<S586>/Action Port'\r\n\r\n      // MATLABSystem: '<S586>/Read Parameter'\r\n      if (SITL_HEXA_MISSION_DW.obj_b.SampleTime !=\r\n          SITL_HEXA_MISSION_P.ReadParameter_SampleTime_g) {\r\n        SITL_HEXA_MISSION_DW.obj_b.SampleTime =\r\n          SITL_HEXA_MISSION_P.ReadParameter_SampleTime_g;\r\n      }\r\n\r\n      SITL_HEXA_MISSION_B.OR_g = MW_Param_Step\r\n        (SITL_HEXA_MISSION_DW.obj_b.MW_PARAMHANDLE, MW_SINGLE,\r\n         &SITL_HEXA_MISSION_B.ParamStep);\r\n      if (SITL_HEXA_MISSION_B.OR_g) {\r\n        SITL_HEXA_MISSION_B.ParamStep = 0.0F;\r\n      }\r\n\r\n      // Gain: '<S586>/Gain' incorporates:\r\n      //   BusAssignment: '<S572>/Bus Assignment1'\r\n      //   BusAssignment: '<S578>/Bus Assignment1'\r\n      //   MATLABSystem: '<S586>/Read Parameter'\r\n      //\r\n      SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].velocity[2] =\r\n        SITL_HEXA_MISSION_P.Gain_Gain_hp * SITL_HEXA_MISSION_B.ParamStep;\r\n      SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].velocity[0] =\r\n        SITL_HEXA_MISSION_P.Constant1_Value_k4[0];\r\n      SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].velocity[1] =\r\n        SITL_HEXA_MISSION_P.Constant1_Value_k4[1];\r\n      SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].position[2] =\r\n        SITL_HEXA_MISSION_P.Constant_Value_l4;\r\n\r\n      // End of Outputs for SubSystem: '<S584>/If Action Subsystem1'\r\n    } else {\r\n      // Outputs for IfAction SubSystem: '<S584>/If Action Subsystem' incorporates:\r\n      //   ActionPort: '<S585>/Action Port'\r\n\r\n      // SignalConversion generated from: '<S585>/In1' incorporates:\r\n      //   BusAssignment: '<S572>/Bus Assignment1'\r\n      //   BusAssignment: '<S578>/Bus Assignment1'\r\n      //   MATLABSystem: '<S578>/MATLAB System'\r\n      //   SignalConversion generated from: '<S578>/MATLAB System'\r\n\r\n      SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].position[2] =\r\n        SITL_HEXA_MISSION_B.MATLABSystem.MATLABSystem[2];\r\n\r\n      // BusAssignment: '<S578>/Bus Assignment1' incorporates:\r\n      //   BusAssignment: '<S572>/Bus Assignment1'\r\n      //   SignalConversion generated from: '<S584>/Matrix Concatenate1'\r\n      //   SignalConversion generated from: '<S585>/In2'\r\n      //\r\n      SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].velocity[0] =\r\n        SITL_HEXA_MISSION_B.In1_p.current.vx;\r\n      SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].velocity[1] =\r\n        SITL_HEXA_MISSION_B.In1_p.current.vy;\r\n      SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].velocity[2] =\r\n        SITL_HEXA_MISSION_B.In1_p.current.vz;\r\n\r\n      // End of Outputs for SubSystem: '<S584>/If Action Subsystem'\r\n    }\r\n\r\n    // End of If: '<S584>/If'\r\n\r\n    // BusAssignment: '<S578>/Bus Assignment1' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment1'\r\n    //   Constant: '<S578>/Constant5'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].timestamp =\r\n      SITL_HEXA_MISSION_B.In1_p.current.timestamp;\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].type =\r\n      SITL_HEXA_MISSION_B.In1_p.current.type;\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].yaw =\r\n      SITL_HEXA_MISSION_B.In1_p.current.yaw;\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].yaw_speed =\r\n      SITL_HEXA_MISSION_B.In1_p.current.yawspeed;\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[0].point_valid =\r\n      SITL_HEXA_MISSION_P.Constant5_Value;\r\n\r\n    // BusAssignment: '<S572>/Bus Assignment1' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment'\r\n    //   Constant: '<S582>/Constant'\r\n    //   SignalConversion generated from: '<S579>/Bus Assignment1'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[1] =\r\n      SITL_HEXA_MISSION_P.Constant_Value.waypoints[1];\r\n\r\n    // SignalConversion generated from: '<S579>/Matrix Concatenate' incorporates:\r\n    //   SignalConversion generated from: '<S578>/Matrix Concatenate1'\r\n\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate1[0] =\r\n      SITL_HEXA_MISSION_B.In1_p.current.lat;\r\n\r\n    // SignalConversion generated from: '<S579>/Matrix Concatenate' incorporates:\r\n    //   SignalConversion generated from: '<S578>/Matrix Concatenate1'\r\n\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate1[1] =\r\n      SITL_HEXA_MISSION_B.In1_p.current.lon;\r\n\r\n    // DataTypeConversion: '<S579>/Data Type Conversion' incorporates:\r\n    //   DataTypeConversion: '<S578>/Data Type Conversion'\r\n\r\n    SITL_HEXA_MISSION_B.MatrixConcatenate1[2] =\r\n      SITL_HEXA_MISSION_B.In1_p.current.alt;\r\n    SITL_HEXA_MISSION_MATLABSystem(SITL_HEXA_MISSION_B.MatrixConcatenate1,\r\n      SITL_HEXA_MISSION_B.MatrixConcatenate1_k,\r\n      SITL_HEXA_MISSION_B.In1_p.current.valid,\r\n      SITL_HEXA_MISSION_B.In1_p.current.type,\r\n      &SITL_HEXA_MISSION_B.MATLABSystem_b);\r\n\r\n    // SignalConversion generated from: '<S579>/Matrix Concatenate1' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment1'\r\n    //   BusAssignment: '<S579>/Bus Assignment1'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[1].velocity[0] =\r\n      SITL_HEXA_MISSION_B.In1_p.current.vx;\r\n\r\n    // SignalConversion generated from: '<S579>/Matrix Concatenate1' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment1'\r\n    //   BusAssignment: '<S579>/Bus Assignment1'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[1].velocity[1] =\r\n      SITL_HEXA_MISSION_B.In1_p.current.vy;\r\n\r\n    // SignalConversion generated from: '<S579>/Matrix Concatenate1' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment1'\r\n    //   BusAssignment: '<S579>/Bus Assignment1'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[1].velocity[2] =\r\n      SITL_HEXA_MISSION_B.In1_p.current.vz;\r\n\r\n    // BusAssignment: '<S579>/Bus Assignment1' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment1'\r\n    //   BusAssignment: '<S578>/Bus Assignment1'\r\n    //   Constant: '<S579>/Constant5'\r\n    //   MATLABSystem: '<S579>/MATLAB System'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[1].timestamp =\r\n      SITL_HEXA_MISSION_B.In1_p.current.timestamp;\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[1].position[0] =\r\n      SITL_HEXA_MISSION_B.MATLABSystem_b.MATLABSystem[0];\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[1].position[1] =\r\n      SITL_HEXA_MISSION_B.MATLABSystem_b.MATLABSystem[1];\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[1].position[2] =\r\n      SITL_HEXA_MISSION_B.MATLABSystem_b.MATLABSystem[2];\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[1].yaw =\r\n      SITL_HEXA_MISSION_B.In1_p.current.yaw;\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[1].yaw_speed =\r\n      SITL_HEXA_MISSION_B.In1_p.current.yawspeed;\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[1].point_valid =\r\n      SITL_HEXA_MISSION_P.Constant5_Value_k;\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[1].type =\r\n      SITL_HEXA_MISSION_B.In1_p.current.type;\r\n\r\n    // BusAssignment: '<S572>/Bus Assignment1' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment'\r\n    //   Constant: '<S582>/Constant'\r\n    //   SignalConversion generated from: '<S581>/Bus Assignment1'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[2] =\r\n      SITL_HEXA_MISSION_P.Constant_Value.waypoints[2];\r\n\r\n    // MATLABSystem: '<S581>/MATLAB System' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment1'\r\n    //   DataTypeConversion: '<S572>/Data Type Conversion'\r\n    //   DataTypeConversion: '<S581>/Data Type Conversion'\r\n    //   SignalConversion generated from: '<S572>/Matrix Concatenate1'\r\n    //   SignalConversion generated from: '<S581>/Matrix Concatenate'\r\n    //\r\n    if (SITL_HEXA_MISSION_B.In1_p.next.valid) {\r\n      SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_B.In1_p.next.lat -\r\n        SITL_HEXA_MISSION_B.In1_f.lat;\r\n      SITL_HEXA_MISSION_B.Gain_i = SITL_HEXA_MISSION_B.In1_p.next.lon -\r\n        SITL_HEXA_MISSION_B.In1_f.lon;\r\n      SITL_HEXA_MISSION_B.flat = fabs(SITL_HEXA_MISSION_B.Sum_f);\r\n      if (SITL_HEXA_MISSION_B.flat > 180.0) {\r\n        if (rtIsNaN(SITL_HEXA_MISSION_B.Sum_f + 180.0) || rtIsInf\r\n            (SITL_HEXA_MISSION_B.Sum_f + 180.0)) {\r\n          SITL_HEXA_MISSION_B.flat = (rtNaN);\r\n        } else if (SITL_HEXA_MISSION_B.Sum_f + 180.0 == 0.0) {\r\n          SITL_HEXA_MISSION_B.flat = 0.0;\r\n        } else {\r\n          SITL_HEXA_MISSION_B.flat = fmod(SITL_HEXA_MISSION_B.Sum_f + 180.0,\r\n            360.0);\r\n          if (SITL_HEXA_MISSION_B.flat == 0.0) {\r\n            SITL_HEXA_MISSION_B.flat = 0.0;\r\n          } else if (SITL_HEXA_MISSION_B.Sum_f + 180.0 < 0.0) {\r\n            SITL_HEXA_MISSION_B.flat += 360.0;\r\n          }\r\n        }\r\n\r\n        SITL_HEXA_MISSION_B.Sum_f = SITL_HEXA_MISSION_B.Sum_f * 0.0 +\r\n          (SITL_HEXA_MISSION_B.flat - 180.0);\r\n        SITL_HEXA_MISSION_B.flat = fabs(SITL_HEXA_MISSION_B.Sum_f);\r\n      }\r\n\r\n      if (SITL_HEXA_MISSION_B.flat > 90.0) {\r\n        SITL_HEXA_MISSION_B.flat = fabs(SITL_HEXA_MISSION_B.Sum_f);\r\n        SITL_HEXA_MISSION_B.latp2 = (SITL_HEXA_MISSION_B.flat > 90.0);\r\n        SITL_HEXA_MISSION_B.Gain_i += 180.0;\r\n        SITL_HEXA_MISSION_B.b_xyzNED_idx_1 = SITL_HEXA_MISSION_B.Sum_f *\r\n          static_cast<real_T>(SITL_HEXA_MISSION_B.latp2);\r\n        if (rtIsNaN(SITL_HEXA_MISSION_B.b_xyzNED_idx_1)) {\r\n          SITL_HEXA_MISSION_B.absx = (rtNaN);\r\n        } else if (SITL_HEXA_MISSION_B.b_xyzNED_idx_1 < 0.0) {\r\n          SITL_HEXA_MISSION_B.absx = -1.0;\r\n        } else {\r\n          SITL_HEXA_MISSION_B.absx = (SITL_HEXA_MISSION_B.b_xyzNED_idx_1 > 0.0);\r\n        }\r\n\r\n        SITL_HEXA_MISSION_B.Sum_f = (90.0 - (SITL_HEXA_MISSION_B.flat *\r\n          static_cast<real_T>(SITL_HEXA_MISSION_B.latp2) - 90.0)) *\r\n          SITL_HEXA_MISSION_B.absx * static_cast<real_T>\r\n          (SITL_HEXA_MISSION_B.latp2) + SITL_HEXA_MISSION_B.Sum_f *\r\n          static_cast<real_T>(!SITL_HEXA_MISSION_B.latp2);\r\n      }\r\n\r\n      if ((SITL_HEXA_MISSION_B.Gain_i > 180.0) || (SITL_HEXA_MISSION_B.Gain_i <\r\n           -180.0)) {\r\n        SITL_HEXA_MISSION_B.flat = SITL_HEXA_MISSION_rt_remd_snf\r\n          (SITL_HEXA_MISSION_B.Gain_i, 360.0);\r\n        SITL_HEXA_MISSION_B.b_xyzNED_idx_1 = SITL_HEXA_MISSION_B.flat / 180.0;\r\n        if (SITL_HEXA_MISSION_B.b_xyzNED_idx_1 < 0.0) {\r\n          SITL_HEXA_MISSION_B.absx = ceil(SITL_HEXA_MISSION_B.b_xyzNED_idx_1);\r\n        } else {\r\n          SITL_HEXA_MISSION_B.absx = floor(SITL_HEXA_MISSION_B.b_xyzNED_idx_1);\r\n        }\r\n\r\n        SITL_HEXA_MISSION_B.Gain_i = (SITL_HEXA_MISSION_B.flat - 360.0 *\r\n          SITL_HEXA_MISSION_B.absx) + SITL_HEXA_MISSION_B.Gain_i * 0.0;\r\n      }\r\n\r\n      SITL_HEXA_MISSION_B.lla0_tmp = SITL_HEXA_MISSION_sind_d\r\n        (SITL_HEXA_MISSION_B.In1_f.lat);\r\n      SITL_HEXA_MISSION_B.flat = 6.378137E+6 / sqrt(1.0 - 0.0066943799901413165 *\r\n        SITL_HEXA_MISSION_B.lla0_tmp * SITL_HEXA_MISSION_B.lla0_tmp);\r\n      if (rtIsInf(SITL_HEXA_MISSION_B.In1_f.lat) || rtIsNaN\r\n          (SITL_HEXA_MISSION_B.In1_f.lat)) {\r\n        SITL_HEXA_MISSION_B.b_xyzNED_idx_1 = (rtNaN);\r\n      } else {\r\n        SITL_HEXA_MISSION_B.b_xyzNED_idx_1 = SITL_HEXA_MISSION_rt_remd_snf\r\n          (SITL_HEXA_MISSION_B.In1_f.lat, 360.0);\r\n        SITL_HEXA_MISSION_B.absx = fabs(SITL_HEXA_MISSION_B.b_xyzNED_idx_1);\r\n        if (SITL_HEXA_MISSION_B.absx > 180.0) {\r\n          if (SITL_HEXA_MISSION_B.b_xyzNED_idx_1 > 0.0) {\r\n            SITL_HEXA_MISSION_B.b_xyzNED_idx_1 -= 360.0;\r\n          } else {\r\n            SITL_HEXA_MISSION_B.b_xyzNED_idx_1 += 360.0;\r\n          }\r\n\r\n          SITL_HEXA_MISSION_B.absx = fabs(SITL_HEXA_MISSION_B.b_xyzNED_idx_1);\r\n        }\r\n\r\n        if (SITL_HEXA_MISSION_B.absx <= 45.0) {\r\n          SITL_HEXA_MISSION_B.b_xyzNED_idx_1 = cos(0.017453292519943295 *\r\n            SITL_HEXA_MISSION_B.b_xyzNED_idx_1);\r\n        } else if (SITL_HEXA_MISSION_B.absx <= 135.0) {\r\n          if (SITL_HEXA_MISSION_B.b_xyzNED_idx_1 > 0.0) {\r\n            SITL_HEXA_MISSION_B.b_xyzNED_idx_1 = -sin\r\n              ((SITL_HEXA_MISSION_B.b_xyzNED_idx_1 - 90.0) *\r\n               0.017453292519943295);\r\n          } else {\r\n            SITL_HEXA_MISSION_B.b_xyzNED_idx_1 = sin\r\n              ((SITL_HEXA_MISSION_B.b_xyzNED_idx_1 + 90.0) *\r\n               0.017453292519943295);\r\n          }\r\n        } else {\r\n          if (SITL_HEXA_MISSION_B.b_xyzNED_idx_1 > 0.0) {\r\n            SITL_HEXA_MISSION_B.b_xyzNED_idx_1 =\r\n              (SITL_HEXA_MISSION_B.b_xyzNED_idx_1 - 180.0) *\r\n              0.017453292519943295;\r\n          } else {\r\n            SITL_HEXA_MISSION_B.b_xyzNED_idx_1 =\r\n              (SITL_HEXA_MISSION_B.b_xyzNED_idx_1 + 180.0) *\r\n              0.017453292519943295;\r\n          }\r\n\r\n          SITL_HEXA_MISSION_B.b_xyzNED_idx_1 = -cos\r\n            (SITL_HEXA_MISSION_B.b_xyzNED_idx_1);\r\n        }\r\n      }\r\n\r\n      SITL_HEXA_MISSION_B.Sum_f /= SITL_HEXA_MISSION_rt_atan2d_snf(1.0,\r\n        0.99330562000985867 / (1.0 - 0.0066943799901413165 *\r\n        SITL_HEXA_MISSION_B.lla0_tmp * SITL_HEXA_MISSION_B.lla0_tmp) *\r\n        SITL_HEXA_MISSION_B.flat) * 57.295779513082323;\r\n      SITL_HEXA_MISSION_B.b_xyzNED_idx_1 = SITL_HEXA_MISSION_B.Gain_i /\r\n        (SITL_HEXA_MISSION_rt_atan2d_snf(1.0, SITL_HEXA_MISSION_B.flat *\r\n          SITL_HEXA_MISSION_B.b_xyzNED_idx_1) * 57.295779513082323);\r\n      SITL_HEXA_MISSION_B.Gain_i = -static_cast<real_T>\r\n        (SITL_HEXA_MISSION_B.In1_p.next.alt) + SITL_HEXA_MISSION_B.In1_f.alt;\r\n      SITL_HEXA_MISSION_B.distinctWptsIdx[0] = rtIsNaN(SITL_HEXA_MISSION_B.Sum_f);\r\n      SITL_HEXA_MISSION_B.distinctWptsIdx[1] = rtIsNaN\r\n        (SITL_HEXA_MISSION_B.b_xyzNED_idx_1);\r\n      SITL_HEXA_MISSION_B.distinctWptsIdx[2] = rtIsNaN\r\n        (SITL_HEXA_MISSION_B.Gain_i);\r\n      SITL_HEXA_MISSION_B.OR_g = false;\r\n      SITL_HEXA_MISSION_B.iy = 0;\r\n      exitg1 = false;\r\n      while ((!exitg1) && (SITL_HEXA_MISSION_B.iy < 3)) {\r\n        if (SITL_HEXA_MISSION_B.distinctWptsIdx[SITL_HEXA_MISSION_B.iy]) {\r\n          SITL_HEXA_MISSION_B.OR_g = true;\r\n          exitg1 = true;\r\n        } else {\r\n          SITL_HEXA_MISSION_B.iy++;\r\n        }\r\n      }\r\n\r\n      SITL_HEXA_MISSION_B.absx = 0.0 / static_cast<real_T>\r\n        (!SITL_HEXA_MISSION_B.OR_g);\r\n      SITL_HEXA_MISSION_B.BusAssignment1.waypoints[2].position[0] = static_cast<\r\n        real32_T>(SITL_HEXA_MISSION_B.absx + SITL_HEXA_MISSION_B.Sum_f);\r\n      SITL_HEXA_MISSION_B.BusAssignment1.waypoints[2].position[1] =\r\n        static_cast<real32_T>(SITL_HEXA_MISSION_B.absx +\r\n        SITL_HEXA_MISSION_B.b_xyzNED_idx_1);\r\n      SITL_HEXA_MISSION_B.BusAssignment1.waypoints[2].position[2] =\r\n        static_cast<real32_T>(SITL_HEXA_MISSION_B.absx +\r\n        SITL_HEXA_MISSION_B.Gain_i);\r\n    } else {\r\n      SITL_HEXA_MISSION_B.BusAssignment1.waypoints[2].position[0] = 0.0F;\r\n      SITL_HEXA_MISSION_B.BusAssignment1.waypoints[2].position[1] = 0.0F;\r\n      SITL_HEXA_MISSION_B.BusAssignment1.waypoints[2].position[2] = 0.0F;\r\n    }\r\n\r\n    // End of MATLABSystem: '<S581>/MATLAB System'\r\n\r\n    // SignalConversion generated from: '<S581>/Matrix Concatenate1' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment1'\r\n    //   BusAssignment: '<S581>/Bus Assignment1'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[2].velocity[0] =\r\n      SITL_HEXA_MISSION_B.In1_p.next.vx;\r\n\r\n    // SignalConversion generated from: '<S581>/Matrix Concatenate1' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment1'\r\n    //   BusAssignment: '<S581>/Bus Assignment1'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[2].velocity[1] =\r\n      SITL_HEXA_MISSION_B.In1_p.next.vy;\r\n\r\n    // SignalConversion generated from: '<S581>/Matrix Concatenate1' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment1'\r\n    //   BusAssignment: '<S581>/Bus Assignment1'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[2].velocity[2] =\r\n      SITL_HEXA_MISSION_B.In1_p.next.vz;\r\n\r\n    // BusAssignment: '<S581>/Bus Assignment1' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment1'\r\n    //   Constant: '<S581>/Constant5'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[2].timestamp =\r\n      SITL_HEXA_MISSION_B.In1_p.next.timestamp;\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[2].yaw =\r\n      SITL_HEXA_MISSION_B.In1_p.next.yaw;\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[2].yaw_speed =\r\n      SITL_HEXA_MISSION_B.In1_p.next.yawspeed;\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[2].point_valid =\r\n      SITL_HEXA_MISSION_P.Constant5_Value_h;\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[2].type =\r\n      SITL_HEXA_MISSION_B.In1_p.next.type;\r\n\r\n    // SignalConversion generated from: '<S580>/Bus Assignment1' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment'\r\n    //   BusAssignment: '<S580>/Bus Assignment1'\r\n    //   Constant: '<S582>/Constant'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1_f =\r\n      SITL_HEXA_MISSION_P.Constant_Value.waypoints[0];\r\n\r\n    // BusAssignment: '<S580>/Bus Assignment1' incorporates:\r\n    //   Constant: '<S580>/Constant'\r\n    //   Constant: '<S580>/Constant1'\r\n    //   Constant: '<S580>/Constant2'\r\n    //   Constant: '<S580>/Constant3'\r\n    //   Constant: '<S580>/Constant4'\r\n    //   Constant: '<S580>/Constant5'\r\n    //   Constant: '<S580>/Constant6'\r\n    //   Constant: '<S580>/Constant7'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1_f.timestamp =\r\n      SITL_HEXA_MISSION_P.Constant7_Value;\r\n    SITL_HEXA_MISSION_B.BusAssignment1_f.yaw =\r\n      SITL_HEXA_MISSION_P.Constant3_Value;\r\n    SITL_HEXA_MISSION_B.BusAssignment1_f.yaw_speed =\r\n      SITL_HEXA_MISSION_P.Constant4_Value;\r\n    SITL_HEXA_MISSION_B.BusAssignment1_f.position[0] =\r\n      SITL_HEXA_MISSION_P.Constant_Value_fh[0];\r\n    SITL_HEXA_MISSION_B.BusAssignment1_f.velocity[0] =\r\n      SITL_HEXA_MISSION_P.Constant1_Value_h[0];\r\n    SITL_HEXA_MISSION_B.BusAssignment1_f.acceleration[0] =\r\n      SITL_HEXA_MISSION_P.Constant2_Value[0];\r\n    SITL_HEXA_MISSION_B.BusAssignment1_f.position[1] =\r\n      SITL_HEXA_MISSION_P.Constant_Value_fh[1];\r\n    SITL_HEXA_MISSION_B.BusAssignment1_f.velocity[1] =\r\n      SITL_HEXA_MISSION_P.Constant1_Value_h[1];\r\n    SITL_HEXA_MISSION_B.BusAssignment1_f.acceleration[1] =\r\n      SITL_HEXA_MISSION_P.Constant2_Value[1];\r\n    SITL_HEXA_MISSION_B.BusAssignment1_f.position[2] =\r\n      SITL_HEXA_MISSION_P.Constant_Value_fh[2];\r\n    SITL_HEXA_MISSION_B.BusAssignment1_f.velocity[2] =\r\n      SITL_HEXA_MISSION_P.Constant1_Value_h[2];\r\n    SITL_HEXA_MISSION_B.BusAssignment1_f.acceleration[2] =\r\n      SITL_HEXA_MISSION_P.Constant2_Value[2];\r\n    SITL_HEXA_MISSION_B.BusAssignment1_f.point_valid =\r\n      SITL_HEXA_MISSION_P.Constant5_Value_l;\r\n    SITL_HEXA_MISSION_B.BusAssignment1_f.type =\r\n      SITL_HEXA_MISSION_P.Constant6_Value;\r\n\r\n    // BusAssignment: '<S572>/Bus Assignment1' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment'\r\n    //   Constant: '<S572>/Constant'\r\n    //   Constant: '<S582>/Constant'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1.timestamp =\r\n      SITL_HEXA_MISSION_B.In1_p.timestamp;\r\n    SITL_HEXA_MISSION_B.BusAssignment1.type =\r\n      SITL_HEXA_MISSION_P.Constant_Value_fm;\r\n    for (SITL_HEXA_MISSION_B.i1 = 0; SITL_HEXA_MISSION_B.i1 < 7;\r\n         SITL_HEXA_MISSION_B.i1++) {\r\n      SITL_HEXA_MISSION_B.BusAssignment1._padding0[SITL_HEXA_MISSION_B.i1] =\r\n        SITL_HEXA_MISSION_P.Constant_Value._padding0[SITL_HEXA_MISSION_B.i1];\r\n    }\r\n\r\n    // BusAssignment: '<S572>/Bus Assignment1' incorporates:\r\n    //   BusAssignment: '<S580>/Bus Assignment1'\r\n    //   Concatenate: '<S572>/Matrix Concatenate'\r\n\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[3] =\r\n      SITL_HEXA_MISSION_B.BusAssignment1_f;\r\n    SITL_HEXA_MISSION_B.BusAssignment1.waypoints[4] =\r\n      SITL_HEXA_MISSION_B.BusAssignment1_f;\r\n\r\n    // MATLABSystem: '<S583>/SinkBlock' incorporates:\r\n    //   BusAssignment: '<S572>/Bus Assignment1'\r\n\r\n    uORB_write_step(SITL_HEXA_MISSION_DW.obj_mc.orbMetadataObj,\r\n                    &SITL_HEXA_MISSION_DW.obj_mc.orbAdvertiseObj,\r\n                    &SITL_HEXA_MISSION_B.BusAssignment1);\r\n  }\r\n\r\n  // End of Outputs for SubSystem: '<S555>/Send waypoints to OBC'\r\n  SITL_HEXA_MISSION_PX4Timestamp(&SITL_HEXA_MISSION_B.PX4Timestamp_pna);\r\n\r\n  // BusAssignment: '<S552>/Bus Assignment' incorporates:\r\n  //   Constant: '<S590>/Constant'\r\n\r\n  SITL_HEXA_MISSION_B.BusAssignment_m = SITL_HEXA_MISSION_P.Constant_Value_i;\r\n\r\n  // BusAssignment: '<S552>/Bus Assignment' incorporates:\r\n  //   DataTypeConversion: '<S552>/Data Type Conversion'\r\n  //   DataTypeConversion: '<S552>/Data Type Conversion1'\r\n  //   DataTypeConversion: '<S552>/Data Type Conversion2'\r\n  //   DataTypeConversion: '<S552>/Data Type Conversion3'\r\n  //   MATLABSystem: '<S552>/PX4 Timestamp'\r\n\r\n  SITL_HEXA_MISSION_B.BusAssignment_m.timestamp =\r\n    SITL_HEXA_MISSION_B.PX4Timestamp_pna.PX4Timestamp;\r\n  SITL_HEXA_MISSION_B.BusAssignment_m.x = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.Merge[0]);\r\n  SITL_HEXA_MISSION_B.BusAssignment_m.y = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.Merge[1]);\r\n  SITL_HEXA_MISSION_B.BusAssignment_m.z = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.Merge[2]);\r\n  SITL_HEXA_MISSION_B.BusAssignment_m.yaw = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_B.Merge[3]);\r\n  SITL_HEXA_MISSION_SinkBlock(&SITL_HEXA_MISSION_B.BusAssignment_m,\r\n    &SITL_HEXA_MISSION_DW.SinkBlock_a);\r\n  SITL_HEXA_MISSION_PX4Timestamp(&SITL_HEXA_MISSION_B.PX4Timestamp_o);\r\n}\r\n\r\n// Termination for atomic system: '<Root>/Navigation'\r\nvoid SITL_HEXA_MISSION_Navigation_Term(void)\r\n{\r\n  // Terminate for MATLABSystem: '<S555>/Read Parameter'\r\n  if (!SITL_HEXA_MISSION_DW.obj_k.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_k.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S555>/Read Parameter'\r\n\r\n  // Terminate for MATLABSystem: '<S576>/SourceBlock'\r\n  if (!SITL_HEXA_MISSION_DW.obj_e.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_e.matlabCodegenIsDeleted = true;\r\n    if ((SITL_HEXA_MISSION_DW.obj_e.isInitialized == 1) &&\r\n        SITL_HEXA_MISSION_DW.obj_e.isSetupComplete) {\r\n      uORB_read_terminate(&SITL_HEXA_MISSION_DW.obj_e.eventStructObj);\r\n    }\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S576>/SourceBlock'\r\n\r\n  // Terminate for MATLABSystem: '<S574>/SourceBlock'\r\n  if (!SITL_HEXA_MISSION_DW.obj_kz.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_kz.matlabCodegenIsDeleted = true;\r\n    if ((SITL_HEXA_MISSION_DW.obj_kz.isInitialized == 1) &&\r\n        SITL_HEXA_MISSION_DW.obj_kz.isSetupComplete) {\r\n      uORB_read_terminate(&SITL_HEXA_MISSION_DW.obj_kz.eventStructObj);\r\n    }\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S574>/SourceBlock'\r\n\r\n  // Terminate for MATLABSystem: '<S573>/SourceBlock'\r\n  if (!SITL_HEXA_MISSION_DW.obj_gf.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_gf.matlabCodegenIsDeleted = true;\r\n    if ((SITL_HEXA_MISSION_DW.obj_gf.isInitialized == 1) &&\r\n        SITL_HEXA_MISSION_DW.obj_gf.isSetupComplete) {\r\n      uORB_read_terminate(&SITL_HEXA_MISSION_DW.obj_gf.eventStructObj);\r\n    }\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S573>/SourceBlock'\r\n\r\n  // Terminate for MATLABSystem: '<S555>/LLA2LocalCoordinates'\r\n  if (!SITL_HEXA_MISSION_DW.obj_mr.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_mr.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S555>/LLA2LocalCoordinates'\r\n\r\n  // Terminate for Enabled SubSystem: '<S555>/Send waypoints to OBC'\r\n  SITL_HEXA_MISSION_MATLABSystem_Term(&SITL_HEXA_MISSION_DW.MATLABSystem);\r\n\r\n  // Terminate for IfAction SubSystem: '<S584>/If Action Subsystem2'\r\n  // Terminate for MATLABSystem: '<S587>/Read Parameter'\r\n  if (!SITL_HEXA_MISSION_DW.obj_ga.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_ga.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S587>/Read Parameter'\r\n  // End of Terminate for SubSystem: '<S584>/If Action Subsystem2'\r\n\r\n  // Terminate for IfAction SubSystem: '<S584>/If Action Subsystem1'\r\n  // Terminate for MATLABSystem: '<S586>/Read Parameter'\r\n  if (!SITL_HEXA_MISSION_DW.obj_b.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_b.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S586>/Read Parameter'\r\n  // End of Terminate for SubSystem: '<S584>/If Action Subsystem1'\r\n  SITL_HEXA_MISSION_MATLABSystem_Term(&SITL_HEXA_MISSION_DW.MATLABSystem_b);\r\n\r\n  // Terminate for MATLABSystem: '<S581>/MATLAB System'\r\n  if (!SITL_HEXA_MISSION_DW.obj_mu.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_mu.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S581>/MATLAB System'\r\n\r\n  // Terminate for MATLABSystem: '<S583>/SinkBlock'\r\n  if (!SITL_HEXA_MISSION_DW.obj_mc.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_mc.matlabCodegenIsDeleted = true;\r\n    if ((SITL_HEXA_MISSION_DW.obj_mc.isInitialized == 1) &&\r\n        SITL_HEXA_MISSION_DW.obj_mc.isSetupComplete) {\r\n      uORB_write_terminate(&SITL_HEXA_MISSION_DW.obj_mc.orbAdvertiseObj);\r\n    }\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S583>/SinkBlock'\r\n  // End of Terminate for SubSystem: '<S555>/Send waypoints to OBC'\r\n  SITL_HEXA_MISSION_PX4Timestamp_Term(&SITL_HEXA_MISSION_DW.PX4Timestamp_pna);\r\n  SITL_HEXA_MISSION_SinkBlock_Term(&SITL_HEXA_MISSION_DW.SinkBlock_a);\r\n  SITL_HEXA_MISSION_PX4Timestamp_Term(&SITL_HEXA_MISSION_DW.PX4Timestamp_o);\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"Navigation.h","type":"header","group":"subsystem","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: Navigation.h\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef Navigation_h_\r\n#define Navigation_h_\r\n#include <drivers/drv_hrt.h>\r\n#include <poll.h>\r\n#include <uORB/uORB.h>\r\n#include \"rtwtypes.h\"\r\n#include \"MW_uORB_Write.h\"\r\n#include \"MW_Parameter.h\"\r\n#include \"MW_ParameterRead.h\"\r\n#include \"MW_uORB_Read.h\"\r\n#include \"SITL_HEXA_MISSION_types.h\"\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rtGetNaN.h\"\r\n\r\n}\r\n\r\n// Block signals for system '<S578>/MATLAB System'\r\nstruct B_MATLABSystem_SITL_HEXA_MISSION_T {\r\n  real32_T MATLABSystem[3];            // '<S578>/MATLAB System'\r\n  real_T dLat;\r\n};\r\n\r\n// Block states (default storage) for system '<S578>/MATLAB System'\r\nstruct DW_MATLABSystem_SITL_HEXA_MISSION_T {\r\n  px4_internal_block_LLA2LocalCoordinatesNED_SITL_HEXA_MISSION_T obj;// '<S578>/MATLAB System' \r\n  boolean_T objisempty;                // '<S578>/MATLAB System'\r\n};\r\n\r\nextern void SITL_HEXA_MISSION_MATLABSystem_Init\r\n  (DW_MATLABSystem_SITL_HEXA_MISSION_T *localDW);\r\nextern void SITL_HEXA_MISSION_MATLABSystem(const real_T rtu_0[3], const real_T\r\n  rtu_1[3], boolean_T rtu_2, uint8_T rtu_3, B_MATLABSystem_SITL_HEXA_MISSION_T\r\n  *localB);\r\nextern void SITL_HEXA_MISSION_Navigation_Init(void);\r\nextern void SITL_HEXA_MISSION_Navigation(void);\r\nextern void SITL_HEXA_MISSION_MATLABSystem_Term\r\n  (DW_MATLABSystem_SITL_HEXA_MISSION_T *localDW);\r\nextern void SITL_HEXA_MISSION_Navigation_Term(void);\r\n\r\n#endif                                 // Navigation_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"actuatorOutputs.cpp","type":"source","group":"subsystem","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: actuatorOutputs.cpp\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#include \"actuatorOutputs.h\"\r\n#include \"rt_sys_SITL_HEXA_MISSION_0.h\"\r\n#include \"SITL_HEXA_MISSION.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"SITL_HEXA_MISSION_private.h\"\r\n\r\n// System initialize for atomic system: '<Root>/actuatorOutputs'\r\nvoid SITL_HEXA_MISSION_actuatorOutputs_Init(void)\r\n{\r\n  static const char_T ParameterNameStr[14] = \"FDD_M1_STATUS\";\r\n  static const char_T ParameterNameStr_0[14] = \"FDD_M2_STATUS\";\r\n  static const char_T ParameterNameStr_1[14] = \"FDD_M3_STATUS\";\r\n  static const char_T ParameterNameStr_2[14] = \"FDD_M4_STATUS\";\r\n  static const char_T ParameterNameStr_3[14] = \"FDD_M5_STATUS\";\r\n  static const char_T ParameterNameStr_4[14] = \"FDD_M6_STATUS\";\r\n  real_T tmp;\r\n\r\n  // Start for MATLABSystem: '<S596>/Read Parameter13'\r\n  SITL_HEXA_MISSION_DW.obj_j.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_j.SampleTime =\r\n    SITL_HEXA_MISSION_P.ReadParameter13_SampleTime;\r\n  SITL_HEXA_MISSION_DW.obj_j.isInitialized = 1;\r\n  if (SITL_HEXA_MISSION_DW.obj_j.SampleTime == -1.0) {\r\n    tmp = 0.2;\r\n  } else {\r\n    tmp = SITL_HEXA_MISSION_DW.obj_j.SampleTime;\r\n  }\r\n\r\n  SITL_HEXA_MISSION_DW.obj_j.MW_PARAMHANDLE = MW_Init_Param(&ParameterNameStr[0],\r\n    true, tmp * 1000.0);\r\n  SITL_HEXA_MISSION_DW.obj_j.isSetupComplete = true;\r\n\r\n  // End of Start for MATLABSystem: '<S596>/Read Parameter13'\r\n\r\n  // Start for MATLABSystem: '<S596>/Read Parameter1'\r\n  SITL_HEXA_MISSION_DW.obj_i.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_i.SampleTime =\r\n    SITL_HEXA_MISSION_P.ReadParameter1_SampleTime;\r\n  SITL_HEXA_MISSION_DW.obj_i.isInitialized = 1;\r\n  if (SITL_HEXA_MISSION_DW.obj_i.SampleTime == -1.0) {\r\n    tmp = 0.2;\r\n  } else {\r\n    tmp = SITL_HEXA_MISSION_DW.obj_i.SampleTime;\r\n  }\r\n\r\n  SITL_HEXA_MISSION_DW.obj_i.MW_PARAMHANDLE = MW_Init_Param(&ParameterNameStr_0\r\n    [0], true, tmp * 1000.0);\r\n  SITL_HEXA_MISSION_DW.obj_i.isSetupComplete = true;\r\n\r\n  // End of Start for MATLABSystem: '<S596>/Read Parameter1'\r\n\r\n  // Start for MATLABSystem: '<S596>/Read Parameter2'\r\n  SITL_HEXA_MISSION_DW.obj_d.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_d.SampleTime =\r\n    SITL_HEXA_MISSION_P.ReadParameter2_SampleTime;\r\n  SITL_HEXA_MISSION_DW.obj_d.isInitialized = 1;\r\n  if (SITL_HEXA_MISSION_DW.obj_d.SampleTime == -1.0) {\r\n    tmp = 0.2;\r\n  } else {\r\n    tmp = SITL_HEXA_MISSION_DW.obj_d.SampleTime;\r\n  }\r\n\r\n  SITL_HEXA_MISSION_DW.obj_d.MW_PARAMHANDLE = MW_Init_Param(&ParameterNameStr_1\r\n    [0], true, tmp * 1000.0);\r\n  SITL_HEXA_MISSION_DW.obj_d.isSetupComplete = true;\r\n\r\n  // End of Start for MATLABSystem: '<S596>/Read Parameter2'\r\n\r\n  // Start for MATLABSystem: '<S596>/Read Parameter3'\r\n  SITL_HEXA_MISSION_DW.obj_g.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_g.SampleTime =\r\n    SITL_HEXA_MISSION_P.ReadParameter3_SampleTime;\r\n  SITL_HEXA_MISSION_DW.obj_g.isInitialized = 1;\r\n  if (SITL_HEXA_MISSION_DW.obj_g.SampleTime == -1.0) {\r\n    tmp = 0.2;\r\n  } else {\r\n    tmp = SITL_HEXA_MISSION_DW.obj_g.SampleTime;\r\n  }\r\n\r\n  SITL_HEXA_MISSION_DW.obj_g.MW_PARAMHANDLE = MW_Init_Param(&ParameterNameStr_2\r\n    [0], true, tmp * 1000.0);\r\n  SITL_HEXA_MISSION_DW.obj_g.isSetupComplete = true;\r\n\r\n  // End of Start for MATLABSystem: '<S596>/Read Parameter3'\r\n\r\n  // Start for MATLABSystem: '<S596>/Read Parameter4'\r\n  SITL_HEXA_MISSION_DW.obj_o.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_o.SampleTime =\r\n    SITL_HEXA_MISSION_P.ReadParameter4_SampleTime;\r\n  SITL_HEXA_MISSION_DW.obj_o.isInitialized = 1;\r\n  if (SITL_HEXA_MISSION_DW.obj_o.SampleTime == -1.0) {\r\n    tmp = 0.2;\r\n  } else {\r\n    tmp = SITL_HEXA_MISSION_DW.obj_o.SampleTime;\r\n  }\r\n\r\n  SITL_HEXA_MISSION_DW.obj_o.MW_PARAMHANDLE = MW_Init_Param(&ParameterNameStr_3\r\n    [0], true, tmp * 1000.0);\r\n  SITL_HEXA_MISSION_DW.obj_o.isSetupComplete = true;\r\n\r\n  // End of Start for MATLABSystem: '<S596>/Read Parameter4'\r\n\r\n  // Start for MATLABSystem: '<S596>/Read Parameter'\r\n  SITL_HEXA_MISSION_DW.obj_jb.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_jb.SampleTime =\r\n    SITL_HEXA_MISSION_P.ReadParameter_SampleTime_n;\r\n  SITL_HEXA_MISSION_DW.obj_jb.isInitialized = 1;\r\n  if (SITL_HEXA_MISSION_DW.obj_jb.SampleTime == -1.0) {\r\n    tmp = 0.2;\r\n  } else {\r\n    tmp = SITL_HEXA_MISSION_DW.obj_jb.SampleTime;\r\n  }\r\n\r\n  SITL_HEXA_MISSION_DW.obj_jb.MW_PARAMHANDLE = MW_Init_Param\r\n    (&ParameterNameStr_4[0], true, tmp * 1000.0);\r\n  SITL_HEXA_MISSION_DW.obj_jb.isSetupComplete = true;\r\n\r\n  // End of Start for MATLABSystem: '<S596>/Read Parameter'\r\n  SITL_HEXA_MISSION_PX4Timestamp_Init(&SITL_HEXA_MISSION_DW.PX4Timestamp1);\r\n\r\n  // Start for MATLABSystem: '<S601>/SinkBlock' incorporates:\r\n  //   BusAssignment: '<S595>/Bus Assignment'\r\n\r\n  SITL_HEXA_MISSION_DW.obj_kg.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_kg.isInitialized = 1;\r\n  SITL_HEXA_MISSION_DW.obj_kg.orbMetadataObj = ORB_ID(actuator_motors);\r\n  uORB_write_initialize(SITL_HEXA_MISSION_DW.obj_kg.orbMetadataObj,\r\n                        &SITL_HEXA_MISSION_DW.obj_kg.orbAdvertiseObj,\r\n                        &SITL_HEXA_MISSION_B.BusAssignment, 1);\r\n  SITL_HEXA_MISSION_DW.obj_kg.isSetupComplete = true;\r\n\r\n  // Start for MATLABSystem: '<S598>/SourceBlock'\r\n  SITL_HEXA_MISSION_DW.obj_kd.matlabCodegenIsDeleted = false;\r\n  SITL_HEXA_MISSION_DW.obj_kd.isInitialized = 1;\r\n  SITL_HEXA_MISSION_DW.obj_kd.orbMetadataObj = ORB_ID(input_rc);\r\n  uORB_read_initialize(SITL_HEXA_MISSION_DW.obj_kd.orbMetadataObj,\r\n                       &SITL_HEXA_MISSION_DW.obj_kd.eventStructObj);\r\n  SITL_HEXA_MISSION_DW.obj_kd.isSetupComplete = true;\r\n}\r\n\r\n// Output and update for atomic system: '<Root>/actuatorOutputs'\r\nvoid SITL_HEXA_MISSION_actuatorOutputs(void)\r\n{\r\n  real_T u0;\r\n  real_T u0_0;\r\n  real_T u0_1;\r\n  real_T u0_2;\r\n  int32_T ParamStep;\r\n  int32_T ParamStep_0;\r\n  int32_T ParamStep_1;\r\n  int32_T ParamStep_2;\r\n  int32_T ParamStep_3;\r\n  int32_T ParamStep_4;\r\n  boolean_T b_varargout_2;\r\n\r\n  // Gain: '<S3>/Gain'\r\n  SITL_HEXA_MISSION_B.Saturation3 = SITL_HEXA_MISSION_P.Gain_Gain_h *\r\n    SITL_HEXA_MISSION_B.Saturation_b;\r\n\r\n  // Saturate: '<S3>/Saturation3'\r\n  if (SITL_HEXA_MISSION_B.Saturation3 > SITL_HEXA_MISSION_P.Saturation3_UpperSat)\r\n  {\r\n    SITL_HEXA_MISSION_B.Saturation3 = SITL_HEXA_MISSION_P.Saturation3_UpperSat;\r\n  } else if (SITL_HEXA_MISSION_B.Saturation3 <\r\n             SITL_HEXA_MISSION_P.Saturation3_LowerSat) {\r\n    SITL_HEXA_MISSION_B.Saturation3 = SITL_HEXA_MISSION_P.Saturation3_LowerSat;\r\n  }\r\n\r\n  // End of Saturate: '<S3>/Saturation3'\r\n\r\n  // Gain: '<S3>/Gain1'\r\n  SITL_HEXA_MISSION_B.Saturation2 = SITL_HEXA_MISSION_P.Gain1_Gain_e *\r\n    SITL_HEXA_MISSION_B.Saturation_c;\r\n\r\n  // Saturate: '<S3>/Saturation2'\r\n  if (SITL_HEXA_MISSION_B.Saturation2 > SITL_HEXA_MISSION_P.Saturation2_UpperSat)\r\n  {\r\n    SITL_HEXA_MISSION_B.Saturation2 = SITL_HEXA_MISSION_P.Saturation2_UpperSat;\r\n  } else if (SITL_HEXA_MISSION_B.Saturation2 <\r\n             SITL_HEXA_MISSION_P.Saturation2_LowerSat) {\r\n    SITL_HEXA_MISSION_B.Saturation2 = SITL_HEXA_MISSION_P.Saturation2_LowerSat;\r\n  }\r\n\r\n  // End of Saturate: '<S3>/Saturation2'\r\n\r\n  // Gain: '<S3>/Gain2'\r\n  SITL_HEXA_MISSION_B.Saturation1 = SITL_HEXA_MISSION_P.Gain2_Gain_h *\r\n    SITL_HEXA_MISSION_B.Saturation;\r\n\r\n  // Saturate: '<S3>/Saturation1'\r\n  if (SITL_HEXA_MISSION_B.Saturation1 > SITL_HEXA_MISSION_P.Saturation1_UpperSat)\r\n  {\r\n    SITL_HEXA_MISSION_B.Saturation1 = SITL_HEXA_MISSION_P.Saturation1_UpperSat;\r\n  } else if (SITL_HEXA_MISSION_B.Saturation1 <\r\n             SITL_HEXA_MISSION_P.Saturation1_LowerSat) {\r\n    SITL_HEXA_MISSION_B.Saturation1 = SITL_HEXA_MISSION_P.Saturation1_LowerSat;\r\n  }\r\n\r\n  // End of Saturate: '<S3>/Saturation1'\r\n\r\n  // Saturate: '<S3>/Saturation'\r\n  if (SITL_HEXA_MISSION_B.Saturation_d > SITL_HEXA_MISSION_P.Saturation_UpperSat)\r\n  {\r\n    SITL_HEXA_MISSION_B.Saturation_cl = SITL_HEXA_MISSION_P.Saturation_UpperSat;\r\n  } else if (SITL_HEXA_MISSION_B.Saturation_d <\r\n             SITL_HEXA_MISSION_P.Saturation_LowerSat) {\r\n    SITL_HEXA_MISSION_B.Saturation_cl = SITL_HEXA_MISSION_P.Saturation_LowerSat;\r\n  } else {\r\n    SITL_HEXA_MISSION_B.Saturation_cl = SITL_HEXA_MISSION_B.Saturation_d;\r\n  }\r\n\r\n  // End of Saturate: '<S3>/Saturation'\r\n\r\n  // MATLAB Function: '<S3>/MATLAB Function'\r\n  SITL_HEXA_MISSION_B.u0_k = (-SITL_HEXA_MISSION_B.Saturation3 -\r\n    SITL_HEXA_MISSION_B.Saturation1) * SITL_HEXA_MISSION_B.Saturation_cl / 3.0 +\r\n    SITL_HEXA_MISSION_B.Saturation_cl;\r\n  u0 = (SITL_HEXA_MISSION_B.Saturation3 + SITL_HEXA_MISSION_B.Saturation1) *\r\n    SITL_HEXA_MISSION_B.Saturation_cl / 3.0 + SITL_HEXA_MISSION_B.Saturation_cl;\r\n  u0_0 = ((SITL_HEXA_MISSION_B.Saturation3 / 2.0 +\r\n           SITL_HEXA_MISSION_B.Saturation2) - SITL_HEXA_MISSION_B.Saturation1) *\r\n    SITL_HEXA_MISSION_B.Saturation_cl / 3.0 + SITL_HEXA_MISSION_B.Saturation_cl;\r\n  u0_1 = ((-SITL_HEXA_MISSION_B.Saturation2 - SITL_HEXA_MISSION_B.Saturation3 /\r\n           2.0) + SITL_HEXA_MISSION_B.Saturation1) *\r\n    SITL_HEXA_MISSION_B.Saturation_cl / 3.0 + SITL_HEXA_MISSION_B.Saturation_cl;\r\n  u0_2 = ((SITL_HEXA_MISSION_B.Saturation2 - SITL_HEXA_MISSION_B.Saturation3 /\r\n           2.0) + SITL_HEXA_MISSION_B.Saturation1) *\r\n    SITL_HEXA_MISSION_B.Saturation_cl / 3.0 + SITL_HEXA_MISSION_B.Saturation_cl;\r\n  SITL_HEXA_MISSION_B.Saturation3 = ((SITL_HEXA_MISSION_B.Saturation3 / 2.0 -\r\n    SITL_HEXA_MISSION_B.Saturation2) - SITL_HEXA_MISSION_B.Saturation1) *\r\n    SITL_HEXA_MISSION_B.Saturation_cl / 3.0 + SITL_HEXA_MISSION_B.Saturation_cl;\r\n\r\n  // MATLABSystem: '<S596>/Read Parameter13'\r\n  if (SITL_HEXA_MISSION_DW.obj_j.SampleTime !=\r\n      SITL_HEXA_MISSION_P.ReadParameter13_SampleTime) {\r\n    SITL_HEXA_MISSION_DW.obj_j.SampleTime =\r\n      SITL_HEXA_MISSION_P.ReadParameter13_SampleTime;\r\n  }\r\n\r\n  b_varargout_2 = MW_Param_Step(SITL_HEXA_MISSION_DW.obj_j.MW_PARAMHANDLE,\r\n    MW_INT32, &ParamStep);\r\n  if (b_varargout_2) {\r\n    ParamStep = 0;\r\n  }\r\n\r\n  // MATLABSystem: '<S596>/Read Parameter1'\r\n  if (SITL_HEXA_MISSION_DW.obj_i.SampleTime !=\r\n      SITL_HEXA_MISSION_P.ReadParameter1_SampleTime) {\r\n    SITL_HEXA_MISSION_DW.obj_i.SampleTime =\r\n      SITL_HEXA_MISSION_P.ReadParameter1_SampleTime;\r\n  }\r\n\r\n  b_varargout_2 = MW_Param_Step(SITL_HEXA_MISSION_DW.obj_i.MW_PARAMHANDLE,\r\n    MW_INT32, &ParamStep_0);\r\n  if (b_varargout_2) {\r\n    ParamStep_0 = 0;\r\n  }\r\n\r\n  // MATLABSystem: '<S596>/Read Parameter2'\r\n  if (SITL_HEXA_MISSION_DW.obj_d.SampleTime !=\r\n      SITL_HEXA_MISSION_P.ReadParameter2_SampleTime) {\r\n    SITL_HEXA_MISSION_DW.obj_d.SampleTime =\r\n      SITL_HEXA_MISSION_P.ReadParameter2_SampleTime;\r\n  }\r\n\r\n  b_varargout_2 = MW_Param_Step(SITL_HEXA_MISSION_DW.obj_d.MW_PARAMHANDLE,\r\n    MW_INT32, &ParamStep_1);\r\n  if (b_varargout_2) {\r\n    ParamStep_1 = 0;\r\n  }\r\n\r\n  // MATLABSystem: '<S596>/Read Parameter3'\r\n  if (SITL_HEXA_MISSION_DW.obj_g.SampleTime !=\r\n      SITL_HEXA_MISSION_P.ReadParameter3_SampleTime) {\r\n    SITL_HEXA_MISSION_DW.obj_g.SampleTime =\r\n      SITL_HEXA_MISSION_P.ReadParameter3_SampleTime;\r\n  }\r\n\r\n  b_varargout_2 = MW_Param_Step(SITL_HEXA_MISSION_DW.obj_g.MW_PARAMHANDLE,\r\n    MW_INT32, &ParamStep_2);\r\n  if (b_varargout_2) {\r\n    ParamStep_2 = 0;\r\n  }\r\n\r\n  // MATLABSystem: '<S596>/Read Parameter4'\r\n  if (SITL_HEXA_MISSION_DW.obj_o.SampleTime !=\r\n      SITL_HEXA_MISSION_P.ReadParameter4_SampleTime) {\r\n    SITL_HEXA_MISSION_DW.obj_o.SampleTime =\r\n      SITL_HEXA_MISSION_P.ReadParameter4_SampleTime;\r\n  }\r\n\r\n  b_varargout_2 = MW_Param_Step(SITL_HEXA_MISSION_DW.obj_o.MW_PARAMHANDLE,\r\n    MW_INT32, &ParamStep_3);\r\n  if (b_varargout_2) {\r\n    ParamStep_3 = 0;\r\n  }\r\n\r\n  // MATLABSystem: '<S596>/Read Parameter'\r\n  if (SITL_HEXA_MISSION_DW.obj_jb.SampleTime !=\r\n      SITL_HEXA_MISSION_P.ReadParameter_SampleTime_n) {\r\n    SITL_HEXA_MISSION_DW.obj_jb.SampleTime =\r\n      SITL_HEXA_MISSION_P.ReadParameter_SampleTime_n;\r\n  }\r\n\r\n  b_varargout_2 = MW_Param_Step(SITL_HEXA_MISSION_DW.obj_jb.MW_PARAMHANDLE,\r\n    MW_INT32, &ParamStep_4);\r\n  if (b_varargout_2) {\r\n    ParamStep_4 = 0;\r\n  }\r\n\r\n  SITL_HEXA_MISSION_PX4Timestamp(&SITL_HEXA_MISSION_B.PX4Timestamp1);\r\n\r\n  // BusAssignment: '<S595>/Bus Assignment' incorporates:\r\n  //   Constant: '<S600>/Constant'\r\n\r\n  SITL_HEXA_MISSION_B.BusAssignment = SITL_HEXA_MISSION_P.Constant_Value_a;\r\n\r\n  // BusAssignment: '<S595>/Bus Assignment' incorporates:\r\n  //   MATLABSystem: '<S595>/PX4 Timestamp1'\r\n\r\n  SITL_HEXA_MISSION_B.BusAssignment.timestamp =\r\n    SITL_HEXA_MISSION_B.PX4Timestamp1.PX4Timestamp;\r\n\r\n  // Saturate: '<S3>/Saturation4'\r\n  if (SITL_HEXA_MISSION_B.u0_k > SITL_HEXA_MISSION_P.Saturation4_UpperSat) {\r\n    SITL_HEXA_MISSION_B.u0_k = SITL_HEXA_MISSION_P.Saturation4_UpperSat;\r\n  } else if (SITL_HEXA_MISSION_B.u0_k < SITL_HEXA_MISSION_P.Saturation4_LowerSat)\r\n  {\r\n    SITL_HEXA_MISSION_B.u0_k = SITL_HEXA_MISSION_P.Saturation4_LowerSat;\r\n  }\r\n\r\n  // BusAssignment: '<S595>/Bus Assignment' incorporates:\r\n  //   DataTypeConversion: '<S595>/Data Type Conversion'\r\n  //   DataTypeConversion: '<S596>/Data Type Conversion3'\r\n  //   Gain: '<S596>/Gain'\r\n  //   MATLABSystem: '<S596>/Read Parameter13'\r\n  //   Product: '<S596>/Product'\r\n  //   Saturate: '<S3>/Saturation4'\r\n  //\r\n  SITL_HEXA_MISSION_B.BusAssignment.control[0] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.Gain_Gain_b * static_cast<real_T>(ParamStep) *\r\n     SITL_HEXA_MISSION_B.u0_k);\r\n\r\n  // Saturate: '<S3>/Saturation4'\r\n  if (u0 > SITL_HEXA_MISSION_P.Saturation4_UpperSat) {\r\n    u0 = SITL_HEXA_MISSION_P.Saturation4_UpperSat;\r\n  } else if (u0 < SITL_HEXA_MISSION_P.Saturation4_LowerSat) {\r\n    u0 = SITL_HEXA_MISSION_P.Saturation4_LowerSat;\r\n  }\r\n\r\n  // BusAssignment: '<S595>/Bus Assignment' incorporates:\r\n  //   DataTypeConversion: '<S595>/Data Type Conversion'\r\n  //   DataTypeConversion: '<S596>/Data Type Conversion1'\r\n  //   Gain: '<S596>/Gain1'\r\n  //   MATLABSystem: '<S596>/Read Parameter1'\r\n  //   Product: '<S596>/Product1'\r\n  //   Saturate: '<S3>/Saturation4'\r\n  //\r\n  SITL_HEXA_MISSION_B.BusAssignment.control[1] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.Gain1_Gain_o * static_cast<real_T>(ParamStep_0) * u0);\r\n\r\n  // Saturate: '<S3>/Saturation4'\r\n  if (u0_0 > SITL_HEXA_MISSION_P.Saturation4_UpperSat) {\r\n    u0_0 = SITL_HEXA_MISSION_P.Saturation4_UpperSat;\r\n  } else if (u0_0 < SITL_HEXA_MISSION_P.Saturation4_LowerSat) {\r\n    u0_0 = SITL_HEXA_MISSION_P.Saturation4_LowerSat;\r\n  }\r\n\r\n  // BusAssignment: '<S595>/Bus Assignment' incorporates:\r\n  //   DataTypeConversion: '<S595>/Data Type Conversion'\r\n  //   DataTypeConversion: '<S596>/Data Type Conversion2'\r\n  //   Gain: '<S596>/Gain2'\r\n  //   MATLABSystem: '<S596>/Read Parameter2'\r\n  //   Product: '<S596>/Product2'\r\n  //   Saturate: '<S3>/Saturation4'\r\n  //\r\n  SITL_HEXA_MISSION_B.BusAssignment.control[2] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.Gain2_Gain_d * static_cast<real_T>(ParamStep_1) * u0_0);\r\n\r\n  // Saturate: '<S3>/Saturation4'\r\n  if (u0_1 > SITL_HEXA_MISSION_P.Saturation4_UpperSat) {\r\n    u0_1 = SITL_HEXA_MISSION_P.Saturation4_UpperSat;\r\n  } else if (u0_1 < SITL_HEXA_MISSION_P.Saturation4_LowerSat) {\r\n    u0_1 = SITL_HEXA_MISSION_P.Saturation4_LowerSat;\r\n  }\r\n\r\n  // BusAssignment: '<S595>/Bus Assignment' incorporates:\r\n  //   DataTypeConversion: '<S595>/Data Type Conversion'\r\n  //   DataTypeConversion: '<S596>/Data Type Conversion4'\r\n  //   Gain: '<S596>/Gain3'\r\n  //   MATLABSystem: '<S596>/Read Parameter3'\r\n  //   Product: '<S596>/Product3'\r\n  //   Saturate: '<S3>/Saturation4'\r\n  //\r\n  SITL_HEXA_MISSION_B.BusAssignment.control[3] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.Gain3_Gain * static_cast<real_T>(ParamStep_2) * u0_1);\r\n\r\n  // Saturate: '<S3>/Saturation4'\r\n  if (u0_2 > SITL_HEXA_MISSION_P.Saturation4_UpperSat) {\r\n    u0_2 = SITL_HEXA_MISSION_P.Saturation4_UpperSat;\r\n  } else if (u0_2 < SITL_HEXA_MISSION_P.Saturation4_LowerSat) {\r\n    u0_2 = SITL_HEXA_MISSION_P.Saturation4_LowerSat;\r\n  }\r\n\r\n  // BusAssignment: '<S595>/Bus Assignment' incorporates:\r\n  //   DataTypeConversion: '<S595>/Data Type Conversion'\r\n  //   DataTypeConversion: '<S596>/Data Type Conversion5'\r\n  //   Gain: '<S596>/Gain4'\r\n  //   MATLABSystem: '<S596>/Read Parameter4'\r\n  //   Product: '<S596>/Product4'\r\n  //   Saturate: '<S3>/Saturation4'\r\n  //\r\n  SITL_HEXA_MISSION_B.BusAssignment.control[4] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.Gain4_Gain * static_cast<real_T>(ParamStep_3) * u0_2);\r\n\r\n  // Saturate: '<S3>/Saturation4'\r\n  if (SITL_HEXA_MISSION_B.Saturation3 > SITL_HEXA_MISSION_P.Saturation4_UpperSat)\r\n  {\r\n    SITL_HEXA_MISSION_B.Saturation3 = SITL_HEXA_MISSION_P.Saturation4_UpperSat;\r\n  } else if (SITL_HEXA_MISSION_B.Saturation3 <\r\n             SITL_HEXA_MISSION_P.Saturation4_LowerSat) {\r\n    SITL_HEXA_MISSION_B.Saturation3 = SITL_HEXA_MISSION_P.Saturation4_LowerSat;\r\n  }\r\n\r\n  // BusAssignment: '<S595>/Bus Assignment' incorporates:\r\n  //   Constant: '<S595>/Constant'\r\n  //   DataTypeConversion: '<S595>/Data Type Conversion'\r\n  //   DataTypeConversion: '<S596>/Data Type Conversion6'\r\n  //   Gain: '<S596>/Gain5'\r\n  //   MATLABSystem: '<S596>/Read Parameter'\r\n  //   Product: '<S596>/Product5'\r\n  //   Saturate: '<S3>/Saturation4'\r\n  //\r\n  SITL_HEXA_MISSION_B.BusAssignment.control[5] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.Gain5_Gain * static_cast<real_T>(ParamStep_4) *\r\n     SITL_HEXA_MISSION_B.Saturation3);\r\n  SITL_HEXA_MISSION_B.BusAssignment.control[6] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.Constant_Value_a0);\r\n  SITL_HEXA_MISSION_B.BusAssignment.control[7] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.Constant_Value_a0);\r\n  SITL_HEXA_MISSION_B.BusAssignment.control[8] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.Constant_Value_a0);\r\n  SITL_HEXA_MISSION_B.BusAssignment.control[9] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.Constant_Value_a0);\r\n  SITL_HEXA_MISSION_B.BusAssignment.control[10] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.Constant_Value_a0);\r\n  SITL_HEXA_MISSION_B.BusAssignment.control[11] = static_cast<real32_T>\r\n    (SITL_HEXA_MISSION_P.Constant_Value_a0);\r\n\r\n  // MATLABSystem: '<S601>/SinkBlock' incorporates:\r\n  //   BusAssignment: '<S595>/Bus Assignment'\r\n\r\n  uORB_write_step(SITL_HEXA_MISSION_DW.obj_kg.orbMetadataObj,\r\n                  &SITL_HEXA_MISSION_DW.obj_kg.orbAdvertiseObj,\r\n                  &SITL_HEXA_MISSION_B.BusAssignment);\r\n\r\n  // MATLABSystem: '<S598>/SourceBlock'\r\n  uORB_read_step(SITL_HEXA_MISSION_DW.obj_kd.orbMetadataObj,\r\n                 &SITL_HEXA_MISSION_DW.obj_kd.eventStructObj,\r\n                 &SITL_HEXA_MISSION_B.r_m, false, 5000.0);\r\n}\r\n\r\n// Termination for atomic system: '<Root>/actuatorOutputs'\r\nvoid SITL_HEXA_MISSION_actuatorOutputs_Term(void)\r\n{\r\n  // Terminate for MATLABSystem: '<S596>/Read Parameter13'\r\n  if (!SITL_HEXA_MISSION_DW.obj_j.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_j.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S596>/Read Parameter13'\r\n\r\n  // Terminate for MATLABSystem: '<S596>/Read Parameter1'\r\n  if (!SITL_HEXA_MISSION_DW.obj_i.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_i.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S596>/Read Parameter1'\r\n\r\n  // Terminate for MATLABSystem: '<S596>/Read Parameter2'\r\n  if (!SITL_HEXA_MISSION_DW.obj_d.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_d.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S596>/Read Parameter2'\r\n\r\n  // Terminate for MATLABSystem: '<S596>/Read Parameter3'\r\n  if (!SITL_HEXA_MISSION_DW.obj_g.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_g.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S596>/Read Parameter3'\r\n\r\n  // Terminate for MATLABSystem: '<S596>/Read Parameter4'\r\n  if (!SITL_HEXA_MISSION_DW.obj_o.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_o.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S596>/Read Parameter4'\r\n\r\n  // Terminate for MATLABSystem: '<S596>/Read Parameter'\r\n  if (!SITL_HEXA_MISSION_DW.obj_jb.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_jb.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S596>/Read Parameter'\r\n  SITL_HEXA_MISSION_PX4Timestamp_Term(&SITL_HEXA_MISSION_DW.PX4Timestamp1);\r\n\r\n  // Terminate for MATLABSystem: '<S601>/SinkBlock'\r\n  if (!SITL_HEXA_MISSION_DW.obj_kg.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_kg.matlabCodegenIsDeleted = true;\r\n    if ((SITL_HEXA_MISSION_DW.obj_kg.isInitialized == 1) &&\r\n        SITL_HEXA_MISSION_DW.obj_kg.isSetupComplete) {\r\n      uORB_write_terminate(&SITL_HEXA_MISSION_DW.obj_kg.orbAdvertiseObj);\r\n    }\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S601>/SinkBlock'\r\n\r\n  // Terminate for MATLABSystem: '<S598>/SourceBlock'\r\n  if (!SITL_HEXA_MISSION_DW.obj_kd.matlabCodegenIsDeleted) {\r\n    SITL_HEXA_MISSION_DW.obj_kd.matlabCodegenIsDeleted = true;\r\n    if ((SITL_HEXA_MISSION_DW.obj_kd.isInitialized == 1) &&\r\n        SITL_HEXA_MISSION_DW.obj_kd.isSetupComplete) {\r\n      uORB_read_terminate(&SITL_HEXA_MISSION_DW.obj_kd.eventStructObj);\r\n    }\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S598>/SourceBlock'\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"actuatorOutputs.h","type":"header","group":"subsystem","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: actuatorOutputs.h\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef actuatorOutputs_h_\r\n#define actuatorOutputs_h_\r\n#include <drivers/drv_hrt.h>\r\n#include <poll.h>\r\n#include <uORB/uORB.h>\r\n#include \"rtwtypes.h\"\r\n#include \"MW_uORB_Write.h\"\r\n#include \"MW_Parameter.h\"\r\n#include \"MW_ParameterRead.h\"\r\n#include \"MW_uORB_Read.h\"\r\n\r\nextern void SITL_HEXA_MISSION_actuatorOutputs_Init(void);\r\nextern void SITL_HEXA_MISSION_actuatorOutputs(void);\r\nextern void SITL_HEXA_MISSION_actuatorOutputs_Term(void);\r\n\r\n#endif                                 // actuatorOutputs_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"mc_att_controller.cpp","type":"source","group":"subsystem","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: mc_att_controller.cpp\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#include \"rtwtypes.h\"\r\n#include \"mc_att_controller.h\"\r\n#include \"SITL_HEXA_MISSION.h\"\r\n#include <math.h>\r\n#include \"SITL_HEXA_MISSION_private.h\"\r\n\r\nconst real_T SITL_HEXA_MISSION_period = 0.004;\r\n\r\n// System initialize for enable system: '<S5>/mc_att_controller'\r\nvoid SITL_HEXA_MISSION_mc_att_controller_Init(void)\r\n{\r\n  // InitializeConditions for RateLimiter: '<S11>/Rate Limiter2'\r\n  SITL_HEXA_MISSION_DW.PrevY = SITL_HEXA_MISSION_P.RateLimiter2_IC;\r\n\r\n  // InitializeConditions for RateLimiter: '<S11>/Rate Limiter1'\r\n  SITL_HEXA_MISSION_DW.PrevY_f = SITL_HEXA_MISSION_P.RateLimiter1_IC;\r\n\r\n  // SystemInitialize for Saturate: '<S173>/Saturation' incorporates:\r\n  //   Outport: '<S11>/Yawrate_sp'\r\n\r\n  SITL_HEXA_MISSION_B.Saturation_e = SITL_HEXA_MISSION_P.Yawrate_sp_Y0;\r\n\r\n  // SystemInitialize for Gain: '<S71>/Proportional Gain' incorporates:\r\n  //   Outport: '<S11>/Pitchrate_sp'\r\n\r\n  SITL_HEXA_MISSION_B.ProportionalGain = SITL_HEXA_MISSION_P.Pitchrate_sp_Y0;\r\n\r\n  // SystemInitialize for Gain: '<S121>/Proportional Gain' incorporates:\r\n  //   Outport: '<S11>/Rollrate_spl'\r\n\r\n  SITL_HEXA_MISSION_B.ProportionalGain_a = SITL_HEXA_MISSION_P.Rollrate_spl_Y0;\r\n}\r\n\r\n// Output and update for enable system: '<S5>/mc_att_controller'\r\nvoid SITL_HEXA_MISSION_mc_att_controller(void)\r\n{\r\n  // Outputs for Enabled SubSystem: '<S5>/mc_att_controller' incorporates:\r\n  //   EnablePort: '<S11>/Enable'\r\n\r\n  if (SITL_HEXA_MISSION_B.In1_b.armed) {\r\n    real_T rtb_Sum5;\r\n\r\n    // Sum: '<S11>/Sum5'\r\n    rtb_Sum5 = SITL_HEXA_MISSION_B.Merge[3] -\r\n      SITL_HEXA_MISSION_B.VectorConcatenate[0];\r\n\r\n    // Switch: '<S29>/Switch' incorporates:\r\n    //   Abs: '<S29>/Abs'\r\n\r\n    if (fabs(rtb_Sum5) > SITL_HEXA_MISSION_P.Switch_Threshold) {\r\n      // Switch: '<S29>/Switch1' incorporates:\r\n      //   Constant: '<S29>/Constant'\r\n      //   Sum: '<S29>/Add'\r\n      //   Sum: '<S29>/Subtract'\r\n\r\n      if (rtb_Sum5 > SITL_HEXA_MISSION_P.Switch1_Threshold) {\r\n        rtb_Sum5 -= SITL_HEXA_MISSION_P.Constant_Value_p;\r\n      } else {\r\n        rtb_Sum5 += SITL_HEXA_MISSION_P.Constant_Value_p;\r\n      }\r\n\r\n      // End of Switch: '<S29>/Switch1'\r\n    }\r\n\r\n    // End of Switch: '<S29>/Switch'\r\n\r\n    // Gain: '<S171>/Proportional Gain'\r\n    rtb_Sum5 *= SITL_HEXA_MISSION_P.MC_YAW_P;\r\n\r\n    // Saturate: '<S173>/Saturation'\r\n    if (rtb_Sum5 > SITL_HEXA_MISSION_P.PIDController5_UpperSaturationLimit) {\r\n      // Saturate: '<S173>/Saturation'\r\n      SITL_HEXA_MISSION_B.Saturation_e =\r\n        SITL_HEXA_MISSION_P.PIDController5_UpperSaturationLimit;\r\n    } else if (rtb_Sum5 <\r\n               SITL_HEXA_MISSION_P.PIDController5_LowerSaturationLimit) {\r\n      // Saturate: '<S173>/Saturation'\r\n      SITL_HEXA_MISSION_B.Saturation_e =\r\n        SITL_HEXA_MISSION_P.PIDController5_LowerSaturationLimit;\r\n    } else {\r\n      // Saturate: '<S173>/Saturation'\r\n      SITL_HEXA_MISSION_B.Saturation_e = rtb_Sum5;\r\n    }\r\n\r\n    // End of Saturate: '<S173>/Saturation'\r\n\r\n    // RateLimiter: '<S11>/Rate Limiter2'\r\n    rtb_Sum5 = SITL_HEXA_MISSION_B.Gain1 - SITL_HEXA_MISSION_DW.PrevY;\r\n    if (rtb_Sum5 > SITL_HEXA_MISSION_P.RateLimiter2_RisingLim *\r\n        SITL_HEXA_MISSION_period) {\r\n      rtb_Sum5 = SITL_HEXA_MISSION_P.RateLimiter2_RisingLim *\r\n        SITL_HEXA_MISSION_period + SITL_HEXA_MISSION_DW.PrevY;\r\n    } else if (rtb_Sum5 < SITL_HEXA_MISSION_P.RateLimiter2_FallingLim *\r\n               SITL_HEXA_MISSION_period) {\r\n      rtb_Sum5 = SITL_HEXA_MISSION_P.RateLimiter2_FallingLim *\r\n        SITL_HEXA_MISSION_period + SITL_HEXA_MISSION_DW.PrevY;\r\n    } else {\r\n      rtb_Sum5 = SITL_HEXA_MISSION_B.Gain1;\r\n    }\r\n\r\n    SITL_HEXA_MISSION_DW.PrevY = rtb_Sum5;\r\n\r\n    // End of RateLimiter: '<S11>/Rate Limiter2'\r\n\r\n    // Gain: '<S71>/Proportional Gain' incorporates:\r\n    //   Sum: '<S11>/Sum2'\r\n\r\n    SITL_HEXA_MISSION_B.ProportionalGain = (rtb_Sum5 -\r\n      SITL_HEXA_MISSION_B.VectorConcatenate[1]) * SITL_HEXA_MISSION_P.MC_PITCH_P;\r\n\r\n    // RateLimiter: '<S11>/Rate Limiter1'\r\n    rtb_Sum5 = SITL_HEXA_MISSION_B.Saturation_n[1] -\r\n      SITL_HEXA_MISSION_DW.PrevY_f;\r\n    if (rtb_Sum5 > SITL_HEXA_MISSION_P.RateLimiter1_RisingLim *\r\n        SITL_HEXA_MISSION_period) {\r\n      rtb_Sum5 = SITL_HEXA_MISSION_P.RateLimiter1_RisingLim *\r\n        SITL_HEXA_MISSION_period + SITL_HEXA_MISSION_DW.PrevY_f;\r\n    } else if (rtb_Sum5 < SITL_HEXA_MISSION_P.RateLimiter1_FallingLim *\r\n               SITL_HEXA_MISSION_period) {\r\n      rtb_Sum5 = SITL_HEXA_MISSION_P.RateLimiter1_FallingLim *\r\n        SITL_HEXA_MISSION_period + SITL_HEXA_MISSION_DW.PrevY_f;\r\n    } else {\r\n      rtb_Sum5 = SITL_HEXA_MISSION_B.Saturation_n[1];\r\n    }\r\n\r\n    SITL_HEXA_MISSION_DW.PrevY_f = rtb_Sum5;\r\n\r\n    // End of RateLimiter: '<S11>/Rate Limiter1'\r\n\r\n    // Gain: '<S121>/Proportional Gain' incorporates:\r\n    //   Sum: '<S11>/Sum3'\r\n\r\n    SITL_HEXA_MISSION_B.ProportionalGain_a = (rtb_Sum5 -\r\n      SITL_HEXA_MISSION_B.VectorConcatenate[2]) * SITL_HEXA_MISSION_P.MC_ROLL_P;\r\n  }\r\n\r\n  // End of Outputs for SubSystem: '<S5>/mc_att_controller'\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"mc_att_controller.h","type":"header","group":"subsystem","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: mc_att_controller.h\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef mc_att_controller_h_\r\n#define mc_att_controller_h_\r\n#include <drivers/drv_hrt.h>\r\n#include <poll.h>\r\n#include <uORB/uORB.h>\r\n#include \"rtwtypes.h\"\r\n#include \"MW_uORB_Write.h\"\r\n#include \"MW_Parameter.h\"\r\n#include \"MW_ParameterRead.h\"\r\n#include \"MW_uORB_Read.h\"\r\n\r\nextern void SITL_HEXA_MISSION_mc_att_controller_Init(void);\r\nextern void SITL_HEXA_MISSION_mc_att_controller(void);\r\n\r\n#endif                                 // mc_att_controller_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"mc_pos_controller.cpp","type":"source","group":"subsystem","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: mc_pos_controller.cpp\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#include \"mc_pos_controller.h\"\r\n#include \"SITL_HEXA_MISSION.h\"\r\n#include <math.h>\r\n#include \"rtwtypes.h\"\r\n#include \"SITL_HEXA_MISSION_private.h\"\r\n\r\n// System initialize for enable system: '<S5>/mc_pos_controller'\r\nvoid SITL_HEXA_MISSION_mc_pos_controller_Init(void)\r\n{\r\n  // InitializeConditions for DiscreteIntegrator: '<S370>/Filter'\r\n  SITL_HEXA_MISSION_DW.Filter_DSTATE_m =\r\n    SITL_HEXA_MISSION_P.PID_vz_InitialConditionForFilter;\r\n\r\n  // InitializeConditions for DiscreteIntegrator: '<S375>/Integrator'\r\n  SITL_HEXA_MISSION_DW.Integrator_DSTATE_c =\r\n    SITL_HEXA_MISSION_P.PID_vz_InitialConditionForIntegrator;\r\n\r\n  // SystemInitialize for Saturate: '<S382>/Saturation' incorporates:\r\n  //   Outport: '<S12>/tau_Thrust'\r\n\r\n  SITL_HEXA_MISSION_B.Saturation_d = SITL_HEXA_MISSION_P.tau_Thrust_Y0;\r\n\r\n  // SystemInitialize for Outport: '<S12>/des_pitch' incorporates:\r\n  //   Gain: '<S12>/Gain1'\r\n\r\n  SITL_HEXA_MISSION_B.Gain1 = SITL_HEXA_MISSION_P.des_pitch_Y0;\r\n\r\n  // SystemInitialize for Outport: '<S12>/des_roll'\r\n  SITL_HEXA_MISSION_B.Saturation_n[1] = SITL_HEXA_MISSION_P.des_roll_Y0;\r\n\r\n  // SystemInitialize for Saturate: '<S280>/Saturation' incorporates:\r\n  //   Outport: '<S12>/XY_velocity_setpoint'\r\n\r\n  SITL_HEXA_MISSION_B.Saturation_bi[0] =\r\n    SITL_HEXA_MISSION_P.XY_velocity_setpoint_Y0;\r\n  SITL_HEXA_MISSION_B.Saturation_bi[1] =\r\n    SITL_HEXA_MISSION_P.XY_velocity_setpoint_Y0;\r\n\r\n  // SystemInitialize for Saturate: '<S330>/Saturation' incorporates:\r\n  //   Outport: '<S12>/Z_velocity_setpoint'\r\n\r\n  SITL_HEXA_MISSION_B.Saturation_o = SITL_HEXA_MISSION_P.Z_velocity_setpoint_Y0;\r\n}\r\n\r\n// Output and update for enable system: '<S5>/mc_pos_controller'\r\nvoid SITL_HEXA_MISSION_mc_pos_controller(void)\r\n{\r\n  // Outputs for Enabled SubSystem: '<S5>/mc_pos_controller' incorporates:\r\n  //   EnablePort: '<S12>/Enable'\r\n\r\n  if (SITL_HEXA_MISSION_B.In1_b.armed) {\r\n    real_T rtb_FilterCoefficient;\r\n    real_T rtb_Gain;\r\n    real_T rtb_Gain1;\r\n    real_T rtb_SinCos_o1;\r\n    real_T tmp;\r\n    real_T u0;\r\n    real_T y_tmp;\r\n    int8_T tmp_0;\r\n    int8_T tmp_1;\r\n\r\n    // Gain: '<S183>/Gain1'\r\n    rtb_Gain1 = SITL_HEXA_MISSION_P.Gain1_Gain *\r\n      SITL_HEXA_MISSION_B.DataTypeConversion1[2];\r\n\r\n    // Switch: '<S189>/Switch' incorporates:\r\n    //   Constant: '<S183>/Constant'\r\n    //   RelationalOperator: '<S189>/UpperRelop'\r\n    //   Switch: '<S189>/Switch2'\r\n\r\n    if (rtb_Gain1 < SITL_HEXA_MISSION_P.Constant_Value_j4) {\r\n      rtb_Gain1 = SITL_HEXA_MISSION_P.Constant_Value_j4;\r\n    }\r\n\r\n    // Gain: '<S328>/Proportional Gain' incorporates:\r\n    //   Sum: '<S12>/Sum2'\r\n    //   Switch: '<S189>/Switch'\r\n    //   Switch: '<S189>/Switch2'\r\n\r\n    u0 = (SITL_HEXA_MISSION_B.desiredZ - rtb_Gain1) *\r\n      SITL_HEXA_MISSION_P.MPC_Z_P;\r\n\r\n    // Saturate: '<S330>/Saturation'\r\n    rtb_Gain1 = -fabs(SITL_HEXA_MISSION_P.MPC_Z_VEL_MAX_DN);\r\n    if (u0 > SITL_HEXA_MISSION_P.MPC_Z_VEL_MAX_UP) {\r\n      // Saturate: '<S330>/Saturation'\r\n      SITL_HEXA_MISSION_B.Saturation_o = SITL_HEXA_MISSION_P.MPC_Z_VEL_MAX_UP;\r\n    } else if (u0 < rtb_Gain1) {\r\n      // Saturate: '<S330>/Saturation'\r\n      SITL_HEXA_MISSION_B.Saturation_o = rtb_Gain1;\r\n    } else {\r\n      // Saturate: '<S330>/Saturation'\r\n      SITL_HEXA_MISSION_B.Saturation_o = u0;\r\n    }\r\n\r\n    // End of Saturate: '<S330>/Saturation'\r\n\r\n    // Sum: '<S12>/Sum3' incorporates:\r\n    //   UnaryMinus: '<S12>/Unary Minus'\r\n\r\n    rtb_Gain = SITL_HEXA_MISSION_B.Saturation_o -\r\n      (-SITL_HEXA_MISSION_B.DataTypeConversion1[5]);\r\n\r\n    // Gain: '<S380>/Proportional Gain'\r\n    rtb_Gain1 = SITL_HEXA_MISSION_P.MPC_Z_VEL_P_ACC * rtb_Gain;\r\n\r\n    // Gain: '<S378>/Filter Coefficient' incorporates:\r\n    //   DiscreteIntegrator: '<S370>/Filter'\r\n    //   Gain: '<S368>/Derivative Gain'\r\n    //   Sum: '<S370>/SumD'\r\n\r\n    rtb_FilterCoefficient = (SITL_HEXA_MISSION_P.MPC_Z_VEL_D_ACC * rtb_Gain -\r\n      SITL_HEXA_MISSION_DW.Filter_DSTATE_m) * SITL_HEXA_MISSION_P.PID_vz_N;\r\n\r\n    // Sum: '<S385>/Sum Fdbk'\r\n    rtb_SinCos_o1 = (rtb_Gain1 + SITL_HEXA_MISSION_DW.Integrator_DSTATE_c) +\r\n      rtb_FilterCoefficient;\r\n\r\n    // DeadZone: '<S367>/DeadZone'\r\n    if (rtb_SinCos_o1 > SITL_HEXA_MISSION_P.PID_vz_UpperSaturationLimit) {\r\n      rtb_SinCos_o1 -= SITL_HEXA_MISSION_P.PID_vz_UpperSaturationLimit;\r\n    } else if (rtb_SinCos_o1 >= SITL_HEXA_MISSION_P.PID_vz_LowerSaturationLimit)\r\n    {\r\n      rtb_SinCos_o1 = 0.0;\r\n    } else {\r\n      rtb_SinCos_o1 -= SITL_HEXA_MISSION_P.PID_vz_LowerSaturationLimit;\r\n    }\r\n\r\n    // End of DeadZone: '<S367>/DeadZone'\r\n\r\n    // Gain: '<S372>/Integral Gain'\r\n    rtb_Gain *= SITL_HEXA_MISSION_P.MPC_Z_VEL_I_ACC;\r\n\r\n    // Switch: '<S365>/Switch1' incorporates:\r\n    //   Constant: '<S365>/Clamping_zero'\r\n    //   Constant: '<S365>/Constant'\r\n    //   Constant: '<S365>/Constant2'\r\n    //   RelationalOperator: '<S365>/fix for DT propagation issue'\r\n\r\n    if (rtb_SinCos_o1 > SITL_HEXA_MISSION_P.Clamping_zero_Value) {\r\n      tmp_0 = SITL_HEXA_MISSION_P.Constant_Value_mp;\r\n    } else {\r\n      tmp_0 = SITL_HEXA_MISSION_P.Constant2_Value_k;\r\n    }\r\n\r\n    // Switch: '<S365>/Switch2' incorporates:\r\n    //   Constant: '<S365>/Clamping_zero'\r\n    //   Constant: '<S365>/Constant3'\r\n    //   Constant: '<S365>/Constant4'\r\n    //   RelationalOperator: '<S365>/fix for DT propagation issue1'\r\n\r\n    if (rtb_Gain > SITL_HEXA_MISSION_P.Clamping_zero_Value) {\r\n      tmp_1 = SITL_HEXA_MISSION_P.Constant3_Value_i;\r\n    } else {\r\n      tmp_1 = SITL_HEXA_MISSION_P.Constant4_Value_j;\r\n    }\r\n\r\n    // Switch: '<S365>/Switch' incorporates:\r\n    //   Constant: '<S365>/Clamping_zero'\r\n    //   Constant: '<S365>/Constant1'\r\n    //   Logic: '<S365>/AND3'\r\n    //   RelationalOperator: '<S365>/Equal1'\r\n    //   RelationalOperator: '<S365>/Relational Operator'\r\n    //   Switch: '<S365>/Switch1'\r\n    //   Switch: '<S365>/Switch2'\r\n\r\n    if ((SITL_HEXA_MISSION_P.Clamping_zero_Value != rtb_SinCos_o1) && (tmp_0 ==\r\n         tmp_1)) {\r\n      rtb_Gain = SITL_HEXA_MISSION_P.Constant1_Value;\r\n    }\r\n\r\n    // DiscreteIntegrator: '<S375>/Integrator' incorporates:\r\n    //   Switch: '<S365>/Switch'\r\n\r\n    rtb_Gain = SITL_HEXA_MISSION_P.Integrator_gainval * rtb_Gain +\r\n      SITL_HEXA_MISSION_DW.Integrator_DSTATE_c;\r\n\r\n    // Sum: '<S384>/Sum'\r\n    u0 = (rtb_Gain1 + rtb_Gain) + rtb_FilterCoefficient;\r\n\r\n    // Saturate: '<S382>/Saturation'\r\n    if (u0 > SITL_HEXA_MISSION_P.PID_vz_UpperSaturationLimit) {\r\n      // Saturate: '<S382>/Saturation'\r\n      SITL_HEXA_MISSION_B.Saturation_d =\r\n        SITL_HEXA_MISSION_P.PID_vz_UpperSaturationLimit;\r\n    } else if (u0 < SITL_HEXA_MISSION_P.PID_vz_LowerSaturationLimit) {\r\n      // Saturate: '<S382>/Saturation'\r\n      SITL_HEXA_MISSION_B.Saturation_d =\r\n        SITL_HEXA_MISSION_P.PID_vz_LowerSaturationLimit;\r\n    } else {\r\n      // Saturate: '<S382>/Saturation'\r\n      SITL_HEXA_MISSION_B.Saturation_d = u0;\r\n    }\r\n\r\n    // End of Saturate: '<S382>/Saturation'\r\n\r\n    // Trigonometry: '<S184>/SinCos'\r\n    rtb_SinCos_o1 = sin(SITL_HEXA_MISSION_B.Merge[3]);\r\n    rtb_Gain1 = cos(SITL_HEXA_MISSION_B.Merge[3]);\r\n\r\n    // Saturate: '<S280>/Saturation'\r\n    y_tmp = fabs(SITL_HEXA_MISSION_P.MPC_XY_VEL_MAX);\r\n\r\n    // Gain: '<S278>/Proportional Gain' incorporates:\r\n    //   Sum: '<S12>/Sum1'\r\n\r\n    u0 = (SITL_HEXA_MISSION_B.Merge[0] -\r\n          SITL_HEXA_MISSION_B.DataTypeConversion1[0]) *\r\n      SITL_HEXA_MISSION_P.MPC_XY_P;\r\n\r\n    // Saturate: '<S280>/Saturation'\r\n    if (u0 > y_tmp) {\r\n      // Saturate: '<S280>/Saturation'\r\n      u0 = y_tmp;\r\n    } else if (u0 < -y_tmp) {\r\n      // Saturate: '<S280>/Saturation'\r\n      u0 = -y_tmp;\r\n    }\r\n\r\n    // Saturate: '<S280>/Saturation'\r\n    SITL_HEXA_MISSION_B.Saturation_bi[0] = u0;\r\n\r\n    // Sum: '<S12>/Sum'\r\n    tmp = u0 - SITL_HEXA_MISSION_B.DataTypeConversion1[3];\r\n\r\n    // Gain: '<S278>/Proportional Gain' incorporates:\r\n    //   Sum: '<S12>/Sum1'\r\n\r\n    u0 = (SITL_HEXA_MISSION_B.Merge[1] -\r\n          SITL_HEXA_MISSION_B.DataTypeConversion1[1]) *\r\n      SITL_HEXA_MISSION_P.MPC_XY_P;\r\n\r\n    // Saturate: '<S280>/Saturation'\r\n    if (u0 > y_tmp) {\r\n      // Saturate: '<S280>/Saturation'\r\n      u0 = y_tmp;\r\n    } else if (u0 < -y_tmp) {\r\n      // Saturate: '<S280>/Saturation'\r\n      u0 = -y_tmp;\r\n    }\r\n\r\n    // Saturate: '<S280>/Saturation'\r\n    SITL_HEXA_MISSION_B.Saturation_bi[1] = u0;\r\n\r\n    // Sum: '<S12>/Sum'\r\n    y_tmp = u0 - SITL_HEXA_MISSION_B.DataTypeConversion1[4];\r\n\r\n    // Saturate: '<S230>/Saturation' incorporates:\r\n    //   Gain: '<S184>/Gain'\r\n    //   Gain: '<S228>/Proportional Gain'\r\n    //   Product: '<S12>/MatrixMultiply'\r\n    //   Reshape: '<S184>/Reshape'\r\n    //   Reshape: '<S184>/Reshape1'\r\n\r\n    u0 = (rtb_Gain1 * tmp + rtb_SinCos_o1 * y_tmp) *\r\n      SITL_HEXA_MISSION_P.PIDController_P;\r\n    if (u0 > SITL_HEXA_MISSION_P.PIDController_UpperSaturationLimit) {\r\n      SITL_HEXA_MISSION_B.Saturation_n[0] =\r\n        SITL_HEXA_MISSION_P.PIDController_UpperSaturationLimit;\r\n    } else if (u0 < SITL_HEXA_MISSION_P.PIDController_LowerSaturationLimit) {\r\n      SITL_HEXA_MISSION_B.Saturation_n[0] =\r\n        SITL_HEXA_MISSION_P.PIDController_LowerSaturationLimit;\r\n    } else {\r\n      SITL_HEXA_MISSION_B.Saturation_n[0] = u0;\r\n    }\r\n\r\n    u0 = (SITL_HEXA_MISSION_P.Gain_Gain * rtb_SinCos_o1 * tmp + rtb_Gain1 *\r\n          y_tmp) * SITL_HEXA_MISSION_P.PIDController_P;\r\n    if (u0 > SITL_HEXA_MISSION_P.PIDController_UpperSaturationLimit) {\r\n      SITL_HEXA_MISSION_B.Saturation_n[1] =\r\n        SITL_HEXA_MISSION_P.PIDController_UpperSaturationLimit;\r\n    } else if (u0 < SITL_HEXA_MISSION_P.PIDController_LowerSaturationLimit) {\r\n      SITL_HEXA_MISSION_B.Saturation_n[1] =\r\n        SITL_HEXA_MISSION_P.PIDController_LowerSaturationLimit;\r\n    } else {\r\n      SITL_HEXA_MISSION_B.Saturation_n[1] = u0;\r\n    }\r\n\r\n    // End of Saturate: '<S230>/Saturation'\r\n\r\n    // Gain: '<S12>/Gain1'\r\n    SITL_HEXA_MISSION_B.Gain1 = SITL_HEXA_MISSION_P.Gain1_Gain_f *\r\n      SITL_HEXA_MISSION_B.Saturation_n[0];\r\n\r\n    // Update for DiscreteIntegrator: '<S370>/Filter'\r\n    SITL_HEXA_MISSION_DW.Filter_DSTATE_m += SITL_HEXA_MISSION_P.Filter_gainval *\r\n      rtb_FilterCoefficient;\r\n\r\n    // Update for DiscreteIntegrator: '<S375>/Integrator'\r\n    SITL_HEXA_MISSION_DW.Integrator_DSTATE_c = rtb_Gain;\r\n  }\r\n\r\n  // End of Outputs for SubSystem: '<S5>/mc_pos_controller'\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"mc_pos_controller.h","type":"header","group":"subsystem","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: mc_pos_controller.h\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef mc_pos_controller_h_\r\n#define mc_pos_controller_h_\r\n#include <drivers/drv_hrt.h>\r\n#include <poll.h>\r\n#include <uORB/uORB.h>\r\n#include \"rtwtypes.h\"\r\n#include \"MW_uORB_Write.h\"\r\n#include \"MW_Parameter.h\"\r\n#include \"MW_ParameterRead.h\"\r\n#include \"MW_uORB_Read.h\"\r\n\r\nextern void SITL_HEXA_MISSION_mc_pos_controller_Init(void);\r\nextern void SITL_HEXA_MISSION_mc_pos_controller(void);\r\n\r\n#endif                                 // mc_pos_controller_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"mc_rate_controller.cpp","type":"source","group":"subsystem","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: mc_rate_controller.cpp\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#include \"mc_rate_controller.h\"\r\n#include \"SITL_HEXA_MISSION.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"SITL_HEXA_MISSION_private.h\"\r\n\r\n// System initialize for enable system: '<S5>/mc_rate_controller'\r\nvoid SITL_HEXA_MISSION_mc_rate_controller_Init(void)\r\n{\r\n  // InitializeConditions for DiscreteIntegrator: '<S430>/Integrator'\r\n  SITL_HEXA_MISSION_DW.Integrator_DSTATE =\r\n    SITL_HEXA_MISSION_P.PIDController_InitialConditionForIntegrator;\r\n\r\n  // InitializeConditions for DiscreteIntegrator: '<S425>/Filter'\r\n  SITL_HEXA_MISSION_DW.Filter_DSTATE =\r\n    SITL_HEXA_MISSION_P.PIDController_InitialConditionForFilter;\r\n\r\n  // InitializeConditions for DiscreteIntegrator: '<S482>/Integrator'\r\n  SITL_HEXA_MISSION_DW.Integrator_DSTATE_d =\r\n    SITL_HEXA_MISSION_P.PIDController1_InitialConditionForIntegrator;\r\n\r\n  // InitializeConditions for DiscreteIntegrator: '<S477>/Filter'\r\n  SITL_HEXA_MISSION_DW.Filter_DSTATE_h =\r\n    SITL_HEXA_MISSION_P.PIDController1_InitialConditionForFilter;\r\n\r\n  // InitializeConditions for DiscreteIntegrator: '<S534>/Integrator'\r\n  SITL_HEXA_MISSION_DW.Integrator_DSTATE_dd =\r\n    SITL_HEXA_MISSION_P.PIDController2_InitialConditionForIntegrator;\r\n\r\n  // InitializeConditions for DiscreteIntegrator: '<S529>/Filter'\r\n  SITL_HEXA_MISSION_DW.Filter_DSTATE_l =\r\n    SITL_HEXA_MISSION_P.PIDController2_InitialConditionForFilter;\r\n\r\n  // SystemInitialize for Saturate: '<S437>/Saturation' incorporates:\r\n  //   Outport: '<S13>/tau_yaw'\r\n\r\n  SITL_HEXA_MISSION_B.Saturation = SITL_HEXA_MISSION_P.tau_yaw_Y0;\r\n\r\n  // SystemInitialize for Saturate: '<S489>/Saturation' incorporates:\r\n  //   Outport: '<S13>/tau_pitch'\r\n\r\n  SITL_HEXA_MISSION_B.Saturation_c = SITL_HEXA_MISSION_P.tau_pitch_Y0;\r\n\r\n  // SystemInitialize for Saturate: '<S541>/Saturation' incorporates:\r\n  //   Outport: '<S13>/tau_roll'\r\n\r\n  SITL_HEXA_MISSION_B.Saturation_b = SITL_HEXA_MISSION_P.tau_roll_Y0;\r\n}\r\n\r\n// Output and update for enable system: '<S5>/mc_rate_controller'\r\nvoid SITL_HEXA_MISSION_mc_rate_controller(void)\r\n{\r\n  // Outputs for Enabled SubSystem: '<S5>/mc_rate_controller' incorporates:\r\n  //   EnablePort: '<S13>/Enable'\r\n\r\n  if (SITL_HEXA_MISSION_B.In1_b.armed) {\r\n    real_T rtb_DeadZone;\r\n    real_T rtb_FilterCoefficient;\r\n    real_T rtb_FilterCoefficient_a;\r\n    real_T rtb_FilterCoefficient_o;\r\n    real_T rtb_Filter_g;\r\n    real_T rtb_Filter_n;\r\n    real_T rtb_Integrator_a;\r\n    int8_T tmp;\r\n    int8_T tmp_0;\r\n    int8_T tmp_1;\r\n    int8_T tmp_2;\r\n    boolean_T rtb_RelationalOperator_e;\r\n    boolean_T rtb_RelationalOperator_m;\r\n\r\n    // Sum: '<S13>/Sum4'\r\n    SITL_HEXA_MISSION_B.Filter_j = SITL_HEXA_MISSION_B.Saturation_e -\r\n      SITL_HEXA_MISSION_B.DataTypeConversion2[2];\r\n\r\n    // Gain: '<S427>/Integral Gain'\r\n    rtb_Integrator_a = SITL_HEXA_MISSION_P.MC_YAWRATE_I *\r\n      SITL_HEXA_MISSION_B.Filter_j;\r\n\r\n    // Gain: '<S433>/Filter Coefficient' incorporates:\r\n    //   DiscreteIntegrator: '<S425>/Filter'\r\n    //   Gain: '<S423>/Derivative Gain'\r\n    //   Sum: '<S425>/SumD'\r\n\r\n    rtb_FilterCoefficient = (SITL_HEXA_MISSION_P.MC_YAWRATE_D *\r\n      SITL_HEXA_MISSION_B.Filter_j - SITL_HEXA_MISSION_DW.Filter_DSTATE) *\r\n      SITL_HEXA_MISSION_P.PIDController_N;\r\n\r\n    // Sum: '<S439>/Sum' incorporates:\r\n    //   DiscreteIntegrator: '<S430>/Integrator'\r\n    //   Gain: '<S435>/Proportional Gain'\r\n\r\n    SITL_HEXA_MISSION_B.Filter_j = (SITL_HEXA_MISSION_P.MC_YAWRATE_P *\r\n      SITL_HEXA_MISSION_B.Filter_j + SITL_HEXA_MISSION_DW.Integrator_DSTATE) +\r\n      rtb_FilterCoefficient;\r\n\r\n    // DeadZone: '<S422>/DeadZone'\r\n    if (SITL_HEXA_MISSION_B.Filter_j >\r\n        SITL_HEXA_MISSION_P.PIDController_UpperSaturationLimit_p) {\r\n      rtb_Filter_n = SITL_HEXA_MISSION_B.Filter_j -\r\n        SITL_HEXA_MISSION_P.PIDController_UpperSaturationLimit_p;\r\n    } else if (SITL_HEXA_MISSION_B.Filter_j >=\r\n               SITL_HEXA_MISSION_P.PIDController_LowerSaturationLimit_b) {\r\n      rtb_Filter_n = 0.0;\r\n    } else {\r\n      rtb_Filter_n = SITL_HEXA_MISSION_B.Filter_j -\r\n        SITL_HEXA_MISSION_P.PIDController_LowerSaturationLimit_b;\r\n    }\r\n\r\n    // End of DeadZone: '<S422>/DeadZone'\r\n\r\n    // Switch: '<S420>/Switch1' incorporates:\r\n    //   Constant: '<S420>/Clamping_zero'\r\n    //   Constant: '<S420>/Constant'\r\n    //   Constant: '<S420>/Constant2'\r\n    //   RelationalOperator: '<S420>/fix for DT propagation issue'\r\n\r\n    if (rtb_Filter_n > SITL_HEXA_MISSION_P.Clamping_zero_Value_i) {\r\n      tmp = SITL_HEXA_MISSION_P.Constant_Value_dt;\r\n    } else {\r\n      tmp = SITL_HEXA_MISSION_P.Constant2_Value_l;\r\n    }\r\n\r\n    // Switch: '<S420>/Switch2' incorporates:\r\n    //   Constant: '<S420>/Clamping_zero'\r\n    //   Constant: '<S420>/Constant3'\r\n    //   Constant: '<S420>/Constant4'\r\n    //   RelationalOperator: '<S420>/fix for DT propagation issue1'\r\n\r\n    if (rtb_Integrator_a > SITL_HEXA_MISSION_P.Clamping_zero_Value_i) {\r\n      tmp_0 = SITL_HEXA_MISSION_P.Constant3_Value_j;\r\n    } else {\r\n      tmp_0 = SITL_HEXA_MISSION_P.Constant4_Value_c;\r\n    }\r\n\r\n    // RelationalOperator: '<S420>/Relational Operator' incorporates:\r\n    //   Constant: '<S420>/Clamping_zero'\r\n\r\n    rtb_RelationalOperator_e = (SITL_HEXA_MISSION_P.Clamping_zero_Value_i !=\r\n      rtb_Filter_n);\r\n\r\n    // Saturate: '<S437>/Saturation'\r\n    if (SITL_HEXA_MISSION_B.Filter_j >\r\n        SITL_HEXA_MISSION_P.PIDController_UpperSaturationLimit_p) {\r\n      // Saturate: '<S437>/Saturation'\r\n      SITL_HEXA_MISSION_B.Saturation =\r\n        SITL_HEXA_MISSION_P.PIDController_UpperSaturationLimit_p;\r\n    } else if (SITL_HEXA_MISSION_B.Filter_j <\r\n               SITL_HEXA_MISSION_P.PIDController_LowerSaturationLimit_b) {\r\n      // Saturate: '<S437>/Saturation'\r\n      SITL_HEXA_MISSION_B.Saturation =\r\n        SITL_HEXA_MISSION_P.PIDController_LowerSaturationLimit_b;\r\n    } else {\r\n      // Saturate: '<S437>/Saturation'\r\n      SITL_HEXA_MISSION_B.Saturation = SITL_HEXA_MISSION_B.Filter_j;\r\n    }\r\n\r\n    // End of Saturate: '<S437>/Saturation'\r\n\r\n    // Sum: '<S13>/Sum'\r\n    rtb_Filter_n = SITL_HEXA_MISSION_B.ProportionalGain -\r\n      SITL_HEXA_MISSION_B.DataTypeConversion2[1];\r\n\r\n    // Gain: '<S479>/Integral Gain'\r\n    SITL_HEXA_MISSION_B.Filter_j = SITL_HEXA_MISSION_P.MC_PITCHRATE_I *\r\n      rtb_Filter_n;\r\n\r\n    // Gain: '<S485>/Filter Coefficient' incorporates:\r\n    //   DiscreteIntegrator: '<S477>/Filter'\r\n    //   Gain: '<S475>/Derivative Gain'\r\n    //   Sum: '<S477>/SumD'\r\n\r\n    rtb_FilterCoefficient_o = (SITL_HEXA_MISSION_P.MC_PITCHRATE_D * rtb_Filter_n\r\n      - SITL_HEXA_MISSION_DW.Filter_DSTATE_h) *\r\n      SITL_HEXA_MISSION_P.PIDController1_N;\r\n\r\n    // Sum: '<S491>/Sum' incorporates:\r\n    //   DiscreteIntegrator: '<S482>/Integrator'\r\n    //   Gain: '<S487>/Proportional Gain'\r\n\r\n    rtb_Filter_n = (SITL_HEXA_MISSION_P.MC_PITCHRATE_P * rtb_Filter_n +\r\n                    SITL_HEXA_MISSION_DW.Integrator_DSTATE_d) +\r\n      rtb_FilterCoefficient_o;\r\n\r\n    // DeadZone: '<S474>/DeadZone'\r\n    if (rtb_Filter_n > SITL_HEXA_MISSION_P.PIDController1_UpperSaturationLimit)\r\n    {\r\n      rtb_Filter_g = rtb_Filter_n -\r\n        SITL_HEXA_MISSION_P.PIDController1_UpperSaturationLimit;\r\n    } else if (rtb_Filter_n >=\r\n               SITL_HEXA_MISSION_P.PIDController1_LowerSaturationLimit) {\r\n      rtb_Filter_g = 0.0;\r\n    } else {\r\n      rtb_Filter_g = rtb_Filter_n -\r\n        SITL_HEXA_MISSION_P.PIDController1_LowerSaturationLimit;\r\n    }\r\n\r\n    // End of DeadZone: '<S474>/DeadZone'\r\n\r\n    // RelationalOperator: '<S472>/Relational Operator' incorporates:\r\n    //   Constant: '<S472>/Clamping_zero'\r\n\r\n    rtb_RelationalOperator_m = (SITL_HEXA_MISSION_P.Clamping_zero_Value_d !=\r\n      rtb_Filter_g);\r\n\r\n    // Switch: '<S472>/Switch1' incorporates:\r\n    //   Constant: '<S472>/Clamping_zero'\r\n    //   Constant: '<S472>/Constant'\r\n    //   Constant: '<S472>/Constant2'\r\n    //   RelationalOperator: '<S472>/fix for DT propagation issue'\r\n\r\n    if (rtb_Filter_g > SITL_HEXA_MISSION_P.Clamping_zero_Value_d) {\r\n      tmp_1 = SITL_HEXA_MISSION_P.Constant_Value_d5;\r\n    } else {\r\n      tmp_1 = SITL_HEXA_MISSION_P.Constant2_Value_e;\r\n    }\r\n\r\n    // Switch: '<S472>/Switch2' incorporates:\r\n    //   Constant: '<S472>/Clamping_zero'\r\n    //   Constant: '<S472>/Constant3'\r\n    //   Constant: '<S472>/Constant4'\r\n    //   RelationalOperator: '<S472>/fix for DT propagation issue1'\r\n\r\n    if (SITL_HEXA_MISSION_B.Filter_j > SITL_HEXA_MISSION_P.Clamping_zero_Value_d)\r\n    {\r\n      tmp_2 = SITL_HEXA_MISSION_P.Constant3_Value_k;\r\n    } else {\r\n      tmp_2 = SITL_HEXA_MISSION_P.Constant4_Value_n;\r\n    }\r\n\r\n    // Saturate: '<S489>/Saturation'\r\n    if (rtb_Filter_n > SITL_HEXA_MISSION_P.PIDController1_UpperSaturationLimit)\r\n    {\r\n      // Saturate: '<S489>/Saturation'\r\n      SITL_HEXA_MISSION_B.Saturation_c =\r\n        SITL_HEXA_MISSION_P.PIDController1_UpperSaturationLimit;\r\n    } else if (rtb_Filter_n <\r\n               SITL_HEXA_MISSION_P.PIDController1_LowerSaturationLimit) {\r\n      // Saturate: '<S489>/Saturation'\r\n      SITL_HEXA_MISSION_B.Saturation_c =\r\n        SITL_HEXA_MISSION_P.PIDController1_LowerSaturationLimit;\r\n    } else {\r\n      // Saturate: '<S489>/Saturation'\r\n      SITL_HEXA_MISSION_B.Saturation_c = rtb_Filter_n;\r\n    }\r\n\r\n    // End of Saturate: '<S489>/Saturation'\r\n\r\n    // Sum: '<S13>/Sum1'\r\n    rtb_Filter_g = SITL_HEXA_MISSION_B.ProportionalGain_a -\r\n      SITL_HEXA_MISSION_B.DataTypeConversion2[0];\r\n\r\n    // Gain: '<S531>/Integral Gain'\r\n    rtb_Filter_n = SITL_HEXA_MISSION_P.MC_ROLLRATE_I * rtb_Filter_g;\r\n\r\n    // Gain: '<S537>/Filter Coefficient' incorporates:\r\n    //   DiscreteIntegrator: '<S529>/Filter'\r\n    //   Gain: '<S527>/Derivative Gain'\r\n    //   Sum: '<S529>/SumD'\r\n\r\n    rtb_FilterCoefficient_a = (SITL_HEXA_MISSION_P.MC_ROLLRATE_D * rtb_Filter_g\r\n      - SITL_HEXA_MISSION_DW.Filter_DSTATE_l) *\r\n      SITL_HEXA_MISSION_P.PIDController2_N;\r\n\r\n    // Sum: '<S543>/Sum' incorporates:\r\n    //   DiscreteIntegrator: '<S534>/Integrator'\r\n    //   Gain: '<S539>/Proportional Gain'\r\n\r\n    rtb_Filter_g = (SITL_HEXA_MISSION_P.MC_ROLLRATE_P * rtb_Filter_g +\r\n                    SITL_HEXA_MISSION_DW.Integrator_DSTATE_dd) +\r\n      rtb_FilterCoefficient_a;\r\n\r\n    // DeadZone: '<S526>/DeadZone' incorporates:\r\n    //   Saturate: '<S541>/Saturation'\r\n\r\n    if (rtb_Filter_g > SITL_HEXA_MISSION_P.PIDController2_UpperSaturationLimit)\r\n    {\r\n      rtb_DeadZone = rtb_Filter_g -\r\n        SITL_HEXA_MISSION_P.PIDController2_UpperSaturationLimit;\r\n\r\n      // Saturate: '<S541>/Saturation'\r\n      SITL_HEXA_MISSION_B.Saturation_b =\r\n        SITL_HEXA_MISSION_P.PIDController2_UpperSaturationLimit;\r\n    } else {\r\n      if (rtb_Filter_g >=\r\n          SITL_HEXA_MISSION_P.PIDController2_LowerSaturationLimit) {\r\n        rtb_DeadZone = 0.0;\r\n      } else {\r\n        rtb_DeadZone = rtb_Filter_g -\r\n          SITL_HEXA_MISSION_P.PIDController2_LowerSaturationLimit;\r\n      }\r\n\r\n      if (rtb_Filter_g < SITL_HEXA_MISSION_P.PIDController2_LowerSaturationLimit)\r\n      {\r\n        // Saturate: '<S541>/Saturation'\r\n        SITL_HEXA_MISSION_B.Saturation_b =\r\n          SITL_HEXA_MISSION_P.PIDController2_LowerSaturationLimit;\r\n      } else {\r\n        // Saturate: '<S541>/Saturation'\r\n        SITL_HEXA_MISSION_B.Saturation_b = rtb_Filter_g;\r\n      }\r\n    }\r\n\r\n    // End of DeadZone: '<S526>/DeadZone'\r\n\r\n    // Switch: '<S420>/Switch' incorporates:\r\n    //   Constant: '<S420>/Constant1'\r\n    //   Logic: '<S420>/AND3'\r\n    //   RelationalOperator: '<S420>/Equal1'\r\n    //   Switch: '<S420>/Switch1'\r\n    //   Switch: '<S420>/Switch2'\r\n\r\n    if (rtb_RelationalOperator_e && (tmp == tmp_0)) {\r\n      rtb_Integrator_a = SITL_HEXA_MISSION_P.Constant1_Value_k;\r\n    }\r\n\r\n    // Update for DiscreteIntegrator: '<S430>/Integrator' incorporates:\r\n    //   Switch: '<S420>/Switch'\r\n\r\n    SITL_HEXA_MISSION_DW.Integrator_DSTATE +=\r\n      SITL_HEXA_MISSION_P.Integrator_gainval_h * rtb_Integrator_a;\r\n\r\n    // Update for DiscreteIntegrator: '<S425>/Filter'\r\n    SITL_HEXA_MISSION_DW.Filter_DSTATE += SITL_HEXA_MISSION_P.Filter_gainval_f *\r\n      rtb_FilterCoefficient;\r\n\r\n    // Switch: '<S472>/Switch' incorporates:\r\n    //   Constant: '<S472>/Constant1'\r\n    //   Logic: '<S472>/AND3'\r\n    //   RelationalOperator: '<S472>/Equal1'\r\n    //   Switch: '<S472>/Switch1'\r\n    //   Switch: '<S472>/Switch2'\r\n\r\n    if (rtb_RelationalOperator_m && (tmp_1 == tmp_2)) {\r\n      SITL_HEXA_MISSION_B.Filter_j = SITL_HEXA_MISSION_P.Constant1_Value_j;\r\n    }\r\n\r\n    // Update for DiscreteIntegrator: '<S482>/Integrator' incorporates:\r\n    //   Switch: '<S472>/Switch'\r\n\r\n    SITL_HEXA_MISSION_DW.Integrator_DSTATE_d +=\r\n      SITL_HEXA_MISSION_P.Integrator_gainval_b * SITL_HEXA_MISSION_B.Filter_j;\r\n\r\n    // Update for DiscreteIntegrator: '<S477>/Filter'\r\n    SITL_HEXA_MISSION_DW.Filter_DSTATE_h += SITL_HEXA_MISSION_P.Filter_gainval_l\r\n      * rtb_FilterCoefficient_o;\r\n\r\n    // Switch: '<S524>/Switch1' incorporates:\r\n    //   Constant: '<S524>/Clamping_zero'\r\n    //   Constant: '<S524>/Constant'\r\n    //   Constant: '<S524>/Constant2'\r\n    //   RelationalOperator: '<S524>/fix for DT propagation issue'\r\n\r\n    if (rtb_DeadZone > SITL_HEXA_MISSION_P.Clamping_zero_Value_e) {\r\n      tmp = SITL_HEXA_MISSION_P.Constant_Value_km;\r\n    } else {\r\n      tmp = SITL_HEXA_MISSION_P.Constant2_Value_m;\r\n    }\r\n\r\n    // Switch: '<S524>/Switch2' incorporates:\r\n    //   Constant: '<S524>/Clamping_zero'\r\n    //   Constant: '<S524>/Constant3'\r\n    //   Constant: '<S524>/Constant4'\r\n    //   RelationalOperator: '<S524>/fix for DT propagation issue1'\r\n\r\n    if (rtb_Filter_n > SITL_HEXA_MISSION_P.Clamping_zero_Value_e) {\r\n      tmp_0 = SITL_HEXA_MISSION_P.Constant3_Value_d;\r\n    } else {\r\n      tmp_0 = SITL_HEXA_MISSION_P.Constant4_Value_b;\r\n    }\r\n\r\n    // Switch: '<S524>/Switch' incorporates:\r\n    //   Constant: '<S524>/Clamping_zero'\r\n    //   Constant: '<S524>/Constant1'\r\n    //   Logic: '<S524>/AND3'\r\n    //   RelationalOperator: '<S524>/Equal1'\r\n    //   RelationalOperator: '<S524>/Relational Operator'\r\n    //   Switch: '<S524>/Switch1'\r\n    //   Switch: '<S524>/Switch2'\r\n\r\n    if ((SITL_HEXA_MISSION_P.Clamping_zero_Value_e != rtb_DeadZone) && (tmp ==\r\n         tmp_0)) {\r\n      rtb_Filter_n = SITL_HEXA_MISSION_P.Constant1_Value_ka;\r\n    }\r\n\r\n    // Update for DiscreteIntegrator: '<S534>/Integrator' incorporates:\r\n    //   Switch: '<S524>/Switch'\r\n\r\n    SITL_HEXA_MISSION_DW.Integrator_DSTATE_dd +=\r\n      SITL_HEXA_MISSION_P.Integrator_gainval_n * rtb_Filter_n;\r\n\r\n    // Update for DiscreteIntegrator: '<S529>/Filter'\r\n    SITL_HEXA_MISSION_DW.Filter_DSTATE_l += SITL_HEXA_MISSION_P.Filter_gainval_a\r\n      * rtb_FilterCoefficient_a;\r\n  }\r\n\r\n  // End of Outputs for SubSystem: '<S5>/mc_rate_controller'\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"mc_rate_controller.h","type":"header","group":"subsystem","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: mc_rate_controller.h\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef mc_rate_controller_h_\r\n#define mc_rate_controller_h_\r\n#include <drivers/drv_hrt.h>\r\n#include <poll.h>\r\n#include <uORB/uORB.h>\r\n#include \"rtwtypes.h\"\r\n#include \"MW_uORB_Write.h\"\r\n#include \"MW_Parameter.h\"\r\n#include \"MW_ParameterRead.h\"\r\n#include \"MW_uORB_Read.h\"\r\n\r\nextern void SITL_HEXA_MISSION_mc_rate_controller_Init(void);\r\nextern void SITL_HEXA_MISSION_mc_rate_controller(void);\r\n\r\n#endif                                 // mc_rate_controller_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rt_sys_SITL_HEXA_MISSION_0.cpp","type":"source","group":"subsystem","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rt_sys_SITL_HEXA_MISSION_0.cpp\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#include \"rt_sys_SITL_HEXA_MISSION_0.h\"\r\n#include \"SITL_HEXA_MISSION_private.h\"\r\n\r\n// System initialize for atomic system:\r\nvoid SITL_HEXA_MISSION_PX4Timestamp_Init(DW_PX4Timestamp_SITL_HEXA_MISSION_T\r\n  *localDW)\r\n{\r\n  // Start for MATLABSystem: '<S6>/PX4 Timestamp'\r\n  localDW->obj.matlabCodegenIsDeleted = false;\r\n  localDW->objisempty = true;\r\n  localDW->obj.isInitialized = 1;\r\n  localDW->obj.isSetupComplete = true;\r\n}\r\n\r\n// Output and update for atomic system:\r\nvoid SITL_HEXA_MISSION_PX4Timestamp(B_PX4Timestamp_SITL_HEXA_MISSION_T *localB)\r\n{\r\n  // MATLABSystem: '<S6>/PX4 Timestamp'\r\n  localB->PX4Timestamp = hrt_absolute_time();\r\n}\r\n\r\n// Termination for atomic system:\r\nvoid SITL_HEXA_MISSION_PX4Timestamp_Term(DW_PX4Timestamp_SITL_HEXA_MISSION_T\r\n  *localDW)\r\n{\r\n  // Terminate for MATLABSystem: '<S6>/PX4 Timestamp'\r\n  if (!localDW->obj.matlabCodegenIsDeleted) {\r\n    localDW->obj.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S6>/PX4 Timestamp'\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rt_sys_SITL_HEXA_MISSION_0.h","type":"header","group":"subsystem","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rt_sys_SITL_HEXA_MISSION_0.h\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef rt_sys_SITL_HEXA_MISSION_0_h_\r\n#define rt_sys_SITL_HEXA_MISSION_0_h_\r\n#include <drivers/drv_hrt.h>\r\n#include <poll.h>\r\n#include <uORB/uORB.h>\r\n#include \"rtwtypes.h\"\r\n#include \"MW_uORB_Write.h\"\r\n#include \"MW_Parameter.h\"\r\n#include \"MW_ParameterRead.h\"\r\n#include \"MW_uORB_Read.h\"\r\n#include \"SITL_HEXA_MISSION_types.h\"\r\n\r\n// Block signals for system '<S6>/PX4 Timestamp'\r\nstruct B_PX4Timestamp_SITL_HEXA_MISSION_T {\r\n  uint64_T PX4Timestamp;               // '<S6>/PX4 Timestamp'\r\n};\r\n\r\n// Block states (default storage) for system '<S6>/PX4 Timestamp'\r\nstruct DW_PX4Timestamp_SITL_HEXA_MISSION_T {\r\n  px4_internal_block_getPX4AbsoluteTime_SITL_HEXA_MISSION_T obj;// '<S6>/PX4 Timestamp' \r\n  boolean_T objisempty;                // '<S6>/PX4 Timestamp'\r\n};\r\n\r\nextern void SITL_HEXA_MISSION_PX4Timestamp_Init\r\n  (DW_PX4Timestamp_SITL_HEXA_MISSION_T *localDW);\r\nextern void SITL_HEXA_MISSION_PX4Timestamp(B_PX4Timestamp_SITL_HEXA_MISSION_T\r\n  *localB);\r\nextern void SITL_HEXA_MISSION_PX4Timestamp_Term\r\n  (DW_PX4Timestamp_SITL_HEXA_MISSION_T *localDW);\r\n\r\n#endif                                 // rt_sys_SITL_HEXA_MISSION_0_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rt_sys_SITL_HEXA_MISSION_2.cpp","type":"source","group":"subsystem","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rt_sys_SITL_HEXA_MISSION_2.cpp\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#include <uORB/topics/vehicle_local_position_setpoint.h>\r\n#include \"rt_sys_SITL_HEXA_MISSION_2.h\"\r\n#include \"SITL_HEXA_MISSION_private.h\"\r\n\r\n// System initialize for atomic system:\r\nvoid SITL_HEXA_MISSION_SinkBlock_Init(const\r\n  px4_Bus_vehicle_local_position_setpoint *rtu_0,\r\n  DW_SinkBlock_SITL_HEXA_MISSION_T *localDW)\r\n{\r\n  // Start for MATLABSystem: '<S17>/SinkBlock'\r\n  localDW->obj.matlabCodegenIsDeleted = false;\r\n  localDW->objisempty = true;\r\n  localDW->obj.isInitialized = 1;\r\n  localDW->obj.orbMetadataObj = ORB_ID(vehicle_local_position_setpoint);\r\n  uORB_write_initialize(localDW->obj.orbMetadataObj,\r\n                        &localDW->obj.orbAdvertiseObj, rtu_0, 1);\r\n  localDW->obj.isSetupComplete = true;\r\n}\r\n\r\n// Output and update for atomic system:\r\nvoid SITL_HEXA_MISSION_SinkBlock(const px4_Bus_vehicle_local_position_setpoint\r\n  *rtu_0, DW_SinkBlock_SITL_HEXA_MISSION_T *localDW)\r\n{\r\n  // MATLABSystem: '<S17>/SinkBlock'\r\n  uORB_write_step(localDW->obj.orbMetadataObj, &localDW->obj.orbAdvertiseObj,\r\n                  rtu_0);\r\n}\r\n\r\n// Termination for atomic system:\r\nvoid SITL_HEXA_MISSION_SinkBlock_Term(DW_SinkBlock_SITL_HEXA_MISSION_T *localDW)\r\n{\r\n  // Terminate for MATLABSystem: '<S17>/SinkBlock'\r\n  if (!localDW->obj.matlabCodegenIsDeleted) {\r\n    localDW->obj.matlabCodegenIsDeleted = true;\r\n    if ((localDW->obj.isInitialized == 1) && localDW->obj.isSetupComplete) {\r\n      uORB_write_terminate(&localDW->obj.orbAdvertiseObj);\r\n    }\r\n  }\r\n\r\n  // End of Terminate for MATLABSystem: '<S17>/SinkBlock'\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rt_sys_SITL_HEXA_MISSION_2.h","type":"header","group":"subsystem","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Subsystem files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rt_sys_SITL_HEXA_MISSION_2.h\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef rt_sys_SITL_HEXA_MISSION_2_h_\r\n#define rt_sys_SITL_HEXA_MISSION_2_h_\r\n#include <drivers/drv_hrt.h>\r\n#include <poll.h>\r\n#include <uORB/uORB.h>\r\n#include \"rtwtypes.h\"\r\n#include \"MW_uORB_Write.h\"\r\n#include \"MW_Parameter.h\"\r\n#include \"MW_ParameterRead.h\"\r\n#include \"MW_uORB_Read.h\"\r\n#include <uORB/topics/vehicle_local_position_setpoint.h>\r\n#include \"SITL_HEXA_MISSION_types.h\"\r\n\r\n// Block states (default storage) for system '<S17>/SinkBlock'\r\nstruct DW_SinkBlock_SITL_HEXA_MISSION_T {\r\n  px4_internal_block_Publisher_SITL_HEXA_MISSION_T obj;// '<S17>/SinkBlock'\r\n  boolean_T objisempty;                // '<S17>/SinkBlock'\r\n};\r\n\r\nextern void SITL_HEXA_MISSION_SinkBlock_Init(const\r\n  px4_Bus_vehicle_local_position_setpoint *rtu_0,\r\n  DW_SinkBlock_SITL_HEXA_MISSION_T *localDW);\r\nextern void SITL_HEXA_MISSION_SinkBlock(const\r\n  px4_Bus_vehicle_local_position_setpoint *rtu_0,\r\n  DW_SinkBlock_SITL_HEXA_MISSION_T *localDW);\r\nextern void SITL_HEXA_MISSION_SinkBlock_Term(DW_SinkBlock_SITL_HEXA_MISSION_T\r\n  *localDW);\r\n\r\n#endif                                 // rt_sys_SITL_HEXA_MISSION_2_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"SITL_HEXA_MISSION_data.cpp","type":"source","group":"data","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Data files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: SITL_HEXA_MISSION_data.cpp\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#include \"SITL_HEXA_MISSION.h\"\r\n\r\n// Block parameters (default storage)\r\nP_SITL_HEXA_MISSION_T SITL_HEXA_MISSION_P = {\r\n  // Variable: MC_PITCHRATE_D\r\n  //  Referenced by: '<S475>/Derivative Gain'\r\n\r\n  0.001,\r\n\r\n  // Variable: MC_PITCHRATE_I\r\n  //  Referenced by: '<S479>/Integral Gain'\r\n\r\n  0.04,\r\n\r\n  // Variable: MC_PITCHRATE_P\r\n  //  Referenced by: '<S487>/Proportional Gain'\r\n\r\n  0.08,\r\n\r\n  // Variable: MC_PITCH_P\r\n  //  Referenced by: '<S71>/Proportional Gain'\r\n\r\n  9.0,\r\n\r\n  // Variable: MC_ROLLRATE_D\r\n  //  Referenced by: '<S527>/Derivative Gain'\r\n\r\n  0.001,\r\n\r\n  // Variable: MC_ROLLRATE_I\r\n  //  Referenced by: '<S531>/Integral Gain'\r\n\r\n  0.04,\r\n\r\n  // Variable: MC_ROLLRATE_P\r\n  //  Referenced by: '<S539>/Proportional Gain'\r\n\r\n  0.08,\r\n\r\n  // Variable: MC_ROLL_P\r\n  //  Referenced by: '<S121>/Proportional Gain'\r\n\r\n  9.0,\r\n\r\n  // Variable: MC_YAWRATE_D\r\n  //  Referenced by: '<S423>/Derivative Gain'\r\n\r\n  0.0,\r\n\r\n  // Variable: MC_YAWRATE_I\r\n  //  Referenced by: '<S427>/Integral Gain'\r\n\r\n  0.1,\r\n\r\n  // Variable: MC_YAWRATE_P\r\n  //  Referenced by: '<S435>/Proportional Gain'\r\n\r\n  0.2,\r\n\r\n  // Variable: MC_YAW_P\r\n  //  Referenced by: '<S171>/Proportional Gain'\r\n\r\n  2.8,\r\n\r\n  // Variable: MPC_XY_P\r\n  //  Referenced by: '<S278>/Proportional Gain'\r\n\r\n  1.0,\r\n\r\n  // Variable: MPC_XY_VEL_MAX\r\n  //  Referenced by: '<S280>/Saturation'\r\n\r\n  4.0,\r\n\r\n  // Variable: MPC_Z_P\r\n  //  Referenced by: '<S328>/Proportional Gain'\r\n\r\n  1.0,\r\n\r\n  // Variable: MPC_Z_VEL_D_ACC\r\n  //  Referenced by: '<S368>/Derivative Gain'\r\n\r\n  0.05,\r\n\r\n  // Variable: MPC_Z_VEL_I_ACC\r\n  //  Referenced by: '<S372>/Integral Gain'\r\n\r\n  0.1,\r\n\r\n  // Variable: MPC_Z_VEL_MAX_DN\r\n  //  Referenced by: '<S330>/Saturation'\r\n\r\n  2.0,\r\n\r\n  // Variable: MPC_Z_VEL_MAX_UP\r\n  //  Referenced by: '<S330>/Saturation'\r\n\r\n  2.0,\r\n\r\n  // Variable: MPC_Z_VEL_P_ACC\r\n  //  Referenced by: '<S380>/Proportional Gain'\r\n\r\n  0.5,\r\n\r\n  // Mask Parameter: PID_vz_InitialConditionForFilter\r\n  //  Referenced by: '<S370>/Filter'\r\n\r\n  0.0,\r\n\r\n  // Mask Parameter: PIDController_InitialConditionForFilter\r\n  //  Referenced by: '<S425>/Filter'\r\n\r\n  0.0,\r\n\r\n  // Mask Parameter: PIDController1_InitialConditionForFilter\r\n  //  Referenced by: '<S477>/Filter'\r\n\r\n  0.0,\r\n\r\n  // Mask Parameter: PIDController2_InitialConditionForFilter\r\n  //  Referenced by: '<S529>/Filter'\r\n\r\n  0.0,\r\n\r\n  // Mask Parameter: PID_vz_InitialConditionForIntegrator\r\n  //  Referenced by: '<S375>/Integrator'\r\n\r\n  0.0,\r\n\r\n  // Mask Parameter: PIDController_InitialConditionForIntegrator\r\n  //  Referenced by: '<S430>/Integrator'\r\n\r\n  0.0,\r\n\r\n  // Mask Parameter: PIDController1_InitialConditionForIntegrator\r\n  //  Referenced by: '<S482>/Integrator'\r\n\r\n  0.0,\r\n\r\n  // Mask Parameter: PIDController2_InitialConditionForIntegrator\r\n  //  Referenced by: '<S534>/Integrator'\r\n\r\n  0.0,\r\n\r\n  // Mask Parameter: PIDController5_LowerSaturationLimit\r\n  //  Referenced by: '<S173>/Saturation'\r\n\r\n  -0.87266462599716477,\r\n\r\n  // Mask Parameter: PID_vz_LowerSaturationLimit\r\n  //  Referenced by:\r\n  //    '<S382>/Saturation'\r\n  //    '<S367>/DeadZone'\r\n\r\n  0.0,\r\n\r\n  // Mask Parameter: PIDController_LowerSaturationLimit\r\n  //  Referenced by: '<S230>/Saturation'\r\n\r\n  -0.3490658503988659,\r\n\r\n  // Mask Parameter: PIDController_LowerSaturationLimit_b\r\n  //  Referenced by:\r\n  //    '<S437>/Saturation'\r\n  //    '<S422>/DeadZone'\r\n\r\n  -0.1,\r\n\r\n  // Mask Parameter: PIDController1_LowerSaturationLimit\r\n  //  Referenced by:\r\n  //    '<S489>/Saturation'\r\n  //    '<S474>/DeadZone'\r\n\r\n  -0.2,\r\n\r\n  // Mask Parameter: PIDController2_LowerSaturationLimit\r\n  //  Referenced by:\r\n  //    '<S541>/Saturation'\r\n  //    '<S526>/DeadZone'\r\n\r\n  -0.2,\r\n\r\n  // Mask Parameter: PID_vz_N\r\n  //  Referenced by: '<S378>/Filter Coefficient'\r\n\r\n  10.0,\r\n\r\n  // Mask Parameter: PIDController_N\r\n  //  Referenced by: '<S433>/Filter Coefficient'\r\n\r\n  100.0,\r\n\r\n  // Mask Parameter: PIDController1_N\r\n  //  Referenced by: '<S485>/Filter Coefficient'\r\n\r\n  50.0,\r\n\r\n  // Mask Parameter: PIDController2_N\r\n  //  Referenced by: '<S537>/Filter Coefficient'\r\n\r\n  50.0,\r\n\r\n  // Mask Parameter: PIDController_P\r\n  //  Referenced by: '<S228>/Proportional Gain'\r\n\r\n  0.3,\r\n\r\n  // Mask Parameter: PIDController5_UpperSaturationLimit\r\n  //  Referenced by: '<S173>/Saturation'\r\n\r\n  0.87266462599716477,\r\n\r\n  // Mask Parameter: PID_vz_UpperSaturationLimit\r\n  //  Referenced by:\r\n  //    '<S382>/Saturation'\r\n  //    '<S367>/DeadZone'\r\n\r\n  1.0,\r\n\r\n  // Mask Parameter: PIDController_UpperSaturationLimit\r\n  //  Referenced by: '<S230>/Saturation'\r\n\r\n  0.3490658503988659,\r\n\r\n  // Mask Parameter: PIDController_UpperSaturationLimit_p\r\n  //  Referenced by:\r\n  //    '<S437>/Saturation'\r\n  //    '<S422>/DeadZone'\r\n\r\n  0.1,\r\n\r\n  // Mask Parameter: PIDController1_UpperSaturationLimit\r\n  //  Referenced by:\r\n  //    '<S489>/Saturation'\r\n  //    '<S474>/DeadZone'\r\n\r\n  0.2,\r\n\r\n  // Mask Parameter: PIDController2_UpperSaturationLimit\r\n  //  Referenced by:\r\n  //    '<S541>/Saturation'\r\n  //    '<S526>/DeadZone'\r\n\r\n  0.2,\r\n\r\n  // Mask Parameter: CompareToConstant_const\r\n  //  Referenced by: '<S570>/Constant'\r\n\r\n  5U,\r\n\r\n  // Computed Parameter: Out1_Y0\r\n  //  Referenced by: '<S577>/Out1'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    0U,                                // type\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U }\r\n    ,                                  // _padding0\r\n\r\n    {\r\n      {\r\n        (0ULL),                        // timestamp\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // position\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // velocity\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // acceleration\r\n        0.0F,                          // yaw\r\n        0.0F,                          // yaw_speed\r\n        false,                         // point_valid\r\n        0U,                            // type\r\n\r\n        {\r\n          0U, 0U }\r\n        // _padding0\r\n      }, {\r\n        (0ULL),                        // timestamp\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // position\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // velocity\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // acceleration\r\n        0.0F,                          // yaw\r\n        0.0F,                          // yaw_speed\r\n        false,                         // point_valid\r\n        0U,                            // type\r\n\r\n        {\r\n          0U, 0U }\r\n        // _padding0\r\n      }, {\r\n        (0ULL),                        // timestamp\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // position\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // velocity\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // acceleration\r\n        0.0F,                          // yaw\r\n        0.0F,                          // yaw_speed\r\n        false,                         // point_valid\r\n        0U,                            // type\r\n\r\n        {\r\n          0U, 0U }\r\n        // _padding0\r\n      }, {\r\n        (0ULL),                        // timestamp\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // position\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // velocity\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // acceleration\r\n        0.0F,                          // yaw\r\n        0.0F,                          // yaw_speed\r\n        false,                         // point_valid\r\n        0U,                            // type\r\n\r\n        {\r\n          0U, 0U }\r\n        // _padding0\r\n      }, {\r\n        (0ULL),                        // timestamp\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // position\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // velocity\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // acceleration\r\n        0.0F,                          // yaw\r\n        0.0F,                          // yaw_speed\r\n        false,                         // point_valid\r\n        0U,                            // type\r\n\r\n        {\r\n          0U, 0U }\r\n        // _padding0\r\n      } }\r\n    // waypoints\r\n  },\r\n\r\n  // Computed Parameter: Constant_Value\r\n  //  Referenced by: '<S582>/Constant'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    0U,                                // type\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U }\r\n    ,                                  // _padding0\r\n\r\n    {\r\n      {\r\n        (0ULL),                        // timestamp\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // position\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // velocity\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // acceleration\r\n        0.0F,                          // yaw\r\n        0.0F,                          // yaw_speed\r\n        false,                         // point_valid\r\n        0U,                            // type\r\n\r\n        {\r\n          0U, 0U }\r\n        // _padding0\r\n      }, {\r\n        (0ULL),                        // timestamp\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // position\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // velocity\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // acceleration\r\n        0.0F,                          // yaw\r\n        0.0F,                          // yaw_speed\r\n        false,                         // point_valid\r\n        0U,                            // type\r\n\r\n        {\r\n          0U, 0U }\r\n        // _padding0\r\n      }, {\r\n        (0ULL),                        // timestamp\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // position\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // velocity\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // acceleration\r\n        0.0F,                          // yaw\r\n        0.0F,                          // yaw_speed\r\n        false,                         // point_valid\r\n        0U,                            // type\r\n\r\n        {\r\n          0U, 0U }\r\n        // _padding0\r\n      }, {\r\n        (0ULL),                        // timestamp\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // position\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // velocity\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // acceleration\r\n        0.0F,                          // yaw\r\n        0.0F,                          // yaw_speed\r\n        false,                         // point_valid\r\n        0U,                            // type\r\n\r\n        {\r\n          0U, 0U }\r\n        // _padding0\r\n      }, {\r\n        (0ULL),                        // timestamp\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // position\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // velocity\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // acceleration\r\n        0.0F,                          // yaw\r\n        0.0F,                          // yaw_speed\r\n        false,                         // point_valid\r\n        0U,                            // type\r\n\r\n        {\r\n          0U, 0U }\r\n        // _padding0\r\n      } }\r\n    // waypoints\r\n  },\r\n\r\n  // Computed Parameter: Constant_Value_g\r\n  //  Referenced by: '<S576>/Constant'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    0U,                                // type\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U }\r\n    ,                                  // _padding0\r\n\r\n    {\r\n      {\r\n        (0ULL),                        // timestamp\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // position\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // velocity\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // acceleration\r\n        0.0F,                          // yaw\r\n        0.0F,                          // yaw_speed\r\n        false,                         // point_valid\r\n        0U,                            // type\r\n\r\n        {\r\n          0U, 0U }\r\n        // _padding0\r\n      }, {\r\n        (0ULL),                        // timestamp\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // position\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // velocity\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // acceleration\r\n        0.0F,                          // yaw\r\n        0.0F,                          // yaw_speed\r\n        false,                         // point_valid\r\n        0U,                            // type\r\n\r\n        {\r\n          0U, 0U }\r\n        // _padding0\r\n      }, {\r\n        (0ULL),                        // timestamp\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // position\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // velocity\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // acceleration\r\n        0.0F,                          // yaw\r\n        0.0F,                          // yaw_speed\r\n        false,                         // point_valid\r\n        0U,                            // type\r\n\r\n        {\r\n          0U, 0U }\r\n        // _padding0\r\n      }, {\r\n        (0ULL),                        // timestamp\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // position\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // velocity\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // acceleration\r\n        0.0F,                          // yaw\r\n        0.0F,                          // yaw_speed\r\n        false,                         // point_valid\r\n        0U,                            // type\r\n\r\n        {\r\n          0U, 0U }\r\n        // _padding0\r\n      }, {\r\n        (0ULL),                        // timestamp\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // position\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // velocity\r\n\r\n        {\r\n          0.0F, 0.0F, 0.0F }\r\n        ,                              // acceleration\r\n        0.0F,                          // yaw\r\n        0.0F,                          // yaw_speed\r\n        false,                         // point_valid\r\n        0U,                            // type\r\n\r\n        {\r\n          0U, 0U }\r\n        // _padding0\r\n      } }\r\n    // waypoints\r\n  },\r\n\r\n  // Computed Parameter: Out1_Y0_h\r\n  //  Referenced by: '<S589>/Out1'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n\r\n    {\r\n      (0ULL),                          // timestamp\r\n      0.0,                             // lat\r\n      0.0,                             // lon\r\n      0.0F,                            // vx\r\n      0.0F,                            // vy\r\n      0.0F,                            // vz\r\n      0.0F,                            // alt\r\n      0.0F,                            // yaw\r\n      0.0F,                            // yawspeed\r\n      0.0F,                            // loiter_radius\r\n      0.0F,                            // acceptance_radius\r\n      0.0F,                            // cruising_speed\r\n      0.0F,                            // cruising_throttle\r\n      false,                           // valid\r\n      0U,                              // type\r\n      false,                           // yaw_valid\r\n      false,                           // yawspeed_valid\r\n      false,                           // loiter_direction_counter_clockwise\r\n      false,                           // gliding_enabled\r\n      false,                           // disable_weather_vane\r\n      0U                               // _padding0\r\n    },                                 // previous\r\n\r\n    {\r\n      (0ULL),                          // timestamp\r\n      0.0,                             // lat\r\n      0.0,                             // lon\r\n      0.0F,                            // vx\r\n      0.0F,                            // vy\r\n      0.0F,                            // vz\r\n      0.0F,                            // alt\r\n      0.0F,                            // yaw\r\n      0.0F,                            // yawspeed\r\n      0.0F,                            // loiter_radius\r\n      0.0F,                            // acceptance_radius\r\n      0.0F,                            // cruising_speed\r\n      0.0F,                            // cruising_throttle\r\n      false,                           // valid\r\n      0U,                              // type\r\n      false,                           // yaw_valid\r\n      false,                           // yawspeed_valid\r\n      false,                           // loiter_direction_counter_clockwise\r\n      false,                           // gliding_enabled\r\n      false,                           // disable_weather_vane\r\n      0U                               // _padding0\r\n    },                                 // current\r\n\r\n    {\r\n      (0ULL),                          // timestamp\r\n      0.0,                             // lat\r\n      0.0,                             // lon\r\n      0.0F,                            // vx\r\n      0.0F,                            // vy\r\n      0.0F,                            // vz\r\n      0.0F,                            // alt\r\n      0.0F,                            // yaw\r\n      0.0F,                            // yawspeed\r\n      0.0F,                            // loiter_radius\r\n      0.0F,                            // acceptance_radius\r\n      0.0F,                            // cruising_speed\r\n      0.0F,                            // cruising_throttle\r\n      false,                           // valid\r\n      0U,                              // type\r\n      false,                           // yaw_valid\r\n      false,                           // yawspeed_valid\r\n      false,                           // loiter_direction_counter_clockwise\r\n      false,                           // gliding_enabled\r\n      false,                           // disable_weather_vane\r\n      0U                               // _padding0\r\n    }                                  // next\r\n  },\r\n\r\n  // Computed Parameter: Constant_Value_d\r\n  //  Referenced by: '<S574>/Constant'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n\r\n    {\r\n      (0ULL),                          // timestamp\r\n      0.0,                             // lat\r\n      0.0,                             // lon\r\n      0.0F,                            // vx\r\n      0.0F,                            // vy\r\n      0.0F,                            // vz\r\n      0.0F,                            // alt\r\n      0.0F,                            // yaw\r\n      0.0F,                            // yawspeed\r\n      0.0F,                            // loiter_radius\r\n      0.0F,                            // acceptance_radius\r\n      0.0F,                            // cruising_speed\r\n      0.0F,                            // cruising_throttle\r\n      false,                           // valid\r\n      0U,                              // type\r\n      false,                           // yaw_valid\r\n      false,                           // yawspeed_valid\r\n      false,                           // loiter_direction_counter_clockwise\r\n      false,                           // gliding_enabled\r\n      false,                           // disable_weather_vane\r\n      0U                               // _padding0\r\n    },                                 // previous\r\n\r\n    {\r\n      (0ULL),                          // timestamp\r\n      0.0,                             // lat\r\n      0.0,                             // lon\r\n      0.0F,                            // vx\r\n      0.0F,                            // vy\r\n      0.0F,                            // vz\r\n      0.0F,                            // alt\r\n      0.0F,                            // yaw\r\n      0.0F,                            // yawspeed\r\n      0.0F,                            // loiter_radius\r\n      0.0F,                            // acceptance_radius\r\n      0.0F,                            // cruising_speed\r\n      0.0F,                            // cruising_throttle\r\n      false,                           // valid\r\n      0U,                              // type\r\n      false,                           // yaw_valid\r\n      false,                           // yawspeed_valid\r\n      false,                           // loiter_direction_counter_clockwise\r\n      false,                           // gliding_enabled\r\n      false,                           // disable_weather_vane\r\n      0U                               // _padding0\r\n    },                                 // current\r\n\r\n    {\r\n      (0ULL),                          // timestamp\r\n      0.0,                             // lat\r\n      0.0,                             // lon\r\n      0.0F,                            // vx\r\n      0.0F,                            // vy\r\n      0.0F,                            // vz\r\n      0.0F,                            // alt\r\n      0.0F,                            // yaw\r\n      0.0F,                            // yawspeed\r\n      0.0F,                            // loiter_radius\r\n      0.0F,                            // acceptance_radius\r\n      0.0F,                            // cruising_speed\r\n      0.0F,                            // cruising_throttle\r\n      false,                           // valid\r\n      0U,                              // type\r\n      false,                           // yaw_valid\r\n      false,                           // yawspeed_valid\r\n      false,                           // loiter_direction_counter_clockwise\r\n      false,                           // gliding_enabled\r\n      false,                           // disable_weather_vane\r\n      0U                               // _padding0\r\n    }                                  // next\r\n  },\r\n\r\n  // Computed Parameter: Out1_Y0_p\r\n  //  Referenced by: '<S609>/Out1'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    (0ULL),                            // timestamp_sample\r\n    (0ULL),                            // ref_timestamp\r\n    0.0,                               // ref_lat\r\n    0.0,                               // ref_lon\r\n    0.0F,                              // x\r\n    0.0F,                              // y\r\n    0.0F,                              // z\r\n\r\n    {\r\n      0.0F, 0.0F }\r\n    ,                                  // delta_xy\r\n    0.0F,                              // delta_z\r\n    0.0F,                              // vx\r\n    0.0F,                              // vy\r\n    0.0F,                              // vz\r\n    0.0F,                              // z_deriv\r\n\r\n    {\r\n      0.0F, 0.0F }\r\n    ,                                  // delta_vxy\r\n    0.0F,                              // delta_vz\r\n    0.0F,                              // ax\r\n    0.0F,                              // ay\r\n    0.0F,                              // az\r\n    0.0F,                              // heading\r\n    0.0F,                              // delta_heading\r\n    0.0F,                              // ref_alt\r\n    0.0F,                              // dist_bottom\r\n    0.0F,                              // eph\r\n    0.0F,                              // epv\r\n    0.0F,                              // evh\r\n    0.0F,                              // evv\r\n    0.0F,                              // vxy_max\r\n    0.0F,                              // vz_max\r\n    0.0F,                              // hagl_min\r\n    0.0F,                              // hagl_max\r\n    false,                             // xy_valid\r\n    false,                             // z_valid\r\n    false,                             // v_xy_valid\r\n    false,                             // v_z_valid\r\n    0U,                                // xy_reset_counter\r\n    0U,                                // z_reset_counter\r\n    0U,                                // vxy_reset_counter\r\n    0U,                                // vz_reset_counter\r\n    0U,                                // heading_reset_counter\r\n    false,                             // heading_good_for_control\r\n    false,                             // xy_global\r\n    false,                             // z_global\r\n    false,                             // dist_bottom_valid\r\n    0U,                                // dist_bottom_sensor_bitfield\r\n    false,                             // dead_reckoning\r\n    0U                                 // _padding0\r\n  },\r\n\r\n  // Computed Parameter: Constant_Value_e\r\n  //  Referenced by: '<S605>/Constant'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    (0ULL),                            // timestamp_sample\r\n    (0ULL),                            // ref_timestamp\r\n    0.0,                               // ref_lat\r\n    0.0,                               // ref_lon\r\n    0.0F,                              // x\r\n    0.0F,                              // y\r\n    0.0F,                              // z\r\n\r\n    {\r\n      0.0F, 0.0F }\r\n    ,                                  // delta_xy\r\n    0.0F,                              // delta_z\r\n    0.0F,                              // vx\r\n    0.0F,                              // vy\r\n    0.0F,                              // vz\r\n    0.0F,                              // z_deriv\r\n\r\n    {\r\n      0.0F, 0.0F }\r\n    ,                                  // delta_vxy\r\n    0.0F,                              // delta_vz\r\n    0.0F,                              // ax\r\n    0.0F,                              // ay\r\n    0.0F,                              // az\r\n    0.0F,                              // heading\r\n    0.0F,                              // delta_heading\r\n    0.0F,                              // ref_alt\r\n    0.0F,                              // dist_bottom\r\n    0.0F,                              // eph\r\n    0.0F,                              // epv\r\n    0.0F,                              // evh\r\n    0.0F,                              // evv\r\n    0.0F,                              // vxy_max\r\n    0.0F,                              // vz_max\r\n    0.0F,                              // hagl_min\r\n    0.0F,                              // hagl_max\r\n    false,                             // xy_valid\r\n    false,                             // z_valid\r\n    false,                             // v_xy_valid\r\n    false,                             // v_z_valid\r\n    0U,                                // xy_reset_counter\r\n    0U,                                // z_reset_counter\r\n    0U,                                // vxy_reset_counter\r\n    0U,                                // vz_reset_counter\r\n    0U,                                // heading_reset_counter\r\n    false,                             // heading_good_for_control\r\n    false,                             // xy_global\r\n    false,                             // z_global\r\n    false,                             // dist_bottom_valid\r\n    0U,                                // dist_bottom_sensor_bitfield\r\n    false,                             // dead_reckoning\r\n    0U                                 // _padding0\r\n  },\r\n\r\n  // Computed Parameter: Constant_Value_a\r\n  //  Referenced by: '<S600>/Constant'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    (0ULL),                            // timestamp_sample\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F }\r\n    ,                                  // control\r\n    0U,                                // reversible_flags\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U }\r\n    // _padding0\r\n  },\r\n\r\n  // Computed Parameter: Out1_Y0_f\r\n  //  Referenced by: '<S599>/Out1'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    (0ULL),                            // timestamp_last_signal\r\n    0,                                 // rssi\r\n    0.0F,                              // rssi_dbm\r\n    0U,                                // rc_lost_frame_count\r\n    0U,                                // rc_total_frame_count\r\n    0U,                                // rc_ppm_frame_length\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U }\r\n    ,                                  // values\r\n    0U,                                // channel_count\r\n    false,                             // rc_failsafe\r\n    false,                             // rc_lost\r\n    0U,                                // input_source\r\n    0,                                 // link_quality\r\n    0U                                 // _padding0\r\n  },\r\n\r\n  // Computed Parameter: Constant_Value_k\r\n  //  Referenced by: '<S598>/Constant'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    (0ULL),                            // timestamp_last_signal\r\n    0,                                 // rssi\r\n    0.0F,                              // rssi_dbm\r\n    0U,                                // rc_lost_frame_count\r\n    0U,                                // rc_total_frame_count\r\n    0U,                                // rc_ppm_frame_length\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U }\r\n    ,                                  // values\r\n    0U,                                // channel_count\r\n    false,                             // rc_failsafe\r\n    false,                             // rc_lost\r\n    0U,                                // input_source\r\n    0,                                 // link_quality\r\n    0U                                 // _padding0\r\n  },\r\n\r\n  // Computed Parameter: Constant_Value_i\r\n  //  Referenced by: '<S590>/Constant'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    0.0F,                              // x\r\n    0.0F,                              // y\r\n    0.0F,                              // z\r\n    0.0F,                              // vx\r\n    0.0F,                              // vy\r\n    0.0F,                              // vz\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F }\r\n    ,                                  // acceleration\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F }\r\n    ,                                  // thrust\r\n    0.0F,                              // yaw\r\n    0.0F                               // yawspeed\r\n  },\r\n\r\n  // Computed Parameter: Constant_Value_l\r\n  //  Referenced by: '<S16>/Constant'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    0.0F,                              // x\r\n    0.0F,                              // y\r\n    0.0F,                              // z\r\n    0.0F,                              // vx\r\n    0.0F,                              // vy\r\n    0.0F,                              // vz\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F }\r\n    ,                                  // acceleration\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F }\r\n    ,                                  // thrust\r\n    0.0F,                              // yaw\r\n    0.0F                               // yawspeed\r\n  },\r\n\r\n  // Computed Parameter: Out1_Y0_k\r\n  //  Referenced by: '<S608>/Out1'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    (0ULL),                            // timestamp_sample\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F, 0.0F }\r\n    ,                                  // q\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F, 0.0F }\r\n    ,                                  // delta_q_reset\r\n    0U,                                // quat_reset_counter\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U }\r\n    // _padding0\r\n  },\r\n\r\n  // Computed Parameter: Constant_Value_lh\r\n  //  Referenced by: '<S604>/Constant'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    (0ULL),                            // timestamp_sample\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F, 0.0F }\r\n    ,                                  // q\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F, 0.0F }\r\n    ,                                  // delta_q_reset\r\n    0U,                                // quat_reset_counter\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U }\r\n    // _padding0\r\n  },\r\n\r\n  // Computed Parameter: Constant_Value_b\r\n  //  Referenced by: '<S14>/Constant'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    0.0F,                              // roll_body\r\n    0.0F,                              // pitch_body\r\n    0.0F,                              // yaw_body\r\n    0.0F,                              // yaw_sp_move_rate\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F, 0.0F }\r\n    ,                                  // q_d\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F }\r\n    ,                                  // thrust_body\r\n    false,                             // reset_integral\r\n    false,                             // fw_control_yaw_wheel\r\n\r\n    {\r\n      0U, 0U }\r\n    // _padding0\r\n  },\r\n\r\n  // Computed Parameter: Out1_Y0_o\r\n  //  Referenced by: '<S588>/Out1'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    0.0,                               // lat\r\n    0.0,                               // lon\r\n    0.0F,                              // alt\r\n    0.0F,                              // x\r\n    0.0F,                              // y\r\n    0.0F,                              // z\r\n    0.0F,                              // yaw\r\n    false,                             // valid_alt\r\n    false,                             // valid_hpos\r\n    false,                             // valid_lpos\r\n    false                              // manual_home\r\n  },\r\n\r\n  // Computed Parameter: Constant_Value_b0\r\n  //  Referenced by: '<S573>/Constant'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    0.0,                               // lat\r\n    0.0,                               // lon\r\n    0.0F,                              // alt\r\n    0.0F,                              // x\r\n    0.0F,                              // y\r\n    0.0F,                              // z\r\n    0.0F,                              // yaw\r\n    false,                             // valid_alt\r\n    false,                             // valid_hpos\r\n    false,                             // valid_lpos\r\n    false                              // manual_home\r\n  },\r\n\r\n  // Computed Parameter: Out1_Y0_e\r\n  //  Referenced by: '<S606>/Out1'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    (0ULL),                            // timestamp_sample\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F }\r\n    ,                                  // xyz\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F }\r\n    // xyz_derivative\r\n  },\r\n\r\n  // Computed Parameter: Constant_Value_n\r\n  //  Referenced by: '<S602>/Constant'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    (0ULL),                            // timestamp_sample\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F }\r\n    ,                                  // xyz\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F }\r\n    // xyz_derivative\r\n  },\r\n\r\n  // Computed Parameter: Constant_Value_j\r\n  //  Referenced by: '<S18>/Constant'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    0.0F,                              // roll\r\n    0.0F,                              // pitch\r\n    0.0F,                              // yaw\r\n\r\n    {\r\n      0.0F, 0.0F, 0.0F }\r\n    ,                                  // thrust_body\r\n    false,                             // reset_integral\r\n\r\n    {\r\n      0U, 0U, 0U, 0U, 0U, 0U, 0U }\r\n    // _padding0\r\n  },\r\n\r\n  // Computed Parameter: Out1_Y0_d\r\n  //  Referenced by: '<S607>/Out1'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    false,                             // armed\r\n    false,                             // prearmed\r\n    false,                             // ready_to_arm\r\n    false,                             // lockdown\r\n    false,                             // manual_lockdown\r\n    false,                             // force_failsafe\r\n    false,                             // in_esc_calibration_mode\r\n    0U                                 // _padding0\r\n  },\r\n\r\n  // Computed Parameter: Constant_Value_jl\r\n  //  Referenced by: '<S603>/Constant'\r\n\r\n  {\r\n    (0ULL),                            // timestamp\r\n    false,                             // armed\r\n    false,                             // prearmed\r\n    false,                             // ready_to_arm\r\n    false,                             // lockdown\r\n    false,                             // manual_lockdown\r\n    false,                             // force_failsafe\r\n    false,                             // in_esc_calibration_mode\r\n    0U                                 // _padding0\r\n  },\r\n\r\n  // Expression: [1 0 0 0]\r\n  //  Referenced by: '<S9>/Constant'\r\n\r\n  { 1.0, 0.0, 0.0, 0.0 },\r\n\r\n  // Expression: 1\r\n  //  Referenced by: '<S24>/Constant'\r\n\r\n  1.0,\r\n\r\n  // Expression: 1\r\n  //  Referenced by: '<S25>/Constant'\r\n\r\n  1.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S29>/Switch1'\r\n\r\n  0.0,\r\n\r\n  // Computed Parameter: Yawrate_sp_Y0\r\n  //  Referenced by: '<S11>/Yawrate_sp'\r\n\r\n  0.0,\r\n\r\n  // Computed Parameter: Pitchrate_sp_Y0\r\n  //  Referenced by: '<S11>/Pitchrate_sp'\r\n\r\n  0.0,\r\n\r\n  // Computed Parameter: Rollrate_spl_Y0\r\n  //  Referenced by: '<S11>/Rollrate_spl'\r\n\r\n  0.0,\r\n\r\n  // Expression: 2*pi\r\n  //  Referenced by: '<S29>/Constant'\r\n\r\n  6.2831853071795862,\r\n\r\n  // Expression: pi\r\n  //  Referenced by: '<S29>/Switch'\r\n\r\n  3.1415926535897931,\r\n\r\n  // Expression: 180*pi/180\r\n  //  Referenced by: '<S11>/Rate Limiter2'\r\n\r\n  3.1415926535897931,\r\n\r\n  // Expression: -180*pi/180\r\n  //  Referenced by: '<S11>/Rate Limiter2'\r\n\r\n  -3.1415926535897931,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S11>/Rate Limiter2'\r\n\r\n  0.0,\r\n\r\n  // Expression: 180*pi/180\r\n  //  Referenced by: '<S11>/Rate Limiter1'\r\n\r\n  3.1415926535897931,\r\n\r\n  // Expression: -180*pi/180\r\n  //  Referenced by: '<S11>/Rate Limiter1'\r\n\r\n  -3.1415926535897931,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S11>/Rate Limiter1'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S183>/Constant'\r\n\r\n  0.0,\r\n\r\n  // Computed Parameter: tau_Thrust_Y0\r\n  //  Referenced by: '<S12>/tau_Thrust'\r\n\r\n  0.0,\r\n\r\n  // Computed Parameter: des_pitch_Y0\r\n  //  Referenced by: '<S12>/des_pitch'\r\n\r\n  0.0,\r\n\r\n  // Computed Parameter: des_roll_Y0\r\n  //  Referenced by: '<S12>/des_roll'\r\n\r\n  0.0,\r\n\r\n  // Computed Parameter: XY_velocity_setpoint_Y0\r\n  //  Referenced by: '<S12>/XY_velocity_setpoint'\r\n\r\n  0.0,\r\n\r\n  // Computed Parameter: Z_velocity_setpoint_Y0\r\n  //  Referenced by: '<S12>/Z_velocity_setpoint'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S365>/Constant1'\r\n\r\n  0.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S183>/Gain1'\r\n\r\n  -1.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S365>/Clamping_zero'\r\n\r\n  0.0,\r\n\r\n  // Computed Parameter: Filter_gainval\r\n  //  Referenced by: '<S370>/Filter'\r\n\r\n  0.004,\r\n\r\n  // Computed Parameter: Integrator_gainval\r\n  //  Referenced by: '<S375>/Integrator'\r\n\r\n  0.004,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S184>/Gain'\r\n\r\n  -1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S12>/Gain1'\r\n\r\n  -1.0,\r\n\r\n  // Computed Parameter: tau_yaw_Y0\r\n  //  Referenced by: '<S13>/tau_yaw'\r\n\r\n  0.0,\r\n\r\n  // Computed Parameter: tau_pitch_Y0\r\n  //  Referenced by: '<S13>/tau_pitch'\r\n\r\n  0.0,\r\n\r\n  // Computed Parameter: tau_roll_Y0\r\n  //  Referenced by: '<S13>/tau_roll'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S420>/Constant1'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S472>/Constant1'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S524>/Constant1'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S420>/Clamping_zero'\r\n\r\n  0.0,\r\n\r\n  // Computed Parameter: Integrator_gainval_h\r\n  //  Referenced by: '<S430>/Integrator'\r\n\r\n  0.004,\r\n\r\n  // Computed Parameter: Filter_gainval_f\r\n  //  Referenced by: '<S425>/Filter'\r\n\r\n  0.004,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S472>/Clamping_zero'\r\n\r\n  0.0,\r\n\r\n  // Computed Parameter: Integrator_gainval_b\r\n  //  Referenced by: '<S482>/Integrator'\r\n\r\n  0.004,\r\n\r\n  // Computed Parameter: Filter_gainval_l\r\n  //  Referenced by: '<S477>/Filter'\r\n\r\n  0.004,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S524>/Clamping_zero'\r\n\r\n  0.0,\r\n\r\n  // Computed Parameter: Integrator_gainval_n\r\n  //  Referenced by: '<S534>/Integrator'\r\n\r\n  0.004,\r\n\r\n  // Computed Parameter: Filter_gainval_a\r\n  //  Referenced by: '<S529>/Filter'\r\n\r\n  0.004,\r\n\r\n  // Computed Parameter: yaw_Out_Y0\r\n  //  Referenced by: '<S568>/yaw_Out'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0.0\r\n  //  Referenced by: '<S566>/Delay'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0.01\r\n  //  Referenced by: '<S566>/Rate'\r\n\r\n  0.01,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S566>/Gain1'\r\n\r\n  -1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S566>/Gain'\r\n\r\n  -1.0,\r\n\r\n  // Expression: 1\r\n  //  Referenced by: '<S567>/Delay'\r\n\r\n  1.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S567>/Constant'\r\n\r\n  0.0,\r\n\r\n  // Computed Parameter: Out_Y0\r\n  //  Referenced by: '<S564>/Out'\r\n\r\n  0.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S562>/Gain'\r\n\r\n  -1.0,\r\n\r\n  // Computed Parameter: yaw_Out_Y0_f\r\n  //  Referenced by: '<S565>/yaw_Out'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0.0\r\n  //  Referenced by: '<S557>/Delay'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0.0\r\n  //  Referenced by: '<S562>/Delay'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S562>/Switch'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0.02\r\n  //  Referenced by: '<S562>/Rate of descent'\r\n\r\n  0.02,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S562>/Gain2'\r\n\r\n  -1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S562>/Gain1'\r\n\r\n  -1.0,\r\n\r\n  // Expression: 1\r\n  //  Referenced by: '<S563>/Delay'\r\n\r\n  1.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S563>/Constant'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S569>/Constant'\r\n\r\n  0.0,\r\n\r\n  // Expression: 6\r\n  //  Referenced by: '<S559>/Constant'\r\n\r\n  6.0,\r\n\r\n  // Computed Parameter: yaw_Out_Y0_p\r\n  //  Referenced by: '<S561>/yaw_Out'\r\n\r\n  0.0,\r\n\r\n  // Expression: 1\r\n  //  Referenced by: '<S560>/Delay'\r\n\r\n  1.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S560>/Constant'\r\n\r\n  0.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S555>/Read Parameter'\r\n\r\n  -1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S587>/Read Parameter'\r\n\r\n  -1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S586>/Read Parameter'\r\n\r\n  -1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S596>/Read Parameter'\r\n\r\n  -1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S596>/Read Parameter1'\r\n\r\n  -1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S596>/Read Parameter13'\r\n\r\n  -1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S596>/Read Parameter2'\r\n\r\n  -1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S596>/Read Parameter3'\r\n\r\n  -1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S596>/Read Parameter4'\r\n\r\n  -1.0,\r\n\r\n  // Expression: 5\r\n  //  Referenced by: '<S3>/Gain'\r\n\r\n  5.0,\r\n\r\n  // Expression: 1\r\n  //  Referenced by: '<S3>/Saturation3'\r\n\r\n  1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S3>/Saturation3'\r\n\r\n  -1.0,\r\n\r\n  // Expression: 5\r\n  //  Referenced by: '<S3>/Gain1'\r\n\r\n  5.0,\r\n\r\n  // Expression: 1\r\n  //  Referenced by: '<S3>/Saturation2'\r\n\r\n  1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S3>/Saturation2'\r\n\r\n  -1.0,\r\n\r\n  // Expression: 10\r\n  //  Referenced by: '<S3>/Gain2'\r\n\r\n  10.0,\r\n\r\n  // Expression: 1\r\n  //  Referenced by: '<S3>/Saturation1'\r\n\r\n  1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S3>/Saturation1'\r\n\r\n  -1.0,\r\n\r\n  // Expression: 1\r\n  //  Referenced by: '<S3>/Saturation'\r\n\r\n  1.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S3>/Saturation'\r\n\r\n  0.0,\r\n\r\n  // Expression: 1\r\n  //  Referenced by: '<S3>/Saturation4'\r\n\r\n  1.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S3>/Saturation4'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0.01\r\n  //  Referenced by: '<S596>/Gain'\r\n\r\n  0.01,\r\n\r\n  // Expression: 0.01\r\n  //  Referenced by: '<S596>/Gain1'\r\n\r\n  0.01,\r\n\r\n  // Expression: 0.01\r\n  //  Referenced by: '<S596>/Gain2'\r\n\r\n  0.01,\r\n\r\n  // Expression: 0.01\r\n  //  Referenced by: '<S596>/Gain3'\r\n\r\n  0.01,\r\n\r\n  // Expression: 0.01\r\n  //  Referenced by: '<S596>/Gain4'\r\n\r\n  0.01,\r\n\r\n  // Expression: 0.01\r\n  //  Referenced by: '<S596>/Gain5'\r\n\r\n  0.01,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S595>/Constant'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S9>/Switch'\r\n\r\n  0.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S5>/Gain'\r\n\r\n  -1.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S6>/thrust_sp_bX'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S6>/thrust_sp_bY'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S7>/Constant'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S8>/thrust_sp_bX'\r\n\r\n  0.0,\r\n\r\n  // Expression: 0\r\n  //  Referenced by: '<S8>/thrust_sp_bY'\r\n\r\n  0.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S5>/Gain1'\r\n\r\n  -1.0,\r\n\r\n  // Expression: -1\r\n  //  Referenced by: '<S5>/Gain2'\r\n\r\n  -1.0,\r\n\r\n  // Computed Parameter: Constant7_Value\r\n  //  Referenced by: '<S580>/Constant7'\r\n\r\n  (0ULL),\r\n\r\n  // Computed Parameter: Constant1_Value_d\r\n  //  Referenced by: '<S587>/Constant1'\r\n\r\n  { 0.0F, 0.0F },\r\n\r\n  // Computed Parameter: Constant_Value_f2\r\n  //  Referenced by: '<S587>/Constant'\r\n\r\n  0.0F,\r\n\r\n  // Computed Parameter: Gain_Gain_hp\r\n  //  Referenced by: '<S586>/Gain'\r\n\r\n  -1.0F,\r\n\r\n  // Computed Parameter: Constant1_Value_k4\r\n  //  Referenced by: '<S586>/Constant1'\r\n\r\n  { 0.0F, 0.0F },\r\n\r\n  // Computed Parameter: Constant_Value_l4\r\n  //  Referenced by: '<S586>/Constant'\r\n\r\n  0.0F,\r\n\r\n  // Computed Parameter: Constant_Value_fh\r\n  //  Referenced by: '<S580>/Constant'\r\n\r\n  { 0.0F, 0.0F, 0.0F },\r\n\r\n  // Computed Parameter: Constant1_Value_h\r\n  //  Referenced by: '<S580>/Constant1'\r\n\r\n  { 0.0F, 0.0F, 0.0F },\r\n\r\n  // Computed Parameter: Constant2_Value\r\n  //  Referenced by: '<S580>/Constant2'\r\n\r\n  { 0.0F, 0.0F, 0.0F },\r\n\r\n  // Computed Parameter: Constant3_Value\r\n  //  Referenced by: '<S580>/Constant3'\r\n\r\n  0.0F,\r\n\r\n  // Computed Parameter: Constant4_Value\r\n  //  Referenced by: '<S580>/Constant4'\r\n\r\n  0.0F,\r\n\r\n  // Computed Parameter: Constant5_Value\r\n  //  Referenced by: '<S578>/Constant5'\r\n\r\n  true,\r\n\r\n  // Computed Parameter: Constant5_Value_k\r\n  //  Referenced by: '<S579>/Constant5'\r\n\r\n  true,\r\n\r\n  // Computed Parameter: Constant1_Value_dl\r\n  //  Referenced by: '<S581>/Constant1'\r\n\r\n  true,\r\n\r\n  // Computed Parameter: Constant5_Value_h\r\n  //  Referenced by: '<S581>/Constant5'\r\n\r\n  true,\r\n\r\n  // Computed Parameter: Constant5_Value_l\r\n  //  Referenced by: '<S580>/Constant5'\r\n\r\n  false,\r\n\r\n  // Computed Parameter: Constant_Value_mp\r\n  //  Referenced by: '<S365>/Constant'\r\n\r\n  1,\r\n\r\n  // Computed Parameter: Constant2_Value_k\r\n  //  Referenced by: '<S365>/Constant2'\r\n\r\n  -1,\r\n\r\n  // Computed Parameter: Constant3_Value_i\r\n  //  Referenced by: '<S365>/Constant3'\r\n\r\n  1,\r\n\r\n  // Computed Parameter: Constant4_Value_j\r\n  //  Referenced by: '<S365>/Constant4'\r\n\r\n  -1,\r\n\r\n  // Computed Parameter: Constant_Value_dt\r\n  //  Referenced by: '<S420>/Constant'\r\n\r\n  1,\r\n\r\n  // Computed Parameter: Constant2_Value_l\r\n  //  Referenced by: '<S420>/Constant2'\r\n\r\n  -1,\r\n\r\n  // Computed Parameter: Constant3_Value_j\r\n  //  Referenced by: '<S420>/Constant3'\r\n\r\n  1,\r\n\r\n  // Computed Parameter: Constant4_Value_c\r\n  //  Referenced by: '<S420>/Constant4'\r\n\r\n  -1,\r\n\r\n  // Computed Parameter: Constant_Value_d5\r\n  //  Referenced by: '<S472>/Constant'\r\n\r\n  1,\r\n\r\n  // Computed Parameter: Constant2_Value_e\r\n  //  Referenced by: '<S472>/Constant2'\r\n\r\n  -1,\r\n\r\n  // Computed Parameter: Constant3_Value_k\r\n  //  Referenced by: '<S472>/Constant3'\r\n\r\n  1,\r\n\r\n  // Computed Parameter: Constant4_Value_n\r\n  //  Referenced by: '<S472>/Constant4'\r\n\r\n  -1,\r\n\r\n  // Computed Parameter: Constant_Value_km\r\n  //  Referenced by: '<S524>/Constant'\r\n\r\n  1,\r\n\r\n  // Computed Parameter: Constant2_Value_m\r\n  //  Referenced by: '<S524>/Constant2'\r\n\r\n  -1,\r\n\r\n  // Computed Parameter: Constant3_Value_d\r\n  //  Referenced by: '<S524>/Constant3'\r\n\r\n  1,\r\n\r\n  // Computed Parameter: Constant4_Value_b\r\n  //  Referenced by: '<S524>/Constant4'\r\n\r\n  -1,\r\n\r\n  // Computed Parameter: Constant_Value_fm\r\n  //  Referenced by: '<S572>/Constant'\r\n\r\n  0U,\r\n\r\n  // Computed Parameter: Constant6_Value\r\n  //  Referenced by: '<S580>/Constant6'\r\n\r\n  255U\r\n};\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rtGetInf.cpp","type":"source","group":"utility","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rtGetInf.cpp\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n\r\n#include \"rtwtypes.h\"\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rtGetInf.h\"\r\n\r\n}\r\n\r\n#include <stddef.h>\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#define NumBitsPerChar                 8U\r\n\r\nextern \"C\"\r\n{\r\n  //\r\n  // Initialize rtInf needed by the generated code.\r\n  // Inf is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  real_T rtGetInf(void)\r\n  {\r\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n    real_T inf = 0.0;\r\n    if (bitsPerReal == 32U) {\r\n      inf = rtGetInfF();\r\n    } else {\r\n      uint16_T one = 1U;\r\n      enum {\r\n        LittleEndian,\r\n        BigEndian\r\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n      switch (machByteOrder) {\r\n       case LittleEndian:\r\n        {\r\n          union {\r\n            LittleEndianIEEEDouble bitVal;\r\n            real_T fltVal;\r\n          } tmpVal;\r\n\r\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n          tmpVal.bitVal.words.wordL = 0x00000000U;\r\n          inf = tmpVal.fltVal;\r\n          break;\r\n        }\r\n\r\n       case BigEndian:\r\n        {\r\n          union {\r\n            BigEndianIEEEDouble bitVal;\r\n            real_T fltVal;\r\n          } tmpVal;\r\n\r\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n          tmpVal.bitVal.words.wordL = 0x00000000U;\r\n          inf = tmpVal.fltVal;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return inf;\r\n  }\r\n\r\n  //\r\n  // Initialize rtInfF needed by the generated code.\r\n  // Inf is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  real32_T rtGetInfF(void)\r\n  {\r\n    IEEESingle infF;\r\n    infF.wordL.wordLuint = 0x7F800000U;\r\n    return infF.wordL.wordLreal;\r\n  }\r\n\r\n  //\r\n  // Initialize rtMinusInf needed by the generated code.\r\n  // Inf is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  real_T rtGetMinusInf(void)\r\n  {\r\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n    real_T minf = 0.0;\r\n    if (bitsPerReal == 32U) {\r\n      minf = rtGetMinusInfF();\r\n    } else {\r\n      uint16_T one = 1U;\r\n      enum {\r\n        LittleEndian,\r\n        BigEndian\r\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n      switch (machByteOrder) {\r\n       case LittleEndian:\r\n        {\r\n          union {\r\n            LittleEndianIEEEDouble bitVal;\r\n            real_T fltVal;\r\n          } tmpVal;\r\n\r\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n          tmpVal.bitVal.words.wordL = 0x00000000U;\r\n          minf = tmpVal.fltVal;\r\n          break;\r\n        }\r\n\r\n       case BigEndian:\r\n        {\r\n          union {\r\n            BigEndianIEEEDouble bitVal;\r\n            real_T fltVal;\r\n          } tmpVal;\r\n\r\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n          tmpVal.bitVal.words.wordL = 0x00000000U;\r\n          minf = tmpVal.fltVal;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return minf;\r\n  }\r\n\r\n  //\r\n  // Initialize rtMinusInfF needed by the generated code.\r\n  // Inf is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  real32_T rtGetMinusInfF(void)\r\n  {\r\n    IEEESingle minfF;\r\n    minfF.wordL.wordLuint = 0xFF800000U;\r\n    return minfF.wordL.wordLreal;\r\n  }\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rtGetInf.h\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef rtGetInf_h_\r\n#define rtGetInf_h_\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#include \"rtwtypes.h\"\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern real_T rtGetInf(void);\r\n  extern real32_T rtGetInfF(void);\r\n  extern real_T rtGetMinusInf(void);\r\n  extern real32_T rtGetMinusInfF(void);\r\n\r\n#ifdef __cplusplus\r\n\r\n}                                      // extern \"C\"\r\n\r\n#endif\r\n#endif                                 // rtGetInf_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rtGetNaN.cpp","type":"source","group":"utility","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rtGetNaN.cpp\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n\r\n#include \"rtwtypes.h\"\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rtGetNaN.h\"\r\n\r\n}\r\n\r\n#include <stddef.h>\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#define NumBitsPerChar                 8U\r\n\r\nextern \"C\"\r\n{\r\n  //\r\n  // Initialize rtNaN needed by the generated code.\r\n  // NaN is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  real_T rtGetNaN(void)\r\n  {\r\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n    real_T nan = 0.0;\r\n    if (bitsPerReal == 32U) {\r\n      nan = rtGetNaNF();\r\n    } else {\r\n      uint16_T one = 1U;\r\n      enum {\r\n        LittleEndian,\r\n        BigEndian\r\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n      switch (machByteOrder) {\r\n       case LittleEndian:\r\n        {\r\n          union {\r\n            LittleEndianIEEEDouble bitVal;\r\n            real_T fltVal;\r\n          } tmpVal;\r\n\r\n          tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n          tmpVal.bitVal.words.wordL = 0x00000000U;\r\n          nan = tmpVal.fltVal;\r\n          break;\r\n        }\r\n\r\n       case BigEndian:\r\n        {\r\n          union {\r\n            BigEndianIEEEDouble bitVal;\r\n            real_T fltVal;\r\n          } tmpVal;\r\n\r\n          tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\r\n          tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\r\n          nan = tmpVal.fltVal;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return nan;\r\n  }\r\n\r\n  //\r\n  // Initialize rtNaNF needed by the generated code.\r\n  // NaN is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  real32_T rtGetNaNF(void)\r\n  {\r\n    IEEESingle nanF = { { 0.0F } };\r\n\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        nanF.wordL.wordLuint = 0xFFC00000U;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        nanF.wordL.wordLuint = 0x7FFFFFFFU;\r\n        break;\r\n      }\r\n    }\r\n\r\n    return nanF.wordL.wordLreal;\r\n  }\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rtGetNaN.h\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef rtGetNaN_h_\r\n#define rtGetNaN_h_\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#include \"rtwtypes.h\"\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern real_T rtGetNaN(void);\r\n  extern real32_T rtGetNaNF(void);\r\n\r\n#ifdef __cplusplus\r\n\r\n}                                      // extern \"C\"\r\n\r\n#endif\r\n#endif                                 // rtGetNaN_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rt_defines.h\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef rt_defines_h_\r\n#define rt_defines_h_\r\n\r\n//===========*\r\n//  Constants *\r\n// ===========\r\n#define RT_PI                          3.14159265358979323846\r\n#define RT_PIF                         3.1415927F\r\n#define RT_LN_10                       2.30258509299404568402\r\n#define RT_LN_10F                      2.3025851F\r\n#define RT_LOG10E                      0.43429448190325182765\r\n#define RT_LOG10EF                     0.43429449F\r\n#define RT_E                           2.7182818284590452354\r\n#define RT_EF                          2.7182817F\r\n\r\n//\r\n//  UNUSED_PARAMETER(x)\r\n//    Used to specify that a function parameter (argument) is required but not\r\n//    accessed by the function body.\r\n\r\n#ifndef UNUSED_PARAMETER\r\n#if defined(__LCC__)\r\n#define UNUSED_PARAMETER(x)                                      // do nothing\r\n#else\r\n\r\n//\r\n//  This is the semi-ANSI standard way of indicating that an\r\n//  unused function parameter is required.\r\n\r\n#define UNUSED_PARAMETER(x)            (void) (x)\r\n#endif\r\n#endif\r\n#endif                                 // rt_defines_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rt_nonfinite.cpp","type":"source","group":"utility","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rt_nonfinite.cpp\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rtGetNaN.h\"\r\n\r\n}\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rtGetInf.h\"\r\n\r\n}\r\n\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n\r\nextern \"C\"\r\n{\r\n\r\n#include \"rt_nonfinite.h\"\r\n\r\n}\r\n\r\n#define NumBitsPerChar                 8U\r\n\r\nextern \"C\"\r\n{\r\n  real_T rtInf;\r\n  real_T rtMinusInf;\r\n  real_T rtNaN;\r\n  real32_T rtInfF;\r\n  real32_T rtMinusInfF;\r\n  real32_T rtNaNF;\r\n}\r\n\r\nextern \"C\"\r\n{\r\n  //\r\n  // Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n  // generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n  //\r\n  void rt_InitInfAndNaN(size_t realSize)\r\n  {\r\n    (void) (realSize);\r\n    rtNaN = rtGetNaN();\r\n    rtNaNF = rtGetNaNF();\r\n    rtInf = rtGetInf();\r\n    rtInfF = rtGetInfF();\r\n    rtMinusInf = rtGetMinusInf();\r\n    rtMinusInfF = rtGetMinusInfF();\r\n  }\r\n\r\n  // Test if value is infinite\r\n  boolean_T rtIsInf(real_T value)\r\n  {\r\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n  }\r\n\r\n  // Test if single-precision value is infinite\r\n  boolean_T rtIsInfF(real32_T value)\r\n  {\r\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n  }\r\n\r\n  // Test if value is not a number\r\n  boolean_T rtIsNaN(real_T value)\r\n  {\r\n    boolean_T result = (boolean_T) 0;\r\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n    if (bitsPerReal == 32U) {\r\n      result = rtIsNaNF((real32_T)value);\r\n    } else {\r\n      uint16_T one = 1U;\r\n      enum {\r\n        LittleEndian,\r\n        BigEndian\r\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n      switch (machByteOrder) {\r\n       case LittleEndian:\r\n        {\r\n          union {\r\n            LittleEndianIEEEDouble bitVal;\r\n            real_T fltVal;\r\n          } tmpVal;\r\n\r\n          tmpVal.fltVal = value;\r\n          result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\r\n                               0x7FF00000 &&\r\n                               ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                                (tmpVal.bitVal.words.wordL != 0) ));\r\n          break;\r\n        }\r\n\r\n       case BigEndian:\r\n        {\r\n          union {\r\n            BigEndianIEEEDouble bitVal;\r\n            real_T fltVal;\r\n          } tmpVal;\r\n\r\n          tmpVal.fltVal = value;\r\n          result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\r\n                               0x7FF00000 &&\r\n                               ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                                (tmpVal.bitVal.words.wordL != 0) ));\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // Test if single-precision value is not a number\r\n  boolean_T rtIsNaNF(real32_T value)\r\n  {\r\n    IEEESingle tmp;\r\n    tmp.wordL.wordLreal = value;\r\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n  }\r\n}\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rt_nonfinite.h\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef rt_nonfinite_h_\r\n#define rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#define NOT_USING_NONFINITE_LITERALS   1\r\n#ifdef __cplusplus\r\n\r\nextern \"C\"\r\n{\r\n\r\n#endif\r\n\r\n  extern real_T rtInf;\r\n  extern real_T rtMinusInf;\r\n  extern real_T rtNaN;\r\n  extern real32_T rtInfF;\r\n  extern real32_T rtMinusInfF;\r\n  extern real32_T rtNaNF;\r\n  extern void rt_InitInfAndNaN(size_t realSize);\r\n  extern boolean_T rtIsInf(real_T value);\r\n  extern boolean_T rtIsInfF(real32_T value);\r\n  extern boolean_T rtIsNaN(real_T value);\r\n  extern boolean_T rtIsNaNF(real32_T value);\r\n  struct BigEndianIEEEDouble {\r\n    struct {\r\n      uint32_T wordH;\r\n      uint32_T wordL;\r\n    } words;\r\n  };\r\n\r\n  struct LittleEndianIEEEDouble {\r\n    struct {\r\n      uint32_T wordL;\r\n      uint32_T wordH;\r\n    } words;\r\n  };\r\n\r\n  struct IEEESingle {\r\n    union {\r\n      real32_T wordLreal;\r\n      uint32_T wordLuint;\r\n    } wordL;\r\n  };\r\n\r\n#ifdef __cplusplus\r\n\r\n}                                      // extern \"C\"\r\n\r\n#endif\r\n#endif                                 // rt_nonfinite_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rtwtypes.h\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n// Logical type definitions\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n//=======================================================================*\r\n//  Target hardware information\r\n//    Device type: ARM Compatible->ARM Cortex\r\n//    Number of bits:     char:   8    short:   16    int:  32\r\n//                        long:  32    long long:  64\r\n//                        native word size:  32\r\n//    Byte ordering: LittleEndian\r\n//    Signed integer division rounds to: Zero\r\n//    Shift right on a signed integer as arithmetic shift: on\r\n// =======================================================================\r\n#ifdef PORTABLE_WORDSIZES              // PORTABLE_WORDSIZES defined\r\n\r\n//=======================================================================*\r\n//  Host information\r\n//    Number of bits:     char:   8    short:   16    int:  32\r\n//                        long:  32\r\n//                        long long:  64\r\n//                        native word size:  64\r\n// =======================================================================\r\n\r\n//=======================================================================*\r\n//  Fixed width word size data types:                                     *\r\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n//    real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n// =======================================================================\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n//===========================================================================*\r\n//  Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n//                            real_T, time_T, ulong_T, ulonglong_T.           *\r\n// ===========================================================================\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned int ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\n\r\n#else                                  // PORTABLE_WORDSIZES not defined\r\n\r\n//=======================================================================*\r\n//  Fixed width word size data types:                                     *\r\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n//    real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n// =======================================================================\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n//===========================================================================*\r\n//  Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n//                            real_T, time_T, ulong_T, ulonglong_T.           *\r\n// ===========================================================================\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n#endif                                 // PORTABLE_WORDSIZES\r\n\r\n//===========================================================================*\r\n//  Complex number type definitions                                           *\r\n// ===========================================================================\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n//=======================================================================*\r\n//  Min and Max:                                                          *\r\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n// =======================================================================\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n// Block D-Work pointer type\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 // RTWTYPES_H\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Interface files","code":"//\r\n// Academic License - for use in teaching, academic research, and meeting\r\n// course requirements at degree granting institutions only.  Not for\r\n// government, commercial, or other organizational use.\r\n//\r\n// File: rtmodel.h\r\n//\r\n// Code generated for Simulink model 'SITL_HEXA_MISSION'.\r\n//\r\n// Model version                  : 5.6\r\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\r\n// C/C++ source code generated on : Sun Oct 20 19:46:11 2024\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: ARM Compatible->ARM Cortex\r\n// Code generation objectives: Unspecified\r\n// Validation result: Not run\r\n//\r\n#ifndef rtmodel_h_\r\n#define rtmodel_h_\r\n#include \"SITL_HEXA_MISSION.h\"\r\n\r\n// Macros generated for backwards compatibility\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 // rtmodel_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"MW_PX4_TaskControl.cpp","type":"source","group":"legacy","path":"C:\\ProgramData\\MATLAB\\SupportPackages\\R2024a\\toolbox\\target\\supportpackages\\px4\\src\\","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2018-2023 The MathWorks, Inc.\n *\n * File: MW_PX4_TaskControl.c\n *\n * Abstract:\n *  This file contains the main application for Simulink that is launched\n *  by PX4 stack at boot up. The main function spawns a new task and assigns\n *  the main function in ert_main.c as callback.\n *\n */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n/*Simulink model generated code specific headers*/\n\n#define MW_StringifyDefine(x) MW_StringifyDefineExpanded(x)\n#define MW_StringifyDefineExpanded(x) #x\n\n#define MW_StringifyDefineFunction(x, y) MW_StringifyDefineExpandedFunction(x, y)\n#define MW_StringifyDefineExpandedFunction(x, y) x##y\n\n#define MW_StringifyDefineX(x) MW_StringifyDefineExpandedX(x)\n#define MW_StringifyDefineExpandedX(x) x.##h\n\n#define MW_StringifyDefineTypesX(x) MW_StringifyDefineExpandedTypesX(x)\n#define MW_StringifyDefineExpandedTypesX(x) x##_types.h\n\n#define MW_StringifyDefinePrivateX(x) MW_StringifyDefineExpandedPrivateX(x)\n#define MW_StringifyDefineExpandedPrivateX(x) x##_private.h\n\n#include MW_StringifyDefine(MODEL.h)\n#include MW_StringifyDefine(MW_StringifyDefineTypesX(MODEL))\n#include MW_StringifyDefine(MW_StringifyDefinePrivateX(MODEL))\n\n#ifndef MW_PX4_DISABLE_MAVLINK\n#include \"mavlink_main.h\"\n#endif\n\n#define DEBUG 0\n\n#ifdef PIL\nextern int errorOccurred;\n#endif\n\nextern \"C\" __EXPORT int px4_simulink_app_main(int argc,\n                                              char* argv[]); /* sbcheck:ok:extern_c needed */\n\nextern struct hrt_call\n    BaseRate_HRT; /* Base-rate HRT-callback is used to post base-rate semaphore */\nextern int terminatingmodel;\nextern int baserate_sem_copy; /* used for checking HRT semaphore water-mark*/\nstatic bool g_baseRateLife =\n    false;                        /* global storage to contain the status of the px4_simulink_app */\nstatic int px4_simulink_app_task; /* Handle of daemon thread */\nchar mavlink_shell_started = 0;\n\n/* Print the correct usage. */\nvoid px4_app_usage(const char* reason) {\n    if (reason) {\n        PX4_INFO(\"px4_simulink_app : %s\\n\", reason);\n    }\n    errx(1, \"usage: px4_simulink_app {start|stop|status} [-p <additional params>]\\n\\n\");\n}\n\n#if defined(MW_PX4_DISABLE_MAVLINK)\nuint8_t buffer[100];\nMavlinkShell shell;\nvoid shellWait(MavlinkShell* shell_ptr, uint8_t buf[]) {\n    /*The shell wait here is to be used for commands which are expected to\n      return a few characters (a max. of 100 characters.)*/\n    int read = 0, readTotal = 0;\n    for (int i = 0; i < 100; i++) {\n        buf[i] = 0;\n    }\n    while (strstr((char*)buf, \"nsh>\") == NULL) {\n        read = shell_ptr->read(buf + readTotal, 100 - readTotal);\n        readTotal = readTotal + read;\n    }\n}\n#endif\n\nvoid px4_simulink_app_control_MAVLink() {\n    if (mavlink_shell_started == 0) {\n#ifdef MW_PX4_DISABLE_MAVLINK\n        shell.start();\n        shellWait(&shell, buffer);\n#endif\n    }\n\n#ifdef MW_PX4_DISABLE_MAVLINK\n    shell.write((uint8_t*)\"mavlink stop-all\\n\", sizeof(\"mavlink stop-all\\n\"));\n    usleep(100000);\n#endif\n}\n\nint px4_simulink_app_main(int argc, char* argv[]) {\n    if (argc < 2) {\n        px4_app_usage(\"missing command\");\n    }\n\n    if (!strcmp(argv[1], \"start\")) {\n        if (g_baseRateLife == false) {\n            /* Start the Simulink Tasks here */\n#if DEBUG\n            printf(\"px4_simulink_app : Starting the Simulink model\\n\");\n            fflush(stdout);\n#endif\n\n            /* Reset semaphore */\n            g_baseRateLife = true;\n            terminatingmodel =\n                0; // reset global variable. For more info on the rational behind this, please see:\n            // http://nuttx.org/doku.php?id=wiki:nxinternal:tasks-vs-processes#nuttx_flat-build_behavior\n\n            px4_simulink_app_task = px4_task_spawn_cmd(\n                \"px4_simulink_app_task\", /* Definition of px4_task_spawn_cmd :\n                                            C:\\px4\\Firmware\\src\\platforms\\nuttx\\px4_layer\\px4_nuttx_tasks.c\n                                          */\n                SCHED_DEFAULT,           /* For STM32 F4, NuttX has SCHED_DEFAULT as SCHED_RR */\n                SCHED_PRIORITY_MAX - 15, /* SCHED_PRIORITY_MAX: 255 */\n                2048, px4_simulink_app_task_main, (char* const*)NULL);\n\n        } else {\n            warnx(\"px4_simulink_app : Simulink model is already running\\n\");\n            fflush(stdout);\n        }\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    if (!strcmp(argv[1], \"stop\")) {\n        if (g_baseRateLife == true) {\n#ifdef PIL\n            errorOccurred = 1;\n#else\n            rtmSetErrorStatus(MW_StringifyDefineFunction(MODEL, _M), \"Module stopped by user\");\n            g_baseRateLife = false;\n            px4_sem_post(&baserateTaskSem);\n#endif\n#if DEBUG\n            PX4_INFO(\"px4_simulink_app : Exiting the Simulink model\\n\");\n#endif\n        } else {\n            warnx(\"px4_simulink_app : No Simulink model is running\\n\");\n        }\n\n        fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    if (!strcmp(argv[1], \"status\")) {\n        if (g_baseRateLife) {\n            PX4_INFO(\"px4_simulink_app : model is running\\n\");\n        } else {\n            PX4_INFO(\"px4_simulink_app : model is not started\\n\");\n        }\n        fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    px4_app_usage(\"unrecognized command\");\n#if defined(MW_PX4_NUTTX_BUILD)\n    exit(1);\n#else\n    return 1;\n#endif\n}\n\nvoid MW_PX4_Terminate() {\n    hrt_cancel(&BaseRate_HRT);\n    g_baseRateLife = false; // set status of PX4 Simulink App to stop\n\n#if defined(MW_HRT_CONSTRAINT) && (1 == MW_HRT_CONSTRAINT)\n    if (baserate_sem_copy > MW_SEM_WATERMARK) {\n        PX4_INFO(\"Hard real-time constraint violated, shutting down. Updating log file. \\n\");\n        FILE* fp_taskover_run = NULL;\n        char msg_watermark[100] = {0};\n        char msg_timestamp[50] = {0};\n        struct tm* sTm;\n        time_t now = time(NULL);\n        sTm = gmtime(&now);\n        sprintf(msg_watermark,\n                \"Base-rate semaphore exceeded water-mark value %d. Model base-rate = %.3f sec.\",\n                MW_SEM_WATERMARK, (float)MW_BASERATE_PERIOD);\n        strftime(msg_timestamp, sizeof(msg_timestamp), \"%Y-%m-%d %H:%M:%S\", sTm);\n        fp_taskover_run = fopen(\"/fs/microsd/log/task_overrun_log.txt\", \"a+\");\n        fprintf(fp_taskover_run, \"%s Timestamp=%s \\n\", msg_watermark, msg_timestamp);\n        fclose(fp_taskover_run);\n    }\n#endif\n\n#if DEBUG\n    PX4_INFO(\"px4_simulink_app : Received command to end the Simulink task \\n\");\n    fflush(stdout);\n#endif\n}\n\n// LocalWords:  HRT px nsh mavlink nuttx doku nxinternal Nutt SCHED fs microsd\n// LocalWords:  dev ACM tty\n"},{"name":"MW_ParameterRead.cpp","type":"source","group":"legacy","path":"C:\\ProgramData\\MATLAB\\SupportPackages\\R2024a\\toolbox\\target\\supportpackages\\px4\\src\\","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2020 The MathWorks, Inc. */\n/* Reads the Parameter value and outputs the same.\n\n **/\n#include \"MW_ParameterRead.h\"\n\n//Below Macro can be enabled for debugging purposes\n#define DEBUG 0\n\n/*\n ****************************************************************************************************************************************************\n * Wrapper function For Initializing and getting the parameter handle\n * Input Params\n * isString  - Denotes if the Parameter is string or numeric\n * sampleTime - Sample time of the block\n \n * Output Params\n * param_handle  - Handle to the requested parameter.\n ****************************************************************************************************************************************************\n */\nMW_Param_Handle MW_Init_Param(void * ParameterName, uint8_T isString , double sampleTime)\n{\n\n    MW_Param_Handle param_handle = PARAM_INVALID;\n    char * parameterStr;\n    /* Check parameters */\n    if (0 == isString)\n    {\n        fprintf(stderr,\"Only string as ParameterName name is supported.\\n\");\n#if defined(MW_PX4_NUTTX_BUILD)\t\n\texit(1);\n#else\n\treturn 1;\n#endif\n    }\n    else\n    {\n        parameterStr = (char*)ParameterName;\n    }\n    param_handle = param_find(parameterStr);\n#if DEBUG\n    printf(\"In MW_Init_Param. Parameter name = %s.\\n\", parameterStr);\n#endif\n    if (param_handle != PARAM_INVALID)\n    {\n#if DEBUG\n        printf(\"In MW_Init_Param. Valid Parameter Handle = %u.\\n\", param_handle);\n#endif    \n    }\n    else\n    {\n#if DEBUG\n        printf(\"In MW_Init_Param. Invalid Parameter Handle. \\n\");\n#endif\n    }\n    return param_handle;\n}\n\n/*\n ****************************************************************************************************************************************************\n * Wrapper function For reading the parameter\n * Input Params\n * param_h  - Handle to the parameter requested\n * dataType - Data Type of the Parameter Requested\n * dataPtr - Pointer to the data, into which param_get is written to\n *\n * Output Params\n * status  - 0 for a valid Parameter Handle ; 1 for a valid Parameter Handle\n ****************************************************************************************************************************************************\n */\nbool MW_Param_Step(MW_Param_Handle param_h, MW_PARAM_DATA_TYPE dataType, void * dataPtr)\n{\n    //status - 0 for a valid Parameter Handle\n    //status - 1 for an invalid Parameter Handle\n    bool status = 1;\n    if (param_h != PARAM_INVALID)\n    {\n#if DEBUG\n        printf(\"In MW_Param_Step.Parameter Handle = %u.\\n\", param_h);\n#endif\n        int32_t  ReturnTmpInt;\n        float ReturnTmpFlt;\n        switch (dataType)\n        {\n            case MW_INT32:\n                if (!param_get(param_h, &ReturnTmpInt))\n                {\n                    *(int*)dataPtr  = ReturnTmpInt;\n#if DEBUG\n                    printf(\"In MW_Param_Step MW_INT32. Value = %ld\\n\", *(int*)dataPtr);\n#endif\n                }\n                break;\n            case MW_SINGLE:\n                if (!param_get(param_h, &ReturnTmpFlt))\n                {\n                    *(float*)dataPtr  = ReturnTmpFlt;\n#if DEBUG\n                    printf(\"In MW_Param_Step MW_SINGLE. Value = %4.4f\\n\", *(float*)dataPtr);\n#endif\n                }\n                break;\n            default:\n                break;\n        }\n         status = 0;\n    }\n    return status;\n}\n\nvoid MW_Param_terminate(void) \n{\n}\n"},{"name":"MW_custom_RTOS_header.h","type":"header","group":"other","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _MW_CUSTOM_RTOS_HEADER_H_\r\n#define _MW_CUSTOM_RTOS_HEADER_H_\r\n#define MW_BASERATE_PRIORITY           250\r\n#define MW_BASERATE_PERIOD             0.004\r\n#define MW_NUMBER_SUBRATES             0\r\n#define MW_NUMBER_APERIODIC_TASKS      0\r\n#define MW_IS_CONCURRENT               0\r\n#define MW_NUMBER_TIMER_DRIVEN_TASKS   0\r\n\r\nextern void exitFcn(int sig);\r\nextern void *terminateTask(void *arg);\r\nextern void *baseRateTask(void *arg);\r\nextern void *subrateTask(void *arg);\r\nextern pthread_t schedulerThread;\r\nextern pthread_t baseRateThread;\r\nextern pthread_t subRateThread[];\r\nextern px4_sem_t stopSem;\r\nextern px4_sem_t baserateTaskSem;\r\nextern px4_sem_t subrateTaskSem[];\r\nextern int taskId[];\r\nextern int subratePriority[];\r\n\r\n#endif\r\n\r\n#define MW_MAX_TASKNAME                16\r\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"MW_PX4_TaskControl.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE PX4 Host Target\n#define MW_CONNECTIONINFO_XCPONTCPIP_IPADDRESS codertarget.pixhawk.registry.getLoopbackIP\n#define MW_CONNECTIONINFO_XCPONTCPIP_PORT 17725\n#define MW_CONNECTIONINFO_XCPONTCPIP_VERBOSE 1\n#define MW_EXTMODE_CONFIGURATION XCP on TCP/IP\n#define MW_RTOS NuttX\n#define MW_RTOSBASERATETASKPRIORITY 250\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 0\n#define MW_CMAKECONFIG 0\n#define MW_SIMULATOR 0\n#define MW_GAZEBOSIMMODEL Quadrotor (iris)\n#define MW_SIMULINKIO_MODELTRANSPORTDATAFCN px4.internal.ConnectedIO.getConfigsetInfo\n#define MW_SIMULINKIO_SERVERDEPLOYFCN px4.internal.ConnectedIO.buildAndDeployPX4IOServer\n#define MW_PWM_CH1_DISARMED 900\n#define MW_PWM_CH2_DISARMED 900\n#define MW_PWM_CH3_DISARMED 900\n#define MW_PWM_CH4_DISARMED 900\n#define MW_PWM_CH5_DISARMED 900\n#define MW_PWM_CH6_DISARMED 900\n#define MW_PWM_CH7_DISARMED 900\n#define MW_PWM_CH8_DISARMED 900\n#define MW_HRT_CONSTRAINT 0\n#define MW_SEM_WATERMARK 20\n#define MW_OBC_CONNECTIVITY_IP 127.0.0.1\n#define MW_IOBLOCKSMODE deployed\n#define MW_DATAVERSION 2016.02\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"MW_uORB_Read.cpp","type":"source","group":"legacy","path":"C:\\ProgramData\\MATLAB\\SupportPackages\\R2024a\\toolbox\\target\\supportpackages\\px4\\src\\","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2020 The MathWorks, Inc. */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"MW_uORB_Read.h\"\n\n#define DEBUG 0\n\nvoid uORB_read_initialize(orb_metadata_t* orbData, pollfd_t* eventStructObj) {\n    int fd = orb_subscribe(orbData);\n    eventStructObj->fd = fd;\n    eventStructObj->events = POLLIN;\n#if DEBUG\n    PX4_INFO(\"* Subscribed to topic: %s (fd = %d)*\\n\", orbData->o_name, fd);\n#endif\n}\n\nboolean_T uORB_read_step(orb_metadata_t* orbData,\n                         pollfd_t* eventStructObj,\n                         void* busData,\n                         boolean_T blockingMode,\n                         double blockingTimeout) {\n    boolean_T updated = 0;\n    bool isUpdated = false;\n    if (blockingMode) {\n#if defined(MW_PX4_NUTTX_BUILD)\n        int poll_ret = px4_poll(eventStructObj, 1, blockingTimeout);\n        static int error_counter = 0;\n        if (poll_ret == 0) {\n#if DEBUG\n            PX4_ERR(\"Got no data within %.9lf second\", blockingTimeout / 1000.0);\n#endif\n        } else if (poll_ret < 0) {\n            if (error_counter < 10 || error_counter % 500 == 0) {\n                /* use a counter to prevent flooding and slowing the system down */\n#if DEBUG\n                PX4_ERR(\"ERROR return value from poll(): %d\", poll_ret);\n#endif\n            }\n            error_counter++;\n\n        } else {\n            if (eventStructObj->revents & POLLIN) {\n                orb_copy(orbData, eventStructObj->fd, busData);\n                updated = 1;\n            }\n        }\n#elif defined(MW_PX4_POSIX_BUILD)\n        double count = 0;\n        /* The blocking timeout mentioned in the block mask is seconds but\n         * system object converts it to milliseconds*/\n        while (count < blockingTimeout) {\n            // Sleep for 1 ms and then again check if\n            // uORB topic is updated\n            usleep(1000);\n            orb_check(eventStructObj->fd, &isUpdated);\n            if (isUpdated) {\n                orb_copy(orbData, eventStructObj->fd, busData);\n                break;\n            }\n            count++;\n        }\n\n        updated = isUpdated ? 1 : 0;\n#endif\n    } else {\n        orb_check(eventStructObj->fd, &isUpdated);\n        if (isUpdated) {\n            orb_copy(orbData, eventStructObj->fd, busData);\n        }\n        updated = isUpdated ? 1 : 0;\n    }\n\n    return updated;\n}\n\nvoid uORB_read_terminate(const pollfd_t* eventStructObj) {\n    orb_unsubscribe(eventStructObj->fd);\n}\n"},{"name":"MW_uORB_Write.cpp","type":"source","group":"legacy","path":"C:\\ProgramData\\MATLAB\\SupportPackages\\R2024a\\toolbox\\target\\supportpackages\\px4\\src\\","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018 The MathWorks, Inc. */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"MW_uORB_Write.h\"\n\n#define DEBUG 0\n\nvoid uORB_write_initialize(orb_metadata_t* orbData,\n                          orb_advert_t* orbAdvertObj,\n                          void* busData,\n                          int queueLen) {\n    *orbAdvertObj = orb_advertise_queue(orbData, busData, queueLen);    \n#if DEBUG\n    PX4_INFO(\"Started advertising topic: %s \\n\",  orbData->o_name);\n#endif    \n}\n\nvoid uORB_write_step(orb_metadata_t* orbData,\n                    orb_advert_t* orbAdvertObj,\n                    void* busData) {\n    orb_publish(orbData, *orbAdvertObj, busData);\n}\n\nvoid uORB_write_terminate(const orb_advert_t* orbAdvertObj) {\n    orb_unadvertise(*orbAdvertObj);\n}\n"},{"name":"MW_uORB_busstruct_conversion.h","type":"header","group":"other","path":"E:\\OneDrive\\Research\\2. FDD\\Hexacopter_FDDProject\\work\\code\\SITL_HEXA_MISSION_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _MW_UORB_BUSSTRUCT_CONVERSION_H_\r\n#define _MW_UORB_BUSSTRUCT_CONVERSION_H_\r\n\r\n#include <uORB/topics/actuator_armed.h>\r\n#include <uORB/topics/actuator_motors.h>\r\n#include <uORB/topics/home_position.h>\r\n#include <uORB/topics/input_rc.h>\r\n#include <uORB/topics/position_setpoint.h>\r\n#include <uORB/topics/position_setpoint_triplet.h>\r\n#include <uORB/topics/trajectory_waypoint.h>\r\n#include <uORB/topics/vehicle_angular_velocity.h>\r\n#include <uORB/topics/vehicle_attitude.h>\r\n#include <uORB/topics/vehicle_attitude_setpoint.h>\r\n#include <uORB/topics/vehicle_local_position.h>\r\n#include <uORB/topics/vehicle_local_position_setpoint.h>\r\n#include <uORB/topics/vehicle_rates_setpoint.h>\r\n#include <uORB/topics/vehicle_trajectory_waypoint.h>\r\n\r\ntypedef struct actuator_armed_s  px4_Bus_actuator_armed ;\r\ntypedef struct actuator_motors_s  px4_Bus_actuator_motors ;\r\ntypedef struct home_position_s  px4_Bus_home_position ;\r\ntypedef struct input_rc_s  px4_Bus_input_rc ;\r\ntypedef struct position_setpoint_s  px4_Bus_position_setpoint ;\r\ntypedef struct position_setpoint_triplet_s  px4_Bus_position_setpoint_triplet ;\r\ntypedef struct trajectory_waypoint_s  px4_Bus_trajectory_waypoint ;\r\ntypedef struct vehicle_angular_velocity_s  px4_Bus_vehicle_angular_velocity ;\r\ntypedef struct vehicle_attitude_s  px4_Bus_vehicle_attitude ;\r\ntypedef struct vehicle_attitude_setpoint_s  px4_Bus_vehicle_attitude_setpoint ;\r\ntypedef struct vehicle_local_position_s  px4_Bus_vehicle_local_position ;\r\ntypedef struct vehicle_local_position_setpoint_s  px4_Bus_vehicle_local_position_setpoint ;\r\ntypedef struct vehicle_rates_setpoint_s  px4_Bus_vehicle_rates_setpoint ;\r\ntypedef struct vehicle_trajectory_waypoint_s  px4_Bus_vehicle_trajectory_waypoint ;\r\n\r\n#endif\r\n"},{"name":"nuttxinitialize.cpp","type":"source","group":"legacy","path":"C:\\ProgramData\\MATLAB\\SupportPackages\\R2024a\\toolbox\\target\\supportpackages\\px4\\src\\","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2018-2022 The MathWorks, Inc.\n *\n * File: nuttxinitialize.c\n *\n * Abstract:\n *  This file contains RTOS thread creation functions\n *\n */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n\n/***********************************************\n * Added for Simulink Threads\n ************************************************/\npthread_attr_t attr;\nstatic baseRateInfo_t g_info;\nstruct sched_param g_sp;\n// extern volatile boolean_T runModel ;\n\n/***********************************************\n * Added for HRT\n ************************************************/\nstruct hrt_call BaseRate_HRT;\nint baserate_sem_copy;\n\n\n#define MW_RTOS_DEBUG 0\n\nbaseRateInfo_t EXT_sig_info;\nbaseRateInfo_t SDCard_sig_info;\nextern pthread_t backgroundThread;\nextern pthread_t loggingThread;\nextern void exitFcn(int sig);\n\nvoid setTaskPeriod(double periodInSeconds, int sigNo) {\n    timer_t timerId;\n    struct sigevent sev;\n    struct itimerspec its;\n    long stNanoSec;\n    int status;\n\n    /* Create a timer */\n    sev.sigev_notify = SIGEV_SIGNAL;\n    sev.sigev_signo = sigNo;\n    sev.sigev_value.sival_ptr = &timerId;\n    status = timer_create(CLOCK_REALTIME, &sev, &timerId);\n    CHECK_STATUS(status, 0, \"timer_create\");\n\n    /* Arm real-time scheduling timer */\n    stNanoSec = (long)(periodInSeconds * 1e9);\n    its.it_value.tv_sec = stNanoSec / 1000000000;\n    its.it_value.tv_nsec = stNanoSec % 1000000000;\n    its.it_interval.tv_sec = its.it_value.tv_sec;\n    its.it_interval.tv_nsec = its.it_value.tv_nsec;\n    status = timer_settime(timerId, 0, &its, NULL);\n    CHECK_STATUS(status, 0, \"timer_settime\");\n}\n\nvoid print_sem_value() {\n    PX4_WARN(\"Sem value = %d\", baserate_sem_copy);\n}\n\nstatic void Base_HRT_Callback(void* arg) {\n#ifndef PX4_CONNECTEDIO\n    int sem_value_check;\n\n    px4_sem_getvalue(&baserateTaskSem, &sem_value_check);\n    px4_sem_post(&baserateTaskSem);\n    baserate_sem_copy = sem_value_check;\n\n#endif\n}\n\n/* ---------------------------- */\n/* Externally visible functions */\n/* ---------------------------- */\nvoid myWaitForThisEvent(int sigNo) {\n    sigset_t sigMask;\n\n    sigemptyset(&sigMask);\n    sigaddset(&sigMask, sigNo);\n    sigwaitinfo(&sigMask, NULL);\n    //\tCHECK_STATUS_NOT(status, -1, \"sigwaitinfo\");\n}\n\nvoid MW_PX4_WaitForThisEvent(void* arg) {\n#ifdef EXT_MODE\n    /*pace External mode thread at 10 Hz*/\n    usleep(100000);\n\n    /*Signaling is causing issue when sample time is greater than 0.1\n     and model runs for more than 60 seconds. In this case model stop is not\n     stopping External mode. Using usleep for now to sleep the External Mode thread.*/\n\n    // baseRateInfo_t ext_info = *((baseRateInfo_t *)arg);\n    // static boolean_T isTaskPeriodSet = false;\n    // boolean_T rtmStopReq = rtmGetStopRequested(MW_StringifyDefineFunction(MODEL, _M));\n\n    // if (!isTaskPeriodSet) {\n    //     setTaskPeriod(ext_info.period, ext_info.sigNo);\n    //     isTaskPeriodSet = true;\n    // }\n\n    // if (!rtmStopReq) {\n    //     myWaitForThisEvent(ext_info.sigNo);\n    // }\n\n#endif\n}\n\nvoid myAddBlockForThisEvent(int sigNo) {\n    int status;\n    sigset_t sigMask;\n\n    sigemptyset(&sigMask);\n    sigaddset(&sigMask, sigNo);\n    status = pthread_sigmask(SIG_BLOCK, &sigMask, NULL);\n    CHECK_STATUS(status, 0, \"pthread_sigmask\");\n}\n\nvoid nuttxRTOSInit(double baseRatePeriod, int numSubrates) {\n    /* This is because in Daren's original Task callback ,a sleep was added before creating the\n     * threads*/\n    sleep(1);\n\n    int status;\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    size_t stackSize;\n    int baseRatePriority = MW_BASERATE_PRIORITY;\n#endif\n\n#ifdef MW_HAS_MULTIPLE_RATES\n    int i;\n    // char taskName[20];\n#endif\n#if defined(MW_PX4_NUTTX_BUILD)\n    sched_lock();\n#endif\n    // status = px4_sem_init(&termSem, 0, 0); PX4 PSP Dev: termSem no longer needed\n    // CHECK_STATUS(status, 0,\"px4_sem_init:termSem\");\n    status = px4_sem_init(&stopSem, 0, 0);\n    CHECK_STATUS(status, 0, \"px4_sem_init:stopSem\");\n    status = px4_sem_init(&baserateTaskSem, 0, 0);\n    CHECK_STATUS(status, 0, \"px4_sem_init:baserateTaskSem\");\n\n    // or you can use/check: _POSIX_PRIORITY_SCHEDULING\n    // _POSIX_THREAD_PRIORITY_SCHEDULING\n#if !defined(_POSIX_PRIORITY_SCHEDULING)\n    PX4_INFO(\"Priority scheduling is NOT supported by your system.\");\n    PX4_INFO(\"The generated code will not run correctly because your\");\n    PX4_INFO(\"model contains multiple rates and uses multi-tasking\");\n    PX4_INFO(\"code generation mode. You can only run the generated code\");\n    PX4_INFO(\"in single-tasking mode in your system. Open\");\n    PX4_INFO(\"Simulation -> Configuration Parameters -> Solver dialog\");\n    PX4_INFO(\"and set \\\"Tasking mode for periodic sample times\\\" parameter to SingleTasking.\");\n    PX4_INFO(\n        \"Re-build the Simulink model with the new settings and try executing the generated code \"\n        \"again.\");\n    fflush(stdout);\n    exit(-1);\n#endif\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    /* Set scheduling policy of the main thread to SCHED_FIFO */\n    g_sp.sched_priority = sched_get_priority_max(SCHED_FIFO) - 50;\n    status = sched_setscheduler(0, SCHED_FIFO, &g_sp);\n    CHECK_STATUS(status, 0, \"sched_setscheduler\");\n\n    /*Added init attribute and scheduler policy */\n    pthread_attr_init(&attr);\n    status = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n    CHECK_STATUS(status, 0, \"pthread_attr_setinheritsched\");\n    status = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedpolicy\");\n    // status = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n    // CHECK_STATUS(status, 0, \"pthread_attr_setdetachstate\");\n\n    /* PTHREAD_STACK_MIN is the minimum stack size required to start a thread */\n    stackSize = 8192 + PTHREAD_STACK_MIN;\n\n    /*added stack attribute back in */\n    status = pthread_attr_setstacksize(&attr, stackSize);\n    CHECK_STATUS(status, 0, \"pthread_attr_setstacksize\");\n#endif\n    /* set up info structure */\n    g_info.period = baseRatePeriod;\n    g_info.sigNo = BASERATE_TIMER_SIGNAL; // SIGRTMIN;\n\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"   stackSize = %d sched_priority = %d\", stackSize, g_sp.sched_priority);\n    PX4_INFO(\"   MW_BASERATE_PERIOD = %8.5f MW_BASERATE_PRIORITY = %d SIGRTMIN = 0x%08X\",\n             (double)baseRatePeriod, (int)baseRatePriority, SIGRTMIN);\n    PX4_INFO(\"   Init info.period = %8.5f sigNo = 0x%04X\", g_info.period, g_info.sigNo);\n    PX4_INFO(\"**creating the Base Rate thread before calling pthread_create**\");\n    fflush(stdout);\n#endif\n\n    /* Create the Base Rate Task here */\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = baseRatePriority;\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&baseRateThread, &attr, &baseRateTask, (void*)&g_info);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&baseRateThread, nullptr, &baseRateTask, (void*)&g_info);\n#endif\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"** Base Rate Task ID = %d with Priority = %d\\n\", baseRateThread, g_sp.sched_priority);\n    fflush(stdout);\n#endif\n\n/* Create sub-rate Tasks here */\n#ifdef MW_HAS_MULTIPLE_RATES\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"Creating sub-rate task threads\\n\");\n    PX4_INFO(\"Number of sub rate tasks: %d \\n\", MW_NUMBER_SUBRATES);\n    fflush(stdout);\n#endif\n\n    for (i = 0; i < MW_NUMBER_SUBRATES; i++) {\n        taskId[i] = i;\n        status = px4_sem_init(&subrateTaskSem[i], 0, 0);\n        CHECK_STATUS(status, 0, \"px4_sem_init: subrateTaskSem\");\n        // g_sp.sched_priority = MW_BASERATE_PRIORITY -40 + subratePriority[i] - 1;\n        g_sp.sched_priority = subratePriority[i];\n#if MW_RTOS_DEBUG\n        PX4_INFO(\"MW_SUBRATE_PRIORITY = %d \", (int)g_sp.sched_priority);\n#endif\n\n#if defined(MW_PX4_NUTTX_BUILD)\n        status = pthread_attr_setschedparam(&attr, &g_sp);\n        CHECK_STATUS(status, 0, \"pthread_attr_setschedparam\");\n        status = pthread_create(&subRateThread[i], &attr, &subrateTask, (void*)&taskId[i]);\n#elif defined(MW_PX4_POSIX_BUILD)\n        status = pthread_create(&subRateThread[i], nullptr, &subrateTask, (void*)&taskId[i]);\n#endif\n        CHECK_STATUS(status, 0, \"pthread_create\");\n\n#if MW_RTOS_DEBUG\n        PX4_INFO(\"** Sub Rate Task ID = %d \", subRateThread[i]);\n        fflush(stdout);\n#endif\n    }\n#endif // End of \"If Multiple Rates\" check\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = baseRatePriority;\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n#endif\n\n    /* Create the Scheduler Task here */\n    long stMicroSec;\n    stMicroSec = (long)(g_info.period * 1e6);\n    hrt_call_every(&BaseRate_HRT, stMicroSec, stMicroSec, Base_HRT_Callback,\n                   NULL); // timing callback to post base-rate semaphore\n\n/* Create the External Mode Task here */\n#ifdef EXT_MODE\n    /*---------- Creating EXT-mode Background Task ------------------*/\n    /* Setup signal info to block for EXT Mode */\n    EXT_sig_info.period = 0.1; // Sample rate at which we want Simulink to update w/ ext mode\n    EXT_sig_info.sigNo = SIGRTMIN;\n    /* Signaling the thread not working for low sample frequency*/\n    // sigemptyset(&EXT_sig_info.sigMask);\n    // sigaddset(&EXT_sig_info.sigMask, EXT_sig_info.sigNo);\n    // myAddBlockForThisEvent(EXT_sig_info.sigNo);\n\n    /* Setup thread for Custom Task */\n    fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = 40; // default is 100\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&backgroundThread, &attr, &backgroundTask, (void*)&EXT_sig_info);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&backgroundThread, nullptr, &backgroundTask, (void*)&EXT_sig_info);\n#endif\n    CHECK_STATUS(status, 0, \"EXT Mode Background pthread_create\");\n/*---------------------------------------------------------*/\n#endif\n\n/* Create the SD Card Task here */\n#if MAT_FILE\n    /*---------- Creating SD Card Background Task ------------------*/\n    fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = 40; // default is 100\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&loggingThread, &attr, &loggingThreadFcn, NULL);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&loggingThread, nullptr, &loggingThreadFcn, NULL);\n#endif\n    CHECK_STATUS(status, 0, \"SD Card Background pthread_create\");\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"** SD Card Background ID = %d \", loggingThread);\n    fflush(stdout);\n#endif\n\n/*---------------------------------------------------------*/\n#endif\n\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"px4_simulink_app : Created Simulink task threads successfully\\n\");\n    fflush(stdout);\n#endif\n#if defined(MW_PX4_NUTTX_BUILD)\n    sched_unlock();\n#endif\n}\n\n/*---------- Following function is added as a workaround for uavcan module build failure -------------\n  Original definition of the function is in the file <px4dir>\\Firmware\\Boards\\px4\\fmu-v5\\src\\can.c*/\n#if defined(MW_PX4_NUTTX_BUILD) && defined(CONFIG_CAN) && defined(UAVCAN_NUM_IFACES_RUNTIME)\n__EXPORT\nuint16_t board_get_can_interfaces(void)\n{\n\tuint16_t enabled_interfaces = 0x7;\n\n\tif (!PX4_MFT_HW_SUPPORTED(PX4_MFT_CAN2)) {\n\t\tenabled_interfaces &= ~(1 << 1);\n\t}\n\n\tif (!PX4_MFT_HW_SUPPORTED(PX4_MFT_CAN3)) {\n\t\tenabled_interfaces &= ~(1 << 2);\n\t}\n\n\treturn enabled_interfaces;\n }\n#endif\n/*---------------------------------------------------------*/\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};