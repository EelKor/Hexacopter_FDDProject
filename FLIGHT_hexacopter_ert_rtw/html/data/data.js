var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"FLIGHT_hexacopter","ref":false,"files":[{"name":"ert_main.cpp","type":"source","group":"main","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Main file","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: ert_main.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.250\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Fri May 23 13:47:19 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include <stdio.h>\n#include <stdlib.h>\n#include \"FLIGHT_hexacopter.h\"\n#include \"FLIGHT_hexacopter_private.h\"\n#include \"rtwtypes.h\"\n#include \"limits.h\"\n#include \"rt_nonfinite.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"nuttxinitialize.h\"\n#define UNUSED(x)                      x = x\n#define NAMELEN                        16\n\n// Function prototype declaration\nvoid exitFcn(int sig);\nvoid *terminateTask(void *arg);\nvoid *baseRateTask(void *arg);\nvoid *subrateTask(void *arg);\nvolatile boolean_T stopRequested = false;\nvolatile boolean_T runModel = true;\npx4_sem_t stopSem;\npx4_sem_t baserateTaskSem;\npx4_sem_t subrateTaskSem[1];\nint taskId[1];\npthread_t schedulerThread;\npthread_t baseRateThread;\nvoid *threadJoinStatus;\nint terminatingmodel = 0;\npthread_t subRateThread[1];\nint subratePriority[1];\nvoid *subrateTask(void *arg)\n{\n  int tid = *((int *) arg);\n  int subRateId;\n  subRateId = tid + 1;\n  while (runModel) {\n    px4_sem_wait(&subrateTaskSem[tid]);\n    if (terminatingmodel)\n      break;\n\n#ifdef MW_RTOS_DEBUG\n\n    printf(\" -subrate task %d semaphore received\\n\", subRateId);\n\n#endif\n\n    FLIGHT_hexacopter_step(subRateId);\n\n    // Get model outputs here\n  }\n\n  pthread_exit((void *)0);\n  return NULL;\n}\n\nvoid *baseRateTask(void *arg)\n{\n  runModel = (rtmGetErrorStatus(FLIGHT_hexacopter_M) == (NULL));\n  while (runModel) {\n    px4_sem_wait(&baserateTaskSem);\n\n#ifdef MW_RTOS_DEBUG\n\n    printf(\"*base rate task semaphore received\\n\");\n    fflush(stdout);\n\n#endif\n\n    if (rtmStepTask(FLIGHT_hexacopter_M, 1)\n        ) {\n      px4_sem_post(&subrateTaskSem[0]);\n    }\n\n    FLIGHT_hexacopter_step(0);\n\n    // Get model outputs here\n    stopRequested = !((rtmGetErrorStatus(FLIGHT_hexacopter_M) == (NULL)));\n  }\n\n  terminateTask(arg);\n  pthread_exit((void *)0);\n  return NULL;\n}\n\nvoid exitFcn(int sig)\n{\n  UNUSED(sig);\n  rtmSetErrorStatus(FLIGHT_hexacopter_M, \"stopping the model\");\n  runModel = 0;\n}\n\nvoid *terminateTask(void *arg)\n{\n  UNUSED(arg);\n  terminatingmodel = 1;\n\n  {\n    int i;\n\n    // Signal all periodic tasks to complete\n    for (i=0; i<1; i++) {\n      CHECK_STATUS(px4_sem_post(&subrateTaskSem[i]), 0, \"px4_sem_post\");\n      CHECK_STATUS(px4_sem_destroy(&subrateTaskSem[i]), 0, \"px4_sem_destroy\");\n    }\n\n    // Wait for all periodic tasks to complete\n    for (i=0; i<1; i++) {\n      CHECK_STATUS(pthread_join(subRateThread[i], &threadJoinStatus), 0,\n                   \"pthread_join\");\n    }\n\n    runModel = 0;\n  }\n\n  MW_PX4_Terminate();\n\n  // Terminate model\n  FLIGHT_hexacopter_terminate();\n  px4_sem_post(&stopSem);\n  return NULL;\n}\n\nint px4_simulink_app_task_main (int argc, char *argv[])\n{\n  subratePriority[0] = 249;\n  px4_simulink_app_control_MAVLink();\n  rtmSetErrorStatus(FLIGHT_hexacopter_M, 0);\n\n  // Initialize model\n  FLIGHT_hexacopter_initialize();\n\n  // Call RTOS Initialization function\n  nuttxRTOSInit(0.001, 1);\n\n  // Wait for stop semaphore\n  px4_sem_wait(&stopSem);\n\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\n\n  {\n    int i;\n    for (i=0; i < MW_NUMBER_TIMER_DRIVEN_TASKS; i++) {\n      CHECK_STATUS(px4_sem_destroy(&timerTaskSem[i]), 0, \"px4_sem_destroy\");\n    }\n  }\n\n#endif\n\n  return 0;\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"FLIGHT_hexacopter.cpp","type":"source","group":"model","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: FLIGHT_hexacopter.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.250\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Fri May 23 13:47:19 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include \"FLIGHT_hexacopter.h\"\n#include \"FLIGHT_hexacopter_types.h\"\n#include \"rtwtypes.h\"\n#include \"FLIGHT_hexacopter_private.h\"\n#include <math.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rt_defines.h\"\n\n// Block signals (default storage)\nB_FLIGHT_hexacopter_T FLIGHT_hexacopter_B;\n\n// Block states (default storage)\nDW_FLIGHT_hexacopter_T FLIGHT_hexacopter_DW;\n\n// Real-time model\nRT_MODEL_FLIGHT_hexacopter_T FLIGHT_hexacopter_M_ = RT_MODEL_FLIGHT_hexacopter_T\n  ();\nRT_MODEL_FLIGHT_hexacopter_T *const FLIGHT_hexacopter_M = &FLIGHT_hexacopter_M_;\n\n// Forward declaration for local functions\nstatic void FLIGHT_hexacopter_PWM_setupImpl(px4_internal_block_PWM_FLIGHT_T *obj,\n  boolean_T armPWM, boolean_T forceFailsafe);\nstatic void rate_monotonic_scheduler(void);\n\n//\n// Set which subrates need to run this base step (base rate always runs).\n// This function must be called prior to calling the model step function\n// in order to remember which rates need to run this base step.  The\n// buffering of events allows for overlapping preemption.\n//\nvoid FLIGHT_hexacopter_SetEventsForThisBaseStep(boolean_T *eventFlags)\n{\n  // Task runs when its counter is zero, computed via rtmStepTask macro\n  eventFlags[1] = ((boolean_T)rtmStepTask(FLIGHT_hexacopter_M, 1));\n}\n\n//\n//         This function updates active task flag for each subrate\n//         and rate transition flags for tasks that exchange data.\n//         The function assumes rate-monotonic multitasking scheduler.\n//         The function must be called at model base rate so that\n//         the generated code self-manages all its subrates and rate\n//         transition flags.\n//\nstatic void rate_monotonic_scheduler(void)\n{\n  // To ensure a deterministic data transfer between two rates,\n  //  data is transferred at the priority of a fast task and the frequency\n  //  of the slow task.  The following flags indicate when the data transfer\n  //  happens.  That is, a rate interaction flag is set true when both rates\n  //  will run, and false otherwise.\n\n\n  // tid 0 shares data with slower tid rate: 1\n  FLIGHT_hexacopter_M->Timing.RateInteraction.TID0_1 =\n    (FLIGHT_hexacopter_M->Timing.TaskCounters.TID[1] == 0);\n\n  // Compute which subrates run during the next base time step.  Subrates\n  //  are an integer multiple of the base rate counter.  Therefore, the subtask\n  //  counter is reset when it reaches its limit (zero means run).\n\n  (FLIGHT_hexacopter_M->Timing.TaskCounters.TID[1])++;\n  if ((FLIGHT_hexacopter_M->Timing.TaskCounters.TID[1]) > 3) {// Sample time: [0.004s, 0.0s] \n    FLIGHT_hexacopter_M->Timing.TaskCounters.TID[1] = 0;\n  }\n}\n\n// System initialize for atomic system:\nvoid FLIGHT_he_PX4Timestamp_Init(DW_PX4Timestamp_FLIGHT_hexaco_T *localDW)\n{\n  // Start for MATLABSystem: '<S3>/PX4 Timestamp'\n  localDW->obj.matlabCodegenIsDeleted = false;\n  localDW->objisempty = true;\n  localDW->obj.isInitialized = 1;\n  localDW->obj.isSetupComplete = true;\n}\n\n// Output and update for atomic system:\nvoid FLIGHT_hexacop_PX4Timestamp(B_PX4Timestamp_FLIGHT_hexacop_T *localB)\n{\n  // MATLABSystem: '<S3>/PX4 Timestamp'\n  localB->PX4Timestamp = hrt_absolute_time();\n}\n\n// Termination for atomic system:\nvoid FLIGHT_he_PX4Timestamp_Term(DW_PX4Timestamp_FLIGHT_hexaco_T *localDW)\n{\n  // Terminate for MATLABSystem: '<S3>/PX4 Timestamp'\n  if (!localDW->obj.matlabCodegenIsDeleted) {\n    localDW->obj.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S3>/PX4 Timestamp'\n}\n\n// System initialize for atomic system:\nvoid FLIGHT__PX4Timestamp_b_Init(DW_PX4Timestamp_FLIGHT_hexa_b_T *localDW)\n{\n  // Start for MATLABSystem: '<S490>/PX4 Timestamp'\n  localDW->obj.matlabCodegenIsDeleted = false;\n  localDW->objisempty = true;\n  localDW->obj.isInitialized = 1;\n  localDW->obj.isSetupComplete = true;\n}\n\n// Output and update for atomic system:\nvoid FLIGHT_hexac_PX4Timestamp_o(B_PX4Timestamp_FLIGHT_hexac_l_T *localB)\n{\n  // MATLABSystem: '<S490>/PX4 Timestamp'\n  localB->PX4Timestamp = hrt_absolute_time();\n}\n\n// Termination for atomic system:\nvoid FLIGHT__PX4Timestamp_o_Term(DW_PX4Timestamp_FLIGHT_hexa_b_T *localDW)\n{\n  // Terminate for MATLABSystem: '<S490>/PX4 Timestamp'\n  if (!localDW->obj.matlabCodegenIsDeleted) {\n    localDW->obj.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S490>/PX4 Timestamp'\n}\n\n// System initialize for atomic system:\nvoid FLIGHT__PX4Timestamp_m_Init(DW_PX4Timestamp_FLIGHT_hexa_f_T *localDW)\n{\n  // Start for MATLABSystem: '<S504>/PX4 Timestamp'\n  localDW->obj.matlabCodegenIsDeleted = false;\n  localDW->objisempty = true;\n  localDW->obj.isInitialized = 1;\n  localDW->obj.isSetupComplete = true;\n}\n\n// Output and update for atomic system:\nvoid FLIGHT_hexac_PX4Timestamp_n(B_PX4Timestamp_FLIGHT_hexac_h_T *localB)\n{\n  // MATLABSystem: '<S504>/PX4 Timestamp'\n  localB->PX4Timestamp = hrt_absolute_time();\n}\n\n// Termination for atomic system:\nvoid FLIGHT__PX4Timestamp_k_Term(DW_PX4Timestamp_FLIGHT_hexa_f_T *localDW)\n{\n  // Terminate for MATLABSystem: '<S504>/PX4 Timestamp'\n  if (!localDW->obj.matlabCodegenIsDeleted) {\n    localDW->obj.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S504>/PX4 Timestamp'\n}\n\nreal32_T rt_roundf_snf(real32_T u)\n{\n  real32_T y;\n  if (static_cast<real32_T>(fabs(static_cast<real_T>(u))) < 8.388608E+6F) {\n    if (u >= 0.5F) {\n      y = static_cast<real32_T>(floor(static_cast<real_T>(u + 0.5F)));\n    } else if (u > -0.5F) {\n      y = u * 0.0F;\n    } else {\n      y = static_cast<real32_T>(ceil(static_cast<real_T>(u - 0.5F)));\n    }\n  } else {\n    y = u;\n  }\n\n  return y;\n}\n\nreal32_T rt_atan2f_snf(real32_T u0, real32_T u1)\n{\n  real32_T y;\n  if (rtIsNaNF(u0) || rtIsNaNF(u1)) {\n    y = (rtNaNF);\n  } else if (rtIsInfF(u0) && rtIsInfF(u1)) {\n    int32_T tmp;\n    int32_T tmp_0;\n    if (u0 > 0.0F) {\n      tmp = 1;\n    } else {\n      tmp = -1;\n    }\n\n    if (u1 > 0.0F) {\n      tmp_0 = 1;\n    } else {\n      tmp_0 = -1;\n    }\n\n    y = static_cast<real32_T>(atan2(static_cast<real_T>(static_cast<real32_T>\n      (tmp)), static_cast<real_T>(static_cast<real32_T>(tmp_0))));\n  } else if (u1 == 0.0F) {\n    if (u0 > 0.0F) {\n      y = RT_PIF / 2.0F;\n    } else if (u0 < 0.0F) {\n      y = -(RT_PIF / 2.0F);\n    } else {\n      y = 0.0F;\n    }\n  } else {\n    y = static_cast<real32_T>(atan2(static_cast<real_T>(u0), static_cast<real_T>\n      (u1)));\n  }\n\n  return y;\n}\n\nstatic void FLIGHT_hexacopter_PWM_setupImpl(px4_internal_block_PWM_FLIGHT_T *obj,\n  boolean_T armPWM, boolean_T forceFailsafe)\n{\n  obj->isMain = true;\n  pwm_open(&obj->actuatorAdvertiseObj, &obj->armAdvertiseObj);\n  obj->servoCount = 8;\n  if (armPWM) {\n    pwm_arm(&obj->armAdvertiseObj);\n    obj->isArmed = true;\n  } else {\n    pwm_disarm(&obj->armAdvertiseObj);\n    obj->isArmed = false;\n  }\n\n  obj->channelMask = 63;\n  if (obj->isMain) {\n    if (forceFailsafe) {\n      pwm_disarm(&obj->armAdvertiseObj);\n    } else {\n      pwm_arm(&obj->armAdvertiseObj);\n    }\n  }\n}\n\n// Model step function for TID0\nvoid FLIGHT_hexacopter_step0(void)     // Sample time: [0.001s, 0.0s]\n{\n  int32_T i;\n  real32_T ParamStep;\n  real32_T ParamStep_0;\n  real32_T ParamStep_1;\n  real32_T rtb_IProdOut;\n  real32_T rtb_IProdOut_h;\n  real32_T rtb_Integrator_cv;\n  real32_T rtb_Integrator_k;\n  real32_T rtb_Product2_a;\n  real32_T rtb_TSamp_p4;\n  real32_T rtb_d;\n  real32_T rtb_p;\n  real32_T rtb_r;\n  real32_T rtb_w_radps;\n  uint32_T tmp;\n  uint16_T tmp_0;\n  boolean_T b_varargout_1;\n  boolean_T rtb_Compare_a;\n\n  {                                    // Sample time: [0.001s, 0.0s]\n    rate_monotonic_scheduler();\n  }\n\n  // RateTransition: '<Root>/rate_transition_arm'\n  if (FLIGHT_hexacopter_M->Timing.RateInteraction.TID0_1) {\n    // RateTransition: '<Root>/rate_transition_arm'\n    FLIGHT_hexacopter_B.rate_transition_arm =\n      FLIGHT_hexacopter_DW.rate_transition_arm_Buffer0;\n\n    // RateTransition: '<Root>/rate_transition_des_p'\n    FLIGHT_hexacopter_B.rate_transition_des_p =\n      FLIGHT_hexacopter_DW.rate_transition_des_p_Buffer0;\n\n    // RateTransition: '<Root>/rate_transition_des_q'\n    FLIGHT_hexacopter_B.rate_transition_des_q =\n      FLIGHT_hexacopter_DW.rate_transition_des_q_Buffer0;\n\n    // RateTransition: '<Root>/rate_transition_des_r'\n    FLIGHT_hexacopter_B.rate_transition_des_r =\n      FLIGHT_hexacopter_DW.rate_transition_des_r_Buffer0;\n  }\n\n  // End of RateTransition: '<Root>/rate_transition_arm'\n\n  // MATLABSystem: '<S497>/SourceBlock'\n  b_varargout_1 = uORB_read_step(FLIGHT_hexacopter_DW.obj_pe.orbMetadataObj,\n    &FLIGHT_hexacopter_DW.obj_pe.eventStructObj, &FLIGHT_hexacopter_B.r4, false,\n    1.0);\n\n  // Outputs for Enabled SubSystem: '<S497>/Enabled Subsystem' incorporates:\n  //   EnablePort: '<S498>/Enable'\n\n  // Start for MATLABSystem: '<S497>/SourceBlock'\n  if (b_varargout_1) {\n    // SignalConversion generated from: '<S498>/In1'\n    FLIGHT_hexacopter_B.In1_h = FLIGHT_hexacopter_B.r4;\n  }\n\n  // End of Outputs for SubSystem: '<S497>/Enabled Subsystem'\n\n  // Outputs for Enabled SubSystem: '<Root>/SAS' incorporates:\n  //   EnablePort: '<S10>/Enable'\n\n  if (FLIGHT_hexacopter_B.rate_transition_arm) {\n    // MATLABSystem: '<S10>/Read Parameter10'\n    if (FLIGHT_hexacopter_DW.obj_c.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_c.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_c.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // MATLAB Function: '<S10>/MATLAB Function' incorporates:\n    //   MATLABSystem: '<S10>/Read Parameter10'\n    //\n    rtb_w_radps = ParamStep * 2.0F * 3.14159274F;\n\n    // Gain: '<S315>/tau'\n    rtb_Product2_a = FLIGHT_hexacopter_P.tau_Gain * rtb_w_radps;\n\n    // Product: '<S316>/Product2'\n    ParamStep = rtb_Product2_a * rtb_Product2_a;\n\n    // Bias: '<S316>/Bias'\n    rtb_d = ParamStep + FLIGHT_hexacopter_P.Bias_Bias;\n\n    // Gain: '<S316>/Gain'\n    rtb_Product2_a *= FLIGHT_hexacopter_P.Gain_Gain_i;\n\n    // Sum: '<S316>/Add1'\n    rtb_r = rtb_d + rtb_Product2_a;\n\n    // Sum: '<S315>/Sum' incorporates:\n    //   UnitDelay: '<S315>/Unit Delay1'\n\n    rtb_Integrator_cv = FLIGHT_hexacopter_B.In1_h.xyz[1] +\n      FLIGHT_hexacopter_DW.UnitDelay1_DSTATE;\n\n    // Sum: '<S315>/Sum1' incorporates:\n    //   Bias: '<S316>/Bias1'\n    //   Gain: '<S315>/Gain1'\n    //   Product: '<S315>/Product5'\n    //   Product: '<S316>/Product4'\n    //   Sum: '<S315>/Sum2'\n    //   UnaryMinus: '<S316>/Unary Minus'\n    //   UnitDelay: '<S315>/Unit Delay1'\n    //   UnitDelay: '<S315>/Unit Delay2'\n\n    FLIGHT_hexacopter_DW.UnitDelay1_DSTATE = ((-ParamStep +\n      FLIGHT_hexacopter_P.Bias1_Bias) / rtb_r * rtb_Integrator_cv +\n      FLIGHT_hexacopter_B.In1_h.xyz[1]) * FLIGHT_hexacopter_P.Gain1_Gain_j +\n      FLIGHT_hexacopter_DW.UnitDelay2_DSTATE;\n\n    // SampleTimeMath: '<S312>/TSamp' incorporates:\n    //   Product: '<S315>/Product1'\n    //   Product: '<S316>/Product3'\n    //\n    //  About '<S312>/TSamp':\n    //   y = u * K where K = 1 / ( w * Ts )\n    //\n    rtb_TSamp_p4 = ParamStep / rtb_r * rtb_Integrator_cv *\n      FLIGHT_hexacopter_P.TSamp_WtEt;\n\n    // MATLABSystem: '<S10>/Read Parameter5'\n    if (FLIGHT_hexacopter_DW.obj_h.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_h.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_h.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // Sum: '<S309>/Sum1'\n    rtb_Integrator_k = FLIGHT_hexacopter_B.rate_transition_des_q -\n      FLIGHT_hexacopter_B.In1_h.xyz[1];\n\n    // MATLABSystem: '<S10>/Read Parameter3'\n    if (FLIGHT_hexacopter_DW.obj_b.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_b.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_b.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_0);\n    if (b_varargout_1) {\n      ParamStep_0 = 0.0F;\n    }\n\n    // Sum: '<S309>/Sum5' incorporates:\n    //   DiscreteIntegrator: '<S350>/Integrator'\n    //   MATLABSystem: '<S10>/Read Parameter3'\n    //   MATLABSystem: '<S10>/Read Parameter5'\n    //   Product: '<S309>/Product2'\n    //   Product: '<S355>/PProd Out'\n    //   Sum: '<S312>/Diff'\n    //   Sum: '<S359>/Sum'\n    //   UnitDelay: '<S312>/UD'\n    //  *\n    //  Block description for '<S312>/Diff':\n    //\n    //   Add in CPU\n    //\n    //  Block description for '<S312>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_B.Sum5 = (rtb_Integrator_k * ParamStep_0 +\n      FLIGHT_hexacopter_DW.Integrator_DSTATE_p) - (rtb_TSamp_p4 -\n      FLIGHT_hexacopter_DW.UD_DSTATE_l) * ParamStep;\n\n    // MATLABSystem: '<S10>/Read Parameter4'\n    if (FLIGHT_hexacopter_DW.obj_p.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_p.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_p.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // Product: '<S347>/IProd Out' incorporates:\n    //   MATLABSystem: '<S10>/Read Parameter4'\n    //\n    rtb_IProdOut = rtb_Integrator_k * ParamStep;\n\n    // Sum: '<S315>/Sum3' incorporates:\n    //   Product: '<S315>/Product2'\n    //   Product: '<S316>/Product5'\n    //   Sum: '<S316>/Add3'\n    //   UnitDelay: '<S315>/Unit Delay2'\n\n    FLIGHT_hexacopter_DW.UnitDelay2_DSTATE = FLIGHT_hexacopter_B.In1_h.xyz[1] -\n      1.0F / rtb_r * (rtb_d - rtb_Product2_a) * rtb_Integrator_cv;\n\n    // Gain: '<S370>/tau'\n    rtb_Integrator_k = FLIGHT_hexacopter_P.tau_Gain_n * rtb_w_radps;\n\n    // Product: '<S371>/Product2'\n    rtb_Integrator_cv = rtb_Integrator_k * rtb_Integrator_k;\n\n    // Bias: '<S371>/Bias'\n    rtb_r = rtb_Integrator_cv + FLIGHT_hexacopter_P.Bias_Bias_b;\n\n    // Gain: '<S371>/Gain'\n    rtb_Integrator_k *= FLIGHT_hexacopter_P.Gain_Gain_e;\n\n    // Sum: '<S371>/Add1'\n    rtb_d = rtb_r + rtb_Integrator_k;\n\n    // Sum: '<S370>/Sum' incorporates:\n    //   UnitDelay: '<S370>/Unit Delay1'\n\n    rtb_Product2_a = FLIGHT_hexacopter_B.In1_h.xyz[0] +\n      FLIGHT_hexacopter_DW.UnitDelay1_DSTATE_f;\n\n    // Sum: '<S370>/Sum1' incorporates:\n    //   Bias: '<S371>/Bias1'\n    //   Gain: '<S370>/Gain1'\n    //   Product: '<S370>/Product5'\n    //   Product: '<S371>/Product4'\n    //   Sum: '<S370>/Sum2'\n    //   UnaryMinus: '<S371>/Unary Minus'\n    //   UnitDelay: '<S370>/Unit Delay1'\n    //   UnitDelay: '<S370>/Unit Delay2'\n\n    FLIGHT_hexacopter_DW.UnitDelay1_DSTATE_f = ((-rtb_Integrator_cv +\n      FLIGHT_hexacopter_P.Bias1_Bias_n) / rtb_d * rtb_Product2_a +\n      FLIGHT_hexacopter_B.In1_h.xyz[0]) * FLIGHT_hexacopter_P.Gain1_Gain_e +\n      FLIGHT_hexacopter_DW.UnitDelay2_DSTATE_c;\n\n    // SampleTimeMath: '<S367>/TSamp' incorporates:\n    //   Product: '<S370>/Product1'\n    //   Product: '<S371>/Product3'\n    //\n    //  About '<S367>/TSamp':\n    //   y = u * K where K = 1 / ( w * Ts )\n    //\n    rtb_Integrator_cv = rtb_Integrator_cv / rtb_d * rtb_Product2_a *\n      FLIGHT_hexacopter_P.TSamp_WtEt_m;\n\n    // MATLABSystem: '<S10>/Read Parameter2'\n    if (FLIGHT_hexacopter_DW.obj_da.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_da.SampleTime =\n        FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_da.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // Sum: '<S310>/Sum1'\n    rtb_p = FLIGHT_hexacopter_B.rate_transition_des_p -\n      FLIGHT_hexacopter_B.In1_h.xyz[0];\n\n    // MATLABSystem: '<S10>/read_mc_rollrate_p'\n    if (FLIGHT_hexacopter_DW.obj_i.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_i.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_i.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_0);\n    if (b_varargout_1) {\n      ParamStep_0 = 0.0F;\n    }\n\n    // Sum: '<S310>/Sum5' incorporates:\n    //   DiscreteIntegrator: '<S405>/Integrator'\n    //   MATLABSystem: '<S10>/Read Parameter2'\n    //   MATLABSystem: '<S10>/read_mc_rollrate_p'\n    //   Product: '<S310>/Product2'\n    //   Product: '<S410>/PProd Out'\n    //   Sum: '<S367>/Diff'\n    //   Sum: '<S414>/Sum'\n    //   UnitDelay: '<S367>/UD'\n    //  *\n    //  Block description for '<S367>/Diff':\n    //\n    //   Add in CPU\n    //\n    //  Block description for '<S367>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_B.Sum5_d = (rtb_p * ParamStep_0 +\n      FLIGHT_hexacopter_DW.Integrator_DSTATE_c) - (rtb_Integrator_cv -\n      FLIGHT_hexacopter_DW.UD_DSTATE_m) * ParamStep;\n\n    // MATLABSystem: '<S10>/Read Parameter1'\n    if (FLIGHT_hexacopter_DW.obj_ea.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_ea.SampleTime =\n        FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_ea.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // Product: '<S402>/IProd Out' incorporates:\n    //   MATLABSystem: '<S10>/Read Parameter1'\n    //\n    rtb_IProdOut_h = rtb_p * ParamStep;\n\n    // Sum: '<S370>/Sum3' incorporates:\n    //   Product: '<S370>/Product2'\n    //   Product: '<S371>/Product5'\n    //   Sum: '<S371>/Add3'\n    //   UnitDelay: '<S370>/Unit Delay2'\n\n    FLIGHT_hexacopter_DW.UnitDelay2_DSTATE_c = FLIGHT_hexacopter_B.In1_h.xyz[0]\n      - 1.0F / rtb_d * (rtb_r - rtb_Integrator_k) * rtb_Product2_a;\n\n    // Gain: '<S425>/tau'\n    rtb_p = FLIGHT_hexacopter_P.tau_Gain_c * rtb_w_radps;\n\n    // Product: '<S426>/Product2'\n    rtb_Integrator_k = rtb_p * rtb_p;\n\n    // Bias: '<S426>/Bias'\n    rtb_r = rtb_Integrator_k + FLIGHT_hexacopter_P.Bias_Bias_c;\n\n    // Gain: '<S426>/Gain'\n    rtb_p *= FLIGHT_hexacopter_P.Gain_Gain_b;\n\n    // Sum: '<S426>/Add1'\n    rtb_d = rtb_r + rtb_p;\n\n    // Sum: '<S425>/Sum' incorporates:\n    //   UnitDelay: '<S425>/Unit Delay1'\n\n    rtb_Product2_a = FLIGHT_hexacopter_B.In1_h.xyz[2] +\n      FLIGHT_hexacopter_DW.UnitDelay1_DSTATE_e;\n\n    // Sum: '<S425>/Sum1' incorporates:\n    //   Bias: '<S426>/Bias1'\n    //   Gain: '<S425>/Gain1'\n    //   Product: '<S425>/Product5'\n    //   Product: '<S426>/Product4'\n    //   Sum: '<S425>/Sum2'\n    //   UnaryMinus: '<S426>/Unary Minus'\n    //   UnitDelay: '<S425>/Unit Delay1'\n    //   UnitDelay: '<S425>/Unit Delay2'\n\n    FLIGHT_hexacopter_DW.UnitDelay1_DSTATE_e = ((-rtb_Integrator_k +\n      FLIGHT_hexacopter_P.Bias1_Bias_i) / rtb_d * rtb_Product2_a +\n      FLIGHT_hexacopter_B.In1_h.xyz[2]) * FLIGHT_hexacopter_P.Gain1_Gain_iw +\n      FLIGHT_hexacopter_DW.UnitDelay2_DSTATE_e;\n\n    // SampleTimeMath: '<S422>/TSamp' incorporates:\n    //   Product: '<S425>/Product1'\n    //   Product: '<S426>/Product3'\n    //\n    //  About '<S422>/TSamp':\n    //   y = u * K where K = 1 / ( w * Ts )\n    //\n    rtb_w_radps = rtb_Integrator_k / rtb_d * rtb_Product2_a *\n      FLIGHT_hexacopter_P.TSamp_WtEt_p;\n\n    // MATLABSystem: '<S10>/Read Parameter8'\n    if (FLIGHT_hexacopter_DW.obj_i4.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_i4.SampleTime =\n        FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_i4.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // MATLABSystem: '<S10>/Read Parameter6'\n    if (FLIGHT_hexacopter_DW.obj_a.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_a.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_a.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_0);\n    if (b_varargout_1) {\n      ParamStep_0 = 0.0F;\n    }\n\n    // Sum: '<S311>/Sum1'\n    rtb_Integrator_k = FLIGHT_hexacopter_B.rate_transition_des_r -\n      FLIGHT_hexacopter_B.In1_h.xyz[2];\n\n    // MATLABSystem: '<S10>/Read Parameter9'\n    if (FLIGHT_hexacopter_DW.obj_e.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_e.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_e.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep_1);\n    if (b_varargout_1) {\n      ParamStep_1 = 0.0F;\n    }\n\n    // Sum: '<S10>/Sum' incorporates:\n    //   DiscreteIntegrator: '<S460>/Integrator'\n    //   MATLABSystem: '<S10>/Read Parameter6'\n    //   MATLABSystem: '<S10>/Read Parameter8'\n    //   MATLABSystem: '<S10>/Read Parameter9'\n    //   Product: '<S10>/yawrate_feedforward'\n    //   Product: '<S311>/Product2'\n    //   Product: '<S465>/PProd Out'\n    //   Sum: '<S311>/Sum5'\n    //   Sum: '<S422>/Diff'\n    //   Sum: '<S469>/Sum'\n    //   UnitDelay: '<S422>/UD'\n    //  *\n    //  Block description for '<S422>/Diff':\n    //\n    //   Add in CPU\n    //\n    //  Block description for '<S422>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_B.Sum = ((rtb_Integrator_k * ParamStep_0 +\n      FLIGHT_hexacopter_DW.Integrator_DSTATE_g) - (rtb_w_radps -\n      FLIGHT_hexacopter_DW.UD_DSTATE_jy) * ParamStep) + ParamStep_1 *\n      FLIGHT_hexacopter_B.rate_transition_des_r;\n\n    // MATLABSystem: '<S10>/Read Parameter7'\n    if (FLIGHT_hexacopter_DW.obj_j.SampleTime !=\n        FLIGHT_hexacopter_P.SampleTime_SAS) {\n      FLIGHT_hexacopter_DW.obj_j.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    }\n\n    b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_j.MW_PARAMHANDLE,\n      MW_SINGLE, &ParamStep);\n    if (b_varargout_1) {\n      ParamStep = 0.0F;\n    }\n\n    // Sum: '<S425>/Sum3' incorporates:\n    //   Product: '<S425>/Product2'\n    //   Product: '<S426>/Product5'\n    //   Sum: '<S426>/Add3'\n    //   UnitDelay: '<S425>/Unit Delay2'\n\n    FLIGHT_hexacopter_DW.UnitDelay2_DSTATE_e = FLIGHT_hexacopter_B.In1_h.xyz[2]\n      - 1.0F / rtb_d * (rtb_r - rtb_p) * rtb_Product2_a;\n\n    // Update for UnitDelay: '<S312>/UD'\n    //\n    //  Block description for '<S312>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_l = rtb_TSamp_p4;\n\n    // Update for DiscreteIntegrator: '<S350>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_p +=\n      FLIGHT_hexacopter_P.Integrator_gainval * rtb_IProdOut;\n\n    // Update for UnitDelay: '<S367>/UD'\n    //\n    //  Block description for '<S367>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_m = rtb_Integrator_cv;\n\n    // Update for DiscreteIntegrator: '<S405>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_c +=\n      FLIGHT_hexacopter_P.Integrator_gainval_b * rtb_IProdOut_h;\n\n    // Update for UnitDelay: '<S422>/UD'\n    //\n    //  Block description for '<S422>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_jy = rtb_w_radps;\n\n    // Update for DiscreteIntegrator: '<S460>/Integrator' incorporates:\n    //   MATLABSystem: '<S10>/Read Parameter7'\n    //   Product: '<S457>/IProd Out'\n    //\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_g += rtb_Integrator_k * ParamStep *\n      FLIGHT_hexacopter_P.Integrator_gainval_p;\n  }\n\n  // End of Outputs for SubSystem: '<Root>/SAS'\n\n  // RateTransition: '<Root>/Rate Transition1' incorporates:\n  //   RateTransition: '<Root>/rate_transition_throttle'\n\n  if (FLIGHT_hexacopter_M->Timing.RateInteraction.TID0_1) {\n    // RateTransition: '<Root>/Rate Transition1'\n    FLIGHT_hexacopter_B.RateTransition1 =\n      FLIGHT_hexacopter_DW.RateTransition1_Buffer0;\n\n    // RateTransition: '<Root>/rate_transition_ctrl_sw'\n    FLIGHT_hexacopter_B.rate_transition_ctrl_sw =\n      FLIGHT_hexacopter_DW.rate_transition_ctrl_sw_Buffer0;\n\n    // RateTransition: '<Root>/rate_transition_throttle'\n    FLIGHT_hexacopter_B.rate_transition_throttle =\n      FLIGHT_hexacopter_DW.rate_transition_throttle_Buffer;\n  }\n\n  // End of RateTransition: '<Root>/Rate Transition1'\n\n  // MATLAB Function: '<S13>/MATLAB Function' incorporates:\n  //   Constant: '<S488>/Constant'\n  //   RelationalOperator: '<S488>/Compare'\n\n  if (FLIGHT_hexacopter_B.rate_transition_ctrl_sw >=\n      FLIGHT_hexacopter_P.CompareToConstant_const) {\n    rtb_Product2_a = FLIGHT_hexacopter_B.RateTransition1;\n  } else {\n    rtb_Product2_a = FLIGHT_hexacopter_B.Sum5_d;\n  }\n\n  // End of MATLAB Function: '<S13>/MATLAB Function'\n\n  // Outputs for Enabled SubSystem: '<Root>/Mixer' incorporates:\n  //   EnablePort: '<S7>/Enable'\n\n  if (FLIGHT_hexacopter_B.rate_transition_arm) {\n    // MATLAB Function: '<S7>/pwm_out2'\n    // Function description:\n    //   Control allocation. The quadrotor type is X-configuration,\n    //   and the airframe is as follows:\n    // 3↓   1↑\n    //   \\ /\n    //   / \\\n    // 2↑   4↓\n    // Input：\n    //   Roll, Pitch, Yaw: attitude controller output.\n    //   Thrust\n    //  M1 = uint16(Thrust*scale + (- Roll + Pitch + Yaw) * scale_att + idle_PWM); \n    //  M2 = uint16(Thrust*scale + (Roll - Pitch + Yaw) * scale_att + idle_PWM); \n    //  M3 = uint16(Thrust*scale + (Roll + Pitch - Yaw) * scale_att + idle_PWM); \n    //  M4 = uint16(Thrust*scale + (- Roll - Pitch - Yaw) * scale_att + idle_PWM); \n    //  Hex X\n    //  M1 = ((Pitch + Roll / 2 - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M2 = ((Pitch - Roll / 2 + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M3 = ((-Roll - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM;\n    //  M4 = ((-Pitch - Roll / 2 + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M5 = ((-Pitch + Roll / 2 - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M6 = ((Roll + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM;\n    //  M7 = 1000;\n    //  M8 = 1000;\n    //  Hex X (From Adam)\n    //  Hex X (Version 2)\n    //  Roll/Yaw\n    //  M1 = ((-Roll - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM;\n    //  M2 = ((Roll + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM;\n    //  % + Pitch/Roll\n    //  M6 = ((Pitch + Roll / 2 - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M4 = ((Pitch - Roll / 2 + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  % - Pitch/Roll\n    //  M5 = ((-Pitch - Roll / 2 + Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    //  M3 = ((-Pitch + Roll / 2 - Yaw) * Thrust / 2 + Thrust) * 1000 + idle_PWM; \n    rtb_d = rt_roundf_snf(((-rtb_Product2_a - FLIGHT_hexacopter_B.Sum) *\n      FLIGHT_hexacopter_B.rate_transition_throttle / 3.0F +\n      FLIGHT_hexacopter_B.rate_transition_throttle) * 1000.0F);\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S7>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S7>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[0] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[0] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[0] = static_cast<uint16_T>(tmp);\n    }\n\n    // MATLAB Function: '<S7>/pwm_out2'\n    rtb_d = rt_roundf_snf(((rtb_Product2_a + FLIGHT_hexacopter_B.Sum) *\n      FLIGHT_hexacopter_B.rate_transition_throttle / 3.0F +\n      FLIGHT_hexacopter_B.rate_transition_throttle) * 1000.0F);\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S7>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S7>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[1] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[1] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[1] = static_cast<uint16_T>(tmp);\n    }\n\n    // MATLAB Function: '<S7>/pwm_out2'\n    rtb_d = rt_roundf_snf((((rtb_Product2_a / 2.0F + FLIGHT_hexacopter_B.Sum5) -\n      FLIGHT_hexacopter_B.Sum) * FLIGHT_hexacopter_B.rate_transition_throttle /\n      3.0F + FLIGHT_hexacopter_B.rate_transition_throttle) * 1000.0F);\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S7>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S7>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[2] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[2] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[2] = static_cast<uint16_T>(tmp);\n    }\n\n    // MATLAB Function: '<S7>/pwm_out2'\n    rtb_d = rt_roundf_snf((((-FLIGHT_hexacopter_B.Sum5 - rtb_Product2_a / 2.0F)\n      + FLIGHT_hexacopter_B.Sum) * FLIGHT_hexacopter_B.rate_transition_throttle /\n      3.0F + FLIGHT_hexacopter_B.rate_transition_throttle) * 1000.0F);\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S7>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S7>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[3] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[3] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[3] = static_cast<uint16_T>(tmp);\n    }\n\n    // MATLAB Function: '<S7>/pwm_out2'\n    rtb_d = rt_roundf_snf((((FLIGHT_hexacopter_B.Sum5 - rtb_Product2_a / 2.0F) +\n      FLIGHT_hexacopter_B.Sum) * FLIGHT_hexacopter_B.rate_transition_throttle /\n      3.0F + FLIGHT_hexacopter_B.rate_transition_throttle) * 1000.0F);\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S7>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S7>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[4] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[4] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[4] = static_cast<uint16_T>(tmp);\n    }\n\n    // MATLAB Function: '<S7>/pwm_out2'\n    rtb_d = rt_roundf_snf((((rtb_Product2_a / 2.0F - FLIGHT_hexacopter_B.Sum5) -\n      FLIGHT_hexacopter_B.Sum) * FLIGHT_hexacopter_B.rate_transition_throttle /\n      3.0F + FLIGHT_hexacopter_B.rate_transition_throttle) * 1000.0F);\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    tmp = tmp_0 + 1000U;\n    if (rtb_d < 65536.0F) {\n      if (rtb_d >= 0.0F) {\n        tmp_0 = static_cast<uint16_T>(rtb_d);\n      } else {\n        tmp_0 = 0U;\n      }\n    } else {\n      tmp_0 = MAX_uint16_T;\n    }\n\n    if (tmp_0 + 1000U > 65535U) {\n      tmp = 65535U;\n    }\n\n    // Saturate: '<S7>/Output_Limits1' incorporates:\n    //   MATLAB Function: '<S7>/pwm_out2'\n\n    if (static_cast<uint16_T>(tmp) > FLIGHT_hexacopter_P.Output_Limits1_UpperSat)\n    {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[5] =\n        FLIGHT_hexacopter_P.Output_Limits1_UpperSat;\n    } else if (static_cast<uint16_T>(tmp) <\n               FLIGHT_hexacopter_P.Output_Limits1_LowerSat) {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[5] =\n        FLIGHT_hexacopter_P.Output_Limits1_LowerSat;\n    } else {\n      // Saturate: '<S7>/Output_Limits1'\n      FLIGHT_hexacopter_B.Output_Limits1[5] = static_cast<uint16_T>(tmp);\n    }\n  }\n\n  // End of Outputs for SubSystem: '<Root>/Mixer'\n\n  // DataTypeConversion: '<S4>/Data Type Conversion6'\n  for (i = 0; i < 6; i++) {\n    FLIGHT_hexacopter_B.DataTypeConversion6[i] =\n      FLIGHT_hexacopter_B.Output_Limits1[i];\n  }\n\n  // End of DataTypeConversion: '<S4>/Data Type Conversion6'\n\n  // MATLABSystem: '<S4>/Read Parameter13'\n  if (FLIGHT_hexacopter_DW.obj_gv.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_gv.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_gv.MW_PARAMHANDLE,\n    MW_INT32, &i);\n  if (b_varargout_1) {\n    i = 0;\n  }\n\n  // RateTransition: '<Root>/Rate Transition4'\n  if (FLIGHT_hexacopter_M->Timing.RateInteraction.TID0_1) {\n    // RateTransition: '<Root>/Rate Transition4'\n    FLIGHT_hexacopter_B.RateTransition4 =\n      FLIGHT_hexacopter_DW.RateTransition4_Buffer0;\n  }\n\n  // End of RateTransition: '<Root>/Rate Transition4'\n\n  // RelationalOperator: '<S185>/Compare' incorporates:\n  //   Constant: '<S185>/Constant'\n\n  rtb_Compare_a = (FLIGHT_hexacopter_B.RateTransition4 >=\n                   FLIGHT_hexacopter_P.CompareToConstant_const_g);\n\n  // MATLABSystem: '<S4>/Read Parameter1'\n  if (FLIGHT_hexacopter_DW.obj_j5.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_j5.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_j5.MW_PARAMHANDLE,\n    MW_INT32, &FLIGHT_hexacopter_B.ParamStep_c);\n  if (b_varargout_1) {\n    FLIGHT_hexacopter_B.ParamStep_c = 0;\n  }\n\n  // MATLABSystem: '<S4>/Read Parameter2'\n  if (FLIGHT_hexacopter_DW.obj_ao.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_ao.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_ao.MW_PARAMHANDLE,\n    MW_INT32, &FLIGHT_hexacopter_B.ParamStep_b);\n  if (b_varargout_1) {\n    FLIGHT_hexacopter_B.ParamStep_b = 0;\n  }\n\n  // MATLABSystem: '<S4>/Read Parameter3'\n  if (FLIGHT_hexacopter_DW.obj_nt.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_nt.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_nt.MW_PARAMHANDLE,\n    MW_INT32, &FLIGHT_hexacopter_B.ParamStep_p);\n  if (b_varargout_1) {\n    FLIGHT_hexacopter_B.ParamStep_p = 0;\n  }\n\n  // MATLABSystem: '<S4>/Read Parameter4'\n  if (FLIGHT_hexacopter_DW.obj_cx.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_cx.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_cx.MW_PARAMHANDLE,\n    MW_INT32, &FLIGHT_hexacopter_B.ParamStep_cv);\n  if (b_varargout_1) {\n    FLIGHT_hexacopter_B.ParamStep_cv = 0;\n  }\n\n  // MATLABSystem: '<S4>/Read Parameter5'\n  if (FLIGHT_hexacopter_DW.obj_aq.SampleTime !=\n      FLIGHT_hexacopter_P.SampleTime_SAS) {\n    FLIGHT_hexacopter_DW.obj_aq.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n  }\n\n  b_varargout_1 = MW_Param_Step(FLIGHT_hexacopter_DW.obj_aq.MW_PARAMHANDLE,\n    MW_INT32, &FLIGHT_hexacopter_B.ParamStep_f);\n  if (b_varargout_1) {\n    FLIGHT_hexacopter_B.ParamStep_f = 0;\n  }\n\n  // Switch: '<S4>/Switch' incorporates:\n  //   Constant: '<S4>/Constant'\n  //   DataTypeConversion: '<S4>/Data Type Conversion3'\n  //   MATLABSystem: '<S4>/Read Parameter13'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.d = i;\n  } else {\n    FLIGHT_hexacopter_B.d = FLIGHT_hexacopter_P.Constant_Value_mc;\n  }\n\n  // Gain: '<S186>/Gain' incorporates:\n  //   Switch: '<S4>/Switch'\n\n  FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Gain_Gain_j *\n    FLIGHT_hexacopter_B.d;\n\n  // Saturate: '<S186>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S186>/Constant'\n  //   Product: '<S186>/Product'\n  //   Saturate: '<S186>/Saturation'\n  //   Sum: '<S186>/Sum'\n  //   Sum: '<S186>/Sum1'\n\n  FLIGHT_hexacopter_B.d = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[0]) -\n    FLIGHT_hexacopter_P.Constant_Value_k) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_k);\n  if (rtIsNaN(FLIGHT_hexacopter_B.d) || rtIsInf(FLIGHT_hexacopter_B.d)) {\n    FLIGHT_hexacopter_B.d = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.d = fmod(FLIGHT_hexacopter_B.d, 65536.0);\n  }\n\n  // Switch: '<S4>/Switch1' incorporates:\n  //   Constant: '<S4>/Constant1'\n  //   DataTypeConversion: '<S4>/Data Type Conversion2'\n  //   MATLABSystem: '<S4>/Read Parameter1'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.d1 = FLIGHT_hexacopter_B.ParamStep_c;\n  } else {\n    FLIGHT_hexacopter_B.d1 = FLIGHT_hexacopter_P.Constant1_Value;\n  }\n\n  // Gain: '<S187>/Gain' incorporates:\n  //   Switch: '<S4>/Switch1'\n\n  FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Gain_Gain_h *\n    FLIGHT_hexacopter_B.d1;\n\n  // Saturate: '<S187>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat_m) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat_m;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat_o)\n  {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat_o;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S187>/Constant'\n  //   Product: '<S187>/Product'\n  //   Saturate: '<S187>/Saturation'\n  //   Sum: '<S187>/Sum'\n  //   Sum: '<S187>/Sum1'\n\n  FLIGHT_hexacopter_B.d1 = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[1]) -\n    FLIGHT_hexacopter_P.Constant_Value_ms) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_ms);\n  if (rtIsNaN(FLIGHT_hexacopter_B.d1) || rtIsInf(FLIGHT_hexacopter_B.d1)) {\n    FLIGHT_hexacopter_B.d1 = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.d1 = fmod(FLIGHT_hexacopter_B.d1, 65536.0);\n  }\n\n  // Switch: '<S4>/Switch2' incorporates:\n  //   Constant: '<S4>/Constant2'\n  //   DataTypeConversion: '<S4>/Data Type Conversion'\n  //   MATLABSystem: '<S4>/Read Parameter2'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.d2 = FLIGHT_hexacopter_B.ParamStep_b;\n  } else {\n    FLIGHT_hexacopter_B.d2 = FLIGHT_hexacopter_P.Constant2_Value;\n  }\n\n  // Gain: '<S188>/Gain' incorporates:\n  //   Switch: '<S4>/Switch2'\n\n  FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Gain_Gain_c *\n    FLIGHT_hexacopter_B.d2;\n\n  // Saturate: '<S188>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat_b) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat_b;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat_g)\n  {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat_g;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S188>/Constant'\n  //   Product: '<S188>/Product'\n  //   Saturate: '<S188>/Saturation'\n  //   Sum: '<S188>/Sum'\n  //   Sum: '<S188>/Sum1'\n\n  FLIGHT_hexacopter_B.d2 = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[2]) -\n    FLIGHT_hexacopter_P.Constant_Value_i) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_i);\n  if (rtIsNaN(FLIGHT_hexacopter_B.d2) || rtIsInf(FLIGHT_hexacopter_B.d2)) {\n    FLIGHT_hexacopter_B.d2 = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.d2 = fmod(FLIGHT_hexacopter_B.d2, 65536.0);\n  }\n\n  // Switch: '<S4>/Switch3' incorporates:\n  //   Constant: '<S4>/Constant3'\n  //   DataTypeConversion: '<S4>/Data Type Conversion4'\n  //   MATLABSystem: '<S4>/Read Parameter3'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.d3 = FLIGHT_hexacopter_B.ParamStep_p;\n  } else {\n    FLIGHT_hexacopter_B.d3 = FLIGHT_hexacopter_P.Constant3_Value;\n  }\n\n  // Gain: '<S189>/Gain' incorporates:\n  //   Switch: '<S4>/Switch3'\n\n  FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Gain_Gain_n *\n    FLIGHT_hexacopter_B.d3;\n\n  // Saturate: '<S189>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat_be) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat_be;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat_e)\n  {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat_e;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S189>/Constant'\n  //   Product: '<S189>/Product'\n  //   Saturate: '<S189>/Saturation'\n  //   Sum: '<S189>/Sum'\n  //   Sum: '<S189>/Sum1'\n\n  FLIGHT_hexacopter_B.d3 = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[3]) -\n    FLIGHT_hexacopter_P.Constant_Value_j) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_j);\n  if (rtIsNaN(FLIGHT_hexacopter_B.d3) || rtIsInf(FLIGHT_hexacopter_B.d3)) {\n    FLIGHT_hexacopter_B.d3 = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.d3 = fmod(FLIGHT_hexacopter_B.d3, 65536.0);\n  }\n\n  // Switch: '<S4>/Switch4' incorporates:\n  //   Constant: '<S4>/Constant4'\n  //   DataTypeConversion: '<S4>/Data Type Conversion1'\n  //   MATLABSystem: '<S4>/Read Parameter4'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.d4 = FLIGHT_hexacopter_B.ParamStep_cv;\n  } else {\n    FLIGHT_hexacopter_B.d4 = FLIGHT_hexacopter_P.Constant4_Value;\n  }\n\n  // Gain: '<S190>/Gain' incorporates:\n  //   Switch: '<S4>/Switch4'\n\n  FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Gain_Gain_f *\n    FLIGHT_hexacopter_B.d4;\n\n  // Saturate: '<S190>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat_d) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat_d;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat_l)\n  {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat_l;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S190>/Constant'\n  //   Product: '<S190>/Product'\n  //   Saturate: '<S190>/Saturation'\n  //   Sum: '<S190>/Sum'\n  //   Sum: '<S190>/Sum1'\n\n  FLIGHT_hexacopter_B.d4 = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[4]) -\n    FLIGHT_hexacopter_P.Constant_Value_lw) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_lw);\n  if (rtIsNaN(FLIGHT_hexacopter_B.d4) || rtIsInf(FLIGHT_hexacopter_B.d4)) {\n    FLIGHT_hexacopter_B.d4 = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.d4 = fmod(FLIGHT_hexacopter_B.d4, 65536.0);\n  }\n\n  // Switch: '<S4>/Switch5' incorporates:\n  //   Constant: '<S4>/Constant5'\n  //   DataTypeConversion: '<S4>/Data Type Conversion5'\n  //   MATLABSystem: '<S4>/Read Parameter5'\n  //\n  if (rtb_Compare_a) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_B.ParamStep_f;\n  } else {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Constant5_Value;\n  }\n\n  // Gain: '<S191>/Gain' incorporates:\n  //   Switch: '<S4>/Switch5'\n\n  FLIGHT_hexacopter_B.u0 *= FLIGHT_hexacopter_P.Gain_Gain_m;\n\n  // Saturate: '<S191>/Saturation'\n  if (FLIGHT_hexacopter_B.u0 > FLIGHT_hexacopter_P.Saturation_UpperSat_i) {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_UpperSat_i;\n  } else if (FLIGHT_hexacopter_B.u0 < FLIGHT_hexacopter_P.Saturation_LowerSat_n)\n  {\n    FLIGHT_hexacopter_B.u0 = FLIGHT_hexacopter_P.Saturation_LowerSat_n;\n  }\n\n  // DataTypeConversion: '<S4>/Data Type Conversion7' incorporates:\n  //   Constant: '<S191>/Constant'\n  //   Product: '<S191>/Product'\n  //   Saturate: '<S191>/Saturation'\n  //   Sum: '<S191>/Sum'\n  //   Sum: '<S191>/Sum1'\n\n  FLIGHT_hexacopter_B.u0 = floor((static_cast<real_T>\n    (FLIGHT_hexacopter_B.DataTypeConversion6[5]) -\n    FLIGHT_hexacopter_P.Constant_Value_ox) * FLIGHT_hexacopter_B.u0 +\n    FLIGHT_hexacopter_P.Constant_Value_ox);\n  if (rtIsNaN(FLIGHT_hexacopter_B.u0) || rtIsInf(FLIGHT_hexacopter_B.u0)) {\n    FLIGHT_hexacopter_B.u0 = 0.0;\n  } else {\n    FLIGHT_hexacopter_B.u0 = fmod(FLIGHT_hexacopter_B.u0, 65536.0);\n  }\n\n  // RateTransition: '<Root>/Rate Transition7'\n  if (FLIGHT_hexacopter_M->Timing.RateInteraction.TID0_1) {\n    // RateTransition: '<Root>/Rate Transition7'\n    FLIGHT_hexacopter_B.RateTransition7 =\n      FLIGHT_hexacopter_DW.RateTransition7_Buffer0;\n  }\n\n  // End of RateTransition: '<Root>/Rate Transition7'\n\n  // MATLABSystem: '<Root>/PX4 PWM Output' incorporates:\n  //   DataTypeConversion: '<S4>/Data Type Conversion7'\n\n  for (i = 0; i < 8; i++) {\n    FLIGHT_hexacopter_B.pwmValue[i] = 0U;\n  }\n\n  FLIGHT_hexacopter_B.pwmValue[0] = static_cast<uint16_T>(FLIGHT_hexacopter_B.d <\n    0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-static_cast<int16_T>(\n    static_cast<uint16_T>(-FLIGHT_hexacopter_B.d)))) : static_cast<int32_T>(\n    static_cast<uint16_T>(FLIGHT_hexacopter_B.d)));\n  FLIGHT_hexacopter_B.pwmValue[1] = static_cast<uint16_T>(FLIGHT_hexacopter_B.d1\n    < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-static_cast<int16_T>(\n    static_cast<uint16_T>(-FLIGHT_hexacopter_B.d1)))) : static_cast<int32_T>(\n    static_cast<uint16_T>(FLIGHT_hexacopter_B.d1)));\n  FLIGHT_hexacopter_B.pwmValue[2] = static_cast<uint16_T>(FLIGHT_hexacopter_B.d2\n    < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-static_cast<int16_T>(\n    static_cast<uint16_T>(-FLIGHT_hexacopter_B.d2)))) : static_cast<int32_T>(\n    static_cast<uint16_T>(FLIGHT_hexacopter_B.d2)));\n  FLIGHT_hexacopter_B.pwmValue[3] = static_cast<uint16_T>(FLIGHT_hexacopter_B.d3\n    < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-static_cast<int16_T>(\n    static_cast<uint16_T>(-FLIGHT_hexacopter_B.d3)))) : static_cast<int32_T>(\n    static_cast<uint16_T>(FLIGHT_hexacopter_B.d3)));\n  FLIGHT_hexacopter_B.pwmValue[4] = static_cast<uint16_T>(FLIGHT_hexacopter_B.d4\n    < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-static_cast<int16_T>(\n    static_cast<uint16_T>(-FLIGHT_hexacopter_B.d4)))) : static_cast<int32_T>(\n    static_cast<uint16_T>(FLIGHT_hexacopter_B.d4)));\n  FLIGHT_hexacopter_B.pwmValue[5] = static_cast<uint16_T>(FLIGHT_hexacopter_B.u0\n    < 0.0 ? static_cast<int32_T>(static_cast<uint16_T>(-static_cast<int16_T>(\n    static_cast<uint16_T>(-FLIGHT_hexacopter_B.u0)))) : static_cast<int32_T>(\n    static_cast<uint16_T>(FLIGHT_hexacopter_B.u0)));\n  if (FLIGHT_hexacopter_B.rate_transition_arm) {\n    if (!FLIGHT_hexacopter_DW.obj_dl.isArmed) {\n      FLIGHT_hexacopter_DW.obj_dl.isArmed = true;\n      pwm_arm(&FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n    }\n\n    pwm_setServo(FLIGHT_hexacopter_DW.obj_dl.servoCount,\n                 FLIGHT_hexacopter_DW.obj_dl.channelMask,\n                 &FLIGHT_hexacopter_B.pwmValue[0],\n                 FLIGHT_hexacopter_DW.obj_dl.isMain,\n                 &FLIGHT_hexacopter_DW.obj_dl.actuatorAdvertiseObj);\n  } else {\n    pwm_disarm(&FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n    FLIGHT_hexacopter_DW.obj_dl.isArmed = false;\n    pwm_resetServo(FLIGHT_hexacopter_DW.obj_dl.servoCount,\n                   FLIGHT_hexacopter_DW.obj_dl.isMain,\n                   &FLIGHT_hexacopter_DW.obj_dl.actuatorAdvertiseObj);\n  }\n\n  if (FLIGHT_hexacopter_DW.obj_dl.isMain) {\n    if (FLIGHT_hexacopter_B.RateTransition7) {\n      pwm_disarm(&FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n    } else {\n      pwm_arm(&FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n    }\n  }\n\n  // End of MATLABSystem: '<Root>/PX4 PWM Output'\n  FLIGHT_hexac_PX4Timestamp_o(&FLIGHT_hexacopter_B.PX4Timestamp_n);\n  FLIGHT_hexac_PX4Timestamp_o(&FLIGHT_hexacopter_B.PX4Timestamp_p);\n\n  // BusAssignment: '<S494>/Bus Assignment' incorporates:\n  //   Constant: '<S493>/Constant'\n  //   Gain: '<S493>/Gain'\n  //   MATLABSystem: '<S15>/PX4 Timestamp'\n  //   MATLABSystem: '<S494>/PX4 Timestamp'\n  //   Saturate: '<S493>/Saturation'\n  //   Sum: '<S493>/Subtract'\n\n  FLIGHT_hexacopter_B.BusAssignment.timestamp =\n    FLIGHT_hexacopter_B.PX4Timestamp_n.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment.timestamp_sample =\n    FLIGHT_hexacopter_B.PX4Timestamp_p.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment.reversible_flags = 0U;\n  for (i = 0; i < 6; i++) {\n    // DataTypeConversion: '<Root>/Data Type Conversion'\n    FLIGHT_hexacopter_B.ParamStep_c = FLIGHT_hexacopter_B.Output_Limits1[i];\n\n    // Saturate: '<S493>/Saturation'\n    if (FLIGHT_hexacopter_B.ParamStep_c >\n        FLIGHT_hexacopter_P.Saturation_UpperSat_ep) {\n      rtb_d = FLIGHT_hexacopter_P.Saturation_UpperSat_ep;\n    } else if (FLIGHT_hexacopter_B.ParamStep_c <\n               FLIGHT_hexacopter_P.Saturation_LowerSat_p) {\n      rtb_d = FLIGHT_hexacopter_P.Saturation_LowerSat_p;\n    } else {\n      rtb_d = static_cast<real32_T>(FLIGHT_hexacopter_B.ParamStep_c);\n    }\n\n    FLIGHT_hexacopter_B.BusAssignment.control[i] = (rtb_d -\n      FLIGHT_hexacopter_P.Constant_Value_e) * FLIGHT_hexacopter_P.Gain_Gain_mg;\n\n    // Saturate: '<S493>/Saturation' incorporates:\n    //   Constant: '<S15>/Constant1'\n    //   Constant: '<S493>/Constant'\n    //   Gain: '<S493>/Gain'\n    //   Sum: '<S493>/Subtract'\n\n    rtb_Product2_a = FLIGHT_hexacopter_P.Constant1_Value_i[i];\n    if (rtb_Product2_a > FLIGHT_hexacopter_P.Saturation_UpperSat_ep) {\n      rtb_Product2_a = FLIGHT_hexacopter_P.Saturation_UpperSat_ep;\n    } else if (rtb_Product2_a < FLIGHT_hexacopter_P.Saturation_LowerSat_p) {\n      rtb_Product2_a = FLIGHT_hexacopter_P.Saturation_LowerSat_p;\n    }\n\n    FLIGHT_hexacopter_B.BusAssignment.control[i + 6] = (rtb_Product2_a -\n      FLIGHT_hexacopter_P.Constant_Value_e) * FLIGHT_hexacopter_P.Gain_Gain_mg;\n    FLIGHT_hexacopter_B.BusAssignment._padding0[i] = 0U;\n  }\n\n  // End of BusAssignment: '<S494>/Bus Assignment'\n\n  // MATLABSystem: '<S496>/SinkBlock' incorporates:\n  //   BusAssignment: '<S494>/Bus Assignment'\n\n  uORB_write_step(FLIGHT_hexacopter_DW.obj_hf.orbMetadataObj,\n                  &FLIGHT_hexacopter_DW.obj_hf.orbAdvertiseObj,\n                  &FLIGHT_hexacopter_B.BusAssignment);\n  FLIGHT_hexac_PX4Timestamp_o(&FLIGHT_hexacopter_B.PX4Timestamp_o);\n\n  // BusAssignment: '<S490>/Bus Assignment' incorporates:\n  //   MATLABSystem: '<S490>/PX4 Timestamp'\n\n  FLIGHT_hexacopter_B.BusAssignment_gi.timestamp =\n    FLIGHT_hexacopter_B.PX4Timestamp_o.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment_gi.control_power[0] = 0.0F;\n  FLIGHT_hexacopter_B.BusAssignment_gi.control_power[1] =\n    FLIGHT_hexacopter_B.Sum5;\n  FLIGHT_hexacopter_B.BusAssignment_gi.control_power[2] =\n    FLIGHT_hexacopter_B.Sum;\n  FLIGHT_hexacopter_B.BusAssignment_gi._padding0[0] = 0U;\n  FLIGHT_hexacopter_B.BusAssignment_gi._padding0[1] = 0U;\n  FLIGHT_hexacopter_B.BusAssignment_gi._padding0[2] = 0U;\n  FLIGHT_hexacopter_B.BusAssignment_gi._padding0[3] = 0U;\n\n  // MATLABSystem: '<S492>/SinkBlock' incorporates:\n  //   BusAssignment: '<S490>/Bus Assignment'\n\n  uORB_write_step(FLIGHT_hexacopter_DW.obj_jk.orbMetadataObj,\n                  &FLIGHT_hexacopter_DW.obj_jk.orbAdvertiseObj,\n                  &FLIGHT_hexacopter_B.BusAssignment_gi);\n\n  // RateTransition: '<Root>/Rate Transition'\n  if (FLIGHT_hexacopter_M->Timing.RateInteraction.TID0_1) {\n    FLIGHT_hexacopter_DW.RateTransition_Buffer[0] =\n      FLIGHT_hexacopter_B.In1_h.xyz[0];\n    FLIGHT_hexacopter_DW.RateTransition_Buffer[1] =\n      FLIGHT_hexacopter_B.In1_h.xyz[1];\n    FLIGHT_hexacopter_DW.RateTransition_Buffer[2] =\n      FLIGHT_hexacopter_B.In1_h.xyz[2];\n  }\n\n  // End of RateTransition: '<Root>/Rate Transition'\n}\n\n// Model step function for TID1\nvoid FLIGHT_hexacopter_step1(void)     // Sample time: [0.004s, 0.0s]\n{\n  real32_T rtb_Gain_f;\n  real32_T rtb_Gain_p;\n  real32_T rtb_PProdOut_ev_idx_0;\n  real32_T rtb_PProdOut_ev_idx_1;\n  real32_T rtb_Product5_dr;\n  real32_T rtb_Product5_e;\n  real32_T rtb_Product5_k;\n  real32_T rtb_Product5_m;\n  real32_T rtb_Saturation1;\n  real32_T rtb_SinCos_o2;\n  real32_T rtb_des_x;\n  real32_T rtb_des_z;\n  int8_T tmp;\n  int8_T tmp_0;\n  boolean_T exitg1;\n  boolean_T guard1;\n  boolean_T rtb_NOT;\n  boolean_T rtb_NOT_h;\n  boolean_T rtb_flag_pos;\n\n  // MATLABSystem: '<S306>/SourceBlock'\n  rtb_flag_pos = uORB_read_step(FLIGHT_hexacopter_DW.obj_n2.orbMetadataObj,\n    &FLIGHT_hexacopter_DW.obj_n2.eventStructObj, &FLIGHT_hexacopter_B.r2, false,\n    1.0);\n\n  // Outputs for Enabled SubSystem: '<S306>/Enabled Subsystem' incorporates:\n  //   EnablePort: '<S307>/Enable'\n\n  // Start for MATLABSystem: '<S306>/SourceBlock'\n  if (rtb_flag_pos) {\n    // SignalConversion generated from: '<S307>/In1'\n    FLIGHT_hexacopter_B.In1_i = FLIGHT_hexacopter_B.r2;\n  }\n\n  // End of Outputs for SubSystem: '<S306>/Enabled Subsystem'\n\n  // RateTransition: '<Root>/Rate Transition4'\n  FLIGHT_hexacopter_DW.RateTransition4_Buffer0 =\n    FLIGHT_hexacopter_B.In1_i.values[7];\n\n  // RateTransition: '<Root>/rate_transition_ctrl_sw'\n  FLIGHT_hexacopter_DW.rate_transition_ctrl_sw_Buffer0 =\n    FLIGHT_hexacopter_B.In1_i.values[9];\n\n  // MATLABSystem: '<S304>/SourceBlock'\n  rtb_flag_pos = uORB_read_step(FLIGHT_hexacopter_DW.obj_ab.orbMetadataObj,\n    &FLIGHT_hexacopter_DW.obj_ab.eventStructObj, &FLIGHT_hexacopter_B.r1, false,\n    1.0);\n\n  // Outputs for Enabled SubSystem: '<S304>/Enabled Subsystem' incorporates:\n  //   EnablePort: '<S305>/Enable'\n\n  // Start for MATLABSystem: '<S304>/SourceBlock'\n  if (rtb_flag_pos) {\n    // SignalConversion generated from: '<S305>/In1'\n    FLIGHT_hexacopter_B.In1_k = FLIGHT_hexacopter_B.r1;\n  }\n\n  // End of Outputs for SubSystem: '<S304>/Enabled Subsystem'\n\n  // MATLAB Function: '<Root>/quat2eul'\n  //  Quaternion conversion to Euler angles based on the PX4 Firmware v1.10.2\n  //  release.\n  FLIGHT_hexacopter_B.ypr[1] = static_cast<real32_T>(asin(static_cast<real_T>\n    ((FLIGHT_hexacopter_B.In1_k.q[1] * FLIGHT_hexacopter_B.In1_k.q[3] -\n      FLIGHT_hexacopter_B.In1_k.q[0] * FLIGHT_hexacopter_B.In1_k.q[2]) * -2.0F)));\n  FLIGHT_hexacopter_B.ypr[2] = rt_atan2f_snf((FLIGHT_hexacopter_B.In1_k.q[0] *\n    FLIGHT_hexacopter_B.In1_k.q[1] + FLIGHT_hexacopter_B.In1_k.q[2] *\n    FLIGHT_hexacopter_B.In1_k.q[3]) * 2.0F, ((FLIGHT_hexacopter_B.In1_k.q[0] *\n    FLIGHT_hexacopter_B.In1_k.q[0] - FLIGHT_hexacopter_B.In1_k.q[1] *\n    FLIGHT_hexacopter_B.In1_k.q[1]) - FLIGHT_hexacopter_B.In1_k.q[2] *\n    FLIGHT_hexacopter_B.In1_k.q[2]) + FLIGHT_hexacopter_B.In1_k.q[3] *\n    FLIGHT_hexacopter_B.In1_k.q[3]);\n\n  // MATLABSystem: '<S500>/SourceBlock'\n  rtb_flag_pos = uORB_read_step(FLIGHT_hexacopter_DW.obj_hm.orbMetadataObj,\n    &FLIGHT_hexacopter_DW.obj_hm.eventStructObj, &FLIGHT_hexacopter_B.r5, false,\n    1.0);\n\n  // Outputs for Enabled SubSystem: '<S500>/Enabled Subsystem' incorporates:\n  //   EnablePort: '<S502>/Enable'\n\n  // Start for MATLABSystem: '<S500>/SourceBlock'\n  if (rtb_flag_pos) {\n    // SignalConversion generated from: '<S502>/In1'\n    FLIGHT_hexacopter_B.In1_n = FLIGHT_hexacopter_B.r5;\n  }\n\n  // End of Outputs for SubSystem: '<S500>/Enabled Subsystem'\n\n  // Outputs for Atomic SubSystem: '<Root>/Stabilized_Mode'\n  // Gain: '<S12>/Gain' incorporates:\n  //   Constant: '<S12>/Constant'\n  //   Sum: '<S12>/Sum'\n\n  FLIGHT_hexacopter_B.Product5_l = static_cast<real32_T>((static_cast<real_T>\n    (FLIGHT_hexacopter_B.In1_i.values[2]) - FLIGHT_hexacopter_P.Constant_Value_c)\n    * FLIGHT_hexacopter_P.Gain_Gain);\n\n  // DeadZone: '<S12>/Dead Zone3'\n  if (FLIGHT_hexacopter_B.Product5_l > FLIGHT_hexacopter_P.DeadZone3_End_l) {\n    rtb_Product5_m = FLIGHT_hexacopter_B.Product5_l -\n      FLIGHT_hexacopter_P.DeadZone3_End_l;\n  } else if (FLIGHT_hexacopter_B.Product5_l >=\n             FLIGHT_hexacopter_P.DeadZone3_Start_p) {\n    rtb_Product5_m = 0.0F;\n  } else {\n    rtb_Product5_m = FLIGHT_hexacopter_B.Product5_l -\n      FLIGHT_hexacopter_P.DeadZone3_Start_p;\n  }\n\n  // End of DeadZone: '<S12>/Dead Zone3'\n\n  // Gain: '<S12>/Gain2' incorporates:\n  //   Constant: '<S12>/Constant1'\n  //   Sum: '<S12>/Sum1'\n\n  FLIGHT_hexacopter_B.Product5_l = (static_cast<real32_T>\n    (FLIGHT_hexacopter_B.In1_i.values[3]) -\n    FLIGHT_hexacopter_P.Constant1_Value_l) * FLIGHT_hexacopter_P.Gain2_Gain_a;\n\n  // DeadZone: '<S12>/Dead Zone2'\n  if (FLIGHT_hexacopter_B.Product5_l > FLIGHT_hexacopter_P.DeadZone2_End) {\n    rtb_Product5_e = FLIGHT_hexacopter_B.Product5_l -\n      FLIGHT_hexacopter_P.DeadZone2_End;\n  } else if (FLIGHT_hexacopter_B.Product5_l >=\n             FLIGHT_hexacopter_P.DeadZone2_Start) {\n    rtb_Product5_e = 0.0F;\n  } else {\n    rtb_Product5_e = FLIGHT_hexacopter_B.Product5_l -\n      FLIGHT_hexacopter_P.DeadZone2_Start;\n  }\n\n  // End of DeadZone: '<S12>/Dead Zone2'\n\n  // Gain: '<S12>/Gain1' incorporates:\n  //   Constant: '<S12>/Constant2'\n  //   Sum: '<S12>/Sum2'\n\n  FLIGHT_hexacopter_B.Product5_l = (static_cast<real32_T>\n    (FLIGHT_hexacopter_B.In1_i.values[1]) -\n    FLIGHT_hexacopter_P.Constant2_Value_i) * FLIGHT_hexacopter_P.Gain1_Gain_m;\n\n  // DeadZone: '<S12>/Dead Zone1'\n  if (FLIGHT_hexacopter_B.Product5_l > FLIGHT_hexacopter_P.DeadZone1_End_m) {\n    rtb_Product5_dr = FLIGHT_hexacopter_B.Product5_l -\n      FLIGHT_hexacopter_P.DeadZone1_End_m;\n  } else if (FLIGHT_hexacopter_B.Product5_l >=\n             FLIGHT_hexacopter_P.DeadZone1_Start_c) {\n    rtb_Product5_dr = 0.0F;\n  } else {\n    rtb_Product5_dr = FLIGHT_hexacopter_B.Product5_l -\n      FLIGHT_hexacopter_P.DeadZone1_Start_c;\n  }\n\n  // End of DeadZone: '<S12>/Dead Zone1'\n\n  // Gain: '<S12>/Gain3' incorporates:\n  //   Constant: '<S12>/Constant3'\n  //   Sum: '<S12>/Sum3'\n\n  FLIGHT_hexacopter_B.Product5_l = (static_cast<real32_T>\n    (FLIGHT_hexacopter_B.In1_i.values[0]) -\n    FLIGHT_hexacopter_P.Constant3_Value_e) * FLIGHT_hexacopter_P.Gain3_Gain;\n\n  // DeadZone: '<S12>/Dead Zone'\n  if (FLIGHT_hexacopter_B.Product5_l > FLIGHT_hexacopter_P.DeadZone_End) {\n    rtb_Product5_k = FLIGHT_hexacopter_B.Product5_l -\n      FLIGHT_hexacopter_P.DeadZone_End;\n  } else if (FLIGHT_hexacopter_B.Product5_l >=\n             FLIGHT_hexacopter_P.DeadZone_Start) {\n    rtb_Product5_k = 0.0F;\n  } else {\n    rtb_Product5_k = FLIGHT_hexacopter_B.Product5_l -\n      FLIGHT_hexacopter_P.DeadZone_Start;\n  }\n\n  // End of DeadZone: '<S12>/Dead Zone'\n  // End of Outputs for SubSystem: '<Root>/Stabilized_Mode'\n\n  // Outputs for Atomic SubSystem: '<Root>/If Action Subsystem'\n  // Fcn: '<S22>/Fcn2' incorporates:\n  //   DataTypeConversion: '<S22>/Data Type Conversion1'\n  //   Fcn: '<S192>/Fcn2'\n\n  FLIGHT_hexacopter_B.ctoc = (static_cast<real32_T>\n    (FLIGHT_hexacopter_B.In1_i.values[0]) - 1514.0F) / 500.0F;\n\n  // End of Outputs for SubSystem: '<Root>/If Action Subsystem'\n\n  // DeadZone: '<S22>/Dead Zone3' incorporates:\n  //   Fcn: '<S22>/Fcn2'\n\n  if (FLIGHT_hexacopter_B.ctoc > FLIGHT_hexacopter_P.DeadZone3_End_n) {\n    rtb_Gain_p = FLIGHT_hexacopter_B.ctoc - FLIGHT_hexacopter_P.DeadZone3_End_n;\n  } else if (FLIGHT_hexacopter_B.ctoc >= FLIGHT_hexacopter_P.DeadZone3_Start_l)\n  {\n    rtb_Gain_p = 0.0F;\n  } else {\n    rtb_Gain_p = FLIGHT_hexacopter_B.ctoc -\n      FLIGHT_hexacopter_P.DeadZone3_Start_l;\n  }\n\n  // End of DeadZone: '<S22>/Dead Zone3'\n\n  // Outputs for Atomic SubSystem: '<Root>/If Action Subsystem'\n  // Fcn: '<S22>/Fcn1' incorporates:\n  //   DataTypeConversion: '<S22>/Data Type Conversion2'\n  //   Fcn: '<S192>/Fcn1'\n\n  FLIGHT_hexacopter_B.cfromc = (static_cast<real32_T>\n    (FLIGHT_hexacopter_B.In1_i.values[1]) - 1514.0F) / 500.0F;\n\n  // End of Outputs for SubSystem: '<Root>/If Action Subsystem'\n\n  // DeadZone: '<S22>/Dead Zone1' incorporates:\n  //   Fcn: '<S22>/Fcn1'\n\n  if (FLIGHT_hexacopter_B.cfromc > FLIGHT_hexacopter_P.DeadZone1_End_mj) {\n    rtb_Gain_f = FLIGHT_hexacopter_B.cfromc -\n      FLIGHT_hexacopter_P.DeadZone1_End_mj;\n  } else if (FLIGHT_hexacopter_B.cfromc >= FLIGHT_hexacopter_P.DeadZone1_Start_n)\n  {\n    rtb_Gain_f = 0.0F;\n  } else {\n    rtb_Gain_f = FLIGHT_hexacopter_B.cfromc -\n      FLIGHT_hexacopter_P.DeadZone1_Start_n;\n  }\n\n  // End of DeadZone: '<S22>/Dead Zone1'\n\n  // Fcn: '<S22>/Fcn7' incorporates:\n  //   DataTypeConversion: '<S22>/Data Type Conversion10'\n\n  FLIGHT_hexacopter_B.Gain_i = (static_cast<real32_T>\n    (FLIGHT_hexacopter_B.In1_i.values[3]) - 1514.0F) / 500.0F;\n\n  // DeadZone: '<S22>/Dead Zone2'\n  if (FLIGHT_hexacopter_B.Gain_i > FLIGHT_hexacopter_P.DeadZone2_End_b) {\n    FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_B.Gain_i -\n      FLIGHT_hexacopter_P.DeadZone2_End_b;\n  } else if (FLIGHT_hexacopter_B.Gain_i >= FLIGHT_hexacopter_P.DeadZone2_Start_m)\n  {\n    FLIGHT_hexacopter_B.Product5_l = 0.0F;\n  } else {\n    FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_B.Gain_i -\n      FLIGHT_hexacopter_P.DeadZone2_Start_m;\n  }\n\n  // End of DeadZone: '<S22>/Dead Zone2'\n\n  // Saturate: '<S22>/Saturation3'\n  if (FLIGHT_hexacopter_B.Product5_l >\n      FLIGHT_hexacopter_P.Saturation3_UpperSat_d) {\n    FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_P.Saturation3_UpperSat_d;\n  } else if (FLIGHT_hexacopter_B.Product5_l <\n             FLIGHT_hexacopter_P.Saturation3_LowerSat_n) {\n    FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_P.Saturation3_LowerSat_n;\n  }\n\n  // Gain: '<S22>/Gain3' incorporates:\n  //   Saturate: '<S22>/Saturation3'\n\n  FLIGHT_hexacopter_B.Gain3 = FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_RATE_Y *\n    FLIGHT_hexacopter_B.Product5_l;\n\n  // Fcn: '<S22>/Fcn3' incorporates:\n  //   DataTypeConversion: '<S22>/Data Type Conversion11'\n\n  FLIGHT_hexacopter_B.Gain_i = (static_cast<real32_T>\n    (FLIGHT_hexacopter_B.In1_i.values[2]) - 1514.0F) / 500.0F;\n\n  // DeadZone: '<S22>/Dead Zone4'\n  if (FLIGHT_hexacopter_B.Gain_i > FLIGHT_hexacopter_P.DeadZone4_End) {\n    FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_B.Gain_i -\n      FLIGHT_hexacopter_P.DeadZone4_End;\n  } else if (FLIGHT_hexacopter_B.Gain_i >= FLIGHT_hexacopter_P.DeadZone4_Start)\n  {\n    FLIGHT_hexacopter_B.Product5_l = 0.0F;\n  } else {\n    FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_B.Gain_i -\n      FLIGHT_hexacopter_P.DeadZone4_Start;\n  }\n\n  // End of DeadZone: '<S22>/Dead Zone4'\n\n  // Saturate: '<S22>/Saturation10'\n  if (FLIGHT_hexacopter_B.Product5_l > FLIGHT_hexacopter_P.Saturation10_UpperSat)\n  {\n    FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_P.Saturation10_UpperSat;\n  } else if (FLIGHT_hexacopter_B.Product5_l <\n             FLIGHT_hexacopter_P.Saturation10_LowerSat) {\n    FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_P.Saturation10_LowerSat;\n  }\n\n  // Gain: '<S22>/Gain' incorporates:\n  //   Saturate: '<S22>/Saturation10'\n\n  FLIGHT_hexacopter_B.Gain_i = FLIGHT_hexacopter_P.Gain_Gain_er *\n    FLIGHT_hexacopter_B.Product5_l;\n\n  // MATLABSystem: '<S301>/SourceBlock'\n  rtb_flag_pos = uORB_read_step(FLIGHT_hexacopter_DW.obj_kk.orbMetadataObj,\n    &FLIGHT_hexacopter_DW.obj_kk.eventStructObj, &FLIGHT_hexacopter_B.r, false,\n    1.0);\n\n  // Outputs for Enabled SubSystem: '<S301>/Enabled Subsystem' incorporates:\n  //   EnablePort: '<S303>/Enable'\n\n  // Start for MATLABSystem: '<S301>/SourceBlock'\n  if (rtb_flag_pos) {\n    // SignalConversion generated from: '<S303>/In1'\n    FLIGHT_hexacopter_B.In1 = FLIGHT_hexacopter_B.r;\n  }\n\n  // End of Outputs for SubSystem: '<S301>/Enabled Subsystem'\n\n  // Gain: '<S1>/Gain' incorporates:\n  //   Sum: '<S1>/Sum3'\n\n  FLIGHT_hexacopter_B.IProdOut_d = (FLIGHT_hexacopter_B.Gain_i -\n    FLIGHT_hexacopter_B.In1.vz) * FLIGHT_hexacopter_P.Gain_Gain_o;\n\n  // MATLABSystem: '<S1>/Read Parameter2'\n  if (FLIGHT_hexacopter_DW.obj_in.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n  {\n    FLIGHT_hexacopter_DW.obj_in.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_in.MW_PARAMHANDLE,\n    MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep);\n  if (rtb_flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep = 0.0F;\n  }\n\n  // Outputs for Atomic SubSystem: '<Root>/If Action Subsystem'\n  // Logic: '<S1>/AND' incorporates:\n  //   Logic: '<S5>/AND'\n\n  rtb_NOT_h = !FLIGHT_hexacopter_B.In1_n.armed;\n\n  // End of Outputs for SubSystem: '<Root>/If Action Subsystem'\n\n  // Logic: '<S1>/NOT' incorporates:\n  //   Constant: '<S23>/Constant'\n  //   Logic: '<S1>/AND'\n  //   RelationalOperator: '<S23>/Compare'\n\n  rtb_NOT = (rtb_NOT_h || (FLIGHT_hexacopter_B.In1_i.values[5] <=\n              FLIGHT_hexacopter_P.CompareToConstant1_const));\n\n  // DiscreteIntegrator: '<S60>/Integrator'\n  if (rtb_NOT || (FLIGHT_hexacopter_DW.Integrator_PrevResetState != 0)) {\n    FLIGHT_hexacopter_DW.Integrator_DSTATE =\n      FLIGHT_hexacopter_P.PIDController_InitialConditio_a;\n  }\n\n  // MATLABSystem: '<S1>/Read Parameter4'\n  if (FLIGHT_hexacopter_DW.obj_lx.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n  {\n    FLIGHT_hexacopter_DW.obj_lx.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_lx.MW_PARAMHANDLE,\n    MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep_m);\n  if (rtb_flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep_m = 0.0F;\n  }\n\n  // DiscreteIntegrator: '<S55>/Filter'\n  if (rtb_NOT || (FLIGHT_hexacopter_DW.Filter_PrevResetState != 0)) {\n    FLIGHT_hexacopter_DW.Filter_DSTATE =\n      FLIGHT_hexacopter_P.PIDController_InitialConditionF;\n  }\n\n  // Product: '<S63>/NProd Out' incorporates:\n  //   Constant: '<S1>/Constant'\n  //   DiscreteIntegrator: '<S55>/Filter'\n  //   MATLABSystem: '<S1>/Read Parameter4'\n  //   Product: '<S53>/DProd Out'\n  //   Sum: '<S55>/SumD'\n  //\n  FLIGHT_hexacopter_B.NProdOut = (FLIGHT_hexacopter_B.IProdOut_d *\n    FLIGHT_hexacopter_B.ParamStep_m - FLIGHT_hexacopter_DW.Filter_DSTATE) *\n    FLIGHT_hexacopter_P.Constant_Value_gx;\n\n  // Sum: '<S69>/Sum' incorporates:\n  //   DiscreteIntegrator: '<S60>/Integrator'\n  //   MATLABSystem: '<S1>/Read Parameter2'\n  //   Product: '<S65>/PProd Out'\n  //\n  FLIGHT_hexacopter_B.DeadZone = (FLIGHT_hexacopter_B.IProdOut_d *\n    FLIGHT_hexacopter_B.ParamStep + FLIGHT_hexacopter_DW.Integrator_DSTATE) +\n    FLIGHT_hexacopter_B.NProdOut;\n\n  // MATLABSystem: '<S1>/Read Parameter1'\n  if (FLIGHT_hexacopter_DW.obj_m.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    FLIGHT_hexacopter_DW.obj_m.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_m.MW_PARAMHANDLE,\n    MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep);\n  if (rtb_flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep = 0.0F;\n  }\n\n  // Saturate: '<S67>/Saturation'\n  if (FLIGHT_hexacopter_B.DeadZone >\n      FLIGHT_hexacopter_P.PIDController_UpperSaturationLi) {\n    FLIGHT_hexacopter_B.Product5_l =\n      FLIGHT_hexacopter_P.PIDController_UpperSaturationLi;\n  } else if (FLIGHT_hexacopter_B.DeadZone <\n             FLIGHT_hexacopter_P.PIDController_LowerSaturationLi) {\n    FLIGHT_hexacopter_B.Product5_l =\n      FLIGHT_hexacopter_P.PIDController_LowerSaturationLi;\n  } else {\n    FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_B.DeadZone;\n  }\n\n  // Sum: '<S1>/Sum6' incorporates:\n  //   MATLABSystem: '<S1>/Read Parameter1'\n  //   Saturate: '<S67>/Saturation'\n  //\n  rtb_Saturation1 = FLIGHT_hexacopter_B.Product5_l +\n    FLIGHT_hexacopter_B.ParamStep;\n\n  // Saturate: '<S1>/Saturation1'\n  if (rtb_Saturation1 > FLIGHT_hexacopter_P.Saturation1_UpperSat_lr) {\n    rtb_Saturation1 = FLIGHT_hexacopter_P.Saturation1_UpperSat_lr;\n  } else if (rtb_Saturation1 < FLIGHT_hexacopter_P.Saturation1_LowerSat_e) {\n    rtb_Saturation1 = FLIGHT_hexacopter_P.Saturation1_LowerSat_e;\n  }\n\n  // End of Saturate: '<S1>/Saturation1'\n\n  // Outputs for Atomic SubSystem: '<Root>/If Action Subsystem'\n  // Trigonometry: '<S249>/SinCos'\n  FLIGHT_hexacopter_B.Product5_l = static_cast<real32_T>(sin(static_cast<real_T>\n    (FLIGHT_hexacopter_B.In1.heading)));\n  rtb_SinCos_o2 = static_cast<real32_T>(cos(static_cast<real_T>\n    (FLIGHT_hexacopter_B.In1.heading)));\n\n  // MATLABSystem: '<S194>/Read Parameter'\n  if (FLIGHT_hexacopter_DW.obj_eq.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n  {\n    FLIGHT_hexacopter_DW.obj_eq.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_eq.MW_PARAMHANDLE,\n    MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep);\n  if (rtb_flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep = 0.0F;\n  }\n\n  // Logic: '<S5>/NOT' incorporates:\n  //   Constant: '<S193>/Constant'\n  //   Logic: '<S5>/AND'\n  //   RelationalOperator: '<S193>/Compare'\n\n  rtb_NOT_h = (rtb_NOT_h || (FLIGHT_hexacopter_B.In1_i.values[5] <=\n    FLIGHT_hexacopter_P.CompareToConstant2_const));\n\n  // DiscreteIntegrator: '<S5>/Discrete-Time Integrator'\n  if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_IC_LOADI != 0) {\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l =\n      FLIGHT_hexacopter_B.In1.x;\n    if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l >\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator_UpperSat) {\n      FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l =\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator_UpperSat;\n    } else if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l <\n               FLIGHT_hexacopter_P.DiscreteTimeIntegrator_LowerSat) {\n      FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l =\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator_LowerSat;\n    }\n  }\n\n  if (rtb_NOT_h || (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_PrevRese != 0))\n  {\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l =\n      FLIGHT_hexacopter_B.In1.x;\n    if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l >\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator_UpperSat) {\n      FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l =\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator_UpperSat;\n    } else if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l <\n               FLIGHT_hexacopter_P.DiscreteTimeIntegrator_LowerSat) {\n      FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l =\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator_LowerSat;\n    }\n  }\n\n  rtb_des_x = FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l;\n\n  // DiscreteIntegrator: '<S5>/Discrete-Time Integrator1'\n  if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_IC_LOAD != 0) {\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE =\n      FLIGHT_hexacopter_B.In1.y;\n    if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE >\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_UpperSa) {\n      FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE =\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_UpperSa;\n    } else if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE <\n               FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_LowerSa) {\n      FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE =\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_LowerSa;\n    }\n  }\n\n  if (rtb_NOT_h || (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_PrevRes != 0))\n  {\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE =\n      FLIGHT_hexacopter_B.In1.y;\n    if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE >\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_UpperSa) {\n      FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE =\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_UpperSa;\n    } else if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE <\n               FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_LowerSa) {\n      FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE =\n        FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_LowerSa;\n    }\n  }\n\n  rtb_des_z = FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE;\n\n  // Product: '<S235>/PProd Out' incorporates:\n  //   DiscreteIntegrator: '<S5>/Discrete-Time Integrator'\n  //   DiscreteIntegrator: '<S5>/Discrete-Time Integrator1'\n  //   MATLABSystem: '<S194>/Read Parameter'\n  //   Sum: '<S194>/Sum'\n  //\n  rtb_PProdOut_ev_idx_0 = (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l\n    - FLIGHT_hexacopter_B.In1.x) * FLIGHT_hexacopter_B.ParamStep;\n  rtb_PProdOut_ev_idx_1 = (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE -\n    FLIGHT_hexacopter_B.In1.y) * FLIGHT_hexacopter_B.ParamStep;\n\n  // MATLABSystem: '<S195>/Read Parameter'\n  if (FLIGHT_hexacopter_DW.obj_pi.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n  {\n    FLIGHT_hexacopter_DW.obj_pi.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_pi.MW_PARAMHANDLE,\n    MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep);\n  if (rtb_flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep = 0.0F;\n  }\n\n  // Sum: '<S195>/Sum'\n  FLIGHT_hexacopter_B.t = rtb_PProdOut_ev_idx_0 - FLIGHT_hexacopter_B.In1.vx;\n  FLIGHT_hexacopter_B.mul = rtb_PProdOut_ev_idx_1 - FLIGHT_hexacopter_B.In1.vy;\n\n  // Saturate: '<S195>/Saturation' incorporates:\n  //   Gain: '<S249>/Gain'\n  //   MATLABSystem: '<S195>/Read Parameter'\n  //   Product: '<S247>/MatrixMultiply'\n  //   Product: '<S288>/PProd Out'\n  //   Reshape: '<S249>/Reshape'\n  //   Reshape: '<S249>/Reshape1'\n  //\n  FLIGHT_hexacopter_B.ParamStep_m = (rtb_SinCos_o2 * FLIGHT_hexacopter_B.t +\n    FLIGHT_hexacopter_B.Product5_l * FLIGHT_hexacopter_B.mul) *\n    FLIGHT_hexacopter_B.ParamStep;\n  rtb_SinCos_o2 = (FLIGHT_hexacopter_P.Gain_Gain_a *\n                   FLIGHT_hexacopter_B.Product5_l * FLIGHT_hexacopter_B.t +\n                   rtb_SinCos_o2 * FLIGHT_hexacopter_B.mul) *\n    FLIGHT_hexacopter_B.ParamStep;\n\n  // DeadZone: '<S192>/Dead Zone3'\n  if (FLIGHT_hexacopter_B.ctoc > FLIGHT_hexacopter_P.DeadZone3_End) {\n    FLIGHT_hexacopter_B.ParamStep = FLIGHT_hexacopter_B.ctoc -\n      FLIGHT_hexacopter_P.DeadZone3_End;\n  } else if (FLIGHT_hexacopter_B.ctoc >= FLIGHT_hexacopter_P.DeadZone3_Start) {\n    FLIGHT_hexacopter_B.ParamStep = 0.0F;\n  } else {\n    FLIGHT_hexacopter_B.ParamStep = FLIGHT_hexacopter_B.ctoc -\n      FLIGHT_hexacopter_P.DeadZone3_Start;\n  }\n\n  // End of DeadZone: '<S192>/Dead Zone3'\n\n  // Update for DiscreteIntegrator: '<S5>/Discrete-Time Integrator'\n  FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_IC_LOADI = 0U;\n\n  // DeadZone: '<S192>/Dead Zone1'\n  if (FLIGHT_hexacopter_B.cfromc > FLIGHT_hexacopter_P.DeadZone1_End) {\n    FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_B.cfromc -\n      FLIGHT_hexacopter_P.DeadZone1_End;\n  } else if (FLIGHT_hexacopter_B.cfromc >= FLIGHT_hexacopter_P.DeadZone1_Start)\n  {\n    FLIGHT_hexacopter_B.Product5_l = 0.0F;\n  } else {\n    FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_B.cfromc -\n      FLIGHT_hexacopter_P.DeadZone1_Start;\n  }\n\n  // End of DeadZone: '<S192>/Dead Zone1'\n\n  // Saturate: '<S192>/Saturation1'\n  if (FLIGHT_hexacopter_B.Product5_l > FLIGHT_hexacopter_P.Saturation1_UpperSat)\n  {\n    FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_P.Saturation1_UpperSat;\n  } else if (FLIGHT_hexacopter_B.Product5_l <\n             FLIGHT_hexacopter_P.Saturation1_LowerSat) {\n    FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_P.Saturation1_LowerSat;\n  }\n\n  // Update for DiscreteIntegrator: '<S5>/Discrete-Time Integrator' incorporates:\n  //   Gain: '<S192>/Gain2'\n  //   Saturate: '<S192>/Saturation1'\n\n  FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l +=\n    FLIGHT_hexacopter_P.Gain2_Gain * FLIGHT_hexacopter_B.Product5_l *\n    FLIGHT_hexacopter_P.DiscreteTimeIntegrator_gainval;\n  if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l >\n      FLIGHT_hexacopter_P.DiscreteTimeIntegrator_UpperSat) {\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l =\n      FLIGHT_hexacopter_P.DiscreteTimeIntegrator_UpperSat;\n  } else if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l <\n             FLIGHT_hexacopter_P.DiscreteTimeIntegrator_LowerSat) {\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE_l =\n      FLIGHT_hexacopter_P.DiscreteTimeIntegrator_LowerSat;\n  }\n\n  FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_PrevRese = static_cast<int8_T>\n    (rtb_NOT_h);\n\n  // Update for DiscreteIntegrator: '<S5>/Discrete-Time Integrator1'\n  FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_IC_LOAD = 0U;\n\n  // Saturate: '<S192>/Saturation9'\n  if (FLIGHT_hexacopter_B.ParamStep > FLIGHT_hexacopter_P.Saturation9_UpperSat)\n  {\n    FLIGHT_hexacopter_B.ParamStep = FLIGHT_hexacopter_P.Saturation9_UpperSat;\n  } else if (FLIGHT_hexacopter_B.ParamStep <\n             FLIGHT_hexacopter_P.Saturation9_LowerSat) {\n    FLIGHT_hexacopter_B.ParamStep = FLIGHT_hexacopter_P.Saturation9_LowerSat;\n  }\n\n  // Update for DiscreteIntegrator: '<S5>/Discrete-Time Integrator1' incorporates:\n  //   DiscreteIntegrator: '<S5>/Discrete-Time Integrator'\n  //   Gain: '<S192>/Gain1'\n  //   Saturate: '<S192>/Saturation9'\n\n  FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE +=\n    FLIGHT_hexacopter_P.MAX_CONTROL_VELOCITY_XY * FLIGHT_hexacopter_B.ParamStep *\n    FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_gainval;\n  if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE >\n      FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_UpperSa) {\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE =\n      FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_UpperSa;\n  } else if (FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE <\n             FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_LowerSa) {\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_DSTATE =\n      FLIGHT_hexacopter_P.DiscreteTimeIntegrator1_LowerSa;\n  }\n\n  FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_PrevRes = static_cast<int8_T>\n    (rtb_NOT_h);\n\n  // End of Outputs for SubSystem: '<Root>/If Action Subsystem'\n\n  // MATLABSystem: '<S501>/SourceBlock'\n  rtb_flag_pos = uORB_read_step(FLIGHT_hexacopter_DW.obj_bw.orbMetadataObj,\n    &FLIGHT_hexacopter_DW.obj_bw.eventStructObj, &FLIGHT_hexacopter_B.r3, false,\n    1.0);\n\n  // Outputs for Enabled SubSystem: '<S501>/Enabled Subsystem' incorporates:\n  //   EnablePort: '<S503>/Enable'\n\n  // Start for MATLABSystem: '<S501>/SourceBlock'\n  if (rtb_flag_pos) {\n    // SignalConversion generated from: '<S503>/In1'\n    FLIGHT_hexacopter_B.In1_f = FLIGHT_hexacopter_B.r3;\n  }\n\n  // End of Outputs for SubSystem: '<S501>/Enabled Subsystem'\n\n  // MATLAB Function: '<S18>/MATLAB Function'\n  switch (FLIGHT_hexacopter_B.In1_f.nav_state) {\n   case 1:\n    //  ALT Mode\n    rtb_flag_pos = false;\n    rtb_NOT_h = true;\n    break;\n\n   case 2:\n    //  POS Mode\n    rtb_flag_pos = true;\n    rtb_NOT_h = false;\n    break;\n\n   default:\n    //  STAB mode\n    rtb_flag_pos = false;\n    rtb_NOT_h = false;\n    break;\n  }\n\n  // End of MATLAB Function: '<S18>/MATLAB Function'\n\n  // Outputs for Atomic SubSystem: '<Root>/If Action Subsystem'\n  // Saturate: '<S195>/Saturation'\n  if (rtb_SinCos_o2 > FLIGHT_hexacopter_P.Saturation_UpperSat_e) {\n    // SignalConversion generated from: '<S6>/ SFunction ' incorporates:\n    //   MATLAB Function: '<Root>/MATLAB Function'\n\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation_UpperSat_e;\n  } else if (rtb_SinCos_o2 < FLIGHT_hexacopter_P.Saturation_LowerSat_a) {\n    // SignalConversion generated from: '<S6>/ SFunction ' incorporates:\n    //   MATLAB Function: '<Root>/MATLAB Function'\n\n    rtb_SinCos_o2 = FLIGHT_hexacopter_P.Saturation_LowerSat_a;\n  }\n\n  if (FLIGHT_hexacopter_B.ParamStep_m >\n      FLIGHT_hexacopter_P.Saturation_UpperSat_e) {\n    FLIGHT_hexacopter_B.ParamStep_m = FLIGHT_hexacopter_P.Saturation_UpperSat_e;\n  } else if (FLIGHT_hexacopter_B.ParamStep_m <\n             FLIGHT_hexacopter_P.Saturation_LowerSat_a) {\n    FLIGHT_hexacopter_B.ParamStep_m = FLIGHT_hexacopter_P.Saturation_LowerSat_a;\n  }\n\n  // SignalConversion generated from: '<S6>/ SFunction ' incorporates:\n  //   Gain: '<S195>/Gain1'\n  //   MATLAB Function: '<Root>/MATLAB Function'\n  //   Saturate: '<S195>/Saturation'\n\n  FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_P.Gain1_Gain_i *\n    FLIGHT_hexacopter_B.ParamStep_m;\n\n  // End of Outputs for SubSystem: '<Root>/If Action Subsystem'\n\n  // MATLAB Function: '<Root>/MATLAB Function' incorporates:\n  //   Gain: '<S12>/Gain4'\n  //   Gain: '<S12>/Gain5'\n  //   Gain: '<S12>/Gain6'\n  //   Gain: '<S22>/Gain1'\n  //   Gain: '<S22>/Gain2'\n  //   Saturate: '<S12>/Saturation1'\n  //   Saturate: '<S12>/Saturation2'\n  //   Saturate: '<S12>/Saturation3'\n  //   Saturate: '<S22>/Saturation1'\n  //   Saturate: '<S22>/Saturation9'\n\n  if ((FLIGHT_hexacopter_B.In1_i.values[5] < 1800) || (!rtb_flag_pos)) {\n    if ((FLIGHT_hexacopter_B.In1_i.values[5] < 1800) &&\n        (FLIGHT_hexacopter_B.In1_i.values[5] >= 1400) && rtb_NOT_h) {\n      // Saturate: '<S22>/Saturation9'\n      //  Altitude\n      if (rtb_Gain_p > FLIGHT_hexacopter_P.Saturation9_UpperSat_c) {\n        rtb_Gain_p = FLIGHT_hexacopter_P.Saturation9_UpperSat_c;\n      } else if (rtb_Gain_p < FLIGHT_hexacopter_P.Saturation9_LowerSat_i) {\n        rtb_Gain_p = FLIGHT_hexacopter_P.Saturation9_LowerSat_i;\n      }\n\n      rtb_SinCos_o2 = FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_ROLL * rtb_Gain_p;\n\n      // Saturate: '<S22>/Saturation1' incorporates:\n      //   Gain: '<S22>/Gain1'\n      //   Saturate: '<S22>/Saturation9'\n\n      if (rtb_Gain_f > FLIGHT_hexacopter_P.Saturation1_UpperSat_d) {\n        rtb_Gain_f = FLIGHT_hexacopter_P.Saturation1_UpperSat_d;\n      } else if (rtb_Gain_f < FLIGHT_hexacopter_P.Saturation1_LowerSat_b) {\n        rtb_Gain_f = FLIGHT_hexacopter_P.Saturation1_LowerSat_b;\n      }\n\n      FLIGHT_hexacopter_B.Product5_l =\n        FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_PITCH * rtb_Gain_f;\n    } else {\n      // Outputs for Atomic SubSystem: '<Root>/Stabilized_Mode'\n      // Saturate: '<S12>/Saturation3'\n      //  Stablized\n      if (rtb_Product5_k > FLIGHT_hexacopter_P.Saturation3_UpperSat) {\n        rtb_Product5_k = FLIGHT_hexacopter_P.Saturation3_UpperSat;\n      } else if (rtb_Product5_k < FLIGHT_hexacopter_P.Saturation3_LowerSat) {\n        rtb_Product5_k = FLIGHT_hexacopter_P.Saturation3_LowerSat;\n      }\n\n      rtb_SinCos_o2 = FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_ROLL *\n        rtb_Product5_k;\n\n      // Saturate: '<S12>/Saturation2' incorporates:\n      //   Gain: '<S12>/Gain4'\n      //   Saturate: '<S12>/Saturation3'\n\n      if (rtb_Product5_dr > FLIGHT_hexacopter_P.Saturation2_UpperSat) {\n        rtb_Product5_dr = FLIGHT_hexacopter_P.Saturation2_UpperSat;\n      } else if (rtb_Product5_dr < FLIGHT_hexacopter_P.Saturation2_LowerSat) {\n        rtb_Product5_dr = FLIGHT_hexacopter_P.Saturation2_LowerSat;\n      }\n\n      FLIGHT_hexacopter_B.Product5_l =\n        FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_PITCH * rtb_Product5_dr;\n\n      // Saturate: '<S12>/Saturation1' incorporates:\n      //   Gain: '<S12>/Gain5'\n      //   Saturate: '<S12>/Saturation2'\n\n      if (rtb_Product5_e > FLIGHT_hexacopter_P.Saturation1_UpperSat_l) {\n        rtb_Product5_e = FLIGHT_hexacopter_P.Saturation1_UpperSat_l;\n      } else if (rtb_Product5_e < FLIGHT_hexacopter_P.Saturation1_LowerSat_i) {\n        rtb_Product5_e = FLIGHT_hexacopter_P.Saturation1_LowerSat_i;\n      }\n\n      FLIGHT_hexacopter_B.Gain3 = FLIGHT_hexacopter_P.MAX_CONTROL_ANGLE_RATE_Y *\n        rtb_Product5_e;\n\n      // Saturate: '<S12>/Saturation' incorporates:\n      //   Gain: '<S12>/Gain6'\n      //   Saturate: '<S12>/Saturation1'\n\n      if (rtb_Product5_m > FLIGHT_hexacopter_P.Saturation_UpperSat_o) {\n        rtb_Saturation1 = FLIGHT_hexacopter_P.Saturation_UpperSat_o;\n      } else if (rtb_Product5_m < FLIGHT_hexacopter_P.Saturation_LowerSat_el) {\n        rtb_Saturation1 = FLIGHT_hexacopter_P.Saturation_LowerSat_el;\n      } else {\n        rtb_Saturation1 = rtb_Product5_m;\n      }\n\n      // End of Saturate: '<S12>/Saturation'\n      // End of Outputs for SubSystem: '<Root>/Stabilized_Mode'\n    }\n  } else {\n    //  position\n  }\n\n  // RelationalOperator: '<S183>/Compare' incorporates:\n  //   Constant: '<S183>/Constant'\n\n  rtb_NOT_h = (FLIGHT_hexacopter_B.In1_i.values[6] >=\n               FLIGHT_hexacopter_P.CompareToConstant1_const_e);\n  FLIGHT_hexacop_PX4Timestamp(&FLIGHT_hexacopter_B.PX4Timestamp);\n\n  // MATLABSystem: '<S3>/Read Parameter1'\n  if (FLIGHT_hexacopter_DW.obj_ct.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n  {\n    FLIGHT_hexacopter_DW.obj_ct.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_ct.MW_PARAMHANDLE,\n    MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep);\n  if (rtb_flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep = 0.0F;\n  }\n\n  // MATLABSystem: '<S3>/Read Parameter'\n  if (FLIGHT_hexacopter_DW.obj_cf.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n  {\n    FLIGHT_hexacopter_DW.obj_cf.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_cf.MW_PARAMHANDLE,\n    MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep_m);\n  if (rtb_flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep_m = 0.0F;\n  }\n\n  // MATLABSystem: '<S3>/Read Parameter2'\n  if (FLIGHT_hexacopter_DW.obj_l.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    FLIGHT_hexacopter_DW.obj_l.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_l.MW_PARAMHANDLE,\n    MW_INT32, &FLIGHT_hexacopter_B.ParamStep_k);\n  if (rtb_flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep_k = 0;\n  }\n\n  // MATLAB Function: '<S3>/MATLAB Function' incorporates:\n  //   DataTypeConversion: '<S3>/Data Type Conversion'\n  //   DataTypeConversion: '<S3>/Data Type Conversion1'\n  //   DataTypeConversion: '<S3>/Data Type Conversion2'\n  //   DataTypeConversion: '<S3>/Data Type Conversion3'\n  //   DataTypeConversion: '<S3>/Data Type Conversion4'\n  //   DataTypeConversion: '<S3>/Data Type Conversion5'\n  //   MATLABSystem: '<S3>/PX4 Timestamp'\n  //   MATLABSystem: '<S3>/Read Parameter'\n  //   MATLABSystem: '<S3>/Read Parameter1'\n  //   MATLABSystem: '<S3>/Read Parameter2'\n  //\n  FLIGHT_hexacopter_B.out_roll = rtb_SinCos_o2;\n  FLIGHT_hexacopter_B.out_pitch = FLIGHT_hexacopter_B.Product5_l;\n  FLIGHT_hexacopter_B.out_yawrate = FLIGHT_hexacopter_B.Gain3;\n  if (rtb_NOT_h && (FLIGHT_hexacopter_DW.start_time_usec == -1.0)) {\n    FLIGHT_hexacopter_DW.start_time_usec = static_cast<real_T>\n      (FLIGHT_hexacopter_B.PX4Timestamp.PX4Timestamp);\n  }\n\n  if (rtb_NOT_h && (FLIGHT_hexacopter_DW.start_time_usec > 0.0)) {\n    //  time calculation\n    FLIGHT_hexacopter_B.reletive_time_sec = (static_cast<real_T>\n      (FLIGHT_hexacopter_B.PX4Timestamp.PX4Timestamp) -\n      FLIGHT_hexacopter_DW.start_time_usec) * 1.0E-6;\n  } else {\n    FLIGHT_hexacopter_DW.start_time_usec = -1.0;\n    FLIGHT_hexacopter_B.reletive_time_sec = 0.0;\n  }\n\n  //  Define Doublet\n  FLIGHT_hexacopter_B.peak_angle_rad = FLIGHT_hexacopter_B.ParamStep *\n    0.017453292519943295;\n\n  //  Default Output\n  //  Generate Doublet Command\n  if (rtb_NOT_h) {\n    switch (FLIGHT_hexacopter_B.ParamStep_k) {\n     case 1:\n      if ((FLIGHT_hexacopter_B.reletive_time_sec >= 0.0) &&\n          (FLIGHT_hexacopter_B.reletive_time_sec <\n           FLIGHT_hexacopter_B.ParamStep_m)) {\n        FLIGHT_hexacopter_B.out_roll = FLIGHT_hexacopter_B.peak_angle_rad;\n      } else if ((FLIGHT_hexacopter_B.reletive_time_sec >=\n                  FLIGHT_hexacopter_B.ParamStep_m) &&\n                 (FLIGHT_hexacopter_B.reletive_time_sec < static_cast<real_T>\n                  (FLIGHT_hexacopter_B.ParamStep_m) +\n                  FLIGHT_hexacopter_B.ParamStep_m)) {\n        FLIGHT_hexacopter_B.out_roll = -FLIGHT_hexacopter_B.peak_angle_rad;\n      } else {\n        FLIGHT_hexacopter_B.out_roll = 0.0;\n      }\n      break;\n\n     case 2:\n      if ((FLIGHT_hexacopter_B.reletive_time_sec >= 0.0) &&\n          (FLIGHT_hexacopter_B.reletive_time_sec <\n           FLIGHT_hexacopter_B.ParamStep_m)) {\n        FLIGHT_hexacopter_B.out_pitch = FLIGHT_hexacopter_B.peak_angle_rad;\n      } else if ((FLIGHT_hexacopter_B.reletive_time_sec >=\n                  FLIGHT_hexacopter_B.ParamStep_m) &&\n                 (FLIGHT_hexacopter_B.reletive_time_sec < static_cast<real_T>\n                  (FLIGHT_hexacopter_B.ParamStep_m) +\n                  FLIGHT_hexacopter_B.ParamStep_m)) {\n        FLIGHT_hexacopter_B.out_pitch = -FLIGHT_hexacopter_B.peak_angle_rad;\n      } else {\n        FLIGHT_hexacopter_B.out_pitch = 0.0;\n      }\n      break;\n\n     case 3:\n      if ((FLIGHT_hexacopter_B.reletive_time_sec >= 0.0) &&\n          (FLIGHT_hexacopter_B.reletive_time_sec <\n           FLIGHT_hexacopter_B.ParamStep_m)) {\n        FLIGHT_hexacopter_B.out_yawrate = FLIGHT_hexacopter_B.peak_angle_rad;\n      } else if ((FLIGHT_hexacopter_B.reletive_time_sec >=\n                  FLIGHT_hexacopter_B.ParamStep_m) &&\n                 (FLIGHT_hexacopter_B.reletive_time_sec < static_cast<real_T>\n                  (FLIGHT_hexacopter_B.ParamStep_m) +\n                  FLIGHT_hexacopter_B.ParamStep_m)) {\n        FLIGHT_hexacopter_B.out_yawrate = -FLIGHT_hexacopter_B.peak_angle_rad;\n      } else {\n        FLIGHT_hexacopter_B.out_yawrate = 0.0;\n      }\n      break;\n    }\n  }\n\n  // End of MATLAB Function: '<S3>/MATLAB Function'\n\n  // Outputs for Enabled SubSystem: '<Root>/CAS' incorporates:\n  //   EnablePort: '<S2>/Enable'\n\n  if (FLIGHT_hexacopter_B.In1_n.armed) {\n    // MATLABSystem: '<S2>/Read Parameter9'\n    if (FLIGHT_hexacopter_DW.obj_k4.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n    {\n      FLIGHT_hexacopter_DW.obj_k4.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    }\n\n    rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_k4.MW_PARAMHANDLE,\n      MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep);\n    if (rtb_flag_pos) {\n      FLIGHT_hexacopter_B.ParamStep = 0.0F;\n    }\n\n    // Gain: '<S77>/Gain1' incorporates:\n    //   MATLABSystem: '<S2>/Read Parameter9'\n    //\n    FLIGHT_hexacopter_B.ParamStep_m = FLIGHT_hexacopter_P.Gain1_Gain_g *\n      FLIGHT_hexacopter_B.ParamStep;\n\n    // MATLABSystem: '<S2>/Read Parameter'\n    if (FLIGHT_hexacopter_DW.obj_jz.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n    {\n      FLIGHT_hexacopter_DW.obj_jz.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    }\n\n    rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_jz.MW_PARAMHANDLE,\n      MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep);\n    if (rtb_flag_pos) {\n      FLIGHT_hexacopter_B.ParamStep = 0.0F;\n    }\n\n    // Product: '<S170>/PProd Out' incorporates:\n    //   DataTypeConversion: '<S3>/Data Type Conversion8'\n    //   MATLABSystem: '<S2>/Read Parameter'\n    //   Sum: '<S2>/Sum3'\n    //\n    FLIGHT_hexacopter_B.ParamStep *= static_cast<real32_T>\n      (FLIGHT_hexacopter_B.out_roll) - FLIGHT_hexacopter_B.ypr[2];\n\n    // Switch: '<S173>/Switch2' incorporates:\n    //   RelationalOperator: '<S173>/LowerRelop1'\n\n    if (FLIGHT_hexacopter_B.ParamStep > FLIGHT_hexacopter_B.ParamStep_m) {\n      // Switch: '<S173>/Switch2'\n      FLIGHT_hexacopter_B.Switch2 = FLIGHT_hexacopter_B.ParamStep_m;\n    } else {\n      // Gain: '<S2>/Gain'\n      FLIGHT_hexacopter_B.ParamStep_m *= FLIGHT_hexacopter_P.Gain_Gain_m3;\n\n      // Switch: '<S173>/Switch' incorporates:\n      //   RelationalOperator: '<S173>/UpperRelop'\n\n      if (FLIGHT_hexacopter_B.ParamStep < FLIGHT_hexacopter_B.ParamStep_m) {\n        // Switch: '<S173>/Switch2'\n        FLIGHT_hexacopter_B.Switch2 = FLIGHT_hexacopter_B.ParamStep_m;\n      } else {\n        // Switch: '<S173>/Switch2'\n        FLIGHT_hexacopter_B.Switch2 = FLIGHT_hexacopter_B.ParamStep;\n      }\n\n      // End of Switch: '<S173>/Switch'\n    }\n\n    // End of Switch: '<S173>/Switch2'\n\n    // MATLABSystem: '<S2>/Read Parameter10'\n    if (FLIGHT_hexacopter_DW.obj_ds.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n    {\n      FLIGHT_hexacopter_DW.obj_ds.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    }\n\n    rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_ds.MW_PARAMHANDLE,\n      MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep);\n    if (rtb_flag_pos) {\n      FLIGHT_hexacopter_B.ParamStep = 0.0F;\n    }\n\n    // Gain: '<S78>/Gain1' incorporates:\n    //   MATLABSystem: '<S2>/Read Parameter10'\n    //\n    FLIGHT_hexacopter_B.ParamStep_m = FLIGHT_hexacopter_P.Gain1_Gain_c *\n      FLIGHT_hexacopter_B.ParamStep;\n\n    // MATLABSystem: '<S2>/Read Parameter1'\n    if (FLIGHT_hexacopter_DW.obj_o.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n    {\n      FLIGHT_hexacopter_DW.obj_o.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    }\n\n    rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_o.MW_PARAMHANDLE,\n      MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep);\n    if (rtb_flag_pos) {\n      FLIGHT_hexacopter_B.ParamStep = 0.0F;\n    }\n\n    // Product: '<S119>/PProd Out' incorporates:\n    //   DataTypeConversion: '<S3>/Data Type Conversion7'\n    //   MATLABSystem: '<S2>/Read Parameter1'\n    //   Sum: '<S2>/Sum2'\n    //\n    FLIGHT_hexacopter_B.ParamStep *= static_cast<real32_T>\n      (FLIGHT_hexacopter_B.out_pitch) - FLIGHT_hexacopter_B.ypr[1];\n\n    // Switch: '<S122>/Switch2' incorporates:\n    //   RelationalOperator: '<S122>/LowerRelop1'\n\n    if (FLIGHT_hexacopter_B.ParamStep > FLIGHT_hexacopter_B.ParamStep_m) {\n      // Switch: '<S122>/Switch2'\n      FLIGHT_hexacopter_B.Switch2_i = FLIGHT_hexacopter_B.ParamStep_m;\n    } else {\n      // Gain: '<S2>/Gain1'\n      FLIGHT_hexacopter_B.ParamStep_m *= FLIGHT_hexacopter_P.Gain1_Gain;\n\n      // Switch: '<S122>/Switch' incorporates:\n      //   RelationalOperator: '<S122>/UpperRelop'\n\n      if (FLIGHT_hexacopter_B.ParamStep < FLIGHT_hexacopter_B.ParamStep_m) {\n        // Switch: '<S122>/Switch2'\n        FLIGHT_hexacopter_B.Switch2_i = FLIGHT_hexacopter_B.ParamStep_m;\n      } else {\n        // Switch: '<S122>/Switch2'\n        FLIGHT_hexacopter_B.Switch2_i = FLIGHT_hexacopter_B.ParamStep;\n      }\n\n      // End of Switch: '<S122>/Switch'\n    }\n\n    // End of Switch: '<S122>/Switch2'\n  }\n\n  // End of Outputs for SubSystem: '<Root>/CAS'\n\n  // S-Function (sdspdiag2): '<S477>/Create Diagonal Matrix' incorporates:\n  //   Constant: '<S477>/Constant'\n  //   Constant: '<S477>/Constant1'\n  //   Constant: '<S477>/Constant2'\n  //   SignalConversion generated from: '<S477>/Create Diagonal Matrix'\n\n  for (FLIGHT_hexacopter_B.ParamStep_k = 0; FLIGHT_hexacopter_B.ParamStep_k < 9;\n       FLIGHT_hexacopter_B.ParamStep_k++) {\n    FLIGHT_hexacopter_B.CreateDiagonalMatrix[FLIGHT_hexacopter_B.ParamStep_k] =\n      0.0F;\n  }\n\n  FLIGHT_hexacopter_B.CreateDiagonalMatrix[0] = FLIGHT_hexacopter_P.Jxx;\n  FLIGHT_hexacopter_B.CreateDiagonalMatrix[4] = FLIGHT_hexacopter_P.Jyy;\n  FLIGHT_hexacopter_B.CreateDiagonalMatrix[8] = FLIGHT_hexacopter_P.Jzz;\n\n  // End of S-Function (sdspdiag2): '<S477>/Create Diagonal Matrix'\n\n  // RateTransition: '<Root>/rate_transition_throttle'\n  FLIGHT_hexacopter_DW.rate_transition_throttle_Buffer = rtb_Saturation1;\n\n  // MATLAB Function: '<S11>/Omega_phi'\n  FLIGHT_hexacopter_B.ParamStep = static_cast<real32_T>(tan(static_cast<real_T>\n    (FLIGHT_hexacopter_B.ypr[1])));\n  FLIGHT_hexacopter_B.TmpSignalConversionAtSFun_c[0] = 1.0F;\n  FLIGHT_hexacopter_B.TmpSignalConversionAtSFun_c[1] = static_cast<real32_T>(sin\n    (static_cast<real_T>(FLIGHT_hexacopter_B.ypr[2]))) *\n    FLIGHT_hexacopter_B.ParamStep;\n  FLIGHT_hexacopter_B.TmpSignalConversionAtSFun_c[2] = static_cast<real32_T>(cos\n    (static_cast<real_T>(FLIGHT_hexacopter_B.ypr[2]))) *\n    FLIGHT_hexacopter_B.ParamStep;\n  for (FLIGHT_hexacopter_B.ParamStep_k = 0; FLIGHT_hexacopter_B.ParamStep_k < 3;\n       FLIGHT_hexacopter_B.ParamStep_k++) {\n    // MATLAB Function: '<S11>/MATLAB Function1' incorporates:\n    //   S-Function (sdspdiag2): '<S477>/Create Diagonal Matrix'\n\n    FLIGHT_hexacopter_B.G1[FLIGHT_hexacopter_B.ParamStep_k] =\n      (FLIGHT_hexacopter_B.CreateDiagonalMatrix[3 *\n       FLIGHT_hexacopter_B.ParamStep_k + 1] *\n       FLIGHT_hexacopter_B.TmpSignalConversionAtSFun_c[1] +\n       FLIGHT_hexacopter_B.CreateDiagonalMatrix[3 *\n       FLIGHT_hexacopter_B.ParamStep_k]) +\n      FLIGHT_hexacopter_B.CreateDiagonalMatrix[3 *\n      FLIGHT_hexacopter_B.ParamStep_k + 2] *\n      FLIGHT_hexacopter_B.TmpSignalConversionAtSFun_c[2];\n\n    // SampleTimeMath: '<S480>/TSamp'\n    //\n    //  About '<S480>/TSamp':\n    //   y = u * K where K = 1 / ( w * Ts )\n    //\n    FLIGHT_hexacopter_B.ParamStep =\n      FLIGHT_hexacopter_B.TmpSignalConversionAtSFun_c[FLIGHT_hexacopter_B.ParamStep_k]\n      * FLIGHT_hexacopter_P.TSamp_WtEt_k;\n    FLIGHT_hexacopter_B.TSamp[FLIGHT_hexacopter_B.ParamStep_k] =\n      FLIGHT_hexacopter_B.ParamStep;\n\n    // Sum: '<S480>/Diff' incorporates:\n    //   SampleTimeMath: '<S480>/TSamp'\n    //   UnitDelay: '<S480>/UD'\n    //\n    //  About '<S480>/TSamp':\n    //   y = u * K where K = 1 / ( w * Ts )\n    //    *\n    //  Block description for '<S480>/Diff':\n    //\n    //   Add in CPU\n    //\n    //  Block description for '<S480>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE[FLIGHT_hexacopter_B.ParamStep_k] =\n      FLIGHT_hexacopter_B.ParamStep -\n      FLIGHT_hexacopter_DW.UD_DSTATE[FLIGHT_hexacopter_B.ParamStep_k];\n  }\n\n  // SampleTimeMath: '<S478>/TSamp' incorporates:\n  //   DataTypeConversion: '<S3>/Data Type Conversion8'\n  //\n  //  About '<S478>/TSamp':\n  //   y = u * K where K = 1 / ( w * Ts )\n  //\n  rtb_Product5_m = static_cast<real32_T>(FLIGHT_hexacopter_B.out_roll) *\n    FLIGHT_hexacopter_P.TSamp_WtEt_c;\n\n  // Sum: '<S478>/Diff' incorporates:\n  //   UnitDelay: '<S478>/UD'\n  //\n  //  Block description for '<S478>/Diff':\n  //\n  //   Add in CPU\n  //\n  //  Block description for '<S478>/UD':\n  //\n  //   Store in Global RAM\n\n  rtb_Gain_p = rtb_Product5_m - FLIGHT_hexacopter_DW.UD_DSTATE_j;\n\n  // SampleTimeMath: '<S479>/TSamp'\n  //\n  //  About '<S479>/TSamp':\n  //   y = u * K where K = 1 / ( w * Ts )\n  //\n  rtb_Product5_e = rtb_Gain_p * FLIGHT_hexacopter_P.TSamp_WtEt_b;\n\n  // Sum: '<S11>/Subtract' incorporates:\n  //   DataTypeConversion: '<S3>/Data Type Conversion8'\n\n  rtb_Product5_dr = FLIGHT_hexacopter_B.ypr[2] - static_cast<real32_T>\n    (FLIGHT_hexacopter_B.out_roll);\n\n  // SampleTimeMath: '<S481>/TSamp'\n  //\n  //  About '<S481>/TSamp':\n  //   y = u * K where K = 1 / ( w * Ts )\n  //\n  rtb_Product5_k = rtb_Product5_dr * FLIGHT_hexacopter_P.TSamp_WtEt_py;\n\n  // MATLABSystem: '<S11>/Read Parameter'\n  if (FLIGHT_hexacopter_DW.obj_g.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    FLIGHT_hexacopter_DW.obj_g.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_g.MW_PARAMHANDLE,\n    MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep);\n  if (rtb_flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep = 0.0F;\n  }\n\n  // MATLABSystem: '<S11>/Read Parameter1'\n  if (FLIGHT_hexacopter_DW.obj_d.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    FLIGHT_hexacopter_DW.obj_d.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_d.MW_PARAMHANDLE,\n    MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep_m);\n  if (rtb_flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep_m = 0.0F;\n  }\n\n  // MATLABSystem: '<S11>/Read Parameter2'\n  if (FLIGHT_hexacopter_DW.obj_k.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    FLIGHT_hexacopter_DW.obj_k.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_k.MW_PARAMHANDLE,\n    MW_SINGLE, &rtb_Gain_f);\n  if (rtb_flag_pos) {\n    rtb_Gain_f = 0.0F;\n  }\n\n  // MATLAB Function: '<S11>/MATLAB Function3' incorporates:\n  //   DiscreteIntegrator: '<S11>/Discrete-Time Integrator'\n  //   MATLABSystem: '<S11>/Read Parameter'\n  //   MATLABSystem: '<S11>/Read Parameter1'\n  //   MATLABSystem: '<S11>/Read Parameter2'\n  //   Sum: '<S481>/Diff'\n  //   UnitDelay: '<S481>/UD'\n  //  *\n  //  Block description for '<S481>/Diff':\n  //\n  //   Add in CPU\n  //\n  //  Block description for '<S481>/UD':\n  //\n  //   Store in Global RAM\n\n  //  PID Like Sliding Surface\n  rtb_Gain_f = ((rtb_Product5_k - FLIGHT_hexacopter_DW.UD_DSTATE_n) * rtb_Gain_f\n                + FLIGHT_hexacopter_B.ParamStep * rtb_Product5_dr) +\n    FLIGHT_hexacopter_B.ParamStep_m *\n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE;\n\n  // MATLABSystem: '<S11>/Read Parameter3'\n  if (FLIGHT_hexacopter_DW.obj_n.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    FLIGHT_hexacopter_DW.obj_n.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_n.MW_PARAMHANDLE,\n    MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep);\n  if (rtb_flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep = 0.0F;\n  }\n\n  // MATLABSystem: '<S11>/Read Parameter4'\n  if (FLIGHT_hexacopter_DW.obj.SampleTime != FLIGHT_hexacopter_P.SampleTime) {\n    FLIGHT_hexacopter_DW.obj.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj.MW_PARAMHANDLE,\n    MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep_m);\n  if (rtb_flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep_m = 0.0F;\n  }\n\n  // MATLAB Function: '<S11>/MATLAB Function2'\n  rtb_flag_pos = true;\n  FLIGHT_hexacopter_B.ypr[0] = 0.0F;\n  if (rtIsInfF(FLIGHT_hexacopter_B.G1[0]) || rtIsNaNF(FLIGHT_hexacopter_B.G1[0]))\n  {\n    rtb_flag_pos = false;\n  }\n\n  if (rtb_flag_pos && (rtIsInfF(FLIGHT_hexacopter_B.G1[1]) || rtIsNaNF\n                       (FLIGHT_hexacopter_B.G1[1]))) {\n    rtb_flag_pos = false;\n  }\n\n  if (rtb_flag_pos && (rtIsInfF(FLIGHT_hexacopter_B.G1[2]) || rtIsNaNF\n                       (FLIGHT_hexacopter_B.G1[2]))) {\n    rtb_flag_pos = false;\n  }\n\n  if (!rtb_flag_pos) {\n    FLIGHT_hexacopter_B.ypr[0] = (rtNaNF);\n  } else {\n    rtb_flag_pos = false;\n    FLIGHT_hexacopter_B.Product5_l = 0.0F;\n    FLIGHT_hexacopter_B.ParamStep_k = 0;\n    exitg1 = false;\n    while ((!exitg1) && (FLIGHT_hexacopter_B.ParamStep_k < 3)) {\n      FLIGHT_hexacopter_B.Gain3 = static_cast<real32_T>(fabs(static_cast<real_T>\n        (FLIGHT_hexacopter_B.G1[FLIGHT_hexacopter_B.ParamStep_k])));\n      if (rtIsNaNF(FLIGHT_hexacopter_B.Gain3)) {\n        FLIGHT_hexacopter_B.Product5_l = (rtNaNF);\n        exitg1 = true;\n      } else {\n        if (FLIGHT_hexacopter_B.Gain3 > FLIGHT_hexacopter_B.Product5_l) {\n          FLIGHT_hexacopter_B.Product5_l = FLIGHT_hexacopter_B.Gain3;\n        }\n\n        FLIGHT_hexacopter_B.ParamStep_k++;\n      }\n    }\n\n    FLIGHT_hexacopter_B.Gain3 = FLIGHT_hexacopter_B.Product5_l;\n    guard1 = false;\n    if ((FLIGHT_hexacopter_B.Product5_l > 0.0F) &&\n        (FLIGHT_hexacopter_B.Product5_l < 9.09494702E-13F)) {\n      rtb_flag_pos = true;\n      FLIGHT_hexacopter_B.Gain3 = 9.09494702E-13F;\n      guard1 = true;\n    } else if (FLIGHT_hexacopter_B.Product5_l > 1.09951163E+12F) {\n      rtb_flag_pos = true;\n      FLIGHT_hexacopter_B.Gain3 = 1.09951163E+12F;\n      guard1 = true;\n    }\n\n    if (guard1) {\n      FLIGHT_hexacopter_B.cfromc = FLIGHT_hexacopter_B.Product5_l;\n      FLIGHT_hexacopter_B.ctoc = FLIGHT_hexacopter_B.Gain3;\n      rtb_NOT_h = true;\n      while (rtb_NOT_h) {\n        rtb_SinCos_o2 = FLIGHT_hexacopter_B.cfromc * 1.97215226E-31F;\n        FLIGHT_hexacopter_B.t = FLIGHT_hexacopter_B.ctoc / 5.0706024E+30F;\n        if ((rtb_SinCos_o2 > FLIGHT_hexacopter_B.ctoc) &&\n            (FLIGHT_hexacopter_B.ctoc != 0.0F)) {\n          FLIGHT_hexacopter_B.mul = 1.97215226E-31F;\n          FLIGHT_hexacopter_B.cfromc = rtb_SinCos_o2;\n        } else if (FLIGHT_hexacopter_B.t > FLIGHT_hexacopter_B.cfromc) {\n          FLIGHT_hexacopter_B.mul = 5.0706024E+30F;\n          FLIGHT_hexacopter_B.ctoc = FLIGHT_hexacopter_B.t;\n        } else {\n          FLIGHT_hexacopter_B.mul = FLIGHT_hexacopter_B.ctoc /\n            FLIGHT_hexacopter_B.cfromc;\n          rtb_NOT_h = false;\n        }\n\n        FLIGHT_hexacopter_B.G1[0] *= FLIGHT_hexacopter_B.mul;\n        FLIGHT_hexacopter_B.G1[1] *= FLIGHT_hexacopter_B.mul;\n        FLIGHT_hexacopter_B.G1[2] *= FLIGHT_hexacopter_B.mul;\n      }\n    }\n\n    FLIGHT_hexacopter_B.ctoc = 1.29246971E-26F;\n    rtb_SinCos_o2 = static_cast<real32_T>(fabs(static_cast<real_T>\n      (FLIGHT_hexacopter_B.G1[0])));\n    if (rtb_SinCos_o2 > 1.29246971E-26F) {\n      FLIGHT_hexacopter_B.cfromc = 1.0F;\n      FLIGHT_hexacopter_B.ctoc = rtb_SinCos_o2;\n    } else {\n      FLIGHT_hexacopter_B.t = rtb_SinCos_o2 / 1.29246971E-26F;\n      FLIGHT_hexacopter_B.cfromc = FLIGHT_hexacopter_B.t * FLIGHT_hexacopter_B.t;\n    }\n\n    rtb_SinCos_o2 = static_cast<real32_T>(fabs(static_cast<real_T>\n      (FLIGHT_hexacopter_B.G1[1])));\n    if (rtb_SinCos_o2 > FLIGHT_hexacopter_B.ctoc) {\n      FLIGHT_hexacopter_B.t = FLIGHT_hexacopter_B.ctoc / rtb_SinCos_o2;\n      FLIGHT_hexacopter_B.cfromc = FLIGHT_hexacopter_B.cfromc *\n        FLIGHT_hexacopter_B.t * FLIGHT_hexacopter_B.t + 1.0F;\n      FLIGHT_hexacopter_B.ctoc = rtb_SinCos_o2;\n    } else {\n      FLIGHT_hexacopter_B.t = rtb_SinCos_o2 / FLIGHT_hexacopter_B.ctoc;\n      FLIGHT_hexacopter_B.cfromc += FLIGHT_hexacopter_B.t *\n        FLIGHT_hexacopter_B.t;\n    }\n\n    rtb_SinCos_o2 = static_cast<real32_T>(fabs(static_cast<real_T>\n      (FLIGHT_hexacopter_B.G1[2])));\n    if (rtb_SinCos_o2 > FLIGHT_hexacopter_B.ctoc) {\n      FLIGHT_hexacopter_B.t = FLIGHT_hexacopter_B.ctoc / rtb_SinCos_o2;\n      FLIGHT_hexacopter_B.cfromc = FLIGHT_hexacopter_B.cfromc *\n        FLIGHT_hexacopter_B.t * FLIGHT_hexacopter_B.t + 1.0F;\n      FLIGHT_hexacopter_B.ctoc = rtb_SinCos_o2;\n    } else {\n      FLIGHT_hexacopter_B.t = rtb_SinCos_o2 / FLIGHT_hexacopter_B.ctoc;\n      FLIGHT_hexacopter_B.cfromc += FLIGHT_hexacopter_B.t *\n        FLIGHT_hexacopter_B.t;\n    }\n\n    FLIGHT_hexacopter_B.cfromc = FLIGHT_hexacopter_B.ctoc * static_cast<real32_T>\n      (sqrt(static_cast<real_T>(FLIGHT_hexacopter_B.cfromc)));\n    if (FLIGHT_hexacopter_B.cfromc > 0.0F) {\n      if (FLIGHT_hexacopter_B.G1[0] < 0.0F) {\n        FLIGHT_hexacopter_B.cfromc = -FLIGHT_hexacopter_B.cfromc;\n      }\n\n      if (static_cast<real32_T>(fabs(static_cast<real_T>\n            (FLIGHT_hexacopter_B.cfromc))) >= 9.86076132E-32F) {\n        FLIGHT_hexacopter_B.ctoc = 1.0F / FLIGHT_hexacopter_B.cfromc;\n        FLIGHT_hexacopter_B.G1[0] *= FLIGHT_hexacopter_B.ctoc;\n        FLIGHT_hexacopter_B.G1[1] *= FLIGHT_hexacopter_B.ctoc;\n        FLIGHT_hexacopter_B.G1[2] *= FLIGHT_hexacopter_B.ctoc;\n      } else {\n        FLIGHT_hexacopter_B.G1[0] /= FLIGHT_hexacopter_B.cfromc;\n        FLIGHT_hexacopter_B.G1[1] /= FLIGHT_hexacopter_B.cfromc;\n        FLIGHT_hexacopter_B.G1[2] /= FLIGHT_hexacopter_B.cfromc;\n      }\n\n      FLIGHT_hexacopter_B.G1[0]++;\n      FLIGHT_hexacopter_B.cfromc = -FLIGHT_hexacopter_B.cfromc;\n    } else {\n      FLIGHT_hexacopter_B.cfromc = 0.0F;\n    }\n\n    if (FLIGHT_hexacopter_B.cfromc != 0.0F) {\n      FLIGHT_hexacopter_B.ctoc = static_cast<real32_T>(fabs(static_cast<real_T>\n        (FLIGHT_hexacopter_B.cfromc)));\n      rtb_SinCos_o2 = FLIGHT_hexacopter_B.cfromc / FLIGHT_hexacopter_B.ctoc;\n      FLIGHT_hexacopter_B.cfromc = FLIGHT_hexacopter_B.ctoc;\n      FLIGHT_hexacopter_B.U[0] = (-FLIGHT_hexacopter_B.G1[0] + 1.0F) *\n        rtb_SinCos_o2;\n      FLIGHT_hexacopter_B.U[1] = rtb_SinCos_o2 * -FLIGHT_hexacopter_B.G1[1];\n      FLIGHT_hexacopter_B.U[2] = rtb_SinCos_o2 * -FLIGHT_hexacopter_B.G1[2];\n    } else {\n      FLIGHT_hexacopter_B.U[1] = 0.0F;\n      FLIGHT_hexacopter_B.U[2] = 0.0F;\n      FLIGHT_hexacopter_B.U[0] = 1.0F;\n    }\n\n    if (rtb_flag_pos) {\n      rtb_flag_pos = true;\n      while (rtb_flag_pos) {\n        FLIGHT_hexacopter_B.ctoc = FLIGHT_hexacopter_B.Gain3 * 1.97215226E-31F;\n        rtb_SinCos_o2 = FLIGHT_hexacopter_B.Product5_l / 5.0706024E+30F;\n        if ((FLIGHT_hexacopter_B.ctoc > FLIGHT_hexacopter_B.Product5_l) &&\n            (FLIGHT_hexacopter_B.Product5_l != 0.0F)) {\n          FLIGHT_hexacopter_B.t = 1.97215226E-31F;\n          FLIGHT_hexacopter_B.Gain3 = FLIGHT_hexacopter_B.ctoc;\n        } else if (rtb_SinCos_o2 > FLIGHT_hexacopter_B.Gain3) {\n          FLIGHT_hexacopter_B.t = 5.0706024E+30F;\n          FLIGHT_hexacopter_B.Product5_l = rtb_SinCos_o2;\n        } else {\n          FLIGHT_hexacopter_B.t = FLIGHT_hexacopter_B.Product5_l /\n            FLIGHT_hexacopter_B.Gain3;\n          rtb_flag_pos = false;\n        }\n\n        FLIGHT_hexacopter_B.cfromc *= FLIGHT_hexacopter_B.t;\n      }\n    }\n\n    FLIGHT_hexacopter_B.Product5_l = 1.0F;\n    rtb_flag_pos = (rtIsInfF(FLIGHT_hexacopter_B.cfromc) || rtIsNaNF\n                    (FLIGHT_hexacopter_B.cfromc));\n    if (rtb_flag_pos) {\n      FLIGHT_hexacopter_B.Gain3 = (rtNaNF);\n    } else if (FLIGHT_hexacopter_B.cfromc < 2.3509887E-38F) {\n      FLIGHT_hexacopter_B.Gain3 = 1.4013E-45F;\n    } else {\n      frexp(static_cast<real_T>(FLIGHT_hexacopter_B.cfromc),\n            &FLIGHT_hexacopter_B.r_c);\n      FLIGHT_hexacopter_B.Gain3 = static_cast<real32_T>(ldexp(1.0,\n        FLIGHT_hexacopter_B.r_c - 24));\n    }\n\n    FLIGHT_hexacopter_B.Gain3 *= 3.0F;\n    if (rtb_flag_pos) {\n      FLIGHT_hexacopter_B.Gain3 = 3.402823466E+38F;\n    }\n\n    FLIGHT_hexacopter_B.r_c = 0;\n    if (FLIGHT_hexacopter_B.cfromc > FLIGHT_hexacopter_B.Gain3) {\n      FLIGHT_hexacopter_B.r_c = 1;\n    }\n\n    if (FLIGHT_hexacopter_B.r_c > 0) {\n      FLIGHT_hexacopter_B.Gain3 = 1.0F / FLIGHT_hexacopter_B.cfromc;\n      for (FLIGHT_hexacopter_B.r_c = 1; FLIGHT_hexacopter_B.r_c < 2;\n           FLIGHT_hexacopter_B.r_c++) {\n        FLIGHT_hexacopter_B.Product5_l *= FLIGHT_hexacopter_B.Gain3;\n      }\n\n      for (FLIGHT_hexacopter_B.r_c = 0; FLIGHT_hexacopter_B.r_c < 3;\n           FLIGHT_hexacopter_B.r_c++) {\n        for (FLIGHT_hexacopter_B.ParamStep_k = FLIGHT_hexacopter_B.r_c + 1;\n             FLIGHT_hexacopter_B.ParamStep_k <= FLIGHT_hexacopter_B.r_c + 1;\n             FLIGHT_hexacopter_B.ParamStep_k++) {\n          FLIGHT_hexacopter_B.ypr[FLIGHT_hexacopter_B.ParamStep_k - 1] = 0.0F;\n        }\n      }\n\n      FLIGHT_hexacopter_B.br = 0;\n      for (FLIGHT_hexacopter_B.r_c = 0; FLIGHT_hexacopter_B.r_c < 3;\n           FLIGHT_hexacopter_B.r_c++) {\n        FLIGHT_hexacopter_B.br++;\n        for (FLIGHT_hexacopter_B.ParamStep_k = FLIGHT_hexacopter_B.br;\n             FLIGHT_hexacopter_B.ParamStep_k <= FLIGHT_hexacopter_B.br;\n             FLIGHT_hexacopter_B.ParamStep_k += 3) {\n          for (FLIGHT_hexacopter_B.b_ic = FLIGHT_hexacopter_B.r_c + 1;\n               FLIGHT_hexacopter_B.b_ic <= FLIGHT_hexacopter_B.r_c + 1;\n               FLIGHT_hexacopter_B.b_ic++) {\n            FLIGHT_hexacopter_B.ypr[FLIGHT_hexacopter_B.b_ic - 1] +=\n              FLIGHT_hexacopter_B.U[FLIGHT_hexacopter_B.ParamStep_k - 1] *\n              FLIGHT_hexacopter_B.Product5_l;\n          }\n        }\n      }\n    }\n  }\n\n  // MATLAB Function: '<S11>/MATLAB Function4'\n  if (rtIsNaNF(rtb_Gain_f)) {\n    FLIGHT_hexacopter_B.Product5_l = (rtNaNF);\n  } else if (rtb_Gain_f < 0.0F) {\n    FLIGHT_hexacopter_B.Product5_l = -1.0F;\n  } else {\n    FLIGHT_hexacopter_B.Product5_l = (rtb_Gain_f > 0.0F);\n  }\n\n  // MATLAB Function: '<S11>/MATLAB Function' incorporates:\n  //   RateTransition: '<Root>/Rate Transition'\n  //   Sum: '<S480>/Diff'\n  //\n  //  Block description for '<S480>/Diff':\n  //\n  //   Add in CPU\n\n  FLIGHT_hexacopter_B.Gain3 = (FLIGHT_hexacopter_DW.UD_DSTATE[0] *\n    FLIGHT_hexacopter_DW.RateTransition_Buffer[0] +\n    FLIGHT_hexacopter_DW.UD_DSTATE[1] *\n    FLIGHT_hexacopter_DW.RateTransition_Buffer[1]) +\n    FLIGHT_hexacopter_DW.UD_DSTATE[2] *\n    FLIGHT_hexacopter_DW.RateTransition_Buffer[2];\n\n  // MATLAB Function: '<S11>/MATLAB Function2' incorporates:\n  //   Constant: '<S477>/Constant'\n  //   Constant: '<S477>/Constant1'\n  //   Constant: '<S477>/Constant2'\n  //   MATLAB Function: '<S11>/MATLAB Function'\n  //   MATLAB Function: '<S11>/MATLAB Function4'\n  //   MATLABSystem: '<S11>/Read Parameter3'\n  //   MATLABSystem: '<S11>/Read Parameter4'\n  //   Product: '<S477>/Divide'\n  //   Product: '<S477>/Divide1'\n  //   Product: '<S477>/Divide2'\n  //   Product: '<S477>/Product'\n  //   Product: '<S477>/Product1'\n  //   Product: '<S477>/Product2'\n  //   Product: '<S477>/Product3'\n  //   Product: '<S477>/Product4'\n  //   Product: '<S477>/Product5'\n  //   RateTransition: '<Root>/Rate Transition'\n  //   Saturate: '<S11>/Saturation2'\n  //   Sum: '<S477>/Add'\n  //   Sum: '<S477>/Add1'\n  //   Sum: '<S477>/Add2'\n  //   Sum: '<S479>/Diff'\n  //   UnitDelay: '<S479>/UD'\n  //  *\n  //  Block description for '<S479>/Diff':\n  //\n  //   Add in CPU\n  //\n  //  Block description for '<S479>/UD':\n  //\n  //   Store in Global RAM\n\n  FLIGHT_hexacopter_B.ParamStep = (-(((((((FLIGHT_hexacopter_P.Jzz -\n    FLIGHT_hexacopter_P.Jxx) / FLIGHT_hexacopter_P.Jyy *\n    (FLIGHT_hexacopter_DW.RateTransition_Buffer[0] *\n     FLIGHT_hexacopter_DW.RateTransition_Buffer[2]) *\n    FLIGHT_hexacopter_B.TmpSignalConversionAtSFun_c[1] +\n    (FLIGHT_hexacopter_P.Jyy - FLIGHT_hexacopter_P.Jzz) /\n    FLIGHT_hexacopter_P.Jxx * (FLIGHT_hexacopter_DW.RateTransition_Buffer[1] *\n    FLIGHT_hexacopter_DW.RateTransition_Buffer[2])) + (FLIGHT_hexacopter_P.Jxx -\n    FLIGHT_hexacopter_P.Jyy) / FLIGHT_hexacopter_P.Jzz *\n    (FLIGHT_hexacopter_DW.RateTransition_Buffer[0] *\n     FLIGHT_hexacopter_DW.RateTransition_Buffer[1]) *\n    FLIGHT_hexacopter_B.TmpSignalConversionAtSFun_c[2]) +\n    FLIGHT_hexacopter_B.Gain3) - (rtb_Product5_e -\n    FLIGHT_hexacopter_DW.UD_DSTATE_g)) + (FLIGHT_hexacopter_B.Gain3 - rtb_Gain_p)\n    * 0.0F) + 0.0F * rtb_Product5_dr) + (-FLIGHT_hexacopter_B.ParamStep *\n    FLIGHT_hexacopter_B.Product5_l - FLIGHT_hexacopter_B.ParamStep_m *\n    rtb_Gain_f)) * FLIGHT_hexacopter_B.ypr[0];\n\n  // Saturate: '<S11>/Saturation2'\n  if (FLIGHT_hexacopter_B.ParamStep > FLIGHT_hexacopter_P.Saturation2_UpperSat_i)\n  {\n    FLIGHT_hexacopter_B.ParamStep = FLIGHT_hexacopter_P.Saturation2_UpperSat_i;\n  } else if (FLIGHT_hexacopter_B.ParamStep <\n             FLIGHT_hexacopter_P.Saturation2_LowerSat_k) {\n    FLIGHT_hexacopter_B.ParamStep = FLIGHT_hexacopter_P.Saturation2_LowerSat_k;\n  }\n\n  // RateTransition: '<Root>/Rate Transition1'\n  FLIGHT_hexacopter_DW.RateTransition1_Buffer0 = FLIGHT_hexacopter_B.ParamStep;\n\n  // RateTransition: '<Root>/rate_transition_des_p'\n  FLIGHT_hexacopter_DW.rate_transition_des_p_Buffer0 =\n    FLIGHT_hexacopter_B.Switch2;\n\n  // RateTransition: '<Root>/rate_transition_des_q'\n  FLIGHT_hexacopter_DW.rate_transition_des_q_Buffer0 =\n    FLIGHT_hexacopter_B.Switch2_i;\n  FLIGHT_hexac_PX4Timestamp_n(&FLIGHT_hexacopter_B.PX4Timestamp_i);\n\n  // BusAssignment: '<S510>/Bus Assignment' incorporates:\n  //   Constant: '<S21>/Constant'\n  //   DataTypeConversion: '<S3>/Data Type Conversion9'\n  //   MATLABSystem: '<S510>/PX4 Timestamp'\n\n  FLIGHT_hexacopter_B.BusAssignment_a.timestamp =\n    FLIGHT_hexacopter_B.PX4Timestamp_i.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment_a.roll = FLIGHT_hexacopter_B.Switch2;\n  FLIGHT_hexacopter_B.BusAssignment_a.pitch = FLIGHT_hexacopter_B.Switch2_i;\n  FLIGHT_hexacopter_B.BusAssignment_a.yaw = static_cast<real32_T>\n    (FLIGHT_hexacopter_B.out_yawrate);\n  FLIGHT_hexacopter_B.BusAssignment_a.thrust_body[0] =\n    FLIGHT_hexacopter_P.Constant_Value_ll;\n  FLIGHT_hexacopter_B.BusAssignment_a.thrust_body[1] =\n    FLIGHT_hexacopter_P.Constant_Value_ll;\n  FLIGHT_hexacopter_B.BusAssignment_a.thrust_body[2] = rtb_Saturation1;\n  FLIGHT_hexacopter_B.BusAssignment_a.reset_integral = false;\n  for (FLIGHT_hexacopter_B.ParamStep_k = 0; FLIGHT_hexacopter_B.ParamStep_k < 7;\n       FLIGHT_hexacopter_B.ParamStep_k++) {\n    FLIGHT_hexacopter_B.BusAssignment_a._padding0[FLIGHT_hexacopter_B.ParamStep_k]\n      = 0U;\n  }\n\n  // End of BusAssignment: '<S510>/Bus Assignment'\n\n  // MATLABSystem: '<S512>/SinkBlock' incorporates:\n  //   BusAssignment: '<S510>/Bus Assignment'\n\n  uORB_write_step(FLIGHT_hexacopter_DW.obj_mq.orbMetadataObj,\n                  &FLIGHT_hexacopter_DW.obj_mq.orbAdvertiseObj,\n                  &FLIGHT_hexacopter_B.BusAssignment_a);\n\n  // RateTransition: '<Root>/rate_transition_des_r' incorporates:\n  //   DataTypeConversion: '<S3>/Data Type Conversion9'\n\n  FLIGHT_hexacopter_DW.rate_transition_des_r_Buffer0 = static_cast<real32_T>\n    (FLIGHT_hexacopter_B.out_yawrate);\n  FLIGHT_hexac_PX4Timestamp_n(&FLIGHT_hexacopter_B.PX4Timestamp_nd);\n\n  // BusAssignment: '<S504>/Bus Assignment' incorporates:\n  //   Constant: '<Root>/Constant'\n  //   DataTypeConversion: '<S3>/Data Type Conversion7'\n  //   DataTypeConversion: '<S3>/Data Type Conversion8'\n  //   DataTypeConversion: '<S3>/Data Type Conversion9'\n  //   MATLABSystem: '<S504>/PX4 Timestamp'\n\n  FLIGHT_hexacopter_B.BusAssignment_p.timestamp =\n    FLIGHT_hexacopter_B.PX4Timestamp_nd.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment_p.roll_body = static_cast<real32_T>\n    (FLIGHT_hexacopter_B.out_roll);\n  FLIGHT_hexacopter_B.BusAssignment_p.pitch_body = static_cast<real32_T>\n    (FLIGHT_hexacopter_B.out_pitch);\n  FLIGHT_hexacopter_B.BusAssignment_p.yaw_body =\n    FLIGHT_hexacopter_P.Constant_Value_a5;\n  FLIGHT_hexacopter_B.BusAssignment_p.yaw_sp_move_rate = static_cast<real32_T>\n    (FLIGHT_hexacopter_B.out_yawrate);\n  FLIGHT_hexacopter_B.BusAssignment_p.q_d[0] = 0.0F;\n  FLIGHT_hexacopter_B.BusAssignment_p.q_d[1] = 0.0F;\n  FLIGHT_hexacopter_B.BusAssignment_p.q_d[2] = 0.0F;\n  FLIGHT_hexacopter_B.BusAssignment_p.q_d[3] = 0.0F;\n  FLIGHT_hexacopter_B.BusAssignment_p.thrust_body[0] = 0.0F;\n  FLIGHT_hexacopter_B.BusAssignment_p.thrust_body[1] = 0.0F;\n  FLIGHT_hexacopter_B.BusAssignment_p.thrust_body[2] = 0.0F;\n  FLIGHT_hexacopter_B.BusAssignment_p.reset_integral = false;\n  FLIGHT_hexacopter_B.BusAssignment_p.fw_control_yaw_wheel = false;\n  FLIGHT_hexacopter_B.BusAssignment_p._padding0[0] = 0U;\n  FLIGHT_hexacopter_B.BusAssignment_p._padding0[1] = 0U;\n\n  // MATLABSystem: '<S507>/SinkBlock' incorporates:\n  //   BusAssignment: '<S504>/Bus Assignment'\n\n  uORB_write_step(FLIGHT_hexacopter_DW.obj_ez.orbMetadataObj,\n                  &FLIGHT_hexacopter_DW.obj_ez.orbAdvertiseObj,\n                  &FLIGHT_hexacopter_B.BusAssignment_p);\n  FLIGHT_hexacop_PX4Timestamp(&FLIGHT_hexacopter_B.PX4Timestamp_pn);\n\n  // BusAssignment: '<S20>/Bus Assignment' incorporates:\n  //   Constant: '<S508>/Constant'\n\n  FLIGHT_hexacopter_B.BusAssignment_g = FLIGHT_hexacopter_P.Constant_Value_n;\n\n  // BusAssignment: '<S20>/Bus Assignment' incorporates:\n  //   MATLABSystem: '<S20>/PX4 Timestamp'\n\n  FLIGHT_hexacopter_B.BusAssignment_g.timestamp =\n    FLIGHT_hexacopter_B.PX4Timestamp_pn.PX4Timestamp;\n  FLIGHT_hexacopter_B.BusAssignment_g.vx = rtb_PProdOut_ev_idx_0;\n  FLIGHT_hexacopter_B.BusAssignment_g.vy = rtb_PProdOut_ev_idx_1;\n  FLIGHT_hexacopter_B.BusAssignment_g.vz = FLIGHT_hexacopter_B.Gain_i;\n  FLIGHT_hexacopter_B.BusAssignment_g.x = rtb_des_x;\n  FLIGHT_hexacopter_B.BusAssignment_g.y = rtb_des_z;\n  FLIGHT_hexacopter_B.BusAssignment_g.z = 0.0F;\n\n  // MATLABSystem: '<S509>/SinkBlock' incorporates:\n  //   BusAssignment: '<S20>/Bus Assignment'\n\n  uORB_write_step(FLIGHT_hexacopter_DW.obj_pa.orbMetadataObj,\n                  &FLIGHT_hexacopter_DW.obj_pa.orbAdvertiseObj,\n                  &FLIGHT_hexacopter_B.BusAssignment_g);\n\n  // DeadZone: '<S52>/DeadZone'\n  if (FLIGHT_hexacopter_B.DeadZone >\n      FLIGHT_hexacopter_P.PIDController_UpperSaturationLi) {\n    FLIGHT_hexacopter_B.DeadZone -=\n      FLIGHT_hexacopter_P.PIDController_UpperSaturationLi;\n  } else if (FLIGHT_hexacopter_B.DeadZone >=\n             FLIGHT_hexacopter_P.PIDController_LowerSaturationLi) {\n    FLIGHT_hexacopter_B.DeadZone = 0.0F;\n  } else {\n    FLIGHT_hexacopter_B.DeadZone -=\n      FLIGHT_hexacopter_P.PIDController_LowerSaturationLi;\n  }\n\n  // End of DeadZone: '<S52>/DeadZone'\n\n  // MATLABSystem: '<S1>/Read Parameter3'\n  if (FLIGHT_hexacopter_DW.obj_l5.SampleTime != FLIGHT_hexacopter_P.SampleTime)\n  {\n    FLIGHT_hexacopter_DW.obj_l5.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n  }\n\n  rtb_flag_pos = MW_Param_Step(FLIGHT_hexacopter_DW.obj_l5.MW_PARAMHANDLE,\n    MW_SINGLE, &FLIGHT_hexacopter_B.ParamStep);\n  if (rtb_flag_pos) {\n    FLIGHT_hexacopter_B.ParamStep = 0.0F;\n  }\n\n  // Product: '<S57>/IProd Out' incorporates:\n  //   MATLABSystem: '<S1>/Read Parameter3'\n  //\n  FLIGHT_hexacopter_B.IProdOut_d *= FLIGHT_hexacopter_B.ParamStep;\n\n  // RateTransition: '<Root>/Rate Transition7'\n  FLIGHT_hexacopter_DW.RateTransition7_Buffer0 =\n    FLIGHT_hexacopter_B.In1_n.manual_lockdown;\n\n  // RateTransition: '<Root>/rate_transition_arm'\n  FLIGHT_hexacopter_DW.rate_transition_arm_Buffer0 =\n    FLIGHT_hexacopter_B.In1_n.armed;\n\n  // Switch: '<S50>/Switch1' incorporates:\n  //   Constant: '<S50>/Clamping_zero'\n  //   Constant: '<S50>/Constant'\n  //   Constant: '<S50>/Constant2'\n  //   RelationalOperator: '<S50>/fix for DT propagation issue'\n\n  if (FLIGHT_hexacopter_B.DeadZone > FLIGHT_hexacopter_P.Clamping_zero_Value) {\n    tmp = FLIGHT_hexacopter_P.Constant_Value_ko;\n  } else {\n    tmp = FLIGHT_hexacopter_P.Constant2_Value_e;\n  }\n\n  // Switch: '<S50>/Switch2' incorporates:\n  //   Constant: '<S50>/Clamping_zero'\n  //   Constant: '<S50>/Constant3'\n  //   Constant: '<S50>/Constant4'\n  //   RelationalOperator: '<S50>/fix for DT propagation issue1'\n\n  if (FLIGHT_hexacopter_B.IProdOut_d > FLIGHT_hexacopter_P.Clamping_zero_Value)\n  {\n    tmp_0 = FLIGHT_hexacopter_P.Constant3_Value_i;\n  } else {\n    tmp_0 = FLIGHT_hexacopter_P.Constant4_Value_d;\n  }\n\n  // Switch: '<S50>/Switch' incorporates:\n  //   Constant: '<S50>/Clamping_zero'\n  //   Constant: '<S50>/Constant1'\n  //   Logic: '<S50>/AND3'\n  //   RelationalOperator: '<S50>/Equal1'\n  //   RelationalOperator: '<S50>/Relational Operator'\n  //   Switch: '<S50>/Switch1'\n  //   Switch: '<S50>/Switch2'\n\n  if ((FLIGHT_hexacopter_P.Clamping_zero_Value != FLIGHT_hexacopter_B.DeadZone) &&\n      (tmp == tmp_0)) {\n    FLIGHT_hexacopter_B.IProdOut_d = FLIGHT_hexacopter_P.Constant1_Value_g;\n  }\n\n  // Update for DiscreteIntegrator: '<S60>/Integrator' incorporates:\n  //   Switch: '<S50>/Switch'\n\n  FLIGHT_hexacopter_DW.Integrator_DSTATE +=\n    FLIGHT_hexacopter_P.Integrator_gainval_h * FLIGHT_hexacopter_B.IProdOut_d;\n  if (FLIGHT_hexacopter_DW.Integrator_DSTATE >\n      FLIGHT_hexacopter_P.PIDController_UpperIntegratorSa) {\n    FLIGHT_hexacopter_DW.Integrator_DSTATE =\n      FLIGHT_hexacopter_P.PIDController_UpperIntegratorSa;\n  } else if (FLIGHT_hexacopter_DW.Integrator_DSTATE <\n             FLIGHT_hexacopter_P.PIDController_LowerIntegratorSa) {\n    FLIGHT_hexacopter_DW.Integrator_DSTATE =\n      FLIGHT_hexacopter_P.PIDController_LowerIntegratorSa;\n  }\n\n  FLIGHT_hexacopter_DW.Integrator_PrevResetState = static_cast<int8_T>(rtb_NOT);\n\n  // Update for DiscreteIntegrator: '<S55>/Filter' incorporates:\n  //   DiscreteIntegrator: '<S60>/Integrator'\n\n  FLIGHT_hexacopter_DW.Filter_DSTATE += FLIGHT_hexacopter_P.Filter_gainval *\n    FLIGHT_hexacopter_B.NProdOut;\n  FLIGHT_hexacopter_DW.Filter_PrevResetState = static_cast<int8_T>(rtb_NOT);\n\n  // Update for UnitDelay: '<S480>/UD' incorporates:\n  //   SampleTimeMath: '<S480>/TSamp'\n  //   Sum: '<S480>/Diff'\n  //\n  //  About '<S480>/TSamp':\n  //   y = u * K where K = 1 / ( w * Ts )\n  //    *\n  //  Block description for '<S480>/UD':\n  //\n  //   Store in Global RAM\n  //\n  //  Block description for '<S480>/Diff':\n  //\n  //   Add in CPU\n\n  FLIGHT_hexacopter_DW.UD_DSTATE[0] = FLIGHT_hexacopter_B.TSamp[0];\n  FLIGHT_hexacopter_DW.UD_DSTATE[1] = FLIGHT_hexacopter_B.TSamp[1];\n  FLIGHT_hexacopter_DW.UD_DSTATE[2] = FLIGHT_hexacopter_B.TSamp[2];\n\n  // Update for UnitDelay: '<S478>/UD'\n  //\n  //  Block description for '<S478>/UD':\n  //\n  //   Store in Global RAM\n\n  FLIGHT_hexacopter_DW.UD_DSTATE_j = rtb_Product5_m;\n\n  // Update for UnitDelay: '<S479>/UD'\n  //\n  //  Block description for '<S479>/UD':\n  //\n  //   Store in Global RAM\n\n  FLIGHT_hexacopter_DW.UD_DSTATE_g = rtb_Product5_e;\n\n  // Update for UnitDelay: '<S481>/UD'\n  //\n  //  Block description for '<S481>/UD':\n  //\n  //   Store in Global RAM\n\n  FLIGHT_hexacopter_DW.UD_DSTATE_n = rtb_Product5_k;\n\n  // Update for DiscreteIntegrator: '<S11>/Discrete-Time Integrator'\n  FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE +=\n    FLIGHT_hexacopter_P.DiscreteTimeIntegrator_gainva_c * rtb_Product5_dr;\n}\n\n// Use this function only if you need to maintain compatibility with an existing static main program.\nvoid FLIGHT_hexacopter_step(int_T tid)\n{\n  switch (tid) {\n   case 0 :\n    FLIGHT_hexacopter_step0();\n    break;\n\n   case 1 :\n    FLIGHT_hexacopter_step1();\n    break;\n\n   default :\n    // do nothing\n    break;\n  }\n}\n\n// Model initialize function\nvoid FLIGHT_hexacopter_initialize(void)\n{\n  // Registration code\n\n  // initialize non-finites\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  {\n    static const char_T ParameterNameStr[14] = \"FDD_M1_STATUS\";\n    static const char_T ParameterNameStr_0[14] = \"FDD_M2_STATUS\";\n    static const char_T ParameterNameStr_1[14] = \"FDD_M3_STATUS\";\n    static const char_T ParameterNameStr_2[14] = \"FDD_M4_STATUS\";\n    static const char_T ParameterNameStr_3[14] = \"FDD_M5_STATUS\";\n    static const char_T ParameterNameStr_4[14] = \"FDD_M6_STATUS\";\n    static const char_T ParameterNameStr_5[16] = \"MPC_Z_VEL_P_ACC\";\n    static const char_T ParameterNameStr_6[16] = \"MPC_Z_VEL_D_ACC\";\n    static const char_T ParameterNameStr_7[14] = \"MPC_THR_HOVER\";\n    static const char_T ParameterNameStr_8[17] = \"DOUBLET_PEAK_ANG\";\n    static const char_T ParameterNameStr_9[11] = \"DOUBLET_DT\";\n    static const char_T ParameterNameStr_a[13] = \"DOUBLET_AXIS\";\n    static const char_T ParameterNameStr_b[8] = \"K_SMC_P\";\n    static const char_T ParameterNameStr_c[8] = \"K_SMC_I\";\n    static const char_T ParameterNameStr_d[8] = \"K_SMC_D\";\n    static const char_T ParameterNameStr_e[10] = \"K_REACH_S\";\n    static const char_T ParameterNameStr_f[10] = \"K_REACH_P\";\n    static const char_T ParameterNameStr_g[16] = \"MPC_Z_VEL_I_ACC\";\n    static const char_T ParameterNameStr_h[16] = \"MC_ROLLRATE_MAX\";\n    static const char_T ParameterNameStr_i[10] = \"MC_ROLL_P\";\n    static const char_T ParameterNameStr_j[17] = \"MC_PITCHRATE_MAX\";\n    static const char_T ParameterNameStr_k[11] = \"MC_PITCH_P\";\n    static const char_T ParameterNameStr_l[9] = \"MPC_XY_P\";\n    static const char_T ParameterNameStr_m[17] = \"MPC_XY_VEL_P_ACC\";\n    static const char_T ParameterNameStr_n[17] = \"IMU_DGYRO_CUTOFF\";\n    static const char_T ParameterNameStr_o[15] = \"MC_PITCHRATE_D\";\n    static const char_T ParameterNameStr_p[15] = \"MC_PITCHRATE_P\";\n    static const char_T ParameterNameStr_q[15] = \"MC_PITCHRATE_I\";\n    static const char_T ParameterNameStr_r[14] = \"MC_ROLLRATE_D\";\n    static const char_T ParameterNameStr_s[14] = \"MC_ROLLRATE_P\";\n    static const char_T ParameterNameStr_t[14] = \"MC_ROLLRATE_I\";\n    static const char_T ParameterNameStr_u[13] = \"MC_YAWRATE_D\";\n    static const char_T ParameterNameStr_v[13] = \"MC_YAWRATE_P\";\n    static const char_T ParameterNameStr_w[14] = \"MC_YAWRATE_FF\";\n    static const char_T ParameterNameStr_x[13] = \"MC_YAWRATE_I\";\n    real_T tmp;\n    int32_T i;\n\n    // Start for RateTransition: '<Root>/rate_transition_arm'\n    FLIGHT_hexacopter_B.rate_transition_arm =\n      FLIGHT_hexacopter_P.rate_transition_arm_InitialCond;\n\n    // Start for RateTransition: '<Root>/rate_transition_des_p'\n    FLIGHT_hexacopter_B.rate_transition_des_p =\n      FLIGHT_hexacopter_P.rate_transition_des_p_InitialCo;\n\n    // Start for RateTransition: '<Root>/rate_transition_des_q'\n    FLIGHT_hexacopter_B.rate_transition_des_q =\n      FLIGHT_hexacopter_P.rate_transition_des_q_InitialCo;\n\n    // Start for RateTransition: '<Root>/rate_transition_des_r'\n    FLIGHT_hexacopter_B.rate_transition_des_r =\n      FLIGHT_hexacopter_P.rate_transition_des_r_InitialCo;\n\n    // Start for RateTransition: '<Root>/Rate Transition1'\n    FLIGHT_hexacopter_B.RateTransition1 =\n      FLIGHT_hexacopter_P.RateTransition1_InitialConditio;\n\n    // Start for RateTransition: '<Root>/rate_transition_ctrl_sw'\n    FLIGHT_hexacopter_B.rate_transition_ctrl_sw =\n      FLIGHT_hexacopter_P.rate_transition_ctrl_sw_Initial;\n\n    // Start for RateTransition: '<Root>/rate_transition_throttle'\n    FLIGHT_hexacopter_B.rate_transition_throttle =\n      FLIGHT_hexacopter_P.rate_transition_throttle_Initia;\n\n    // Start for RateTransition: '<Root>/Rate Transition4'\n    FLIGHT_hexacopter_B.RateTransition4 =\n      FLIGHT_hexacopter_P.RateTransition4_InitialConditio;\n\n    // Start for RateTransition: '<Root>/Rate Transition7'\n    FLIGHT_hexacopter_B.RateTransition7 =\n      FLIGHT_hexacopter_P.RateTransition7_InitialConditio;\n\n    // InitializeConditions for RateTransition: '<Root>/rate_transition_arm'\n    FLIGHT_hexacopter_DW.rate_transition_arm_Buffer0 =\n      FLIGHT_hexacopter_P.rate_transition_arm_InitialCond;\n\n    // InitializeConditions for RateTransition: '<Root>/rate_transition_des_p'\n    FLIGHT_hexacopter_DW.rate_transition_des_p_Buffer0 =\n      FLIGHT_hexacopter_P.rate_transition_des_p_InitialCo;\n\n    // InitializeConditions for RateTransition: '<Root>/rate_transition_des_q'\n    FLIGHT_hexacopter_DW.rate_transition_des_q_Buffer0 =\n      FLIGHT_hexacopter_P.rate_transition_des_q_InitialCo;\n\n    // InitializeConditions for RateTransition: '<Root>/rate_transition_des_r'\n    FLIGHT_hexacopter_DW.rate_transition_des_r_Buffer0 =\n      FLIGHT_hexacopter_P.rate_transition_des_r_InitialCo;\n\n    // InitializeConditions for RateTransition: '<Root>/Rate Transition1'\n    FLIGHT_hexacopter_DW.RateTransition1_Buffer0 =\n      FLIGHT_hexacopter_P.RateTransition1_InitialConditio;\n\n    // InitializeConditions for RateTransition: '<Root>/rate_transition_ctrl_sw' \n    FLIGHT_hexacopter_DW.rate_transition_ctrl_sw_Buffer0 =\n      FLIGHT_hexacopter_P.rate_transition_ctrl_sw_Initial;\n\n    // InitializeConditions for RateTransition: '<Root>/rate_transition_throttle' \n    FLIGHT_hexacopter_DW.rate_transition_throttle_Buffer =\n      FLIGHT_hexacopter_P.rate_transition_throttle_Initia;\n\n    // InitializeConditions for RateTransition: '<Root>/Rate Transition4'\n    FLIGHT_hexacopter_DW.RateTransition4_Buffer0 =\n      FLIGHT_hexacopter_P.RateTransition4_InitialConditio;\n\n    // InitializeConditions for RateTransition: '<Root>/Rate Transition7'\n    FLIGHT_hexacopter_DW.RateTransition7_Buffer0 =\n      FLIGHT_hexacopter_P.RateTransition7_InitialConditio;\n\n    // InitializeConditions for DiscreteIntegrator: '<S60>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE =\n      FLIGHT_hexacopter_P.PIDController_InitialConditio_a;\n\n    // InitializeConditions for DiscreteIntegrator: '<S55>/Filter'\n    FLIGHT_hexacopter_DW.Filter_DSTATE =\n      FLIGHT_hexacopter_P.PIDController_InitialConditionF;\n\n    // InitializeConditions for UnitDelay: '<S480>/UD' incorporates:\n    //   Sum: '<S480>/Diff'\n    //\n    //  Block description for '<S480>/UD':\n    //\n    //   Store in Global RAM\n    //\n    //  Block description for '<S480>/Diff':\n    //\n    //   Add in CPU\n\n    FLIGHT_hexacopter_DW.UD_DSTATE[0] =\n      FLIGHT_hexacopter_P.DiscreteDerivative2_ICPrevSca_a;\n    FLIGHT_hexacopter_DW.UD_DSTATE[1] =\n      FLIGHT_hexacopter_P.DiscreteDerivative2_ICPrevSca_a;\n    FLIGHT_hexacopter_DW.UD_DSTATE[2] =\n      FLIGHT_hexacopter_P.DiscreteDerivative2_ICPrevSca_a;\n\n    // InitializeConditions for UnitDelay: '<S478>/UD'\n    //\n    //  Block description for '<S478>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_j =\n      FLIGHT_hexacopter_P.DiscreteDerivative_ICPrevScaled;\n\n    // InitializeConditions for UnitDelay: '<S479>/UD'\n    //\n    //  Block description for '<S479>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_g =\n      FLIGHT_hexacopter_P.DiscreteDerivative1_ICPrevScale;\n\n    // InitializeConditions for UnitDelay: '<S481>/UD'\n    //\n    //  Block description for '<S481>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_n =\n      FLIGHT_hexacopter_P.DiscreteDerivative3_ICPrevScale;\n\n    // InitializeConditions for DiscreteIntegrator: '<S11>/Discrete-Time Integrator' \n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_DSTATE =\n      FLIGHT_hexacopter_P.DiscreteTimeIntegrator_IC;\n\n    // SystemInitialize for Enabled SubSystem: '<Root>/CAS'\n    // Start for MATLABSystem: '<S2>/Read Parameter9'\n    FLIGHT_hexacopter_DW.obj_k4.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_k4.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_k4.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_k4.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_k4.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_k4.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_h[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_k4.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S2>/Read Parameter9'\n\n    // Start for MATLABSystem: '<S2>/Read Parameter'\n    FLIGHT_hexacopter_DW.obj_jz.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_jz.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_jz.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_jz.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_jz.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_jz.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_i[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_jz.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S2>/Read Parameter'\n\n    // Start for MATLABSystem: '<S2>/Read Parameter10'\n    FLIGHT_hexacopter_DW.obj_ds.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_ds.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_ds.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_ds.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_ds.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_ds.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_j[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_ds.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S2>/Read Parameter10'\n\n    // Start for MATLABSystem: '<S2>/Read Parameter1'\n    FLIGHT_hexacopter_DW.obj_o.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_o.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_o.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_o.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_o.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_o.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_k[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_o.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S2>/Read Parameter1'\n\n    // SystemInitialize for Switch: '<S173>/Switch2' incorporates:\n    //   Outport: '<S2>/des_p'\n\n    FLIGHT_hexacopter_B.Switch2 = FLIGHT_hexacopter_P.des_p_Y0;\n\n    // SystemInitialize for Switch: '<S122>/Switch2' incorporates:\n    //   Outport: '<S2>/des_q'\n\n    FLIGHT_hexacopter_B.Switch2_i = FLIGHT_hexacopter_P.des_q_Y0;\n\n    // End of SystemInitialize for SubSystem: '<Root>/CAS'\n\n    // SystemInitialize for MATLAB Function: '<S3>/MATLAB Function'\n    FLIGHT_hexacopter_DW.start_time_usec = -1.0;\n\n    // SystemInitialize for Atomic SubSystem: '<Root>/If Action Subsystem'\n    // InitializeConditions for DiscreteIntegrator: '<S5>/Discrete-Time Integrator' \n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator_IC_LOADI = 1U;\n\n    // InitializeConditions for DiscreteIntegrator: '<S5>/Discrete-Time Integrator1' \n    FLIGHT_hexacopter_DW.DiscreteTimeIntegrator1_IC_LOAD = 1U;\n\n    // Start for MATLABSystem: '<S194>/Read Parameter'\n    FLIGHT_hexacopter_DW.obj_eq.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_eq.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_eq.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_eq.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_eq.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_eq.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_l[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_eq.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S194>/Read Parameter'\n\n    // Start for MATLABSystem: '<S195>/Read Parameter'\n    FLIGHT_hexacopter_DW.obj_pi.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_pi.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_pi.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_pi.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_pi.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_pi.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_m[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_pi.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S195>/Read Parameter'\n    // End of SystemInitialize for SubSystem: '<Root>/If Action Subsystem'\n\n    // SystemInitialize for Enabled SubSystem: '<Root>/Mixer'\n    for (i = 0; i < 6; i++) {\n      // SystemInitialize for Saturate: '<S7>/Output_Limits1' incorporates:\n      //   Outport: '<S7>/PWM'\n\n      FLIGHT_hexacopter_B.Output_Limits1[i] = FLIGHT_hexacopter_P.PWM_Y0;\n    }\n\n    // End of SystemInitialize for SubSystem: '<Root>/Mixer'\n\n    // SystemInitialize for Enabled SubSystem: '<S301>/Enabled Subsystem'\n    // SystemInitialize for SignalConversion generated from: '<S303>/In1' incorporates:\n    //   Outport: '<S303>/Out1'\n\n    FLIGHT_hexacopter_B.In1 = FLIGHT_hexacopter_P.Out1_Y0;\n\n    // End of SystemInitialize for SubSystem: '<S301>/Enabled Subsystem'\n\n    // SystemInitialize for Enabled SubSystem: '<S304>/Enabled Subsystem'\n    // SystemInitialize for SignalConversion generated from: '<S305>/In1' incorporates:\n    //   Outport: '<S305>/Out1'\n\n    FLIGHT_hexacopter_B.In1_k = FLIGHT_hexacopter_P.Out1_Y0_d;\n\n    // End of SystemInitialize for SubSystem: '<S304>/Enabled Subsystem'\n\n    // SystemInitialize for Enabled SubSystem: '<S306>/Enabled Subsystem'\n    // SystemInitialize for SignalConversion generated from: '<S307>/In1' incorporates:\n    //   Outport: '<S307>/Out1'\n\n    FLIGHT_hexacopter_B.In1_i = FLIGHT_hexacopter_P.Out1_Y0_o;\n\n    // End of SystemInitialize for SubSystem: '<S306>/Enabled Subsystem'\n\n    // SystemInitialize for Enabled SubSystem: '<Root>/SAS'\n    // InitializeConditions for UnitDelay: '<S315>/Unit Delay1'\n    FLIGHT_hexacopter_DW.UnitDelay1_DSTATE =\n      FLIGHT_hexacopter_P.UnitDelay1_InitialCondition;\n\n    // InitializeConditions for UnitDelay: '<S315>/Unit Delay2'\n    FLIGHT_hexacopter_DW.UnitDelay2_DSTATE =\n      FLIGHT_hexacopter_P.UnitDelay2_InitialCondition;\n\n    // InitializeConditions for UnitDelay: '<S312>/UD'\n    //\n    //  Block description for '<S312>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_l =\n      FLIGHT_hexacopter_P.DiscreteDerivative2_ICPrevScale;\n\n    // InitializeConditions for DiscreteIntegrator: '<S350>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_p =\n      FLIGHT_hexacopter_P.pid_ctrl_rollrate_InitialCondit;\n\n    // InitializeConditions for UnitDelay: '<S370>/Unit Delay1'\n    FLIGHT_hexacopter_DW.UnitDelay1_DSTATE_f =\n      FLIGHT_hexacopter_P.UnitDelay1_InitialCondition_p;\n\n    // InitializeConditions for UnitDelay: '<S370>/Unit Delay2'\n    FLIGHT_hexacopter_DW.UnitDelay2_DSTATE_c =\n      FLIGHT_hexacopter_P.UnitDelay2_InitialCondition_e;\n\n    // InitializeConditions for UnitDelay: '<S367>/UD'\n    //\n    //  Block description for '<S367>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_m =\n      FLIGHT_hexacopter_P.DiscreteDerivative2_ICPrevSca_n;\n\n    // InitializeConditions for DiscreteIntegrator: '<S405>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_c =\n      FLIGHT_hexacopter_P.pid_ctrl_rollrate_InitialCond_j;\n\n    // InitializeConditions for UnitDelay: '<S425>/Unit Delay1'\n    FLIGHT_hexacopter_DW.UnitDelay1_DSTATE_e =\n      FLIGHT_hexacopter_P.UnitDelay1_InitialCondition_e;\n\n    // InitializeConditions for UnitDelay: '<S425>/Unit Delay2'\n    FLIGHT_hexacopter_DW.UnitDelay2_DSTATE_e =\n      FLIGHT_hexacopter_P.UnitDelay2_InitialCondition_m;\n\n    // InitializeConditions for UnitDelay: '<S422>/UD'\n    //\n    //  Block description for '<S422>/UD':\n    //\n    //   Store in Global RAM\n\n    FLIGHT_hexacopter_DW.UD_DSTATE_jy =\n      FLIGHT_hexacopter_P.DiscreteDerivative2_ICPrevSca_o;\n\n    // InitializeConditions for DiscreteIntegrator: '<S460>/Integrator'\n    FLIGHT_hexacopter_DW.Integrator_DSTATE_g =\n      FLIGHT_hexacopter_P.pid_ctrl_rollrate_InitialCond_p;\n\n    // Start for MATLABSystem: '<S10>/Read Parameter10'\n    FLIGHT_hexacopter_DW.obj_c.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_c.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_c.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_c.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_c.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_c.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_n[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_c.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter10'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter5'\n    FLIGHT_hexacopter_DW.obj_h.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_h.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_h.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_h.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_h.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_h.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_o[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_h.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter5'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter3'\n    FLIGHT_hexacopter_DW.obj_b.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_b.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_b.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_b.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_b.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_b.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_p[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_b.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter3'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter4'\n    FLIGHT_hexacopter_DW.obj_p.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_p.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_p.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_p.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_p.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_p.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_q[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_p.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter4'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter2'\n    FLIGHT_hexacopter_DW.obj_da.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_da.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_da.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_da.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_da.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_da.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_r[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_da.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter2'\n\n    // Start for MATLABSystem: '<S10>/read_mc_rollrate_p'\n    FLIGHT_hexacopter_DW.obj_i.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_i.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_i.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_i.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_i.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_i.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_s[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_i.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/read_mc_rollrate_p'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter1'\n    FLIGHT_hexacopter_DW.obj_ea.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_ea.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_ea.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_ea.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_ea.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_ea.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_t[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_ea.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter1'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter8'\n    FLIGHT_hexacopter_DW.obj_i4.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_i4.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_i4.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_i4.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_i4.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_i4.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_u[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_i4.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter8'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter6'\n    FLIGHT_hexacopter_DW.obj_a.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_a.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_a.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_a.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_a.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_a.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_v[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_a.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter6'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter9'\n    FLIGHT_hexacopter_DW.obj_e.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_e.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_e.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_e.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_e.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_e.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_w[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_e.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter9'\n\n    // Start for MATLABSystem: '<S10>/Read Parameter7'\n    FLIGHT_hexacopter_DW.obj_j.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_j.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_j.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_j.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_j.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_j.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_x[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_j.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S10>/Read Parameter7'\n\n    // SystemInitialize for Sum: '<S310>/Sum5' incorporates:\n    //   Outport: '<S10>/tau_roll'\n\n    FLIGHT_hexacopter_B.Sum5_d = FLIGHT_hexacopter_P.tau_roll_Y0;\n\n    // SystemInitialize for Sum: '<S309>/Sum5' incorporates:\n    //   Outport: '<S10>/tau_pitch'\n\n    FLIGHT_hexacopter_B.Sum5 = FLIGHT_hexacopter_P.tau_pitch_Y0;\n\n    // SystemInitialize for Sum: '<S10>/Sum' incorporates:\n    //   Outport: '<S10>/tau_yaw'\n\n    FLIGHT_hexacopter_B.Sum = FLIGHT_hexacopter_P.tau_yaw_Y0;\n\n    // End of SystemInitialize for SubSystem: '<Root>/SAS'\n\n    // SystemInitialize for Enabled SubSystem: '<S497>/Enabled Subsystem'\n    // SystemInitialize for SignalConversion generated from: '<S498>/In1' incorporates:\n    //   Outport: '<S498>/Out1'\n\n    FLIGHT_hexacopter_B.In1_h = FLIGHT_hexacopter_P.Out1_Y0_p;\n\n    // End of SystemInitialize for SubSystem: '<S497>/Enabled Subsystem'\n\n    // SystemInitialize for Enabled SubSystem: '<S501>/Enabled Subsystem'\n    // SystemInitialize for SignalConversion generated from: '<S503>/In1' incorporates:\n    //   Outport: '<S503>/Out1'\n\n    FLIGHT_hexacopter_B.In1_f = FLIGHT_hexacopter_P.Out1_Y0_a;\n\n    // End of SystemInitialize for SubSystem: '<S501>/Enabled Subsystem'\n\n    // SystemInitialize for Enabled SubSystem: '<S500>/Enabled Subsystem'\n    // SystemInitialize for SignalConversion generated from: '<S502>/In1' incorporates:\n    //   Outport: '<S502>/Out1'\n\n    FLIGHT_hexacopter_B.In1_n = FLIGHT_hexacopter_P.Out1_Y0_h;\n\n    // End of SystemInitialize for SubSystem: '<S500>/Enabled Subsystem'\n\n    // Start for MATLABSystem: '<S497>/SourceBlock'\n    FLIGHT_hexacopter_DW.obj_pe.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_pe.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_pe.orbMetadataObj = ORB_ID(vehicle_angular_velocity);\n    uORB_read_initialize(FLIGHT_hexacopter_DW.obj_pe.orbMetadataObj,\n                         &FLIGHT_hexacopter_DW.obj_pe.eventStructObj);\n    FLIGHT_hexacopter_DW.obj_pe.isSetupComplete = true;\n\n    // Start for MATLABSystem: '<S4>/Read Parameter13'\n    FLIGHT_hexacopter_DW.obj_gv.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_gv.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_gv.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_gv.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_gv.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_gv.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_gv.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter13'\n\n    // Start for MATLABSystem: '<S4>/Read Parameter1'\n    FLIGHT_hexacopter_DW.obj_j5.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_j5.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_j5.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_j5.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_j5.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_j5.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_0[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_j5.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter1'\n\n    // Start for MATLABSystem: '<S4>/Read Parameter2'\n    FLIGHT_hexacopter_DW.obj_ao.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_ao.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_ao.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_ao.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_ao.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_ao.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_1[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_ao.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter2'\n\n    // Start for MATLABSystem: '<S4>/Read Parameter3'\n    FLIGHT_hexacopter_DW.obj_nt.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_nt.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_nt.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_nt.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_nt.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_nt.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_2[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_nt.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter3'\n\n    // Start for MATLABSystem: '<S4>/Read Parameter4'\n    FLIGHT_hexacopter_DW.obj_cx.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_cx.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_cx.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_cx.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_cx.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_cx.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_3[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_cx.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter4'\n\n    // Start for MATLABSystem: '<S4>/Read Parameter5'\n    FLIGHT_hexacopter_DW.obj_aq.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_aq.SampleTime = FLIGHT_hexacopter_P.SampleTime_SAS;\n    FLIGHT_hexacopter_DW.obj_aq.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_aq.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_aq.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_aq.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_4[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_aq.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S4>/Read Parameter5'\n\n    // Start for MATLABSystem: '<Root>/PX4 PWM Output'\n    FLIGHT_hexacopter_DW.obj_dl.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_dl.isSetupComplete = false;\n    FLIGHT_hexacopter_DW.obj_dl.isInitialized = 1;\n    FLIGHT_hexacopter_PWM_setupImpl(&FLIGHT_hexacopter_DW.obj_dl, false, false);\n    FLIGHT_hexacopter_DW.obj_dl.isSetupComplete = true;\n    FLIGHT__PX4Timestamp_b_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_n);\n    FLIGHT__PX4Timestamp_b_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_p);\n\n    // Start for MATLABSystem: '<S496>/SinkBlock' incorporates:\n    //   BusAssignment: '<S494>/Bus Assignment'\n\n    FLIGHT_hexacopter_DW.obj_hf.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_hf.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_hf.orbMetadataObj = ORB_ID(actuator_motors);\n    uORB_write_initialize(FLIGHT_hexacopter_DW.obj_hf.orbMetadataObj,\n                          &FLIGHT_hexacopter_DW.obj_hf.orbAdvertiseObj,\n                          &FLIGHT_hexacopter_B.BusAssignment, 1);\n    FLIGHT_hexacopter_DW.obj_hf.isSetupComplete = true;\n    FLIGHT__PX4Timestamp_b_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_o);\n\n    // Start for MATLABSystem: '<S492>/SinkBlock' incorporates:\n    //   BusAssignment: '<S490>/Bus Assignment'\n\n    FLIGHT_hexacopter_DW.obj_jk.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_jk.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_jk.orbMetadataObj = ORB_ID\n      (actuator_controls_status_0);\n    uORB_write_initialize(FLIGHT_hexacopter_DW.obj_jk.orbMetadataObj,\n                          &FLIGHT_hexacopter_DW.obj_jk.orbAdvertiseObj,\n                          &FLIGHT_hexacopter_B.BusAssignment_gi, 1);\n    FLIGHT_hexacopter_DW.obj_jk.isSetupComplete = true;\n\n    // Start for MATLABSystem: '<S306>/SourceBlock'\n    FLIGHT_hexacopter_DW.obj_n2.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_n2.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_n2.orbMetadataObj = ORB_ID(input_rc);\n    uORB_read_initialize(FLIGHT_hexacopter_DW.obj_n2.orbMetadataObj,\n                         &FLIGHT_hexacopter_DW.obj_n2.eventStructObj);\n    FLIGHT_hexacopter_DW.obj_n2.isSetupComplete = true;\n\n    // Start for MATLABSystem: '<S304>/SourceBlock'\n    FLIGHT_hexacopter_DW.obj_ab.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_ab.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_ab.orbMetadataObj = ORB_ID(vehicle_odometry);\n    uORB_read_initialize(FLIGHT_hexacopter_DW.obj_ab.orbMetadataObj,\n                         &FLIGHT_hexacopter_DW.obj_ab.eventStructObj);\n    FLIGHT_hexacopter_DW.obj_ab.isSetupComplete = true;\n\n    // Start for MATLABSystem: '<S500>/SourceBlock'\n    FLIGHT_hexacopter_DW.obj_hm.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_hm.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_hm.orbMetadataObj = ORB_ID(actuator_armed);\n    uORB_read_initialize(FLIGHT_hexacopter_DW.obj_hm.orbMetadataObj,\n                         &FLIGHT_hexacopter_DW.obj_hm.eventStructObj);\n    FLIGHT_hexacopter_DW.obj_hm.isSetupComplete = true;\n\n    // Start for MATLABSystem: '<S301>/SourceBlock'\n    FLIGHT_hexacopter_DW.obj_kk.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_kk.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_kk.orbMetadataObj = ORB_ID(vehicle_local_position);\n    uORB_read_initialize(FLIGHT_hexacopter_DW.obj_kk.orbMetadataObj,\n                         &FLIGHT_hexacopter_DW.obj_kk.eventStructObj);\n    FLIGHT_hexacopter_DW.obj_kk.isSetupComplete = true;\n\n    // Start for MATLABSystem: '<S1>/Read Parameter2'\n    FLIGHT_hexacopter_DW.obj_in.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_in.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_in.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_in.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_in.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_in.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_5[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_in.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S1>/Read Parameter2'\n\n    // Start for MATLABSystem: '<S1>/Read Parameter4'\n    FLIGHT_hexacopter_DW.obj_lx.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_lx.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_lx.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_lx.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_lx.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_lx.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_6[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_lx.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S1>/Read Parameter4'\n\n    // Start for MATLABSystem: '<S1>/Read Parameter1'\n    FLIGHT_hexacopter_DW.obj_m.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_m.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_m.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_m.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_m.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_m.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_7[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_m.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S1>/Read Parameter1'\n\n    // Start for MATLABSystem: '<S501>/SourceBlock'\n    FLIGHT_hexacopter_DW.obj_bw.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_bw.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_bw.orbMetadataObj = ORB_ID(vehicle_status);\n    uORB_read_initialize(FLIGHT_hexacopter_DW.obj_bw.orbMetadataObj,\n                         &FLIGHT_hexacopter_DW.obj_bw.eventStructObj);\n    FLIGHT_hexacopter_DW.obj_bw.isSetupComplete = true;\n    FLIGHT_he_PX4Timestamp_Init(&FLIGHT_hexacopter_DW.PX4Timestamp);\n\n    // Start for MATLABSystem: '<S3>/Read Parameter1'\n    FLIGHT_hexacopter_DW.obj_ct.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_ct.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_ct.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_ct.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_ct.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_ct.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_8[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_ct.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S3>/Read Parameter1'\n\n    // Start for MATLABSystem: '<S3>/Read Parameter'\n    FLIGHT_hexacopter_DW.obj_cf.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_cf.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_cf.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_cf.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_cf.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_cf.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_9[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_cf.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S3>/Read Parameter'\n\n    // Start for MATLABSystem: '<S3>/Read Parameter2'\n    FLIGHT_hexacopter_DW.obj_l.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_l.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_l.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_l.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_l.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_l.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_a[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_l.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S3>/Read Parameter2'\n\n    // Start for MATLABSystem: '<S11>/Read Parameter'\n    FLIGHT_hexacopter_DW.obj_g.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_g.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_g.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_g.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_g.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_g.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_b[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_g.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S11>/Read Parameter'\n\n    // Start for MATLABSystem: '<S11>/Read Parameter1'\n    FLIGHT_hexacopter_DW.obj_d.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_d.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_d.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_d.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_d.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_d.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_c[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_d.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S11>/Read Parameter1'\n\n    // Start for MATLABSystem: '<S11>/Read Parameter2'\n    FLIGHT_hexacopter_DW.obj_k.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_k.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_k.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_k.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_k.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_k.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_d[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_k.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S11>/Read Parameter2'\n\n    // Start for MATLABSystem: '<S11>/Read Parameter3'\n    FLIGHT_hexacopter_DW.obj_n.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_n.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_n.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_n.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_n.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_n.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_e[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_n.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S11>/Read Parameter3'\n\n    // Start for MATLABSystem: '<S11>/Read Parameter4'\n    FLIGHT_hexacopter_DW.obj.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj.MW_PARAMHANDLE = MW_Init_Param(&ParameterNameStr_f\n      [0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S11>/Read Parameter4'\n    FLIGHT__PX4Timestamp_m_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_i);\n\n    // Start for MATLABSystem: '<S512>/SinkBlock' incorporates:\n    //   BusAssignment: '<S510>/Bus Assignment'\n\n    FLIGHT_hexacopter_DW.obj_mq.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_mq.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_mq.orbMetadataObj = ORB_ID(vehicle_rates_setpoint);\n    uORB_write_initialize(FLIGHT_hexacopter_DW.obj_mq.orbMetadataObj,\n                          &FLIGHT_hexacopter_DW.obj_mq.orbAdvertiseObj,\n                          &FLIGHT_hexacopter_B.BusAssignment_a, 1);\n    FLIGHT_hexacopter_DW.obj_mq.isSetupComplete = true;\n    FLIGHT__PX4Timestamp_m_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_nd);\n\n    // Start for MATLABSystem: '<S507>/SinkBlock' incorporates:\n    //   BusAssignment: '<S504>/Bus Assignment'\n\n    FLIGHT_hexacopter_DW.obj_ez.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_ez.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_ez.orbMetadataObj = ORB_ID\n      (vehicle_attitude_setpoint);\n    uORB_write_initialize(FLIGHT_hexacopter_DW.obj_ez.orbMetadataObj,\n                          &FLIGHT_hexacopter_DW.obj_ez.orbAdvertiseObj,\n                          &FLIGHT_hexacopter_B.BusAssignment_p, 1);\n    FLIGHT_hexacopter_DW.obj_ez.isSetupComplete = true;\n    FLIGHT_he_PX4Timestamp_Init(&FLIGHT_hexacopter_DW.PX4Timestamp_pn);\n\n    // Start for MATLABSystem: '<S509>/SinkBlock' incorporates:\n    //   BusAssignment: '<S20>/Bus Assignment'\n\n    FLIGHT_hexacopter_DW.obj_pa.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_pa.isInitialized = 1;\n    FLIGHT_hexacopter_DW.obj_pa.orbMetadataObj = ORB_ID\n      (vehicle_local_position_setpoint);\n    uORB_write_initialize(FLIGHT_hexacopter_DW.obj_pa.orbMetadataObj,\n                          &FLIGHT_hexacopter_DW.obj_pa.orbAdvertiseObj,\n                          &FLIGHT_hexacopter_B.BusAssignment_g, 1);\n    FLIGHT_hexacopter_DW.obj_pa.isSetupComplete = true;\n\n    // Start for MATLABSystem: '<S1>/Read Parameter3'\n    FLIGHT_hexacopter_DW.obj_l5.matlabCodegenIsDeleted = false;\n    FLIGHT_hexacopter_DW.obj_l5.SampleTime = FLIGHT_hexacopter_P.SampleTime;\n    FLIGHT_hexacopter_DW.obj_l5.isInitialized = 1;\n    if (FLIGHT_hexacopter_DW.obj_l5.SampleTime == -1.0) {\n      tmp = 0.2;\n    } else {\n      tmp = FLIGHT_hexacopter_DW.obj_l5.SampleTime;\n    }\n\n    FLIGHT_hexacopter_DW.obj_l5.MW_PARAMHANDLE = MW_Init_Param\n      (&ParameterNameStr_g[0], true, tmp * 1000.0);\n    FLIGHT_hexacopter_DW.obj_l5.isSetupComplete = true;\n\n    // End of Start for MATLABSystem: '<S1>/Read Parameter3'\n  }\n}\n\n// Model terminate function\nvoid FLIGHT_hexacopter_terminate(void)\n{\n  // Terminate for MATLABSystem: '<S497>/SourceBlock'\n  if (!FLIGHT_hexacopter_DW.obj_pe.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_pe.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_pe.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_pe.isSetupComplete) {\n      uORB_read_terminate(&FLIGHT_hexacopter_DW.obj_pe.eventStructObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S497>/SourceBlock'\n\n  // Terminate for Enabled SubSystem: '<Root>/SAS'\n  // Terminate for MATLABSystem: '<S10>/Read Parameter10'\n  if (!FLIGHT_hexacopter_DW.obj_c.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_c.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter10'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter5'\n  if (!FLIGHT_hexacopter_DW.obj_h.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_h.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter5'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter3'\n  if (!FLIGHT_hexacopter_DW.obj_b.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_b.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter3'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter4'\n  if (!FLIGHT_hexacopter_DW.obj_p.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_p.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter4'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter2'\n  if (!FLIGHT_hexacopter_DW.obj_da.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_da.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter2'\n\n  // Terminate for MATLABSystem: '<S10>/read_mc_rollrate_p'\n  if (!FLIGHT_hexacopter_DW.obj_i.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_i.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/read_mc_rollrate_p'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter1'\n  if (!FLIGHT_hexacopter_DW.obj_ea.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_ea.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter1'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter8'\n  if (!FLIGHT_hexacopter_DW.obj_i4.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_i4.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter8'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter6'\n  if (!FLIGHT_hexacopter_DW.obj_a.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_a.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter6'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter9'\n  if (!FLIGHT_hexacopter_DW.obj_e.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_e.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter9'\n\n  // Terminate for MATLABSystem: '<S10>/Read Parameter7'\n  if (!FLIGHT_hexacopter_DW.obj_j.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_j.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S10>/Read Parameter7'\n  // End of Terminate for SubSystem: '<Root>/SAS'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter13'\n  if (!FLIGHT_hexacopter_DW.obj_gv.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_gv.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter13'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter1'\n  if (!FLIGHT_hexacopter_DW.obj_j5.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_j5.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter1'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter2'\n  if (!FLIGHT_hexacopter_DW.obj_ao.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_ao.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter2'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter3'\n  if (!FLIGHT_hexacopter_DW.obj_nt.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_nt.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter3'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter4'\n  if (!FLIGHT_hexacopter_DW.obj_cx.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_cx.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter4'\n\n  // Terminate for MATLABSystem: '<S4>/Read Parameter5'\n  if (!FLIGHT_hexacopter_DW.obj_aq.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_aq.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S4>/Read Parameter5'\n\n  // Terminate for MATLABSystem: '<Root>/PX4 PWM Output'\n  if (!FLIGHT_hexacopter_DW.obj_dl.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_dl.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_dl.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_dl.isSetupComplete) {\n      pwm_disarm(&FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n      pwm_resetServo(FLIGHT_hexacopter_DW.obj_dl.servoCount,\n                     FLIGHT_hexacopter_DW.obj_dl.isMain,\n                     &FLIGHT_hexacopter_DW.obj_dl.actuatorAdvertiseObj);\n      pwm_close(FLIGHT_hexacopter_DW.obj_dl.servoCount,\n                &FLIGHT_hexacopter_DW.obj_dl.actuatorAdvertiseObj,\n                &FLIGHT_hexacopter_DW.obj_dl.armAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<Root>/PX4 PWM Output'\n  FLIGHT__PX4Timestamp_o_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_n);\n  FLIGHT__PX4Timestamp_o_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_p);\n\n  // Terminate for MATLABSystem: '<S496>/SinkBlock'\n  if (!FLIGHT_hexacopter_DW.obj_hf.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_hf.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_hf.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_hf.isSetupComplete) {\n      uORB_write_terminate(&FLIGHT_hexacopter_DW.obj_hf.orbAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S496>/SinkBlock'\n  FLIGHT__PX4Timestamp_o_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_o);\n\n  // Terminate for MATLABSystem: '<S492>/SinkBlock'\n  if (!FLIGHT_hexacopter_DW.obj_jk.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_jk.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_jk.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_jk.isSetupComplete) {\n      uORB_write_terminate(&FLIGHT_hexacopter_DW.obj_jk.orbAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S492>/SinkBlock'\n\n  // Terminate for MATLABSystem: '<S306>/SourceBlock'\n  if (!FLIGHT_hexacopter_DW.obj_n2.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_n2.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_n2.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_n2.isSetupComplete) {\n      uORB_read_terminate(&FLIGHT_hexacopter_DW.obj_n2.eventStructObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S306>/SourceBlock'\n\n  // Terminate for MATLABSystem: '<S304>/SourceBlock'\n  if (!FLIGHT_hexacopter_DW.obj_ab.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_ab.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_ab.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_ab.isSetupComplete) {\n      uORB_read_terminate(&FLIGHT_hexacopter_DW.obj_ab.eventStructObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S304>/SourceBlock'\n\n  // Terminate for MATLABSystem: '<S500>/SourceBlock'\n  if (!FLIGHT_hexacopter_DW.obj_hm.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_hm.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_hm.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_hm.isSetupComplete) {\n      uORB_read_terminate(&FLIGHT_hexacopter_DW.obj_hm.eventStructObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S500>/SourceBlock'\n\n  // Terminate for MATLABSystem: '<S301>/SourceBlock'\n  if (!FLIGHT_hexacopter_DW.obj_kk.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_kk.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_kk.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_kk.isSetupComplete) {\n      uORB_read_terminate(&FLIGHT_hexacopter_DW.obj_kk.eventStructObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S301>/SourceBlock'\n\n  // Terminate for MATLABSystem: '<S1>/Read Parameter2'\n  if (!FLIGHT_hexacopter_DW.obj_in.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_in.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S1>/Read Parameter2'\n\n  // Terminate for MATLABSystem: '<S1>/Read Parameter4'\n  if (!FLIGHT_hexacopter_DW.obj_lx.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_lx.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S1>/Read Parameter4'\n\n  // Terminate for MATLABSystem: '<S1>/Read Parameter1'\n  if (!FLIGHT_hexacopter_DW.obj_m.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_m.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S1>/Read Parameter1'\n\n  // Terminate for Atomic SubSystem: '<Root>/If Action Subsystem'\n  // Terminate for MATLABSystem: '<S194>/Read Parameter'\n  if (!FLIGHT_hexacopter_DW.obj_eq.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_eq.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S194>/Read Parameter'\n\n  // Terminate for MATLABSystem: '<S195>/Read Parameter'\n  if (!FLIGHT_hexacopter_DW.obj_pi.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_pi.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S195>/Read Parameter'\n  // End of Terminate for SubSystem: '<Root>/If Action Subsystem'\n\n  // Terminate for MATLABSystem: '<S501>/SourceBlock'\n  if (!FLIGHT_hexacopter_DW.obj_bw.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_bw.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_bw.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_bw.isSetupComplete) {\n      uORB_read_terminate(&FLIGHT_hexacopter_DW.obj_bw.eventStructObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S501>/SourceBlock'\n  FLIGHT_he_PX4Timestamp_Term(&FLIGHT_hexacopter_DW.PX4Timestamp);\n\n  // Terminate for MATLABSystem: '<S3>/Read Parameter1'\n  if (!FLIGHT_hexacopter_DW.obj_ct.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_ct.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S3>/Read Parameter1'\n\n  // Terminate for MATLABSystem: '<S3>/Read Parameter'\n  if (!FLIGHT_hexacopter_DW.obj_cf.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_cf.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S3>/Read Parameter'\n\n  // Terminate for MATLABSystem: '<S3>/Read Parameter2'\n  if (!FLIGHT_hexacopter_DW.obj_l.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_l.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S3>/Read Parameter2'\n\n  // Terminate for Enabled SubSystem: '<Root>/CAS'\n  // Terminate for MATLABSystem: '<S2>/Read Parameter9'\n  if (!FLIGHT_hexacopter_DW.obj_k4.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_k4.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter9'\n\n  // Terminate for MATLABSystem: '<S2>/Read Parameter'\n  if (!FLIGHT_hexacopter_DW.obj_jz.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_jz.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter'\n\n  // Terminate for MATLABSystem: '<S2>/Read Parameter10'\n  if (!FLIGHT_hexacopter_DW.obj_ds.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_ds.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter10'\n\n  // Terminate for MATLABSystem: '<S2>/Read Parameter1'\n  if (!FLIGHT_hexacopter_DW.obj_o.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_o.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S2>/Read Parameter1'\n  // End of Terminate for SubSystem: '<Root>/CAS'\n\n  // Terminate for MATLABSystem: '<S11>/Read Parameter'\n  if (!FLIGHT_hexacopter_DW.obj_g.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_g.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S11>/Read Parameter'\n\n  // Terminate for MATLABSystem: '<S11>/Read Parameter1'\n  if (!FLIGHT_hexacopter_DW.obj_d.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_d.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S11>/Read Parameter1'\n\n  // Terminate for MATLABSystem: '<S11>/Read Parameter2'\n  if (!FLIGHT_hexacopter_DW.obj_k.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_k.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S11>/Read Parameter2'\n\n  // Terminate for MATLABSystem: '<S11>/Read Parameter3'\n  if (!FLIGHT_hexacopter_DW.obj_n.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_n.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S11>/Read Parameter3'\n\n  // Terminate for MATLABSystem: '<S11>/Read Parameter4'\n  if (!FLIGHT_hexacopter_DW.obj.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S11>/Read Parameter4'\n  FLIGHT__PX4Timestamp_k_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_i);\n\n  // Terminate for MATLABSystem: '<S512>/SinkBlock'\n  if (!FLIGHT_hexacopter_DW.obj_mq.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_mq.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_mq.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_mq.isSetupComplete) {\n      uORB_write_terminate(&FLIGHT_hexacopter_DW.obj_mq.orbAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S512>/SinkBlock'\n  FLIGHT__PX4Timestamp_k_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_nd);\n\n  // Terminate for MATLABSystem: '<S507>/SinkBlock'\n  if (!FLIGHT_hexacopter_DW.obj_ez.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_ez.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_ez.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_ez.isSetupComplete) {\n      uORB_write_terminate(&FLIGHT_hexacopter_DW.obj_ez.orbAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S507>/SinkBlock'\n  FLIGHT_he_PX4Timestamp_Term(&FLIGHT_hexacopter_DW.PX4Timestamp_pn);\n\n  // Terminate for MATLABSystem: '<S509>/SinkBlock'\n  if (!FLIGHT_hexacopter_DW.obj_pa.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_pa.matlabCodegenIsDeleted = true;\n    if ((FLIGHT_hexacopter_DW.obj_pa.isInitialized == 1) &&\n        FLIGHT_hexacopter_DW.obj_pa.isSetupComplete) {\n      uORB_write_terminate(&FLIGHT_hexacopter_DW.obj_pa.orbAdvertiseObj);\n    }\n  }\n\n  // End of Terminate for MATLABSystem: '<S509>/SinkBlock'\n\n  // Terminate for MATLABSystem: '<S1>/Read Parameter3'\n  if (!FLIGHT_hexacopter_DW.obj_l5.matlabCodegenIsDeleted) {\n    FLIGHT_hexacopter_DW.obj_l5.matlabCodegenIsDeleted = true;\n  }\n\n  // End of Terminate for MATLABSystem: '<S1>/Read Parameter3'\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"FLIGHT_hexacopter.h","type":"header","group":"model","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: FLIGHT_hexacopter.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.250\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Fri May 23 13:47:19 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef FLIGHT_hexacopter_h_\n#define FLIGHT_hexacopter_h_\n#include <drivers/drv_hrt.h>\n#include <poll.h>\n#include <uORB/uORB.h>\n#include \"rtwtypes.h\"\n#include \"MW_Parameter.h\"\n#include \"MW_ParameterRead.h\"\n#include \"MW_PX4_PWM.h\"\n#include \"MW_uORB_Read.h\"\n#include \"MW_uORB_Write.h\"\n#include \"FLIGHT_hexacopter_types.h\"\n#include <uORB/topics/vehicle_local_position.h>\n#include <uORB/topics/vehicle_odometry.h>\n#include <uORB/topics/input_rc.h>\n#include <uORB/topics/vehicle_status.h>\n#include <uORB/topics/actuator_motors.h>\n#include <uORB/topics/vehicle_local_position_setpoint.h>\n#include <uORB/topics/vehicle_attitude_setpoint.h>\n#include <uORB/topics/vehicle_angular_velocity.h>\n#include <uORB/topics/vehicle_rates_setpoint.h>\n#include <uORB/topics/actuator_controls_status.h>\n#include <uORB/topics/actuator_armed.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <stddef.h>\n\n// Macros for accessing real-time model data structure\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmStepTask\n#define rtmStepTask(rtm, idx)          ((rtm)->Timing.TaskCounters.TID[(idx)] == 0)\n#endif\n\n#ifndef rtmTaskCounter\n#define rtmTaskCounter(rtm, idx)       ((rtm)->Timing.TaskCounters.TID[(idx)])\n#endif\n\n// Block signals for system '<S3>/PX4 Timestamp'\nstruct B_PX4Timestamp_FLIGHT_hexacop_T {\n  uint64_T PX4Timestamp;               // '<S3>/PX4 Timestamp'\n};\n\n// Block states (default storage) for system '<S3>/PX4 Timestamp'\nstruct DW_PX4Timestamp_FLIGHT_hexaco_T {\n  px4_internal_block_getPX4Abso_T obj; // '<S3>/PX4 Timestamp'\n  boolean_T objisempty;                // '<S3>/PX4 Timestamp'\n};\n\n// Block signals for system '<S490>/PX4 Timestamp'\nstruct B_PX4Timestamp_FLIGHT_hexac_l_T {\n  uint64_T PX4Timestamp;               // '<S490>/PX4 Timestamp'\n};\n\n// Block states (default storage) for system '<S490>/PX4 Timestamp'\nstruct DW_PX4Timestamp_FLIGHT_hexa_b_T {\n  px4_internal_block_getPX4Abso_T obj; // '<S490>/PX4 Timestamp'\n  boolean_T objisempty;                // '<S490>/PX4 Timestamp'\n};\n\n// Block signals for system '<S504>/PX4 Timestamp'\nstruct B_PX4Timestamp_FLIGHT_hexac_h_T {\n  uint64_T PX4Timestamp;               // '<S504>/PX4 Timestamp'\n};\n\n// Block states (default storage) for system '<S504>/PX4 Timestamp'\nstruct DW_PX4Timestamp_FLIGHT_hexa_f_T {\n  px4_internal_block_getPX4Abso_T obj; // '<S504>/PX4 Timestamp'\n  boolean_T objisempty;                // '<S504>/PX4 Timestamp'\n};\n\n// Block signals (default storage)\nstruct B_FLIGHT_hexacopter_T {\n  px4_Bus_vehicle_local_position In1;  // '<S303>/In1'\n  px4_Bus_vehicle_local_position r;\n  px4_Bus_vehicle_odometry In1_k;      // '<S305>/In1'\n  px4_Bus_vehicle_odometry r1;\n  px4_Bus_input_rc In1_i;              // '<S307>/In1'\n  px4_Bus_input_rc r2;\n  px4_Bus_vehicle_status In1_f;        // '<S503>/In1'\n  px4_Bus_actuator_motors BusAssignment;// '<S494>/Bus Assignment'\n  px4_Bus_vehicle_status r3;\n  px4_Bus_vehicle_local_position_setpoint BusAssignment_g;// '<S20>/Bus Assignment' \n  px4_Bus_vehicle_attitude_setpoint BusAssignment_p;// '<S504>/Bus Assignment'\n  px4_Bus_vehicle_angular_velocity r4;\n  px4_Bus_vehicle_rates_setpoint BusAssignment_a;// '<S510>/Bus Assignment'\n  px4_Bus_vehicle_angular_velocity In1_h;// '<S498>/In1'\n  real32_T CreateDiagonalMatrix[9];    // '<S477>/Create Diagonal Matrix'\n  px4_Bus_actuator_controls_status BusAssignment_gi;// '<S490>/Bus Assignment'\n  uint16_T pwmValue[8];\n  px4_Bus_actuator_armed In1_n;        // '<S502>/In1'\n  px4_Bus_actuator_armed r5;\n  real32_T U[3];\n  real32_T ypr[3];                     // '<Root>/quat2eul'\n  real32_T TmpSignalConversionAtSFun_c[3];// '<S11>/MATLAB Function'\n  real32_T G1[3];                      // '<S11>/MATLAB Function1'\n  real32_T TSamp[3];                   // '<S480>/TSamp'\n  uint16_T DataTypeConversion6[6];     // '<S4>/Data Type Conversion6'\n  real_T reletive_time_sec;\n  real_T peak_angle_rad;\n  real_T out_roll;                     // '<S3>/MATLAB Function'\n  real_T out_pitch;                    // '<S3>/MATLAB Function'\n  real_T out_yawrate;                  // '<S3>/MATLAB Function'\n  real_T u0;\n  real_T d;\n  real_T d1;\n  real_T d2;\n  real_T d3;\n  real_T d4;\n  real32_T rate_transition_des_p;      // '<Root>/rate_transition_des_p'\n  real32_T rate_transition_des_q;      // '<Root>/rate_transition_des_q'\n  real32_T rate_transition_des_r;      // '<Root>/rate_transition_des_r'\n  real32_T RateTransition1;            // '<Root>/Rate Transition1'\n  real32_T rate_transition_throttle;   // '<Root>/rate_transition_throttle'\n  real32_T Sum5;                       // '<S309>/Sum5'\n  real32_T Sum5_d;                     // '<S310>/Sum5'\n  real32_T Sum;                        // '<S10>/Sum'\n  real32_T Switch2;                    // '<S173>/Switch2'\n  real32_T Switch2_i;                  // '<S122>/Switch2'\n  real32_T cfromc;\n  real32_T ctoc;\n  real32_T mul;\n  real32_T t;\n  real32_T ParamStep;\n  real32_T ParamStep_m;\n  real32_T Product5_l;                 // '<S477>/Product5'\n  real32_T Gain_i;                     // '<S22>/Gain'\n  real32_T Gain3;                      // '<S22>/Gain3'\n  real32_T IProdOut_d;                 // '<S57>/IProd Out'\n  real32_T NProdOut;                   // '<S63>/NProd Out'\n  real32_T DeadZone;                   // '<S52>/DeadZone'\n  int32_T r_c;\n  int32_T br;\n  int32_T b_ic;\n  int32_T ParamStep_k;\n  int32_T ParamStep_c;\n  int32_T ParamStep_b;\n  int32_T ParamStep_p;\n  int32_T ParamStep_cv;\n  int32_T ParamStep_f;\n  uint16_T rate_transition_ctrl_sw;    // '<Root>/rate_transition_ctrl_sw'\n  uint16_T RateTransition4;            // '<Root>/Rate Transition4'\n  uint16_T Output_Limits1[6];          // '<S7>/Output_Limits1'\n  boolean_T rate_transition_arm;       // '<Root>/rate_transition_arm'\n  boolean_T RateTransition7;           // '<Root>/Rate Transition7'\n  B_PX4Timestamp_FLIGHT_hexac_h_T PX4Timestamp_i;// '<S504>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexacop_T PX4Timestamp_pn;// '<S3>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexac_h_T PX4Timestamp_nd;// '<S504>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexac_l_T PX4Timestamp_n;// '<S490>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexac_l_T PX4Timestamp_p;// '<S490>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexac_l_T PX4Timestamp_o;// '<S490>/PX4 Timestamp'\n  B_PX4Timestamp_FLIGHT_hexacop_T PX4Timestamp;// '<S3>/PX4 Timestamp'\n};\n\n// Block states (default storage) for system '<Root>'\nstruct DW_FLIGHT_hexacopter_T {\n  px4_internal_block_ParameterU_T obj; // '<S11>/Read Parameter4'\n  px4_internal_block_ParameterU_T obj_n;// '<S11>/Read Parameter3'\n  px4_internal_block_ParameterU_T obj_k;// '<S11>/Read Parameter2'\n  px4_internal_block_ParameterU_T obj_d;// '<S11>/Read Parameter1'\n  px4_internal_block_ParameterU_T obj_g;// '<S11>/Read Parameter'\n  px4_internal_block_ParameterU_T obj_i;// '<S10>/read_mc_rollrate_p'\n  px4_internal_block_ParameterU_T obj_e;// '<S10>/Read Parameter9'\n  px4_internal_block_ParameterU_T obj_i4;// '<S10>/Read Parameter8'\n  px4_internal_block_ParameterU_T obj_j;// '<S10>/Read Parameter7'\n  px4_internal_block_ParameterU_T obj_a;// '<S10>/Read Parameter6'\n  px4_internal_block_ParameterU_T obj_h;// '<S10>/Read Parameter5'\n  px4_internal_block_ParameterU_T obj_p;// '<S10>/Read Parameter4'\n  px4_internal_block_ParameterU_T obj_b;// '<S10>/Read Parameter3'\n  px4_internal_block_ParameterU_T obj_da;// '<S10>/Read Parameter2'\n  px4_internal_block_ParameterU_T obj_c;// '<S10>/Read Parameter10'\n  px4_internal_block_ParameterU_T obj_ea;// '<S10>/Read Parameter1'\n  px4_internal_block_ParameterU_T obj_pi;// '<S195>/Read Parameter'\n  px4_internal_block_ParameterU_T obj_eq;// '<S194>/Read Parameter'\n  px4_internal_block_ParameterU_T obj_aq;// '<S4>/Read Parameter5'\n  px4_internal_block_ParameterU_T obj_cx;// '<S4>/Read Parameter4'\n  px4_internal_block_ParameterU_T obj_nt;// '<S4>/Read Parameter3'\n  px4_internal_block_ParameterU_T obj_ao;// '<S4>/Read Parameter2'\n  px4_internal_block_ParameterU_T obj_gv;// '<S4>/Read Parameter13'\n  px4_internal_block_ParameterU_T obj_j5;// '<S4>/Read Parameter1'\n  px4_internal_block_ParameterU_T obj_l;// '<S3>/Read Parameter2'\n  px4_internal_block_ParameterU_T obj_ct;// '<S3>/Read Parameter1'\n  px4_internal_block_ParameterU_T obj_cf;// '<S3>/Read Parameter'\n  px4_internal_block_ParameterU_T obj_k4;// '<S2>/Read Parameter9'\n  px4_internal_block_ParameterU_T obj_ds;// '<S2>/Read Parameter10'\n  px4_internal_block_ParameterU_T obj_o;// '<S2>/Read Parameter1'\n  px4_internal_block_ParameterU_T obj_jz;// '<S2>/Read Parameter'\n  px4_internal_block_ParameterU_T obj_lx;// '<S1>/Read Parameter4'\n  px4_internal_block_ParameterU_T obj_l5;// '<S1>/Read Parameter3'\n  px4_internal_block_ParameterU_T obj_in;// '<S1>/Read Parameter2'\n  px4_internal_block_ParameterU_T obj_m;// '<S1>/Read Parameter1'\n  px4_internal_block_Subscriber_T obj_bw;// '<S501>/SourceBlock'\n  px4_internal_block_Subscriber_T obj_hm;// '<S500>/SourceBlock'\n  px4_internal_block_Subscriber_T obj_pe;// '<S497>/SourceBlock'\n  px4_internal_block_Subscriber_T obj_n2;// '<S306>/SourceBlock'\n  px4_internal_block_Subscriber_T obj_ab;// '<S304>/SourceBlock'\n  px4_internal_block_Subscriber_T obj_kk;// '<S301>/SourceBlock'\n  px4_internal_block_PWM_FLIGHT_T obj_dl;// '<Root>/PX4 PWM Output'\n  px4_internal_block_Publisher__T obj_mq;// '<S512>/SinkBlock'\n  px4_internal_block_Publisher__T obj_pa;// '<S509>/SinkBlock'\n  px4_internal_block_Publisher__T obj_ez;// '<S507>/SinkBlock'\n  px4_internal_block_Publisher__T obj_hf;// '<S496>/SinkBlock'\n  px4_internal_block_Publisher__T obj_jk;// '<S492>/SinkBlock'\n  real_T start_time_usec;              // '<S3>/MATLAB Function'\n  real32_T Integrator_DSTATE;          // '<S60>/Integrator'\n  real32_T Filter_DSTATE;              // '<S55>/Filter'\n  real32_T UD_DSTATE[3];               // '<S480>/UD'\n  real32_T UD_DSTATE_j;                // '<S478>/UD'\n  real32_T UD_DSTATE_g;                // '<S479>/UD'\n  real32_T UD_DSTATE_n;                // '<S481>/UD'\n  real32_T DiscreteTimeIntegrator_DSTATE;// '<S11>/Discrete-Time Integrator'\n  real32_T UnitDelay1_DSTATE;          // '<S315>/Unit Delay1'\n  real32_T UnitDelay2_DSTATE;          // '<S315>/Unit Delay2'\n  real32_T UD_DSTATE_l;                // '<S312>/UD'\n  real32_T Integrator_DSTATE_p;        // '<S350>/Integrator'\n  real32_T UnitDelay1_DSTATE_f;        // '<S370>/Unit Delay1'\n  real32_T UnitDelay2_DSTATE_c;        // '<S370>/Unit Delay2'\n  real32_T UD_DSTATE_m;                // '<S367>/UD'\n  real32_T Integrator_DSTATE_c;        // '<S405>/Integrator'\n  real32_T UnitDelay1_DSTATE_e;        // '<S425>/Unit Delay1'\n  real32_T UnitDelay2_DSTATE_e;        // '<S425>/Unit Delay2'\n  real32_T UD_DSTATE_jy;               // '<S422>/UD'\n  real32_T Integrator_DSTATE_g;        // '<S460>/Integrator'\n  real32_T DiscreteTimeIntegrator_DSTATE_l;// '<S5>/Discrete-Time Integrator'\n  real32_T DiscreteTimeIntegrator1_DSTATE;// '<S5>/Discrete-Time Integrator1'\n  real32_T rate_transition_des_p_Buffer0;// '<Root>/rate_transition_des_p'\n  real32_T rate_transition_des_q_Buffer0;// '<Root>/rate_transition_des_q'\n  real32_T rate_transition_des_r_Buffer0;// '<Root>/rate_transition_des_r'\n  real32_T RateTransition1_Buffer0;    // '<Root>/Rate Transition1'\n  real32_T rate_transition_throttle_Buffer;// '<Root>/rate_transition_throttle'\n  real32_T RateTransition_Buffer[3];   // '<Root>/Rate Transition'\n  uint16_T rate_transition_ctrl_sw_Buffer0;// '<Root>/rate_transition_ctrl_sw'\n  uint16_T RateTransition4_Buffer0;    // '<Root>/Rate Transition4'\n  int8_T Integrator_PrevResetState;    // '<S60>/Integrator'\n  int8_T Filter_PrevResetState;        // '<S55>/Filter'\n  int8_T DiscreteTimeIntegrator_PrevRese;// '<S5>/Discrete-Time Integrator'\n  int8_T DiscreteTimeIntegrator1_PrevRes;// '<S5>/Discrete-Time Integrator1'\n  uint8_T DiscreteTimeIntegrator_IC_LOADI;// '<S5>/Discrete-Time Integrator'\n  uint8_T DiscreteTimeIntegrator1_IC_LOAD;// '<S5>/Discrete-Time Integrator1'\n  boolean_T rate_transition_arm_Buffer0;// '<Root>/rate_transition_arm'\n  boolean_T RateTransition7_Buffer0;   // '<Root>/Rate Transition7'\n  DW_PX4Timestamp_FLIGHT_hexa_f_T PX4Timestamp_i;// '<S504>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexaco_T PX4Timestamp_pn;// '<S3>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexa_f_T PX4Timestamp_nd;// '<S504>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexa_b_T PX4Timestamp_n;// '<S490>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexa_b_T PX4Timestamp_p;// '<S490>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexa_b_T PX4Timestamp_o;// '<S490>/PX4 Timestamp'\n  DW_PX4Timestamp_FLIGHT_hexaco_T PX4Timestamp;// '<S3>/PX4 Timestamp'\n};\n\n// Parameters (default storage)\nstruct P_FLIGHT_hexacopter_T_ {\n  real_T SampleTime;                   // Variable: SampleTime\n                                          //  Referenced by:\n                                          //    '<S1>/Read Parameter1'\n                                          //    '<S1>/Read Parameter2'\n                                          //    '<S1>/Read Parameter3'\n                                          //    '<S1>/Read Parameter4'\n                                          //    '<S2>/Read Parameter'\n                                          //    '<S2>/Read Parameter1'\n                                          //    '<S2>/Read Parameter10'\n                                          //    '<S2>/Read Parameter9'\n                                          //    '<S3>/Read Parameter'\n                                          //    '<S3>/Read Parameter1'\n                                          //    '<S3>/Read Parameter2'\n                                          //    '<S11>/Read Parameter'\n                                          //    '<S11>/Read Parameter1'\n                                          //    '<S11>/Read Parameter2'\n                                          //    '<S11>/Read Parameter3'\n                                          //    '<S11>/Read Parameter4'\n                                          //    '<S194>/Read Parameter'\n                                          //    '<S195>/Read Parameter'\n\n  real_T SampleTime_SAS;               // Variable: SampleTime_SAS\n                                          //  Referenced by:\n                                          //    '<S4>/Read Parameter1'\n                                          //    '<S4>/Read Parameter13'\n                                          //    '<S4>/Read Parameter2'\n                                          //    '<S4>/Read Parameter3'\n                                          //    '<S4>/Read Parameter4'\n                                          //    '<S4>/Read Parameter5'\n                                          //    '<S10>/Read Parameter1'\n                                          //    '<S10>/Read Parameter10'\n                                          //    '<S10>/Read Parameter2'\n                                          //    '<S10>/Read Parameter3'\n                                          //    '<S10>/Read Parameter4'\n                                          //    '<S10>/Read Parameter5'\n                                          //    '<S10>/Read Parameter6'\n                                          //    '<S10>/Read Parameter7'\n                                          //    '<S10>/Read Parameter8'\n                                          //    '<S10>/Read Parameter9'\n                                          //    '<S10>/read_mc_rollrate_p'\n\n  real32_T Jxx;                        // Variable: Jxx\n                                          //  Referenced by: '<S477>/Constant'\n\n  real32_T Jyy;                        // Variable: Jyy\n                                          //  Referenced by: '<S477>/Constant1'\n\n  real32_T Jzz;                        // Variable: Jzz\n                                          //  Referenced by: '<S477>/Constant2'\n\n  real32_T MAX_CONTROL_ANGLE_PITCH;    // Variable: MAX_CONTROL_ANGLE_PITCH\n                                          //  Referenced by:\n                                          //    '<S12>/Gain5'\n                                          //    '<S22>/Gain2'\n\n  real32_T MAX_CONTROL_ANGLE_RATE_Y;   // Variable: MAX_CONTROL_ANGLE_RATE_Y\n                                          //  Referenced by:\n                                          //    '<S12>/Gain6'\n                                          //    '<S22>/Gain3'\n\n  real32_T MAX_CONTROL_ANGLE_ROLL;     // Variable: MAX_CONTROL_ANGLE_ROLL\n                                          //  Referenced by:\n                                          //    '<S12>/Gain4'\n                                          //    '<S22>/Gain1'\n\n  real32_T MAX_CONTROL_VELOCITY_XY;    // Variable: MAX_CONTROL_VELOCITY_XY\n                                          //  Referenced by: '<S192>/Gain1'\n\n  real32_T DiscreteDerivative2_ICPrevScale;\n                              // Mask Parameter: DiscreteDerivative2_ICPrevScale\n                                 //  Referenced by: '<S312>/UD'\n\n  real32_T DiscreteDerivative2_ICPrevSca_n;\n                              // Mask Parameter: DiscreteDerivative2_ICPrevSca_n\n                                 //  Referenced by: '<S367>/UD'\n\n  real32_T DiscreteDerivative2_ICPrevSca_o;\n                              // Mask Parameter: DiscreteDerivative2_ICPrevSca_o\n                                 //  Referenced by: '<S422>/UD'\n\n  real32_T DiscreteDerivative2_ICPrevSca_a;\n                              // Mask Parameter: DiscreteDerivative2_ICPrevSca_a\n                                 //  Referenced by: '<S480>/UD'\n\n  real32_T DiscreteDerivative_ICPrevScaled;\n                              // Mask Parameter: DiscreteDerivative_ICPrevScaled\n                                 //  Referenced by: '<S478>/UD'\n\n  real32_T DiscreteDerivative1_ICPrevScale;\n                              // Mask Parameter: DiscreteDerivative1_ICPrevScale\n                                 //  Referenced by: '<S479>/UD'\n\n  real32_T DiscreteDerivative3_ICPrevScale;\n                              // Mask Parameter: DiscreteDerivative3_ICPrevScale\n                                 //  Referenced by: '<S481>/UD'\n\n  real32_T PIDController_InitialConditionF;\n                              // Mask Parameter: PIDController_InitialConditionF\n                                 //  Referenced by: '<S55>/Filter'\n\n  real32_T pid_ctrl_rollrate_InitialCondit;\n                              // Mask Parameter: pid_ctrl_rollrate_InitialCondit\n                                 //  Referenced by: '<S350>/Integrator'\n\n  real32_T pid_ctrl_rollrate_InitialCond_j;\n                              // Mask Parameter: pid_ctrl_rollrate_InitialCond_j\n                                 //  Referenced by: '<S405>/Integrator'\n\n  real32_T pid_ctrl_rollrate_InitialCond_p;\n                              // Mask Parameter: pid_ctrl_rollrate_InitialCond_p\n                                 //  Referenced by: '<S460>/Integrator'\n\n  real32_T PIDController_InitialConditio_a;\n                              // Mask Parameter: PIDController_InitialConditio_a\n                                 //  Referenced by: '<S60>/Integrator'\n\n  real32_T PIDController_LowerIntegratorSa;\n                              // Mask Parameter: PIDController_LowerIntegratorSa\n                                 //  Referenced by: '<S60>/Integrator'\n\n  real32_T PIDController_LowerSaturationLi;\n                              // Mask Parameter: PIDController_LowerSaturationLi\n                                 //  Referenced by:\n                                 //    '<S67>/Saturation'\n                                 //    '<S52>/DeadZone'\n\n  real32_T PIDController_UpperIntegratorSa;\n                              // Mask Parameter: PIDController_UpperIntegratorSa\n                                 //  Referenced by: '<S60>/Integrator'\n\n  real32_T PIDController_UpperSaturationLi;\n                              // Mask Parameter: PIDController_UpperSaturationLi\n                                 //  Referenced by:\n                                 //    '<S67>/Saturation'\n                                 //    '<S52>/DeadZone'\n\n  uint16_T CompareToConstant2_const; // Mask Parameter: CompareToConstant2_const\n                                        //  Referenced by: '<S193>/Constant'\n\n  uint16_T CompareToConstant_const;   // Mask Parameter: CompareToConstant_const\n                                         //  Referenced by: '<S488>/Constant'\n\n  uint16_T CompareToConstant_const_g;\n                                    // Mask Parameter: CompareToConstant_const_g\n                                       //  Referenced by: '<S185>/Constant'\n\n  uint16_T CompareToConstant1_const; // Mask Parameter: CompareToConstant1_const\n                                        //  Referenced by: '<S23>/Constant'\n\n  uint16_T CompareToConstant1_const_e;\n                                   // Mask Parameter: CompareToConstant1_const_e\n                                      //  Referenced by: '<S183>/Constant'\n\n  px4_Bus_vehicle_local_position Out1_Y0;// Computed Parameter: Out1_Y0\n                                            //  Referenced by: '<S303>/Out1'\n\n  px4_Bus_vehicle_local_position Constant_Value;// Computed Parameter: Constant_Value\n                                                   //  Referenced by: '<S301>/Constant'\n\n  px4_Bus_vehicle_odometry Out1_Y0_d;  // Computed Parameter: Out1_Y0_d\n                                          //  Referenced by: '<S305>/Out1'\n\n  px4_Bus_vehicle_odometry Constant_Value_g;// Computed Parameter: Constant_Value_g\n                                               //  Referenced by: '<S304>/Constant'\n\n  px4_Bus_actuator_motors Constant_Value_m;// Computed Parameter: Constant_Value_m\n                                              //  Referenced by: '<S495>/Constant'\n\n  px4_Bus_input_rc Out1_Y0_o;          // Computed Parameter: Out1_Y0_o\n                                          //  Referenced by: '<S307>/Out1'\n\n  px4_Bus_input_rc Constant_Value_m1;  // Computed Parameter: Constant_Value_m1\n                                          //  Referenced by: '<S306>/Constant'\n\n  px4_Bus_vehicle_status Out1_Y0_a;    // Computed Parameter: Out1_Y0_a\n                                          //  Referenced by: '<S503>/Out1'\n\n  px4_Bus_vehicle_status Constant_Value_o;// Computed Parameter: Constant_Value_o\n                                             //  Referenced by: '<S501>/Constant'\n\n  px4_Bus_vehicle_local_position_setpoint Constant_Value_n;// Computed Parameter: Constant_Value_n\n                                                              //  Referenced by: '<S508>/Constant'\n\n  px4_Bus_vehicle_attitude_setpoint Constant_Value_l;// Computed Parameter: Constant_Value_l\n                                                        //  Referenced by: '<S506>/Constant'\n\n  px4_Bus_vehicle_angular_velocity Out1_Y0_p;// Computed Parameter: Out1_Y0_p\n                                                //  Referenced by: '<S498>/Out1'\n\n  px4_Bus_vehicle_angular_velocity Constant_Value_gk;// Computed Parameter: Constant_Value_gk\n                                                        //  Referenced by: '<S497>/Constant'\n\n  px4_Bus_vehicle_rates_setpoint Constant_Value_ni;// Computed Parameter: Constant_Value_ni\n                                                      //  Referenced by: '<S511>/Constant'\n\n  px4_Bus_actuator_controls_status Constant_Value_a;// Computed Parameter: Constant_Value_a\n                                                       //  Referenced by: '<S491>/Constant'\n\n  px4_Bus_actuator_armed Out1_Y0_h;    // Computed Parameter: Out1_Y0_h\n                                          //  Referenced by: '<S502>/Out1'\n\n  px4_Bus_actuator_armed Constant_Value_m3;// Computed Parameter: Constant_Value_m3\n                                              //  Referenced by: '<S500>/Constant'\n\n  real_T Constant1_Value;              // Expression: 100\n                                          //  Referenced by: '<S4>/Constant1'\n\n  real_T Constant2_Value;              // Expression: 100\n                                          //  Referenced by: '<S4>/Constant2'\n\n  real_T Constant3_Value;              // Expression: 100\n                                          //  Referenced by: '<S4>/Constant3'\n\n  real_T Constant4_Value;              // Expression: 100\n                                          //  Referenced by: '<S4>/Constant4'\n\n  real_T Constant5_Value;              // Expression: 100\n                                          //  Referenced by: '<S4>/Constant5'\n\n  real_T Constant_Value_mc;            // Expression: 100\n                                          //  Referenced by: '<S4>/Constant'\n\n  real_T Constant_Value_c;             // Expression: 1094\n                                          //  Referenced by: '<S12>/Constant'\n\n  real_T Gain_Gain;                    // Expression: 1/800\n                                          //  Referenced by: '<S12>/Gain'\n\n  real_T Gain_Gain_j;                  // Expression: 0.01\n                                          //  Referenced by: '<S186>/Gain'\n\n  real_T Saturation_UpperSat;          // Expression: 1\n                                          //  Referenced by: '<S186>/Saturation'\n\n  real_T Saturation_LowerSat;          // Expression: 0\n                                          //  Referenced by: '<S186>/Saturation'\n\n  real_T Gain_Gain_h;                  // Expression: 0.01\n                                          //  Referenced by: '<S187>/Gain'\n\n  real_T Saturation_UpperSat_m;        // Expression: 1\n                                          //  Referenced by: '<S187>/Saturation'\n\n  real_T Saturation_LowerSat_o;        // Expression: 0\n                                          //  Referenced by: '<S187>/Saturation'\n\n  real_T Gain_Gain_c;                  // Expression: 0.01\n                                          //  Referenced by: '<S188>/Gain'\n\n  real_T Saturation_UpperSat_b;        // Expression: 1\n                                          //  Referenced by: '<S188>/Saturation'\n\n  real_T Saturation_LowerSat_g;        // Expression: 0\n                                          //  Referenced by: '<S188>/Saturation'\n\n  real_T Gain_Gain_n;                  // Expression: 0.01\n                                          //  Referenced by: '<S189>/Gain'\n\n  real_T Saturation_UpperSat_be;       // Expression: 1\n                                          //  Referenced by: '<S189>/Saturation'\n\n  real_T Saturation_LowerSat_e;        // Expression: 0\n                                          //  Referenced by: '<S189>/Saturation'\n\n  real_T Gain_Gain_f;                  // Expression: 0.01\n                                          //  Referenced by: '<S190>/Gain'\n\n  real_T Saturation_UpperSat_d;        // Expression: 1\n                                          //  Referenced by: '<S190>/Saturation'\n\n  real_T Saturation_LowerSat_l;        // Expression: 0\n                                          //  Referenced by: '<S190>/Saturation'\n\n  real_T Gain_Gain_m;                  // Expression: 0.01\n                                          //  Referenced by: '<S191>/Gain'\n\n  real_T Saturation_UpperSat_i;        // Expression: 1\n                                          //  Referenced by: '<S191>/Saturation'\n\n  real_T Saturation_LowerSat_n;        // Expression: 0\n                                          //  Referenced by: '<S191>/Saturation'\n\n  real32_T Gain1_Gain;                 // Computed Parameter: Gain1_Gain\n                                          //  Referenced by: '<S2>/Gain1'\n\n  real32_T Gain_Gain_m3;               // Computed Parameter: Gain_Gain_m3\n                                          //  Referenced by: '<S2>/Gain'\n\n  real32_T des_p_Y0;                   // Computed Parameter: des_p_Y0\n                                          //  Referenced by: '<S2>/des_p'\n\n  real32_T des_q_Y0;                   // Computed Parameter: des_q_Y0\n                                          //  Referenced by: '<S2>/des_q'\n\n  real32_T Gain1_Gain_g;               // Computed Parameter: Gain1_Gain_g\n                                          //  Referenced by: '<S77>/Gain1'\n\n  real32_T Gain1_Gain_c;               // Computed Parameter: Gain1_Gain_c\n                                          //  Referenced by: '<S78>/Gain1'\n\n  real32_T Gain_Gain_a;                // Computed Parameter: Gain_Gain_a\n                                          //  Referenced by: '<S249>/Gain'\n\n  real32_T DiscreteTimeIntegrator_gainval;\n                           // Computed Parameter: DiscreteTimeIntegrator_gainval\n                              //  Referenced by: '<S5>/Discrete-Time Integrator'\n\n  real32_T DiscreteTimeIntegrator_UpperSat;\n                          // Computed Parameter: DiscreteTimeIntegrator_UpperSat\n                             //  Referenced by: '<S5>/Discrete-Time Integrator'\n\n  real32_T DiscreteTimeIntegrator_LowerSat;\n                          // Computed Parameter: DiscreteTimeIntegrator_LowerSat\n                             //  Referenced by: '<S5>/Discrete-Time Integrator'\n\n  real32_T DiscreteTimeIntegrator1_gainval;\n                          // Computed Parameter: DiscreteTimeIntegrator1_gainval\n                             //  Referenced by: '<S5>/Discrete-Time Integrator1'\n\n  real32_T DiscreteTimeIntegrator1_UpperSa;\n                          // Computed Parameter: DiscreteTimeIntegrator1_UpperSa\n                             //  Referenced by: '<S5>/Discrete-Time Integrator1'\n\n  real32_T DiscreteTimeIntegrator1_LowerSa;\n                          // Computed Parameter: DiscreteTimeIntegrator1_LowerSa\n                             //  Referenced by: '<S5>/Discrete-Time Integrator1'\n\n  real32_T Saturation_UpperSat_e;   // Computed Parameter: Saturation_UpperSat_e\n                                       //  Referenced by: '<S195>/Saturation'\n\n  real32_T Saturation_LowerSat_a;   // Computed Parameter: Saturation_LowerSat_a\n                                       //  Referenced by: '<S195>/Saturation'\n\n  real32_T Gain1_Gain_i;               // Computed Parameter: Gain1_Gain_i\n                                          //  Referenced by: '<S195>/Gain1'\n\n  real32_T DeadZone3_Start;            // Computed Parameter: DeadZone3_Start\n                                          //  Referenced by: '<S192>/Dead Zone3'\n\n  real32_T DeadZone3_End;              // Computed Parameter: DeadZone3_End\n                                          //  Referenced by: '<S192>/Dead Zone3'\n\n  real32_T Saturation9_UpperSat;     // Computed Parameter: Saturation9_UpperSat\n                                        //  Referenced by: '<S192>/Saturation9'\n\n  real32_T Saturation9_LowerSat;     // Computed Parameter: Saturation9_LowerSat\n                                        //  Referenced by: '<S192>/Saturation9'\n\n  real32_T DeadZone1_Start;            // Computed Parameter: DeadZone1_Start\n                                          //  Referenced by: '<S192>/Dead Zone1'\n\n  real32_T DeadZone1_End;              // Computed Parameter: DeadZone1_End\n                                          //  Referenced by: '<S192>/Dead Zone1'\n\n  real32_T Saturation1_UpperSat;     // Computed Parameter: Saturation1_UpperSat\n                                        //  Referenced by: '<S192>/Saturation1'\n\n  real32_T Saturation1_LowerSat;     // Computed Parameter: Saturation1_LowerSat\n                                        //  Referenced by: '<S192>/Saturation1'\n\n  real32_T Gain2_Gain;                 // Computed Parameter: Gain2_Gain\n                                          //  Referenced by: '<S192>/Gain2'\n\n  real32_T tau_roll_Y0;                // Computed Parameter: tau_roll_Y0\n                                          //  Referenced by: '<S10>/tau_roll'\n\n  real32_T tau_pitch_Y0;               // Computed Parameter: tau_pitch_Y0\n                                          //  Referenced by: '<S10>/tau_pitch'\n\n  real32_T tau_yaw_Y0;                 // Computed Parameter: tau_yaw_Y0\n                                          //  Referenced by: '<S10>/tau_yaw'\n\n  real32_T tau_Gain;                   // Computed Parameter: tau_Gain\n                                          //  Referenced by: '<S315>/tau'\n\n  real32_T Bias1_Bias;                 // Computed Parameter: Bias1_Bias\n                                          //  Referenced by: '<S316>/Bias1'\n\n  real32_T Bias_Bias;                  // Computed Parameter: Bias_Bias\n                                          //  Referenced by: '<S316>/Bias'\n\n  real32_T Gain_Gain_i;                // Computed Parameter: Gain_Gain_i\n                                          //  Referenced by: '<S316>/Gain'\n\n  real32_T UnitDelay1_InitialCondition;\n                              // Computed Parameter: UnitDelay1_InitialCondition\n                                 //  Referenced by: '<S315>/Unit Delay1'\n\n  real32_T Gain1_Gain_j;               // Computed Parameter: Gain1_Gain_j\n                                          //  Referenced by: '<S315>/Gain1'\n\n  real32_T UnitDelay2_InitialCondition;\n                              // Computed Parameter: UnitDelay2_InitialCondition\n                                 //  Referenced by: '<S315>/Unit Delay2'\n\n  real32_T TSamp_WtEt;                 // Computed Parameter: TSamp_WtEt\n                                          //  Referenced by: '<S312>/TSamp'\n\n  real32_T Integrator_gainval;         // Computed Parameter: Integrator_gainval\n                                          //  Referenced by: '<S350>/Integrator'\n\n  real32_T tau_Gain_n;                 // Computed Parameter: tau_Gain_n\n                                          //  Referenced by: '<S370>/tau'\n\n  real32_T Bias1_Bias_n;               // Computed Parameter: Bias1_Bias_n\n                                          //  Referenced by: '<S371>/Bias1'\n\n  real32_T Bias_Bias_b;                // Computed Parameter: Bias_Bias_b\n                                          //  Referenced by: '<S371>/Bias'\n\n  real32_T Gain_Gain_e;                // Computed Parameter: Gain_Gain_e\n                                          //  Referenced by: '<S371>/Gain'\n\n  real32_T UnitDelay1_InitialCondition_p;\n                            // Computed Parameter: UnitDelay1_InitialCondition_p\n                               //  Referenced by: '<S370>/Unit Delay1'\n\n  real32_T Gain1_Gain_e;               // Computed Parameter: Gain1_Gain_e\n                                          //  Referenced by: '<S370>/Gain1'\n\n  real32_T UnitDelay2_InitialCondition_e;\n                            // Computed Parameter: UnitDelay2_InitialCondition_e\n                               //  Referenced by: '<S370>/Unit Delay2'\n\n  real32_T TSamp_WtEt_m;               // Computed Parameter: TSamp_WtEt_m\n                                          //  Referenced by: '<S367>/TSamp'\n\n  real32_T Integrator_gainval_b;     // Computed Parameter: Integrator_gainval_b\n                                        //  Referenced by: '<S405>/Integrator'\n\n  real32_T tau_Gain_c;                 // Computed Parameter: tau_Gain_c\n                                          //  Referenced by: '<S425>/tau'\n\n  real32_T Bias1_Bias_i;               // Computed Parameter: Bias1_Bias_i\n                                          //  Referenced by: '<S426>/Bias1'\n\n  real32_T Bias_Bias_c;                // Computed Parameter: Bias_Bias_c\n                                          //  Referenced by: '<S426>/Bias'\n\n  real32_T Gain_Gain_b;                // Computed Parameter: Gain_Gain_b\n                                          //  Referenced by: '<S426>/Gain'\n\n  real32_T UnitDelay1_InitialCondition_e;\n                            // Computed Parameter: UnitDelay1_InitialCondition_e\n                               //  Referenced by: '<S425>/Unit Delay1'\n\n  real32_T Gain1_Gain_iw;              // Computed Parameter: Gain1_Gain_iw\n                                          //  Referenced by: '<S425>/Gain1'\n\n  real32_T UnitDelay2_InitialCondition_m;\n                            // Computed Parameter: UnitDelay2_InitialCondition_m\n                               //  Referenced by: '<S425>/Unit Delay2'\n\n  real32_T TSamp_WtEt_p;               // Computed Parameter: TSamp_WtEt_p\n                                          //  Referenced by: '<S422>/TSamp'\n\n  real32_T Integrator_gainval_p;     // Computed Parameter: Integrator_gainval_p\n                                        //  Referenced by: '<S460>/Integrator'\n\n  real32_T DeadZone3_Start_p;          // Computed Parameter: DeadZone3_Start_p\n                                          //  Referenced by: '<S12>/Dead Zone3'\n\n  real32_T DeadZone3_End_l;            // Computed Parameter: DeadZone3_End_l\n                                          //  Referenced by: '<S12>/Dead Zone3'\n\n  real32_T Saturation_UpperSat_o;   // Computed Parameter: Saturation_UpperSat_o\n                                       //  Referenced by: '<S12>/Saturation'\n\n  real32_T Saturation_LowerSat_el; // Computed Parameter: Saturation_LowerSat_el\n                                      //  Referenced by: '<S12>/Saturation'\n\n  real32_T Constant1_Value_l;          // Computed Parameter: Constant1_Value_l\n                                          //  Referenced by: '<S12>/Constant1'\n\n  real32_T Gain2_Gain_a;               // Computed Parameter: Gain2_Gain_a\n                                          //  Referenced by: '<S12>/Gain2'\n\n  real32_T DeadZone2_Start;            // Computed Parameter: DeadZone2_Start\n                                          //  Referenced by: '<S12>/Dead Zone2'\n\n  real32_T DeadZone2_End;              // Computed Parameter: DeadZone2_End\n                                          //  Referenced by: '<S12>/Dead Zone2'\n\n  real32_T Saturation1_UpperSat_l; // Computed Parameter: Saturation1_UpperSat_l\n                                      //  Referenced by: '<S12>/Saturation1'\n\n  real32_T Saturation1_LowerSat_i; // Computed Parameter: Saturation1_LowerSat_i\n                                      //  Referenced by: '<S12>/Saturation1'\n\n  real32_T Constant2_Value_i;          // Computed Parameter: Constant2_Value_i\n                                          //  Referenced by: '<S12>/Constant2'\n\n  real32_T Gain1_Gain_m;               // Computed Parameter: Gain1_Gain_m\n                                          //  Referenced by: '<S12>/Gain1'\n\n  real32_T DeadZone1_Start_c;          // Computed Parameter: DeadZone1_Start_c\n                                          //  Referenced by: '<S12>/Dead Zone1'\n\n  real32_T DeadZone1_End_m;            // Computed Parameter: DeadZone1_End_m\n                                          //  Referenced by: '<S12>/Dead Zone1'\n\n  real32_T Saturation2_UpperSat;     // Computed Parameter: Saturation2_UpperSat\n                                        //  Referenced by: '<S12>/Saturation2'\n\n  real32_T Saturation2_LowerSat;     // Computed Parameter: Saturation2_LowerSat\n                                        //  Referenced by: '<S12>/Saturation2'\n\n  real32_T Constant3_Value_e;          // Computed Parameter: Constant3_Value_e\n                                          //  Referenced by: '<S12>/Constant3'\n\n  real32_T Gain3_Gain;                 // Computed Parameter: Gain3_Gain\n                                          //  Referenced by: '<S12>/Gain3'\n\n  real32_T DeadZone_Start;             // Computed Parameter: DeadZone_Start\n                                          //  Referenced by: '<S12>/Dead Zone'\n\n  real32_T DeadZone_End;               // Computed Parameter: DeadZone_End\n                                          //  Referenced by: '<S12>/Dead Zone'\n\n  real32_T Saturation3_UpperSat;     // Computed Parameter: Saturation3_UpperSat\n                                        //  Referenced by: '<S12>/Saturation3'\n\n  real32_T Saturation3_LowerSat;     // Computed Parameter: Saturation3_LowerSat\n                                        //  Referenced by: '<S12>/Saturation3'\n\n  real32_T Constant1_Value_g;          // Computed Parameter: Constant1_Value_g\n                                          //  Referenced by: '<S50>/Constant1'\n\n  real32_T rate_transition_des_p_InitialCo;\n                          // Computed Parameter: rate_transition_des_p_InitialCo\n                             //  Referenced by: '<Root>/rate_transition_des_p'\n\n  real32_T rate_transition_des_q_InitialCo;\n                          // Computed Parameter: rate_transition_des_q_InitialCo\n                             //  Referenced by: '<Root>/rate_transition_des_q'\n\n  real32_T rate_transition_des_r_InitialCo;\n                          // Computed Parameter: rate_transition_des_r_InitialCo\n                             //  Referenced by: '<Root>/rate_transition_des_r'\n\n  real32_T RateTransition1_InitialConditio;\n                          // Computed Parameter: RateTransition1_InitialConditio\n                             //  Referenced by: '<Root>/Rate Transition1'\n\n  real32_T rate_transition_throttle_Initia;\n                          // Computed Parameter: rate_transition_throttle_Initia\n                             //  Referenced by: '<Root>/rate_transition_throttle'\n\n  real32_T Constant1_Value_i[6];       // Computed Parameter: Constant1_Value_i\n                                          //  Referenced by: '<S15>/Constant1'\n\n  real32_T Saturation_UpperSat_ep; // Computed Parameter: Saturation_UpperSat_ep\n                                      //  Referenced by: '<S493>/Saturation'\n\n  real32_T Saturation_LowerSat_p;   // Computed Parameter: Saturation_LowerSat_p\n                                       //  Referenced by: '<S493>/Saturation'\n\n  real32_T Constant_Value_e;           // Computed Parameter: Constant_Value_e\n                                          //  Referenced by: '<S493>/Constant'\n\n  real32_T Gain_Gain_mg;               // Computed Parameter: Gain_Gain_mg\n                                          //  Referenced by: '<S493>/Gain'\n\n  real32_T Constant_Value_k;           // Computed Parameter: Constant_Value_k\n                                          //  Referenced by: '<S186>/Constant'\n\n  real32_T Constant_Value_ms;          // Computed Parameter: Constant_Value_ms\n                                          //  Referenced by: '<S187>/Constant'\n\n  real32_T Constant_Value_i;           // Computed Parameter: Constant_Value_i\n                                          //  Referenced by: '<S188>/Constant'\n\n  real32_T Constant_Value_j;           // Computed Parameter: Constant_Value_j\n                                          //  Referenced by: '<S189>/Constant'\n\n  real32_T Constant_Value_lw;          // Computed Parameter: Constant_Value_lw\n                                          //  Referenced by: '<S190>/Constant'\n\n  real32_T Constant_Value_ox;          // Computed Parameter: Constant_Value_ox\n                                          //  Referenced by: '<S191>/Constant'\n\n  real32_T DeadZone3_Start_l;          // Computed Parameter: DeadZone3_Start_l\n                                          //  Referenced by: '<S22>/Dead Zone3'\n\n  real32_T DeadZone3_End_n;            // Computed Parameter: DeadZone3_End_n\n                                          //  Referenced by: '<S22>/Dead Zone3'\n\n  real32_T Saturation9_UpperSat_c; // Computed Parameter: Saturation9_UpperSat_c\n                                      //  Referenced by: '<S22>/Saturation9'\n\n  real32_T Saturation9_LowerSat_i; // Computed Parameter: Saturation9_LowerSat_i\n                                      //  Referenced by: '<S22>/Saturation9'\n\n  real32_T DeadZone1_Start_n;          // Computed Parameter: DeadZone1_Start_n\n                                          //  Referenced by: '<S22>/Dead Zone1'\n\n  real32_T DeadZone1_End_mj;           // Computed Parameter: DeadZone1_End_mj\n                                          //  Referenced by: '<S22>/Dead Zone1'\n\n  real32_T Saturation1_UpperSat_d; // Computed Parameter: Saturation1_UpperSat_d\n                                      //  Referenced by: '<S22>/Saturation1'\n\n  real32_T Saturation1_LowerSat_b; // Computed Parameter: Saturation1_LowerSat_b\n                                      //  Referenced by: '<S22>/Saturation1'\n\n  real32_T DeadZone2_Start_m;          // Computed Parameter: DeadZone2_Start_m\n                                          //  Referenced by: '<S22>/Dead Zone2'\n\n  real32_T DeadZone2_End_b;            // Computed Parameter: DeadZone2_End_b\n                                          //  Referenced by: '<S22>/Dead Zone2'\n\n  real32_T Saturation3_UpperSat_d; // Computed Parameter: Saturation3_UpperSat_d\n                                      //  Referenced by: '<S22>/Saturation3'\n\n  real32_T Saturation3_LowerSat_n; // Computed Parameter: Saturation3_LowerSat_n\n                                      //  Referenced by: '<S22>/Saturation3'\n\n  real32_T DeadZone4_Start;            // Computed Parameter: DeadZone4_Start\n                                          //  Referenced by: '<S22>/Dead Zone4'\n\n  real32_T DeadZone4_End;              // Computed Parameter: DeadZone4_End\n                                          //  Referenced by: '<S22>/Dead Zone4'\n\n  real32_T Saturation10_UpperSat;   // Computed Parameter: Saturation10_UpperSat\n                                       //  Referenced by: '<S22>/Saturation10'\n\n  real32_T Saturation10_LowerSat;   // Computed Parameter: Saturation10_LowerSat\n                                       //  Referenced by: '<S22>/Saturation10'\n\n  real32_T Gain_Gain_er;               // Computed Parameter: Gain_Gain_er\n                                          //  Referenced by: '<S22>/Gain'\n\n  real32_T Gain_Gain_o;                // Computed Parameter: Gain_Gain_o\n                                          //  Referenced by: '<S1>/Gain'\n\n  real32_T Integrator_gainval_h;     // Computed Parameter: Integrator_gainval_h\n                                        //  Referenced by: '<S60>/Integrator'\n\n  real32_T Filter_gainval;             // Computed Parameter: Filter_gainval\n                                          //  Referenced by: '<S55>/Filter'\n\n  real32_T Constant_Value_gx;          // Computed Parameter: Constant_Value_gx\n                                          //  Referenced by: '<S1>/Constant'\n\n  real32_T Saturation1_UpperSat_lr;\n                                  // Computed Parameter: Saturation1_UpperSat_lr\n                                     //  Referenced by: '<S1>/Saturation1'\n\n  real32_T Saturation1_LowerSat_e; // Computed Parameter: Saturation1_LowerSat_e\n                                      //  Referenced by: '<S1>/Saturation1'\n\n  real32_T TSamp_WtEt_k;               // Computed Parameter: TSamp_WtEt_k\n                                          //  Referenced by: '<S480>/TSamp'\n\n  real32_T TSamp_WtEt_c;               // Computed Parameter: TSamp_WtEt_c\n                                          //  Referenced by: '<S478>/TSamp'\n\n  real32_T TSamp_WtEt_b;               // Computed Parameter: TSamp_WtEt_b\n                                          //  Referenced by: '<S479>/TSamp'\n\n  real32_T TSamp_WtEt_py;              // Computed Parameter: TSamp_WtEt_py\n                                          //  Referenced by: '<S481>/TSamp'\n\n  real32_T DiscreteTimeIntegrator_gainva_c;\n                          // Computed Parameter: DiscreteTimeIntegrator_gainva_c\n                             //  Referenced by: '<S11>/Discrete-Time Integrator'\n\n  real32_T DiscreteTimeIntegrator_IC;\n                                // Computed Parameter: DiscreteTimeIntegrator_IC\n                                   //  Referenced by: '<S11>/Discrete-Time Integrator'\n\n  real32_T Saturation2_UpperSat_i; // Computed Parameter: Saturation2_UpperSat_i\n                                      //  Referenced by: '<S11>/Saturation2'\n\n  real32_T Saturation2_LowerSat_k; // Computed Parameter: Saturation2_LowerSat_k\n                                      //  Referenced by: '<S11>/Saturation2'\n\n  real32_T Constant_Value_ll;          // Computed Parameter: Constant_Value_ll\n                                          //  Referenced by: '<S21>/Constant'\n\n  real32_T Constant_Value_a5;          // Computed Parameter: Constant_Value_a5\n                                          //  Referenced by: '<Root>/Constant'\n\n  real32_T Clamping_zero_Value;       // Computed Parameter: Clamping_zero_Value\n                                         //  Referenced by: '<S50>/Clamping_zero'\n\n  uint16_T PWM_Y0;                     // Computed Parameter: PWM_Y0\n                                          //  Referenced by: '<S7>/PWM'\n\n  uint16_T Output_Limits1_UpperSat;\n                                  // Computed Parameter: Output_Limits1_UpperSat\n                                     //  Referenced by: '<S7>/Output_Limits1'\n\n  uint16_T Output_Limits1_LowerSat;\n                                  // Computed Parameter: Output_Limits1_LowerSat\n                                     //  Referenced by: '<S7>/Output_Limits1'\n\n  uint16_T rate_transition_ctrl_sw_Initial;\n                          // Computed Parameter: rate_transition_ctrl_sw_Initial\n                             //  Referenced by: '<Root>/rate_transition_ctrl_sw'\n\n  uint16_T RateTransition4_InitialConditio;\n                          // Computed Parameter: RateTransition4_InitialConditio\n                             //  Referenced by: '<Root>/Rate Transition4'\n\n  boolean_T rate_transition_arm_InitialCond;\n                          // Computed Parameter: rate_transition_arm_InitialCond\n                             //  Referenced by: '<Root>/rate_transition_arm'\n\n  boolean_T RateTransition7_InitialConditio;\n                          // Computed Parameter: RateTransition7_InitialConditio\n                             //  Referenced by: '<Root>/Rate Transition7'\n\n  int8_T Constant_Value_ko;            // Computed Parameter: Constant_Value_ko\n                                          //  Referenced by: '<S50>/Constant'\n\n  int8_T Constant2_Value_e;            // Computed Parameter: Constant2_Value_e\n                                          //  Referenced by: '<S50>/Constant2'\n\n  int8_T Constant3_Value_i;            // Computed Parameter: Constant3_Value_i\n                                          //  Referenced by: '<S50>/Constant3'\n\n  int8_T Constant4_Value_d;            // Computed Parameter: Constant4_Value_d\n                                          //  Referenced by: '<S50>/Constant4'\n\n};\n\n// Real-time Model Data Structure\nstruct tag_RTM_FLIGHT_hexacopter_T {\n  const char_T * volatile errorStatus;\n\n  //\n  //  Timing:\n  //  The following substructure contains information regarding\n  //  the timing information for the model.\n\n  struct {\n    struct {\n      uint8_T TID[2];\n    } TaskCounters;\n\n    struct {\n      boolean_T TID0_1;\n    } RateInteraction;\n  } Timing;\n};\n\n// Block parameters (default storage)\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern P_FLIGHT_hexacopter_T FLIGHT_hexacopter_P;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n// Block signals (default storage)\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern struct B_FLIGHT_hexacopter_T FLIGHT_hexacopter_B;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n// Block states (default storage)\nextern struct DW_FLIGHT_hexacopter_T FLIGHT_hexacopter_DW;\n\n// External function called from main\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern void FLIGHT_hexacopter_SetEventsForThisBaseStep(boolean_T *eventFlags);\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  // Model entry point functions\n  extern void FLIGHT_hexacopter_initialize(void);\n  extern void FLIGHT_hexacopter_step0(void);\n  extern void FLIGHT_hexacopter_step1(void);\n  extern void FLIGHT_hexacopter_step(int_T tid);\n  extern void FLIGHT_hexacopter_terminate(void);\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n// Real-time Model object\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern RT_MODEL_FLIGHT_hexacopter_T *const FLIGHT_hexacopter_M;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\nextern volatile boolean_T stopRequested;\nextern volatile boolean_T runModel;\n\n//-\n//  These blocks were eliminated from the model due to optimizations:\n//\n//  Block '<S22>/Display' : Unused code path elimination\n//  Block '<S22>/Display1' : Unused code path elimination\n//  Block '<S22>/Display2' : Unused code path elimination\n//  Block '<S22>/Display3' : Unused code path elimination\n//  Block '<S122>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S122>/Data Type Propagation' : Unused code path elimination\n//  Block '<S173>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S173>/Data Type Propagation' : Unused code path elimination\n//  Block '<S192>/Data Type Conversion10' : Unused code path elimination\n//  Block '<S192>/Data Type Conversion11' : Unused code path elimination\n//  Block '<S192>/Dead Zone2' : Unused code path elimination\n//  Block '<S192>/Dead Zone4' : Unused code path elimination\n//  Block '<S192>/Display' : Unused code path elimination\n//  Block '<S192>/Display1' : Unused code path elimination\n//  Block '<S192>/Display2' : Unused code path elimination\n//  Block '<S192>/Display3' : Unused code path elimination\n//  Block '<S192>/Fcn3' : Unused code path elimination\n//  Block '<S192>/Fcn7' : Unused code path elimination\n//  Block '<S192>/Gain' : Unused code path elimination\n//  Block '<S192>/Gain3' : Unused code path elimination\n//  Block '<S192>/Saturation10' : Unused code path elimination\n//  Block '<S192>/Saturation3' : Unused code path elimination\n//  Block '<S301>/NOT' : Unused code path elimination\n//  Block '<S304>/NOT' : Unused code path elimination\n//  Block '<S302>/Signal Copy' : Unused code path elimination\n//  Block '<S302>/Signal Copy1' : Unused code path elimination\n//  Block '<S302>/Signal Copy2' : Unused code path elimination\n//  Block '<S306>/NOT' : Unused code path elimination\n//  Block '<S312>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S367>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S422>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S478>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S479>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S480>/Data Type Duplicate' : Unused code path elimination\n//  Block '<S481>/Data Type Duplicate' : Unused code path elimination\n//  Block '<Root>/Scope1' : Unused code path elimination\n//  Block '<S12>/Display' : Unused code path elimination\n//  Block '<S12>/Display1' : Unused code path elimination\n//  Block '<S12>/Display2' : Unused code path elimination\n//  Block '<S12>/Display3' : Unused code path elimination\n//  Block '<S12>/Display5' : Unused code path elimination\n//  Block '<S12>/Display6' : Unused code path elimination\n//  Block '<S12>/Display7' : Unused code path elimination\n//  Block '<S497>/NOT' : Unused code path elimination\n//  Block '<S500>/NOT' : Unused code path elimination\n//  Block '<S501>/NOT' : Unused code path elimination\n//  Block '<S19>/Constant' : Unused code path elimination\n//  Block '<S505>/1//2' : Unused code path elimination\n//  Block '<S505>/q0' : Unused code path elimination\n//  Block '<S505>/q1' : Unused code path elimination\n//  Block '<S505>/q2' : Unused code path elimination\n//  Block '<S505>/q3' : Unused code path elimination\n//  Block '<S505>/sincos' : Unused code path elimination\n//  Block '<Root>/Scope' : Unused code path elimination\n//  Block '<S8>/Data Type Conversion' : Eliminate redundant data type conversion\n//  Block '<S8>/Data Type Conversion9' : Eliminate redundant data type conversion\n//  Block '<S477>/Data Type Conversion' : Eliminate redundant data type conversion\n//  Block '<S477>/Data Type Conversion1' : Eliminate redundant data type conversion\n//  Block '<S15>/Data Type Conversion1' : Eliminate redundant data type conversion\n\n\n//-\n//  The generated code includes comments that allow you to trace directly\n//  back to the appropriate location in the model.  The basic format\n//  is <system>/block_name, where system is the system number (uniquely\n//  assigned by Simulink) and block_name is the name of the block.\n//\n//  Use the MATLAB hilite_system command to trace the generated code back\n//  to the model.  For example,\n//\n//  hilite_system('<S3>')    - opens system 3\n//  hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n//\n//  Here is the system hierarchy for this model\n//\n//  '<Root>' : 'FLIGHT_hexacopter'\n//  '<S1>'   : 'FLIGHT_hexacopter/Altitude_Mode'\n//  '<S2>'   : 'FLIGHT_hexacopter/CAS'\n//  '<S3>'   : 'FLIGHT_hexacopter/Doublet_Generator'\n//  '<S4>'   : 'FLIGHT_hexacopter/Fault_Injection'\n//  '<S5>'   : 'FLIGHT_hexacopter/If Action Subsystem'\n//  '<S6>'   : 'FLIGHT_hexacopter/MATLAB Function'\n//  '<S7>'   : 'FLIGHT_hexacopter/Mixer'\n//  '<S8>'   : 'FLIGHT_hexacopter/Read uORB'\n//  '<S9>'   : 'FLIGHT_hexacopter/Remote Control'\n//  '<S10>'  : 'FLIGHT_hexacopter/SAS'\n//  '<S11>'  : 'FLIGHT_hexacopter/SMC'\n//  '<S12>'  : 'FLIGHT_hexacopter/Stabilized_Mode'\n//  '<S13>'  : 'FLIGHT_hexacopter/Subsystem'\n//  '<S14>'  : 'FLIGHT_hexacopter/actuator_controls'\n//  '<S15>'  : 'FLIGHT_hexacopter/actuator_outputs_motors'\n//  '<S16>'  : 'FLIGHT_hexacopter/quat2eul'\n//  '<S17>'  : 'FLIGHT_hexacopter/sub_vehicle_angular_velocity'\n//  '<S18>'  : 'FLIGHT_hexacopter/sub_vehicle_status'\n//  '<S19>'  : 'FLIGHT_hexacopter/vehicle_attitude_setpoint'\n//  '<S20>'  : 'FLIGHT_hexacopter/vehicle_local_position_setpoint'\n//  '<S21>'  : 'FLIGHT_hexacopter/vehicle_rate_setpoint'\n//  '<S22>'  : 'FLIGHT_hexacopter/Altitude_Mode/Altitude_Mode_Stick2Command'\n//  '<S23>'  : 'FLIGHT_hexacopter/Altitude_Mode/Compare To Constant1'\n//  '<S24>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller'\n//  '<S25>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Anti-windup'\n//  '<S26>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/D Gain'\n//  '<S27>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/External Derivative'\n//  '<S28>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Filter'\n//  '<S29>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Filter ICs'\n//  '<S30>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/I Gain'\n//  '<S31>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Ideal P Gain'\n//  '<S32>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Ideal P Gain Fdbk'\n//  '<S33>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Integrator'\n//  '<S34>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Integrator ICs'\n//  '<S35>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/N Copy'\n//  '<S36>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/N Gain'\n//  '<S37>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/P Copy'\n//  '<S38>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Parallel P Gain'\n//  '<S39>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Reset Signal'\n//  '<S40>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Saturation'\n//  '<S41>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Saturation Fdbk'\n//  '<S42>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Sum'\n//  '<S43>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Sum Fdbk'\n//  '<S44>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Tracking Mode'\n//  '<S45>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Tracking Mode Sum'\n//  '<S46>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Tsamp - Integral'\n//  '<S47>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Tsamp - Ngain'\n//  '<S48>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/postSat Signal'\n//  '<S49>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/preSat Signal'\n//  '<S50>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Anti-windup/Disc. Clamping Parallel'\n//  '<S51>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Anti-windup/Disc. Clamping Parallel/Dead Zone'\n//  '<S52>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Anti-windup/Disc. Clamping Parallel/Dead Zone/Enabled'\n//  '<S53>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/D Gain/External Parameters'\n//  '<S54>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/External Derivative/Error'\n//  '<S55>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Filter/Disc. Forward Euler Filter'\n//  '<S56>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Filter ICs/Internal IC - Filter'\n//  '<S57>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/I Gain/External Parameters'\n//  '<S58>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Ideal P Gain/Passthrough'\n//  '<S59>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Ideal P Gain Fdbk/Disabled'\n//  '<S60>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Integrator/Discrete'\n//  '<S61>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Integrator ICs/Internal IC'\n//  '<S62>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/N Copy/Disabled'\n//  '<S63>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/N Gain/External Parameters'\n//  '<S64>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/P Copy/Disabled'\n//  '<S65>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Parallel P Gain/External Parameters'\n//  '<S66>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Reset Signal/External Reset'\n//  '<S67>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Saturation/Enabled'\n//  '<S68>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Saturation Fdbk/Disabled'\n//  '<S69>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Sum/Sum_PID'\n//  '<S70>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Sum Fdbk/Disabled'\n//  '<S71>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Tracking Mode/Disabled'\n//  '<S72>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Tracking Mode Sum/Passthrough'\n//  '<S73>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Tsamp - Integral/TsSignalSpecification'\n//  '<S74>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/Tsamp - Ngain/Passthrough'\n//  '<S75>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/postSat Signal/Forward_Path'\n//  '<S76>'  : 'FLIGHT_hexacopter/Altitude_Mode/PID Controller/preSat Signal/Forward_Path'\n//  '<S77>'  : 'FLIGHT_hexacopter/CAS/Degrees to Radians'\n//  '<S78>'  : 'FLIGHT_hexacopter/CAS/Degrees to Radians1'\n//  '<S79>'  : 'FLIGHT_hexacopter/CAS/PID Controller3'\n//  '<S80>'  : 'FLIGHT_hexacopter/CAS/PID Controller4'\n//  '<S81>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Anti-windup'\n//  '<S82>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/D Gain'\n//  '<S83>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/External Derivative'\n//  '<S84>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Filter'\n//  '<S85>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Filter ICs'\n//  '<S86>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/I Gain'\n//  '<S87>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Ideal P Gain'\n//  '<S88>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Ideal P Gain Fdbk'\n//  '<S89>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Integrator'\n//  '<S90>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Integrator ICs'\n//  '<S91>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/N Copy'\n//  '<S92>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/N Gain'\n//  '<S93>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/P Copy'\n//  '<S94>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Parallel P Gain'\n//  '<S95>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Reset Signal'\n//  '<S96>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Saturation'\n//  '<S97>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Saturation Fdbk'\n//  '<S98>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Sum'\n//  '<S99>'  : 'FLIGHT_hexacopter/CAS/PID Controller3/Sum Fdbk'\n//  '<S100>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tracking Mode'\n//  '<S101>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tracking Mode Sum'\n//  '<S102>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tsamp - Integral'\n//  '<S103>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tsamp - Ngain'\n//  '<S104>' : 'FLIGHT_hexacopter/CAS/PID Controller3/postSat Signal'\n//  '<S105>' : 'FLIGHT_hexacopter/CAS/PID Controller3/preSat Signal'\n//  '<S106>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Anti-windup/Disabled'\n//  '<S107>' : 'FLIGHT_hexacopter/CAS/PID Controller3/D Gain/Disabled'\n//  '<S108>' : 'FLIGHT_hexacopter/CAS/PID Controller3/External Derivative/Disabled'\n//  '<S109>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Filter/Disabled'\n//  '<S110>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Filter ICs/Disabled'\n//  '<S111>' : 'FLIGHT_hexacopter/CAS/PID Controller3/I Gain/Disabled'\n//  '<S112>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Ideal P Gain/Passthrough'\n//  '<S113>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Ideal P Gain Fdbk/Disabled'\n//  '<S114>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Integrator/Disabled'\n//  '<S115>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Integrator ICs/Disabled'\n//  '<S116>' : 'FLIGHT_hexacopter/CAS/PID Controller3/N Copy/Disabled wSignal Specification'\n//  '<S117>' : 'FLIGHT_hexacopter/CAS/PID Controller3/N Gain/Disabled'\n//  '<S118>' : 'FLIGHT_hexacopter/CAS/PID Controller3/P Copy/Disabled'\n//  '<S119>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Parallel P Gain/External Parameters'\n//  '<S120>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Reset Signal/Disabled'\n//  '<S121>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Saturation/External'\n//  '<S122>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Saturation/External/Saturation Dynamic'\n//  '<S123>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Saturation Fdbk/Disabled'\n//  '<S124>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Sum/Passthrough_P'\n//  '<S125>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Sum Fdbk/Disabled'\n//  '<S126>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tracking Mode/Disabled'\n//  '<S127>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tracking Mode Sum/Passthrough'\n//  '<S128>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tsamp - Integral/TsSignalSpecification'\n//  '<S129>' : 'FLIGHT_hexacopter/CAS/PID Controller3/Tsamp - Ngain/Passthrough'\n//  '<S130>' : 'FLIGHT_hexacopter/CAS/PID Controller3/postSat Signal/Forward_Path'\n//  '<S131>' : 'FLIGHT_hexacopter/CAS/PID Controller3/preSat Signal/Forward_Path'\n//  '<S132>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Anti-windup'\n//  '<S133>' : 'FLIGHT_hexacopter/CAS/PID Controller4/D Gain'\n//  '<S134>' : 'FLIGHT_hexacopter/CAS/PID Controller4/External Derivative'\n//  '<S135>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Filter'\n//  '<S136>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Filter ICs'\n//  '<S137>' : 'FLIGHT_hexacopter/CAS/PID Controller4/I Gain'\n//  '<S138>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Ideal P Gain'\n//  '<S139>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Ideal P Gain Fdbk'\n//  '<S140>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Integrator'\n//  '<S141>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Integrator ICs'\n//  '<S142>' : 'FLIGHT_hexacopter/CAS/PID Controller4/N Copy'\n//  '<S143>' : 'FLIGHT_hexacopter/CAS/PID Controller4/N Gain'\n//  '<S144>' : 'FLIGHT_hexacopter/CAS/PID Controller4/P Copy'\n//  '<S145>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Parallel P Gain'\n//  '<S146>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Reset Signal'\n//  '<S147>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Saturation'\n//  '<S148>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Saturation Fdbk'\n//  '<S149>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Sum'\n//  '<S150>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Sum Fdbk'\n//  '<S151>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tracking Mode'\n//  '<S152>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tracking Mode Sum'\n//  '<S153>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tsamp - Integral'\n//  '<S154>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tsamp - Ngain'\n//  '<S155>' : 'FLIGHT_hexacopter/CAS/PID Controller4/postSat Signal'\n//  '<S156>' : 'FLIGHT_hexacopter/CAS/PID Controller4/preSat Signal'\n//  '<S157>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Anti-windup/Disabled'\n//  '<S158>' : 'FLIGHT_hexacopter/CAS/PID Controller4/D Gain/Disabled'\n//  '<S159>' : 'FLIGHT_hexacopter/CAS/PID Controller4/External Derivative/Disabled'\n//  '<S160>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Filter/Disabled'\n//  '<S161>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Filter ICs/Disabled'\n//  '<S162>' : 'FLIGHT_hexacopter/CAS/PID Controller4/I Gain/Disabled'\n//  '<S163>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Ideal P Gain/Passthrough'\n//  '<S164>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Ideal P Gain Fdbk/Disabled'\n//  '<S165>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Integrator/Disabled'\n//  '<S166>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Integrator ICs/Disabled'\n//  '<S167>' : 'FLIGHT_hexacopter/CAS/PID Controller4/N Copy/Disabled wSignal Specification'\n//  '<S168>' : 'FLIGHT_hexacopter/CAS/PID Controller4/N Gain/Disabled'\n//  '<S169>' : 'FLIGHT_hexacopter/CAS/PID Controller4/P Copy/Disabled'\n//  '<S170>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Parallel P Gain/External Parameters'\n//  '<S171>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Reset Signal/Disabled'\n//  '<S172>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Saturation/External'\n//  '<S173>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Saturation/External/Saturation Dynamic'\n//  '<S174>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Saturation Fdbk/Disabled'\n//  '<S175>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Sum/Passthrough_P'\n//  '<S176>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Sum Fdbk/Disabled'\n//  '<S177>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tracking Mode/Disabled'\n//  '<S178>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tracking Mode Sum/Passthrough'\n//  '<S179>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tsamp - Integral/TsSignalSpecification'\n//  '<S180>' : 'FLIGHT_hexacopter/CAS/PID Controller4/Tsamp - Ngain/Passthrough'\n//  '<S181>' : 'FLIGHT_hexacopter/CAS/PID Controller4/postSat Signal/Forward_Path'\n//  '<S182>' : 'FLIGHT_hexacopter/CAS/PID Controller4/preSat Signal/Forward_Path'\n//  '<S183>' : 'FLIGHT_hexacopter/Doublet_Generator/Compare To Constant1'\n//  '<S184>' : 'FLIGHT_hexacopter/Doublet_Generator/MATLAB Function'\n//  '<S185>' : 'FLIGHT_hexacopter/Fault_Injection/Compare To Constant'\n//  '<S186>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference'\n//  '<S187>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference1'\n//  '<S188>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference2'\n//  '<S189>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference3'\n//  '<S190>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference4'\n//  '<S191>' : 'FLIGHT_hexacopter/Fault_Injection/Subsystem Reference5'\n//  '<S192>' : 'FLIGHT_hexacopter/If Action Subsystem/Altitude_Mode_Stick2Command'\n//  '<S193>' : 'FLIGHT_hexacopter/If Action Subsystem/Compare To Constant2'\n//  '<S194>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller'\n//  '<S195>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller'\n//  '<S196>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude'\n//  '<S197>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Anti-windup'\n//  '<S198>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/D Gain'\n//  '<S199>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/External Derivative'\n//  '<S200>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Filter'\n//  '<S201>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Filter ICs'\n//  '<S202>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/I Gain'\n//  '<S203>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Ideal P Gain'\n//  '<S204>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Ideal P Gain Fdbk'\n//  '<S205>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Integrator'\n//  '<S206>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Integrator ICs'\n//  '<S207>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/N Copy'\n//  '<S208>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/N Gain'\n//  '<S209>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/P Copy'\n//  '<S210>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Parallel P Gain'\n//  '<S211>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Reset Signal'\n//  '<S212>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Saturation'\n//  '<S213>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Saturation Fdbk'\n//  '<S214>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Sum'\n//  '<S215>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Sum Fdbk'\n//  '<S216>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tracking Mode'\n//  '<S217>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tracking Mode Sum'\n//  '<S218>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tsamp - Integral'\n//  '<S219>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tsamp - Ngain'\n//  '<S220>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/postSat Signal'\n//  '<S221>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/preSat Signal'\n//  '<S222>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Anti-windup/Disabled'\n//  '<S223>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/D Gain/Disabled'\n//  '<S224>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/External Derivative/Disabled'\n//  '<S225>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Filter/Disabled'\n//  '<S226>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Filter ICs/Disabled'\n//  '<S227>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/I Gain/Disabled'\n//  '<S228>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Ideal P Gain/Passthrough'\n//  '<S229>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Ideal P Gain Fdbk/Disabled'\n//  '<S230>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Integrator/Disabled'\n//  '<S231>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Integrator ICs/Disabled'\n//  '<S232>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/N Copy/Disabled wSignal Specification'\n//  '<S233>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/N Gain/Disabled'\n//  '<S234>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/P Copy/Disabled'\n//  '<S235>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Parallel P Gain/External Parameters'\n//  '<S236>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Reset Signal/Disabled'\n//  '<S237>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Saturation/Passthrough'\n//  '<S238>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Saturation Fdbk/Disabled'\n//  '<S239>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Sum/Passthrough_P'\n//  '<S240>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Sum Fdbk/Disabled'\n//  '<S241>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tracking Mode/Disabled'\n//  '<S242>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tracking Mode Sum/Passthrough'\n//  '<S243>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tsamp - Integral/TsSignalSpecification'\n//  '<S244>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/Tsamp - Ngain/Passthrough'\n//  '<S245>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/postSat Signal/Forward_Path'\n//  '<S246>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Pos Controller/PID_Altitude/preSat Signal/Forward_Path'\n//  '<S247>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/NED2Body1'\n//  '<S248>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude'\n//  '<S249>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/NED2Body1/Calculate Transformation Matrix'\n//  '<S250>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Anti-windup'\n//  '<S251>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/D Gain'\n//  '<S252>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/External Derivative'\n//  '<S253>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Filter'\n//  '<S254>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Filter ICs'\n//  '<S255>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/I Gain'\n//  '<S256>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Ideal P Gain'\n//  '<S257>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Ideal P Gain Fdbk'\n//  '<S258>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Integrator'\n//  '<S259>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Integrator ICs'\n//  '<S260>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/N Copy'\n//  '<S261>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/N Gain'\n//  '<S262>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/P Copy'\n//  '<S263>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Parallel P Gain'\n//  '<S264>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Reset Signal'\n//  '<S265>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Saturation'\n//  '<S266>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Saturation Fdbk'\n//  '<S267>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Sum'\n//  '<S268>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Sum Fdbk'\n//  '<S269>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tracking Mode'\n//  '<S270>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tracking Mode Sum'\n//  '<S271>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tsamp - Integral'\n//  '<S272>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tsamp - Ngain'\n//  '<S273>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/postSat Signal'\n//  '<S274>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/preSat Signal'\n//  '<S275>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Anti-windup/Disabled'\n//  '<S276>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/D Gain/Disabled'\n//  '<S277>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/External Derivative/Disabled'\n//  '<S278>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Filter/Disabled'\n//  '<S279>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Filter ICs/Disabled'\n//  '<S280>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/I Gain/Disabled'\n//  '<S281>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Ideal P Gain/Passthrough'\n//  '<S282>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Ideal P Gain Fdbk/Disabled'\n//  '<S283>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Integrator/Disabled'\n//  '<S284>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Integrator ICs/Disabled'\n//  '<S285>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/N Copy/Disabled wSignal Specification'\n//  '<S286>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/N Gain/Disabled'\n//  '<S287>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/P Copy/Disabled'\n//  '<S288>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Parallel P Gain/External Parameters'\n//  '<S289>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Reset Signal/Disabled'\n//  '<S290>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Saturation/Passthrough'\n//  '<S291>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Saturation Fdbk/Disabled'\n//  '<S292>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Sum/Passthrough_P'\n//  '<S293>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Sum Fdbk/Disabled'\n//  '<S294>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tracking Mode/Disabled'\n//  '<S295>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tracking Mode Sum/Passthrough'\n//  '<S296>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tsamp - Integral/TsSignalSpecification'\n//  '<S297>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/Tsamp - Ngain/Passthrough'\n//  '<S298>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/postSat Signal/Forward_Path'\n//  '<S299>' : 'FLIGHT_hexacopter/If Action Subsystem/XY Velocity Controller/PID_Altitude/preSat Signal/Forward_Path'\n//  '<S300>' : 'FLIGHT_hexacopter/Mixer/pwm_out2'\n//  '<S301>' : 'FLIGHT_hexacopter/Read uORB/PX4 uORB Read'\n//  '<S302>' : 'FLIGHT_hexacopter/Read uORB/Vehicle Attitude'\n//  '<S303>' : 'FLIGHT_hexacopter/Read uORB/PX4 uORB Read/Enabled Subsystem'\n//  '<S304>' : 'FLIGHT_hexacopter/Read uORB/Vehicle Attitude/PX4 uORB Read'\n//  '<S305>' : 'FLIGHT_hexacopter/Read uORB/Vehicle Attitude/PX4 uORB Read/Enabled Subsystem'\n//  '<S306>' : 'FLIGHT_hexacopter/Remote Control/PX4 uORB Read'\n//  '<S307>' : 'FLIGHT_hexacopter/Remote Control/PX4 uORB Read/Enabled Subsystem'\n//  '<S308>' : 'FLIGHT_hexacopter/SAS/MATLAB Function'\n//  '<S309>' : 'FLIGHT_hexacopter/SAS/Pitchrate'\n//  '<S310>' : 'FLIGHT_hexacopter/SAS/Rollrate'\n//  '<S311>' : 'FLIGHT_hexacopter/SAS/Yawrate'\n//  '<S312>' : 'FLIGHT_hexacopter/SAS/Pitchrate/Discrete Derivative2'\n//  '<S313>' : 'FLIGHT_hexacopter/SAS/Pitchrate/Discrete Varying Lowpass2'\n//  '<S314>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate'\n//  '<S315>' : 'FLIGHT_hexacopter/SAS/Pitchrate/Discrete Varying Lowpass2/SOS1'\n//  '<S316>' : 'FLIGHT_hexacopter/SAS/Pitchrate/Discrete Varying Lowpass2/SOS1/Arithmetic'\n//  '<S317>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Anti-windup'\n//  '<S318>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/D Gain'\n//  '<S319>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/External Derivative'\n//  '<S320>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Filter'\n//  '<S321>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Filter ICs'\n//  '<S322>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/I Gain'\n//  '<S323>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Ideal P Gain'\n//  '<S324>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Ideal P Gain Fdbk'\n//  '<S325>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Integrator'\n//  '<S326>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Integrator ICs'\n//  '<S327>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/N Copy'\n//  '<S328>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/N Gain'\n//  '<S329>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/P Copy'\n//  '<S330>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Parallel P Gain'\n//  '<S331>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Reset Signal'\n//  '<S332>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Saturation'\n//  '<S333>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Saturation Fdbk'\n//  '<S334>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Sum'\n//  '<S335>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Sum Fdbk'\n//  '<S336>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Tracking Mode'\n//  '<S337>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Tracking Mode Sum'\n//  '<S338>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Tsamp - Integral'\n//  '<S339>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Tsamp - Ngain'\n//  '<S340>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/postSat Signal'\n//  '<S341>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/preSat Signal'\n//  '<S342>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Anti-windup/Passthrough'\n//  '<S343>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/D Gain/Disabled'\n//  '<S344>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/External Derivative/Disabled'\n//  '<S345>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Filter/Disabled'\n//  '<S346>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Filter ICs/Disabled'\n//  '<S347>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/I Gain/External Parameters'\n//  '<S348>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Ideal P Gain/Passthrough'\n//  '<S349>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Ideal P Gain Fdbk/Disabled'\n//  '<S350>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Integrator/Discrete'\n//  '<S351>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Integrator ICs/Internal IC'\n//  '<S352>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/N Copy/Disabled wSignal Specification'\n//  '<S353>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/N Gain/Disabled'\n//  '<S354>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/P Copy/Disabled'\n//  '<S355>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Parallel P Gain/External Parameters'\n//  '<S356>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Reset Signal/Disabled'\n//  '<S357>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Saturation/Passthrough'\n//  '<S358>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Saturation Fdbk/Disabled'\n//  '<S359>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Sum/Sum_PI'\n//  '<S360>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Sum Fdbk/Disabled'\n//  '<S361>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Tracking Mode/Disabled'\n//  '<S362>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Tracking Mode Sum/Passthrough'\n//  '<S363>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Tsamp - Integral/TsSignalSpecification'\n//  '<S364>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/Tsamp - Ngain/Passthrough'\n//  '<S365>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/postSat Signal/Forward_Path'\n//  '<S366>' : 'FLIGHT_hexacopter/SAS/Pitchrate/pid_ctrl_rollrate/preSat Signal/Forward_Path'\n//  '<S367>' : 'FLIGHT_hexacopter/SAS/Rollrate/Discrete Derivative2'\n//  '<S368>' : 'FLIGHT_hexacopter/SAS/Rollrate/Discrete Varying Lowpass2'\n//  '<S369>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate'\n//  '<S370>' : 'FLIGHT_hexacopter/SAS/Rollrate/Discrete Varying Lowpass2/SOS1'\n//  '<S371>' : 'FLIGHT_hexacopter/SAS/Rollrate/Discrete Varying Lowpass2/SOS1/Arithmetic'\n//  '<S372>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Anti-windup'\n//  '<S373>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/D Gain'\n//  '<S374>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/External Derivative'\n//  '<S375>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Filter'\n//  '<S376>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Filter ICs'\n//  '<S377>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/I Gain'\n//  '<S378>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Ideal P Gain'\n//  '<S379>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Ideal P Gain Fdbk'\n//  '<S380>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Integrator'\n//  '<S381>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Integrator ICs'\n//  '<S382>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/N Copy'\n//  '<S383>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/N Gain'\n//  '<S384>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/P Copy'\n//  '<S385>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Parallel P Gain'\n//  '<S386>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Reset Signal'\n//  '<S387>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Saturation'\n//  '<S388>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Saturation Fdbk'\n//  '<S389>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Sum'\n//  '<S390>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Sum Fdbk'\n//  '<S391>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Tracking Mode'\n//  '<S392>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Tracking Mode Sum'\n//  '<S393>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Tsamp - Integral'\n//  '<S394>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Tsamp - Ngain'\n//  '<S395>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/postSat Signal'\n//  '<S396>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/preSat Signal'\n//  '<S397>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Anti-windup/Passthrough'\n//  '<S398>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/D Gain/Disabled'\n//  '<S399>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/External Derivative/Disabled'\n//  '<S400>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Filter/Disabled'\n//  '<S401>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Filter ICs/Disabled'\n//  '<S402>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/I Gain/External Parameters'\n//  '<S403>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Ideal P Gain/Passthrough'\n//  '<S404>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Ideal P Gain Fdbk/Disabled'\n//  '<S405>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Integrator/Discrete'\n//  '<S406>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Integrator ICs/Internal IC'\n//  '<S407>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/N Copy/Disabled wSignal Specification'\n//  '<S408>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/N Gain/Disabled'\n//  '<S409>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/P Copy/Disabled'\n//  '<S410>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Parallel P Gain/External Parameters'\n//  '<S411>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Reset Signal/Disabled'\n//  '<S412>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Saturation/Passthrough'\n//  '<S413>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Saturation Fdbk/Disabled'\n//  '<S414>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Sum/Sum_PI'\n//  '<S415>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Sum Fdbk/Disabled'\n//  '<S416>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Tracking Mode/Disabled'\n//  '<S417>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Tracking Mode Sum/Passthrough'\n//  '<S418>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Tsamp - Integral/TsSignalSpecification'\n//  '<S419>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/Tsamp - Ngain/Passthrough'\n//  '<S420>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/postSat Signal/Forward_Path'\n//  '<S421>' : 'FLIGHT_hexacopter/SAS/Rollrate/pid_ctrl_rollrate/preSat Signal/Forward_Path'\n//  '<S422>' : 'FLIGHT_hexacopter/SAS/Yawrate/Discrete Derivative2'\n//  '<S423>' : 'FLIGHT_hexacopter/SAS/Yawrate/Discrete Varying Lowpass2'\n//  '<S424>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate'\n//  '<S425>' : 'FLIGHT_hexacopter/SAS/Yawrate/Discrete Varying Lowpass2/SOS1'\n//  '<S426>' : 'FLIGHT_hexacopter/SAS/Yawrate/Discrete Varying Lowpass2/SOS1/Arithmetic'\n//  '<S427>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Anti-windup'\n//  '<S428>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/D Gain'\n//  '<S429>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/External Derivative'\n//  '<S430>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Filter'\n//  '<S431>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Filter ICs'\n//  '<S432>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/I Gain'\n//  '<S433>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Ideal P Gain'\n//  '<S434>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Ideal P Gain Fdbk'\n//  '<S435>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Integrator'\n//  '<S436>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Integrator ICs'\n//  '<S437>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/N Copy'\n//  '<S438>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/N Gain'\n//  '<S439>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/P Copy'\n//  '<S440>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Parallel P Gain'\n//  '<S441>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Reset Signal'\n//  '<S442>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Saturation'\n//  '<S443>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Saturation Fdbk'\n//  '<S444>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Sum'\n//  '<S445>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Sum Fdbk'\n//  '<S446>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Tracking Mode'\n//  '<S447>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Tracking Mode Sum'\n//  '<S448>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Tsamp - Integral'\n//  '<S449>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Tsamp - Ngain'\n//  '<S450>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/postSat Signal'\n//  '<S451>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/preSat Signal'\n//  '<S452>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Anti-windup/Passthrough'\n//  '<S453>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/D Gain/Disabled'\n//  '<S454>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/External Derivative/Disabled'\n//  '<S455>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Filter/Disabled'\n//  '<S456>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Filter ICs/Disabled'\n//  '<S457>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/I Gain/External Parameters'\n//  '<S458>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Ideal P Gain/Passthrough'\n//  '<S459>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Ideal P Gain Fdbk/Disabled'\n//  '<S460>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Integrator/Discrete'\n//  '<S461>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Integrator ICs/Internal IC'\n//  '<S462>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/N Copy/Disabled wSignal Specification'\n//  '<S463>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/N Gain/Disabled'\n//  '<S464>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/P Copy/Disabled'\n//  '<S465>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Parallel P Gain/External Parameters'\n//  '<S466>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Reset Signal/Disabled'\n//  '<S467>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Saturation/Passthrough'\n//  '<S468>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Saturation Fdbk/Disabled'\n//  '<S469>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Sum/Sum_PI'\n//  '<S470>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Sum Fdbk/Disabled'\n//  '<S471>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Tracking Mode/Disabled'\n//  '<S472>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Tracking Mode Sum/Passthrough'\n//  '<S473>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Tsamp - Integral/TsSignalSpecification'\n//  '<S474>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/Tsamp - Ngain/Passthrough'\n//  '<S475>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/postSat Signal/Forward_Path'\n//  '<S476>' : 'FLIGHT_hexacopter/SAS/Yawrate/pid_ctrl_rollrate/preSat Signal/Forward_Path'\n//  '<S477>' : 'FLIGHT_hexacopter/SMC/Calc_Fx_Gx'\n//  '<S478>' : 'FLIGHT_hexacopter/SMC/Discrete Derivative'\n//  '<S479>' : 'FLIGHT_hexacopter/SMC/Discrete Derivative1'\n//  '<S480>' : 'FLIGHT_hexacopter/SMC/Discrete Derivative2'\n//  '<S481>' : 'FLIGHT_hexacopter/SMC/Discrete Derivative3'\n//  '<S482>' : 'FLIGHT_hexacopter/SMC/MATLAB Function'\n//  '<S483>' : 'FLIGHT_hexacopter/SMC/MATLAB Function1'\n//  '<S484>' : 'FLIGHT_hexacopter/SMC/MATLAB Function2'\n//  '<S485>' : 'FLIGHT_hexacopter/SMC/MATLAB Function3'\n//  '<S486>' : 'FLIGHT_hexacopter/SMC/MATLAB Function4'\n//  '<S487>' : 'FLIGHT_hexacopter/SMC/Omega_phi'\n//  '<S488>' : 'FLIGHT_hexacopter/Subsystem/Compare To Constant'\n//  '<S489>' : 'FLIGHT_hexacopter/Subsystem/MATLAB Function'\n//  '<S490>' : 'FLIGHT_hexacopter/actuator_controls/PX4 ULog'\n//  '<S491>' : 'FLIGHT_hexacopter/actuator_controls/PX4 ULog/PX4 uORB Message'\n//  '<S492>' : 'FLIGHT_hexacopter/actuator_controls/PX4 ULog/PX4_log_write'\n//  '<S493>' : 'FLIGHT_hexacopter/actuator_outputs_motors/Normalize_pwm6'\n//  '<S494>' : 'FLIGHT_hexacopter/actuator_outputs_motors/PX4 ULog'\n//  '<S495>' : 'FLIGHT_hexacopter/actuator_outputs_motors/PX4 ULog/PX4 uORB Message'\n//  '<S496>' : 'FLIGHT_hexacopter/actuator_outputs_motors/PX4 ULog/PX4_log_write'\n//  '<S497>' : 'FLIGHT_hexacopter/sub_vehicle_angular_velocity/PX4 uORB Read1'\n//  '<S498>' : 'FLIGHT_hexacopter/sub_vehicle_angular_velocity/PX4 uORB Read1/Enabled Subsystem'\n//  '<S499>' : 'FLIGHT_hexacopter/sub_vehicle_status/MATLAB Function'\n//  '<S500>' : 'FLIGHT_hexacopter/sub_vehicle_status/PX4 uORB Read'\n//  '<S501>' : 'FLIGHT_hexacopter/sub_vehicle_status/PX4 uORB Read1'\n//  '<S502>' : 'FLIGHT_hexacopter/sub_vehicle_status/PX4 uORB Read/Enabled Subsystem'\n//  '<S503>' : 'FLIGHT_hexacopter/sub_vehicle_status/PX4 uORB Read1/Enabled Subsystem'\n//  '<S504>' : 'FLIGHT_hexacopter/vehicle_attitude_setpoint/PX4 ULog'\n//  '<S505>' : 'FLIGHT_hexacopter/vehicle_attitude_setpoint/Rotation Angles to Quaternions'\n//  '<S506>' : 'FLIGHT_hexacopter/vehicle_attitude_setpoint/PX4 ULog/PX4 uORB Message'\n//  '<S507>' : 'FLIGHT_hexacopter/vehicle_attitude_setpoint/PX4 ULog/PX4_log_write'\n//  '<S508>' : 'FLIGHT_hexacopter/vehicle_local_position_setpoint/PX4 uORB Message'\n//  '<S509>' : 'FLIGHT_hexacopter/vehicle_local_position_setpoint/PX4 uORB Write'\n//  '<S510>' : 'FLIGHT_hexacopter/vehicle_rate_setpoint/PX4 ULog'\n//  '<S511>' : 'FLIGHT_hexacopter/vehicle_rate_setpoint/PX4 ULog/PX4 uORB Message'\n//  '<S512>' : 'FLIGHT_hexacopter/vehicle_rate_setpoint/PX4 ULog/PX4_log_write'\n\n#endif                                 // FLIGHT_hexacopter_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"FLIGHT_hexacopter_private.h","type":"header","group":"model","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: FLIGHT_hexacopter_private.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.250\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Fri May 23 13:47:19 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef FLIGHT_hexacopter_private_h_\n#define FLIGHT_hexacopter_private_h_\n#include \"rtwtypes.h\"\n#include \"FLIGHT_hexacopter.h\"\n#include \"FLIGHT_hexacopter_types.h\"\n\nextern real32_T rt_roundf_snf(real32_T u);\nextern real32_T rt_atan2f_snf(real32_T u0, real32_T u1);\nextern void FLIGHT_he_PX4Timestamp_Init(DW_PX4Timestamp_FLIGHT_hexaco_T *localDW);\nextern void FLIGHT_hexacop_PX4Timestamp(B_PX4Timestamp_FLIGHT_hexacop_T *localB);\nextern void FLIGHT__PX4Timestamp_b_Init(DW_PX4Timestamp_FLIGHT_hexa_b_T *localDW);\nextern void FLIGHT_hexac_PX4Timestamp_o(B_PX4Timestamp_FLIGHT_hexac_l_T *localB);\nextern void FLIGHT__PX4Timestamp_m_Init(DW_PX4Timestamp_FLIGHT_hexa_f_T *localDW);\nextern void FLIGHT_hexac_PX4Timestamp_n(B_PX4Timestamp_FLIGHT_hexac_h_T *localB);\nextern void FLIGHT_he_PX4Timestamp_Term(DW_PX4Timestamp_FLIGHT_hexaco_T *localDW);\nextern void FLIGHT__PX4Timestamp_o_Term(DW_PX4Timestamp_FLIGHT_hexa_b_T *localDW);\nextern void FLIGHT__PX4Timestamp_k_Term(DW_PX4Timestamp_FLIGHT_hexa_f_T *localDW);\n\n#endif                                 // FLIGHT_hexacopter_private_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"FLIGHT_hexacopter_types.h","type":"header","group":"model","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: FLIGHT_hexacopter_types.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.250\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Fri May 23 13:47:19 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef FLIGHT_hexacopter_types_h_\n#define FLIGHT_hexacopter_types_h_\n#include \"rtwtypes.h\"\n#include \"MW_Parameter.h\"\n#include <uORB/topics/vehicle_local_position.h>\n#include <uORB/topics/vehicle_odometry.h>\n#include <uORB/topics/input_rc.h>\n#include <uORB/topics/actuator_controls_status.h>\n#include <uORB/topics/actuator_motors.h>\n#include <uORB/topics/vehicle_angular_velocity.h>\n#include <uORB/topics/actuator_armed.h>\n#include <uORB/topics/vehicle_status.h>\n#include <uORB/topics/vehicle_attitude_setpoint.h>\n#include <uORB/topics/vehicle_local_position_setpoint.h>\n#include <uORB/topics/vehicle_rates_setpoint.h>\n#ifndef struct_e_px4_internal_block_SampleTi_T\n#define struct_e_px4_internal_block_SampleTi_T\n\nstruct e_px4_internal_block_SampleTi_T\n{\n  int32_T __dummy;\n};\n\n#endif                                // struct_e_px4_internal_block_SampleTi_T\n\n#ifndef struct_px4_internal_block_getPX4Abso_T\n#define struct_px4_internal_block_getPX4Abso_T\n\nstruct px4_internal_block_getPX4Abso_T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  e_px4_internal_block_SampleTi_T SampleTimeHandler;\n};\n\n#endif                                // struct_px4_internal_block_getPX4Abso_T\n\n// Custom Type definition for MATLABSystem: '<S11>/Read Parameter4'\n#include \"MW_Parameter.h\"\n#ifndef struct_px4_internal_block_ParameterU_T\n#define struct_px4_internal_block_ParameterU_T\n\nstruct px4_internal_block_ParameterU_T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  real_T SampleTime;\n  MW_Param_Handle MW_PARAMHANDLE;\n};\n\n#endif                                // struct_px4_internal_block_ParameterU_T\n\n#ifndef struct_px4_internal_block_PWM_FLIGHT_T\n#define struct_px4_internal_block_PWM_FLIGHT_T\n\nstruct px4_internal_block_PWM_FLIGHT_T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  unsigned int servoCount;\n  int channelMask;\n  boolean_T isMain;\n  orb_advert_t armAdvertiseObj;\n  orb_advert_t actuatorAdvertiseObj;\n  boolean_T isArmed;\n};\n\n#endif                                // struct_px4_internal_block_PWM_FLIGHT_T\n\n#ifndef struct_px4_internal_block_Publisher__T\n#define struct_px4_internal_block_Publisher__T\n\nstruct px4_internal_block_Publisher__T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  orb_advert_t orbAdvertiseObj;\n  orb_metadata_t * orbMetadataObj;\n};\n\n#endif                                // struct_px4_internal_block_Publisher__T\n\n#ifndef struct_px4_internal_block_Subscriber_T\n#define struct_px4_internal_block_Subscriber_T\n\nstruct px4_internal_block_Subscriber_T\n{\n  boolean_T matlabCodegenIsDeleted;\n  int32_T isInitialized;\n  boolean_T isSetupComplete;\n  e_px4_internal_block_SampleTi_T SampleTimeHandler;\n  pollfd_t eventStructObj;\n  orb_metadata_t * orbMetadataObj;\n};\n\n#endif                                // struct_px4_internal_block_Subscriber_T\n\n// Parameters (default storage)\ntypedef struct P_FLIGHT_hexacopter_T_ P_FLIGHT_hexacopter_T;\n\n// Forward declaration for rtModel\ntypedef struct tag_RTM_FLIGHT_hexacopter_T RT_MODEL_FLIGHT_hexacopter_T;\n\n#endif                                 // FLIGHT_hexacopter_types_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"FLIGHT_hexacopter_data.cpp","type":"source","group":"data","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Data files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: FLIGHT_hexacopter_data.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.250\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Fri May 23 13:47:19 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#include \"FLIGHT_hexacopter.h\"\n\n// Block parameters (default storage)\nP_FLIGHT_hexacopter_T FLIGHT_hexacopter_P = {\n  // Variable: SampleTime\n  //  Referenced by:\n  //    '<S1>/Read Parameter1'\n  //    '<S1>/Read Parameter2'\n  //    '<S1>/Read Parameter3'\n  //    '<S1>/Read Parameter4'\n  //    '<S2>/Read Parameter'\n  //    '<S2>/Read Parameter1'\n  //    '<S2>/Read Parameter10'\n  //    '<S2>/Read Parameter9'\n  //    '<S3>/Read Parameter'\n  //    '<S3>/Read Parameter1'\n  //    '<S3>/Read Parameter2'\n  //    '<S11>/Read Parameter'\n  //    '<S11>/Read Parameter1'\n  //    '<S11>/Read Parameter2'\n  //    '<S11>/Read Parameter3'\n  //    '<S11>/Read Parameter4'\n  //    '<S194>/Read Parameter'\n  //    '<S195>/Read Parameter'\n\n  0.004,\n\n  // Variable: SampleTime_SAS\n  //  Referenced by:\n  //    '<S4>/Read Parameter1'\n  //    '<S4>/Read Parameter13'\n  //    '<S4>/Read Parameter2'\n  //    '<S4>/Read Parameter3'\n  //    '<S4>/Read Parameter4'\n  //    '<S4>/Read Parameter5'\n  //    '<S10>/Read Parameter1'\n  //    '<S10>/Read Parameter10'\n  //    '<S10>/Read Parameter2'\n  //    '<S10>/Read Parameter3'\n  //    '<S10>/Read Parameter4'\n  //    '<S10>/Read Parameter5'\n  //    '<S10>/Read Parameter6'\n  //    '<S10>/Read Parameter7'\n  //    '<S10>/Read Parameter8'\n  //    '<S10>/Read Parameter9'\n  //    '<S10>/read_mc_rollrate_p'\n\n  0.001,\n\n  // Variable: Jxx\n  //  Referenced by: '<S477>/Constant'\n\n  0.0211F,\n\n  // Variable: Jyy\n  //  Referenced by: '<S477>/Constant1'\n\n  0.0219F,\n\n  // Variable: Jzz\n  //  Referenced by: '<S477>/Constant2'\n\n  0.0366F,\n\n  // Variable: MAX_CONTROL_ANGLE_PITCH\n  //  Referenced by:\n  //    '<S12>/Gain5'\n  //    '<S22>/Gain2'\n\n  0.52359879F,\n\n  // Variable: MAX_CONTROL_ANGLE_RATE_Y\n  //  Referenced by:\n  //    '<S12>/Gain6'\n  //    '<S22>/Gain3'\n\n  2.09439516F,\n\n  // Variable: MAX_CONTROL_ANGLE_ROLL\n  //  Referenced by:\n  //    '<S12>/Gain4'\n  //    '<S22>/Gain1'\n\n  0.52359879F,\n\n  // Variable: MAX_CONTROL_VELOCITY_XY\n  //  Referenced by: '<S192>/Gain1'\n\n  1.5F,\n\n  // Mask Parameter: DiscreteDerivative2_ICPrevScale\n  //  Referenced by: '<S312>/UD'\n\n  0.0F,\n\n  // Mask Parameter: DiscreteDerivative2_ICPrevSca_n\n  //  Referenced by: '<S367>/UD'\n\n  0.0F,\n\n  // Mask Parameter: DiscreteDerivative2_ICPrevSca_o\n  //  Referenced by: '<S422>/UD'\n\n  0.0F,\n\n  // Mask Parameter: DiscreteDerivative2_ICPrevSca_a\n  //  Referenced by: '<S480>/UD'\n\n  0.0F,\n\n  // Mask Parameter: DiscreteDerivative_ICPrevScaled\n  //  Referenced by: '<S478>/UD'\n\n  0.0F,\n\n  // Mask Parameter: DiscreteDerivative1_ICPrevScale\n  //  Referenced by: '<S479>/UD'\n\n  0.0F,\n\n  // Mask Parameter: DiscreteDerivative3_ICPrevScale\n  //  Referenced by: '<S481>/UD'\n\n  0.0F,\n\n  // Mask Parameter: PIDController_InitialConditionF\n  //  Referenced by: '<S55>/Filter'\n\n  0.0F,\n\n  // Mask Parameter: pid_ctrl_rollrate_InitialCondit\n  //  Referenced by: '<S350>/Integrator'\n\n  0.0F,\n\n  // Mask Parameter: pid_ctrl_rollrate_InitialCond_j\n  //  Referenced by: '<S405>/Integrator'\n\n  0.0F,\n\n  // Mask Parameter: pid_ctrl_rollrate_InitialCond_p\n  //  Referenced by: '<S460>/Integrator'\n\n  0.0F,\n\n  // Mask Parameter: PIDController_InitialConditio_a\n  //  Referenced by: '<S60>/Integrator'\n\n  0.0F,\n\n  // Mask Parameter: PIDController_LowerIntegratorSa\n  //  Referenced by: '<S60>/Integrator'\n\n  -0.3F,\n\n  // Mask Parameter: PIDController_LowerSaturationLi\n  //  Referenced by:\n  //    '<S67>/Saturation'\n  //    '<S52>/DeadZone'\n\n  0.0F,\n\n  // Mask Parameter: PIDController_UpperIntegratorSa\n  //  Referenced by: '<S60>/Integrator'\n\n  0.3F,\n\n  // Mask Parameter: PIDController_UpperSaturationLi\n  //  Referenced by:\n  //    '<S67>/Saturation'\n  //    '<S52>/DeadZone'\n\n  1.0F,\n\n  // Mask Parameter: CompareToConstant2_const\n  //  Referenced by: '<S193>/Constant'\n\n  1800U,\n\n  // Mask Parameter: CompareToConstant_const\n  //  Referenced by: '<S488>/Constant'\n\n  1800U,\n\n  // Mask Parameter: CompareToConstant_const_g\n  //  Referenced by: '<S185>/Constant'\n\n  1400U,\n\n  // Mask Parameter: CompareToConstant1_const\n  //  Referenced by: '<S23>/Constant'\n\n  1400U,\n\n  // Mask Parameter: CompareToConstant1_const_e\n  //  Referenced by: '<S183>/Constant'\n\n  1800U,\n\n  // Computed Parameter: Out1_Y0\n  //  Referenced by: '<S303>/Out1'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n    (0ULL),                            // ref_timestamp\n    0.0,                               // ref_lat\n    0.0,                               // ref_lon\n    0.0F,                              // x\n    0.0F,                              // y\n    0.0F,                              // z\n\n    {\n      0.0F, 0.0F }\n    ,                                  // delta_xy\n    0.0F,                              // delta_z\n    0.0F,                              // vx\n    0.0F,                              // vy\n    0.0F,                              // vz\n    0.0F,                              // z_deriv\n\n    {\n      0.0F, 0.0F }\n    ,                                  // delta_vxy\n    0.0F,                              // delta_vz\n    0.0F,                              // ax\n    0.0F,                              // ay\n    0.0F,                              // az\n    0.0F,                              // heading\n    0.0F,                              // delta_heading\n    0.0F,                              // ref_alt\n    0.0F,                              // dist_bottom\n    0.0F,                              // eph\n    0.0F,                              // epv\n    0.0F,                              // evh\n    0.0F,                              // evv\n    0.0F,                              // vxy_max\n    0.0F,                              // vz_max\n    0.0F,                              // hagl_min\n    0.0F,                              // hagl_max\n    false,                             // xy_valid\n    false,                             // z_valid\n    false,                             // v_xy_valid\n    false,                             // v_z_valid\n    0U,                                // xy_reset_counter\n    0U,                                // z_reset_counter\n    0U,                                // vxy_reset_counter\n    0U,                                // vz_reset_counter\n    0U,                                // heading_reset_counter\n    false,                             // heading_good_for_control\n    false,                             // xy_global\n    false,                             // z_global\n    false,                             // dist_bottom_valid\n    0U,                                // dist_bottom_sensor_bitfield\n    false,                             // dead_reckoning\n    0U                                 // _padding0\n  },\n\n  // Computed Parameter: Constant_Value\n  //  Referenced by: '<S301>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n    (0ULL),                            // ref_timestamp\n    0.0,                               // ref_lat\n    0.0,                               // ref_lon\n    0.0F,                              // x\n    0.0F,                              // y\n    0.0F,                              // z\n\n    {\n      0.0F, 0.0F }\n    ,                                  // delta_xy\n    0.0F,                              // delta_z\n    0.0F,                              // vx\n    0.0F,                              // vy\n    0.0F,                              // vz\n    0.0F,                              // z_deriv\n\n    {\n      0.0F, 0.0F }\n    ,                                  // delta_vxy\n    0.0F,                              // delta_vz\n    0.0F,                              // ax\n    0.0F,                              // ay\n    0.0F,                              // az\n    0.0F,                              // heading\n    0.0F,                              // delta_heading\n    0.0F,                              // ref_alt\n    0.0F,                              // dist_bottom\n    0.0F,                              // eph\n    0.0F,                              // epv\n    0.0F,                              // evh\n    0.0F,                              // evv\n    0.0F,                              // vxy_max\n    0.0F,                              // vz_max\n    0.0F,                              // hagl_min\n    0.0F,                              // hagl_max\n    false,                             // xy_valid\n    false,                             // z_valid\n    false,                             // v_xy_valid\n    false,                             // v_z_valid\n    0U,                                // xy_reset_counter\n    0U,                                // z_reset_counter\n    0U,                                // vxy_reset_counter\n    0U,                                // vz_reset_counter\n    0U,                                // heading_reset_counter\n    false,                             // heading_good_for_control\n    false,                             // xy_global\n    false,                             // z_global\n    false,                             // dist_bottom_valid\n    0U,                                // dist_bottom_sensor_bitfield\n    false,                             // dead_reckoning\n    0U                                 // _padding0\n  },\n\n  // Computed Parameter: Out1_Y0_d\n  //  Referenced by: '<S305>/Out1'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // position\n\n    {\n      0.0F, 0.0F, 0.0F, 0.0F }\n    ,                                  // q\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // velocity\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // angular_velocity\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // position_variance\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // orientation_variance\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // velocity_variance\n    0U,                                // pose_frame\n    0U,                                // velocity_frame\n    0U,                                // reset_counter\n    0,                                 // quality\n\n    {\n      0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_g\n  //  Referenced by: '<S304>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // position\n\n    {\n      0.0F, 0.0F, 0.0F, 0.0F }\n    ,                                  // q\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // velocity\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // angular_velocity\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // position_variance\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // orientation_variance\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // velocity_variance\n    0U,                                // pose_frame\n    0U,                                // velocity_frame\n    0U,                                // reset_counter\n    0,                                 // quality\n\n    {\n      0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_m\n  //  Referenced by: '<S495>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n\n    {\n      0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F }\n    ,                                  // control\n    0U,                                // reversible_flags\n\n    {\n      0U, 0U, 0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Out1_Y0_o\n  //  Referenced by: '<S307>/Out1'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_last_signal\n    0,                                 // rssi\n    0.0F,                              // rssi_dbm\n    0U,                                // rc_lost_frame_count\n    0U,                                // rc_total_frame_count\n    0U,                                // rc_ppm_frame_length\n\n    {\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U }\n    ,                                  // values\n    0U,                                // channel_count\n    false,                             // rc_failsafe\n    false,                             // rc_lost\n    0U,                                // input_source\n    0,                                 // link_quality\n    0U                                 // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_m1\n  //  Referenced by: '<S306>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_last_signal\n    0,                                 // rssi\n    0.0F,                              // rssi_dbm\n    0U,                                // rc_lost_frame_count\n    0U,                                // rc_total_frame_count\n    0U,                                // rc_ppm_frame_length\n\n    {\n      0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U }\n    ,                                  // values\n    0U,                                // channel_count\n    false,                             // rc_failsafe\n    false,                             // rc_lost\n    0U,                                // input_source\n    0,                                 // link_quality\n    0U                                 // _padding0\n  },\n\n  // Computed Parameter: Out1_Y0_a\n  //  Referenced by: '<S503>/Out1'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // armed_time\n    (0ULL),                            // takeoff_time\n    (0ULL),                            // nav_state_timestamp\n    0U,                                // failure_detector_status\n    0U,                                // arming_state\n    0U,                                // latest_arming_reason\n    0U,                                // latest_disarming_reason\n    0U,                                // nav_state_user_intention\n    0U,                                // nav_state\n    0U,                                // hil_state\n    0U,                                // vehicle_type\n    false,                             // failsafe\n    false,                             // failsafe_and_user_took_over\n    false,                             // gcs_connection_lost\n    0U,                                // gcs_connection_lost_counter\n    false,                             // high_latency_data_link_lost\n    false,                             // is_vtol\n    false,                             // is_vtol_tailsitter\n    false,                             // in_transition_mode\n    false,                             // in_transition_to_fw\n    0U,                                // system_type\n    0U,                                // system_id\n    0U,                                // component_id\n    false,                             // safety_button_available\n    false,                             // safety_off\n    false,                             // power_input_valid\n    false,                             // usb_connected\n    false,                             // open_drone_id_system_present\n    false,                             // open_drone_id_system_healthy\n    false,                             // parachute_system_present\n    false,                             // parachute_system_healthy\n    false,                             // avoidance_system_required\n    false,                             // avoidance_system_valid\n    false,                             // rc_calibration_in_progress\n    false,                             // calibration_enabled\n    false,                             // pre_flight_checks_pass\n\n    {\n      0U, 0U, 0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_o\n  //  Referenced by: '<S501>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // armed_time\n    (0ULL),                            // takeoff_time\n    (0ULL),                            // nav_state_timestamp\n    0U,                                // failure_detector_status\n    0U,                                // arming_state\n    0U,                                // latest_arming_reason\n    0U,                                // latest_disarming_reason\n    0U,                                // nav_state_user_intention\n    0U,                                // nav_state\n    0U,                                // hil_state\n    0U,                                // vehicle_type\n    false,                             // failsafe\n    false,                             // failsafe_and_user_took_over\n    false,                             // gcs_connection_lost\n    0U,                                // gcs_connection_lost_counter\n    false,                             // high_latency_data_link_lost\n    false,                             // is_vtol\n    false,                             // is_vtol_tailsitter\n    false,                             // in_transition_mode\n    false,                             // in_transition_to_fw\n    0U,                                // system_type\n    0U,                                // system_id\n    0U,                                // component_id\n    false,                             // safety_button_available\n    false,                             // safety_off\n    false,                             // power_input_valid\n    false,                             // usb_connected\n    false,                             // open_drone_id_system_present\n    false,                             // open_drone_id_system_healthy\n    false,                             // parachute_system_present\n    false,                             // parachute_system_healthy\n    false,                             // avoidance_system_required\n    false,                             // avoidance_system_valid\n    false,                             // rc_calibration_in_progress\n    false,                             // calibration_enabled\n    false,                             // pre_flight_checks_pass\n\n    {\n      0U, 0U, 0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_n\n  //  Referenced by: '<S508>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    0.0F,                              // x\n    0.0F,                              // y\n    0.0F,                              // z\n    0.0F,                              // vx\n    0.0F,                              // vy\n    0.0F,                              // vz\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // acceleration\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // thrust\n    0.0F,                              // yaw\n    0.0F                               // yawspeed\n  },\n\n  // Computed Parameter: Constant_Value_l\n  //  Referenced by: '<S506>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    0.0F,                              // roll_body\n    0.0F,                              // pitch_body\n    0.0F,                              // yaw_body\n    0.0F,                              // yaw_sp_move_rate\n\n    {\n      0.0F, 0.0F, 0.0F, 0.0F }\n    ,                                  // q_d\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // thrust_body\n    false,                             // reset_integral\n    false,                             // fw_control_yaw_wheel\n\n    {\n      0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Out1_Y0_p\n  //  Referenced by: '<S498>/Out1'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // xyz\n\n    {\n      0.0F, 0.0F, 0.0F }\n    // xyz_derivative\n  },\n\n  // Computed Parameter: Constant_Value_gk\n  //  Referenced by: '<S497>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    (0ULL),                            // timestamp_sample\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // xyz\n\n    {\n      0.0F, 0.0F, 0.0F }\n    // xyz_derivative\n  },\n\n  // Computed Parameter: Constant_Value_ni\n  //  Referenced by: '<S511>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    0.0F,                              // roll\n    0.0F,                              // pitch\n    0.0F,                              // yaw\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // thrust_body\n    false,                             // reset_integral\n\n    {\n      0U, 0U, 0U, 0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_a\n  //  Referenced by: '<S491>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n\n    {\n      0.0F, 0.0F, 0.0F }\n    ,                                  // control_power\n\n    {\n      0U, 0U, 0U, 0U }\n    // _padding0\n  },\n\n  // Computed Parameter: Out1_Y0_h\n  //  Referenced by: '<S502>/Out1'\n\n  {\n    (0ULL),                            // timestamp\n    false,                             // armed\n    false,                             // prearmed\n    false,                             // ready_to_arm\n    false,                             // lockdown\n    false,                             // manual_lockdown\n    false,                             // force_failsafe\n    false,                             // in_esc_calibration_mode\n    0U                                 // _padding0\n  },\n\n  // Computed Parameter: Constant_Value_m3\n  //  Referenced by: '<S500>/Constant'\n\n  {\n    (0ULL),                            // timestamp\n    false,                             // armed\n    false,                             // prearmed\n    false,                             // ready_to_arm\n    false,                             // lockdown\n    false,                             // manual_lockdown\n    false,                             // force_failsafe\n    false,                             // in_esc_calibration_mode\n    0U                                 // _padding0\n  },\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant1'\n\n  100.0,\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant2'\n\n  100.0,\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant3'\n\n  100.0,\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant4'\n\n  100.0,\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant5'\n\n  100.0,\n\n  // Expression: 100\n  //  Referenced by: '<S4>/Constant'\n\n  100.0,\n\n  // Expression: 1094\n  //  Referenced by: '<S12>/Constant'\n\n  1094.0,\n\n  // Expression: 1/800\n  //  Referenced by: '<S12>/Gain'\n\n  0.00125,\n\n  // Expression: 0.01\n  //  Referenced by: '<S186>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S186>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S186>/Saturation'\n\n  0.0,\n\n  // Expression: 0.01\n  //  Referenced by: '<S187>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S187>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S187>/Saturation'\n\n  0.0,\n\n  // Expression: 0.01\n  //  Referenced by: '<S188>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S188>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S188>/Saturation'\n\n  0.0,\n\n  // Expression: 0.01\n  //  Referenced by: '<S189>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S189>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S189>/Saturation'\n\n  0.0,\n\n  // Expression: 0.01\n  //  Referenced by: '<S190>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S190>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S190>/Saturation'\n\n  0.0,\n\n  // Expression: 0.01\n  //  Referenced by: '<S191>/Gain'\n\n  0.01,\n\n  // Expression: 1\n  //  Referenced by: '<S191>/Saturation'\n\n  1.0,\n\n  // Expression: 0\n  //  Referenced by: '<S191>/Saturation'\n\n  0.0,\n\n  // Computed Parameter: Gain1_Gain\n  //  Referenced by: '<S2>/Gain1'\n\n  -1.0F,\n\n  // Computed Parameter: Gain_Gain_m3\n  //  Referenced by: '<S2>/Gain'\n\n  -1.0F,\n\n  // Computed Parameter: des_p_Y0\n  //  Referenced by: '<S2>/des_p'\n\n  0.0F,\n\n  // Computed Parameter: des_q_Y0\n  //  Referenced by: '<S2>/des_q'\n\n  0.0F,\n\n  // Computed Parameter: Gain1_Gain_g\n  //  Referenced by: '<S77>/Gain1'\n\n  0.0174532924F,\n\n  // Computed Parameter: Gain1_Gain_c\n  //  Referenced by: '<S78>/Gain1'\n\n  0.0174532924F,\n\n  // Computed Parameter: Gain_Gain_a\n  //  Referenced by: '<S249>/Gain'\n\n  -1.0F,\n\n  // Computed Parameter: DiscreteTimeIntegrator_gainval\n  //  Referenced by: '<S5>/Discrete-Time Integrator'\n\n  0.004F,\n\n  // Computed Parameter: DiscreteTimeIntegrator_UpperSat\n  //  Referenced by: '<S5>/Discrete-Time Integrator'\n\n  10.0F,\n\n  // Computed Parameter: DiscreteTimeIntegrator_LowerSat\n  //  Referenced by: '<S5>/Discrete-Time Integrator'\n\n  -50.0F,\n\n  // Computed Parameter: DiscreteTimeIntegrator1_gainval\n  //  Referenced by: '<S5>/Discrete-Time Integrator1'\n\n  0.004F,\n\n  // Computed Parameter: DiscreteTimeIntegrator1_UpperSa\n  //  Referenced by: '<S5>/Discrete-Time Integrator1'\n\n  10.0F,\n\n  // Computed Parameter: DiscreteTimeIntegrator1_LowerSa\n  //  Referenced by: '<S5>/Discrete-Time Integrator1'\n\n  -50.0F,\n\n  // Computed Parameter: Saturation_UpperSat_e\n  //  Referenced by: '<S195>/Saturation'\n\n  0.610865235F,\n\n  // Computed Parameter: Saturation_LowerSat_a\n  //  Referenced by: '<S195>/Saturation'\n\n  -0.610865235F,\n\n  // Computed Parameter: Gain1_Gain_i\n  //  Referenced by: '<S195>/Gain1'\n\n  -1.0F,\n\n  // Computed Parameter: DeadZone3_Start\n  //  Referenced by: '<S192>/Dead Zone3'\n\n  -0.1F,\n\n  // Computed Parameter: DeadZone3_End\n  //  Referenced by: '<S192>/Dead Zone3'\n\n  0.1F,\n\n  // Computed Parameter: Saturation9_UpperSat\n  //  Referenced by: '<S192>/Saturation9'\n\n  1.0F,\n\n  // Computed Parameter: Saturation9_LowerSat\n  //  Referenced by: '<S192>/Saturation9'\n\n  -1.0F,\n\n  // Computed Parameter: DeadZone1_Start\n  //  Referenced by: '<S192>/Dead Zone1'\n\n  -0.1F,\n\n  // Computed Parameter: DeadZone1_End\n  //  Referenced by: '<S192>/Dead Zone1'\n\n  0.1F,\n\n  // Computed Parameter: Saturation1_UpperSat\n  //  Referenced by: '<S192>/Saturation1'\n\n  1.0F,\n\n  // Computed Parameter: Saturation1_LowerSat\n  //  Referenced by: '<S192>/Saturation1'\n\n  -1.0F,\n\n  // Computed Parameter: Gain2_Gain\n  //  Referenced by: '<S192>/Gain2'\n\n  -1.5F,\n\n  // Computed Parameter: tau_roll_Y0\n  //  Referenced by: '<S10>/tau_roll'\n\n  0.0F,\n\n  // Computed Parameter: tau_pitch_Y0\n  //  Referenced by: '<S10>/tau_pitch'\n\n  0.0F,\n\n  // Computed Parameter: tau_yaw_Y0\n  //  Referenced by: '<S10>/tau_yaw'\n\n  0.0F,\n\n  // Computed Parameter: tau_Gain\n  //  Referenced by: '<S315>/tau'\n\n  0.0005F,\n\n  // Computed Parameter: Bias1_Bias\n  //  Referenced by: '<S316>/Bias1'\n\n  1.0F,\n\n  // Computed Parameter: Bias_Bias\n  //  Referenced by: '<S316>/Bias'\n\n  1.0F,\n\n  // Computed Parameter: Gain_Gain_i\n  //  Referenced by: '<S316>/Gain'\n\n  1.41421354F,\n\n  // Computed Parameter: UnitDelay1_InitialCondition\n  //  Referenced by: '<S315>/Unit Delay1'\n\n  0.0F,\n\n  // Computed Parameter: Gain1_Gain_j\n  //  Referenced by: '<S315>/Gain1'\n\n  2.0F,\n\n  // Computed Parameter: UnitDelay2_InitialCondition\n  //  Referenced by: '<S315>/Unit Delay2'\n\n  0.0F,\n\n  // Computed Parameter: TSamp_WtEt\n  //  Referenced by: '<S312>/TSamp'\n\n  1000.0F,\n\n  // Computed Parameter: Integrator_gainval\n  //  Referenced by: '<S350>/Integrator'\n\n  0.001F,\n\n  // Computed Parameter: tau_Gain_n\n  //  Referenced by: '<S370>/tau'\n\n  0.0005F,\n\n  // Computed Parameter: Bias1_Bias_n\n  //  Referenced by: '<S371>/Bias1'\n\n  1.0F,\n\n  // Computed Parameter: Bias_Bias_b\n  //  Referenced by: '<S371>/Bias'\n\n  1.0F,\n\n  // Computed Parameter: Gain_Gain_e\n  //  Referenced by: '<S371>/Gain'\n\n  1.41421354F,\n\n  // Computed Parameter: UnitDelay1_InitialCondition_p\n  //  Referenced by: '<S370>/Unit Delay1'\n\n  0.0F,\n\n  // Computed Parameter: Gain1_Gain_e\n  //  Referenced by: '<S370>/Gain1'\n\n  2.0F,\n\n  // Computed Parameter: UnitDelay2_InitialCondition_e\n  //  Referenced by: '<S370>/Unit Delay2'\n\n  0.0F,\n\n  // Computed Parameter: TSamp_WtEt_m\n  //  Referenced by: '<S367>/TSamp'\n\n  1000.0F,\n\n  // Computed Parameter: Integrator_gainval_b\n  //  Referenced by: '<S405>/Integrator'\n\n  0.001F,\n\n  // Computed Parameter: tau_Gain_c\n  //  Referenced by: '<S425>/tau'\n\n  0.0005F,\n\n  // Computed Parameter: Bias1_Bias_i\n  //  Referenced by: '<S426>/Bias1'\n\n  1.0F,\n\n  // Computed Parameter: Bias_Bias_c\n  //  Referenced by: '<S426>/Bias'\n\n  1.0F,\n\n  // Computed Parameter: Gain_Gain_b\n  //  Referenced by: '<S426>/Gain'\n\n  1.41421354F,\n\n  // Computed Parameter: UnitDelay1_InitialCondition_e\n  //  Referenced by: '<S425>/Unit Delay1'\n\n  0.0F,\n\n  // Computed Parameter: Gain1_Gain_iw\n  //  Referenced by: '<S425>/Gain1'\n\n  2.0F,\n\n  // Computed Parameter: UnitDelay2_InitialCondition_m\n  //  Referenced by: '<S425>/Unit Delay2'\n\n  0.0F,\n\n  // Computed Parameter: TSamp_WtEt_p\n  //  Referenced by: '<S422>/TSamp'\n\n  1000.0F,\n\n  // Computed Parameter: Integrator_gainval_p\n  //  Referenced by: '<S460>/Integrator'\n\n  0.001F,\n\n  // Computed Parameter: DeadZone3_Start_p\n  //  Referenced by: '<S12>/Dead Zone3'\n\n  -0.05F,\n\n  // Computed Parameter: DeadZone3_End_l\n  //  Referenced by: '<S12>/Dead Zone3'\n\n  0.05F,\n\n  // Computed Parameter: Saturation_UpperSat_o\n  //  Referenced by: '<S12>/Saturation'\n\n  0.9F,\n\n  // Computed Parameter: Saturation_LowerSat_el\n  //  Referenced by: '<S12>/Saturation'\n\n  0.0F,\n\n  // Computed Parameter: Constant1_Value_l\n  //  Referenced by: '<S12>/Constant1'\n\n  1514.0F,\n\n  // Computed Parameter: Gain2_Gain_a\n  //  Referenced by: '<S12>/Gain2'\n\n  0.0025F,\n\n  // Computed Parameter: DeadZone2_Start\n  //  Referenced by: '<S12>/Dead Zone2'\n\n  -0.005F,\n\n  // Computed Parameter: DeadZone2_End\n  //  Referenced by: '<S12>/Dead Zone2'\n\n  0.005F,\n\n  // Computed Parameter: Saturation1_UpperSat_l\n  //  Referenced by: '<S12>/Saturation1'\n\n  1.0F,\n\n  // Computed Parameter: Saturation1_LowerSat_i\n  //  Referenced by: '<S12>/Saturation1'\n\n  -1.0F,\n\n  // Computed Parameter: Constant2_Value_i\n  //  Referenced by: '<S12>/Constant2'\n\n  1514.0F,\n\n  // Computed Parameter: Gain1_Gain_m\n  //  Referenced by: '<S12>/Gain1'\n\n  0.0025F,\n\n  // Computed Parameter: DeadZone1_Start_c\n  //  Referenced by: '<S12>/Dead Zone1'\n\n  -0.005F,\n\n  // Computed Parameter: DeadZone1_End_m\n  //  Referenced by: '<S12>/Dead Zone1'\n\n  0.005F,\n\n  // Computed Parameter: Saturation2_UpperSat\n  //  Referenced by: '<S12>/Saturation2'\n\n  1.0F,\n\n  // Computed Parameter: Saturation2_LowerSat\n  //  Referenced by: '<S12>/Saturation2'\n\n  -1.0F,\n\n  // Computed Parameter: Constant3_Value_e\n  //  Referenced by: '<S12>/Constant3'\n\n  1514.0F,\n\n  // Computed Parameter: Gain3_Gain\n  //  Referenced by: '<S12>/Gain3'\n\n  0.0025F,\n\n  // Computed Parameter: DeadZone_Start\n  //  Referenced by: '<S12>/Dead Zone'\n\n  -0.005F,\n\n  // Computed Parameter: DeadZone_End\n  //  Referenced by: '<S12>/Dead Zone'\n\n  0.005F,\n\n  // Computed Parameter: Saturation3_UpperSat\n  //  Referenced by: '<S12>/Saturation3'\n\n  1.0F,\n\n  // Computed Parameter: Saturation3_LowerSat\n  //  Referenced by: '<S12>/Saturation3'\n\n  -1.0F,\n\n  // Computed Parameter: Constant1_Value_g\n  //  Referenced by: '<S50>/Constant1'\n\n  0.0F,\n\n  // Computed Parameter: rate_transition_des_p_InitialCo\n  //  Referenced by: '<Root>/rate_transition_des_p'\n\n  0.0F,\n\n  // Computed Parameter: rate_transition_des_q_InitialCo\n  //  Referenced by: '<Root>/rate_transition_des_q'\n\n  0.0F,\n\n  // Computed Parameter: rate_transition_des_r_InitialCo\n  //  Referenced by: '<Root>/rate_transition_des_r'\n\n  0.0F,\n\n  // Computed Parameter: RateTransition1_InitialConditio\n  //  Referenced by: '<Root>/Rate Transition1'\n\n  0.0F,\n\n  // Computed Parameter: rate_transition_throttle_Initia\n  //  Referenced by: '<Root>/rate_transition_throttle'\n\n  0.0F,\n\n  // Computed Parameter: Constant1_Value_i\n  //  Referenced by: '<S15>/Constant1'\n\n  { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F },\n\n  // Computed Parameter: Saturation_UpperSat_ep\n  //  Referenced by: '<S493>/Saturation'\n\n  2000.0F,\n\n  // Computed Parameter: Saturation_LowerSat_p\n  //  Referenced by: '<S493>/Saturation'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_e\n  //  Referenced by: '<S493>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Gain_Gain_mg\n  //  Referenced by: '<S493>/Gain'\n\n  0.001F,\n\n  // Computed Parameter: Constant_Value_k\n  //  Referenced by: '<S186>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_ms\n  //  Referenced by: '<S187>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_i\n  //  Referenced by: '<S188>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_j\n  //  Referenced by: '<S189>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_lw\n  //  Referenced by: '<S190>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: Constant_Value_ox\n  //  Referenced by: '<S191>/Constant'\n\n  1000.0F,\n\n  // Computed Parameter: DeadZone3_Start_l\n  //  Referenced by: '<S22>/Dead Zone3'\n\n  -0.003F,\n\n  // Computed Parameter: DeadZone3_End_n\n  //  Referenced by: '<S22>/Dead Zone3'\n\n  0.003F,\n\n  // Computed Parameter: Saturation9_UpperSat_c\n  //  Referenced by: '<S22>/Saturation9'\n\n  1.0F,\n\n  // Computed Parameter: Saturation9_LowerSat_i\n  //  Referenced by: '<S22>/Saturation9'\n\n  -1.0F,\n\n  // Computed Parameter: DeadZone1_Start_n\n  //  Referenced by: '<S22>/Dead Zone1'\n\n  -0.001F,\n\n  // Computed Parameter: DeadZone1_End_mj\n  //  Referenced by: '<S22>/Dead Zone1'\n\n  0.001F,\n\n  // Computed Parameter: Saturation1_UpperSat_d\n  //  Referenced by: '<S22>/Saturation1'\n\n  1.0F,\n\n  // Computed Parameter: Saturation1_LowerSat_b\n  //  Referenced by: '<S22>/Saturation1'\n\n  -1.0F,\n\n  // Computed Parameter: DeadZone2_Start_m\n  //  Referenced by: '<S22>/Dead Zone2'\n\n  -0.005F,\n\n  // Computed Parameter: DeadZone2_End_b\n  //  Referenced by: '<S22>/Dead Zone2'\n\n  0.005F,\n\n  // Computed Parameter: Saturation3_UpperSat_d\n  //  Referenced by: '<S22>/Saturation3'\n\n  1.0F,\n\n  // Computed Parameter: Saturation3_LowerSat_n\n  //  Referenced by: '<S22>/Saturation3'\n\n  -1.0F,\n\n  // Computed Parameter: DeadZone4_Start\n  //  Referenced by: '<S22>/Dead Zone4'\n\n  -0.1F,\n\n  // Computed Parameter: DeadZone4_End\n  //  Referenced by: '<S22>/Dead Zone4'\n\n  0.1F,\n\n  // Computed Parameter: Saturation10_UpperSat\n  //  Referenced by: '<S22>/Saturation10'\n\n  1.0F,\n\n  // Computed Parameter: Saturation10_LowerSat\n  //  Referenced by: '<S22>/Saturation10'\n\n  -1.0F,\n\n  // Computed Parameter: Gain_Gain_er\n  //  Referenced by: '<S22>/Gain'\n\n  -1.0F,\n\n  // Computed Parameter: Gain_Gain_o\n  //  Referenced by: '<S1>/Gain'\n\n  -1.0F,\n\n  // Computed Parameter: Integrator_gainval_h\n  //  Referenced by: '<S60>/Integrator'\n\n  0.004F,\n\n  // Computed Parameter: Filter_gainval\n  //  Referenced by: '<S55>/Filter'\n\n  0.004F,\n\n  // Computed Parameter: Constant_Value_gx\n  //  Referenced by: '<S1>/Constant'\n\n  50.0F,\n\n  // Computed Parameter: Saturation1_UpperSat_lr\n  //  Referenced by: '<S1>/Saturation1'\n\n  1.0F,\n\n  // Computed Parameter: Saturation1_LowerSat_e\n  //  Referenced by: '<S1>/Saturation1'\n\n  0.0F,\n\n  // Computed Parameter: TSamp_WtEt_k\n  //  Referenced by: '<S480>/TSamp'\n\n  250.0F,\n\n  // Computed Parameter: TSamp_WtEt_c\n  //  Referenced by: '<S478>/TSamp'\n\n  250.0F,\n\n  // Computed Parameter: TSamp_WtEt_b\n  //  Referenced by: '<S479>/TSamp'\n\n  250.0F,\n\n  // Computed Parameter: TSamp_WtEt_py\n  //  Referenced by: '<S481>/TSamp'\n\n  250.0F,\n\n  // Computed Parameter: DiscreteTimeIntegrator_gainva_c\n  //  Referenced by: '<S11>/Discrete-Time Integrator'\n\n  0.004F,\n\n  // Computed Parameter: DiscreteTimeIntegrator_IC\n  //  Referenced by: '<S11>/Discrete-Time Integrator'\n\n  0.0F,\n\n  // Computed Parameter: Saturation2_UpperSat_i\n  //  Referenced by: '<S11>/Saturation2'\n\n  1.0F,\n\n  // Computed Parameter: Saturation2_LowerSat_k\n  //  Referenced by: '<S11>/Saturation2'\n\n  -1.0F,\n\n  // Computed Parameter: Constant_Value_ll\n  //  Referenced by: '<S21>/Constant'\n\n  0.0F,\n\n  // Computed Parameter: Constant_Value_a5\n  //  Referenced by: '<Root>/Constant'\n\n  0.0F,\n\n  // Computed Parameter: Clamping_zero_Value\n  //  Referenced by: '<S50>/Clamping_zero'\n\n  0.0F,\n\n  // Computed Parameter: PWM_Y0\n  //  Referenced by: '<S7>/PWM'\n\n  0U,\n\n  // Computed Parameter: Output_Limits1_UpperSat\n  //  Referenced by: '<S7>/Output_Limits1'\n\n  2000U,\n\n  // Computed Parameter: Output_Limits1_LowerSat\n  //  Referenced by: '<S7>/Output_Limits1'\n\n  1000U,\n\n  // Computed Parameter: rate_transition_ctrl_sw_Initial\n  //  Referenced by: '<Root>/rate_transition_ctrl_sw'\n\n  0U,\n\n  // Computed Parameter: RateTransition4_InitialConditio\n  //  Referenced by: '<Root>/Rate Transition4'\n\n  0U,\n\n  // Computed Parameter: rate_transition_arm_InitialCond\n  //  Referenced by: '<Root>/rate_transition_arm'\n\n  false,\n\n  // Computed Parameter: RateTransition7_InitialConditio\n  //  Referenced by: '<Root>/Rate Transition7'\n\n  false,\n\n  // Computed Parameter: Constant_Value_ko\n  //  Referenced by: '<S50>/Constant'\n\n  1,\n\n  // Computed Parameter: Constant2_Value_e\n  //  Referenced by: '<S50>/Constant2'\n\n  -1,\n\n  // Computed Parameter: Constant3_Value_i\n  //  Referenced by: '<S50>/Constant3'\n\n  1,\n\n  // Computed Parameter: Constant4_Value_d\n  //  Referenced by: '<S50>/Constant4'\n\n  -1\n};\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtGetInf.cpp","type":"source","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtGetInf.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.250\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Fri May 23 13:47:19 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  //\n  // Initialize rtInf needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  real_T rtGetInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T inf = 0.0;\n    if (bitsPerReal == 32U) {\n      inf = rtGetInfF();\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.bitVal.words.wordH = 0x7FF00000U;\n      tmpVal.bitVal.words.wordL = 0x00000000U;\n      inf = tmpVal.fltVal;\n    }\n\n    return inf;\n  }\n\n  //\n  // Initialize rtInfF needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  real32_T rtGetInfF(void)\n  {\n    IEEESingle infF;\n    infF.wordL.wordLuint = 0x7F800000U;\n    return infF.wordL.wordLreal;\n  }\n\n  //\n  // Initialize rtMinusInf needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  real_T rtGetMinusInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T minf = 0.0;\n    if (bitsPerReal == 32U) {\n      minf = rtGetMinusInfF();\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.bitVal.words.wordH = 0xFFF00000U;\n      tmpVal.bitVal.words.wordL = 0x00000000U;\n      minf = tmpVal.fltVal;\n    }\n\n    return minf;\n  }\n\n  //\n  // Initialize rtMinusInfF needed by the generated code.\n  // Inf is initialized as non-signaling. Assumes IEEE.\n  //\n  real32_T rtGetMinusInfF(void)\n  {\n    IEEESingle minfF;\n    minfF.wordL.wordLuint = 0xFF800000U;\n    return minfF.wordL.wordLreal;\n  }\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtGetInf.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.250\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Fri May 23 13:47:19 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef rtGetInf_h_\n#define rtGetInf_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetInf(void);\n  extern real32_T rtGetInfF(void);\n  extern real_T rtGetMinusInf(void);\n  extern real32_T rtGetMinusInfF(void);\n\n#ifdef __cplusplus\n\n}                                      // extern \"C\"\n\n#endif\n#endif                                 // rtGetInf_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtGetNaN.cpp","type":"source","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtGetNaN.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.250\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Fri May 23 13:47:19 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  //\n  // Initialize rtNaN needed by the generated code.\n  // NaN is initialized as non-signaling. Assumes IEEE.\n  //\n  real_T rtGetNaN(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T nan = 0.0;\n    if (bitsPerReal == 32U) {\n      nan = rtGetNaNF();\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.bitVal.words.wordH = 0xFFF80000U;\n      tmpVal.bitVal.words.wordL = 0x00000000U;\n      nan = tmpVal.fltVal;\n    }\n\n    return nan;\n  }\n\n  //\n  // Initialize rtNaNF needed by the generated code.\n  // NaN is initialized as non-signaling. Assumes IEEE.\n  //\n  real32_T rtGetNaNF(void)\n  {\n    IEEESingle nanF = { { 0.0F } };\n\n    nanF.wordL.wordLuint = 0xFFC00000U;\n    return nanF.wordL.wordLreal;\n  }\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtGetNaN.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.250\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Fri May 23 13:47:19 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef rtGetNaN_h_\n#define rtGetNaN_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetNaN(void);\n  extern real32_T rtGetNaNF(void);\n\n#ifdef __cplusplus\n\n}                                      // extern \"C\"\n\n#endif\n#endif                                 // rtGetNaN_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rt_defines.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.250\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Fri May 23 13:47:19 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef rt_defines_h_\n#define rt_defines_h_\n\n//===========*\n//  Constants *\n// ===========\n#define RT_PI                          3.14159265358979323846\n#define RT_PIF                         3.1415927F\n#define RT_LN_10                       2.30258509299404568402\n#define RT_LN_10F                      2.3025851F\n#define RT_LOG10E                      0.43429448190325182765\n#define RT_LOG10EF                     0.43429449F\n#define RT_E                           2.7182818284590452354\n#define RT_EF                          2.7182817F\n\n//\n//  UNUSED_PARAMETER(x)\n//    Used to specify that a function parameter (argument) is required but not\n//    accessed by the function body.\n\n#ifndef UNUSED_PARAMETER\n#if defined(__LCC__)\n#define UNUSED_PARAMETER(x)                                      // do nothing\n#else\n\n//\n//  This is the semi-ANSI standard way of indicating that an\n//  unused function parameter is required.\n\n#define UNUSED_PARAMETER(x)            (void) (x)\n#endif\n#endif\n#endif                                 // rt_defines_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rt_nonfinite.cpp","type":"source","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rt_nonfinite.cpp\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.250\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Fri May 23 13:47:19 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  real_T rtInf;\n  real_T rtMinusInf;\n  real_T rtNaN;\n  real32_T rtInfF;\n  real32_T rtMinusInfF;\n  real32_T rtNaNF;\n}\n\nextern \"C\"\n{\n  //\n  // Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n  // generated code. NaN is initialized as non-signaling. Assumes IEEE.\n  //\n  void rt_InitInfAndNaN(size_t realSize)\n  {\n    (void) (realSize);\n    rtNaN = rtGetNaN();\n    rtNaNF = rtGetNaNF();\n    rtInf = rtGetInf();\n    rtInfF = rtGetInfF();\n    rtMinusInf = rtGetMinusInf();\n    rtMinusInfF = rtGetMinusInfF();\n  }\n\n  // Test if value is infinite\n  boolean_T rtIsInf(real_T value)\n  {\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n  }\n\n  // Test if single-precision value is infinite\n  boolean_T rtIsInfF(real32_T value)\n  {\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n  }\n\n  // Test if value is not a number\n  boolean_T rtIsNaN(real_T value)\n  {\n    boolean_T result = (boolean_T) 0;\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    if (bitsPerReal == 32U) {\n      result = rtIsNaNF((real32_T)value);\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.fltVal = value;\n      result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                           0x7FF00000 &&\n                           ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                            (tmpVal.bitVal.words.wordL != 0) ));\n    }\n\n    return result;\n  }\n\n  // Test if single-precision value is not a number\n  boolean_T rtIsNaNF(real32_T value)\n  {\n    IEEESingle tmp;\n    tmp.wordL.wordLreal = value;\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n  }\n}\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rt_nonfinite.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.250\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Fri May 23 13:47:19 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef rt_nonfinite_h_\n#define rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#define NOT_USING_NONFINITE_LITERALS   1\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtInf;\n  extern real_T rtMinusInf;\n  extern real_T rtNaN;\n  extern real32_T rtInfF;\n  extern real32_T rtMinusInfF;\n  extern real32_T rtNaNF;\n  extern void rt_InitInfAndNaN(size_t realSize);\n  extern boolean_T rtIsInf(real_T value);\n  extern boolean_T rtIsInfF(real32_T value);\n  extern boolean_T rtIsNaN(real_T value);\n  extern boolean_T rtIsNaNF(real32_T value);\n  struct BigEndianIEEEDouble {\n    struct {\n      uint32_T wordH;\n      uint32_T wordL;\n    } words;\n  };\n\n  struct LittleEndianIEEEDouble {\n    struct {\n      uint32_T wordL;\n      uint32_T wordH;\n    } words;\n  };\n\n  struct IEEESingle {\n    union {\n      real32_T wordLreal;\n      uint32_T wordLuint;\n    } wordL;\n  };\n\n#ifdef __cplusplus\n\n}                                      // extern \"C\"\n\n#endif\n#endif                                 // rt_nonfinite_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtwtypes.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.250\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Fri May 23 13:47:19 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n\n// Logical type definitions\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n//=======================================================================*\n//  Target hardware information\n//    Device type: ARM Compatible->ARM Cortex\n//    Number of bits:     char:   8    short:   16    int:  32\n//                        long:  32    long long:  64\n//                        native word size:  32\n//    Byte ordering: LittleEndian\n//    Signed integer division rounds to: Zero\n//    Shift right on a signed integer as arithmetic shift: on\n// =======================================================================\n\n//=======================================================================*\n//  Fixed width word size data types:                                     *\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n//    real32_T, real64_T           - 32 and 64 bit floating point numbers *\n// =======================================================================\ntypedef signed char int8_T;\ntypedef unsigned char uint8_T;\ntypedef short int16_T;\ntypedef unsigned short uint16_T;\ntypedef int int32_T;\ntypedef unsigned int uint32_T;\ntypedef long long int64_T;\ntypedef unsigned long long uint64_T;\ntypedef float real32_T;\ntypedef double real64_T;\n\n//===========================================================================*\n//  Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n//                            real_T, time_T, ulong_T, ulonglong_T.           *\n// ===========================================================================\ntypedef double real_T;\ntypedef double time_T;\ntypedef unsigned char boolean_T;\ntypedef int int_T;\ntypedef unsigned int uint_T;\ntypedef unsigned long ulong_T;\ntypedef unsigned long long ulonglong_T;\ntypedef char char_T;\ntypedef unsigned char uchar_T;\ntypedef char_T byte_T;\n\n//===========================================================================*\n//  Complex number type definitions                                           *\n// ===========================================================================\n#define CREAL_T\n\ntypedef struct {\n  real32_T re;\n  real32_T im;\n} creal32_T;\n\ntypedef struct {\n  real64_T re;\n  real64_T im;\n} creal64_T;\n\ntypedef struct {\n  real_T re;\n  real_T im;\n} creal_T;\n\n#define CINT8_T\n\ntypedef struct {\n  int8_T re;\n  int8_T im;\n} cint8_T;\n\n#define CUINT8_T\n\ntypedef struct {\n  uint8_T re;\n  uint8_T im;\n} cuint8_T;\n\n#define CINT16_T\n\ntypedef struct {\n  int16_T re;\n  int16_T im;\n} cint16_T;\n\n#define CUINT16_T\n\ntypedef struct {\n  uint16_T re;\n  uint16_T im;\n} cuint16_T;\n\n#define CINT32_T\n\ntypedef struct {\n  int32_T re;\n  int32_T im;\n} cint32_T;\n\n#define CUINT32_T\n\ntypedef struct {\n  uint32_T re;\n  uint32_T im;\n} cuint32_T;\n\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n//=======================================================================*\n//  Min and Max:                                                          *\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n// =======================================================================\n#define MAX_int8_T                     ((int8_T)(127))\n#define MIN_int8_T                     ((int8_T)(-128))\n#define MAX_uint8_T                    ((uint8_T)(255U))\n#define MAX_int16_T                    ((int16_T)(32767))\n#define MIN_int16_T                    ((int16_T)(-32768))\n#define MAX_uint16_T                   ((uint16_T)(65535U))\n#define MAX_int32_T                    ((int32_T)(2147483647))\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\n\n// Block D-Work pointer type\ntypedef void * pointer_T;\n\n#endif                                 // RTWTYPES_H\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Interface files","code":"//\n// Academic License - for use in teaching, academic research, and meeting\n// course requirements at degree granting institutions only.  Not for\n// government, commercial, or other organizational use.\n//\n// File: rtmodel.h\n//\n// Code generated for Simulink model 'FLIGHT_hexacopter'.\n//\n// Model version                  : 1.250\n// Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n// C/C++ source code generated on : Fri May 23 13:47:19 2025\n//\n// Target selection: ert.tlc\n// Embedded hardware selection: ARM Compatible->ARM Cortex\n// Code generation objectives: Unspecified\n// Validation result: Not run\n//\n#ifndef rtmodel_h_\n#define rtmodel_h_\n#include \"FLIGHT_hexacopter.h\"\n\n// Macros generated for backwards compatibility\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((void*) 0)\n#endif\n#endif                                 // rtmodel_h_\n\n//\n// File trailer for generated code.\n//\n// [EOF]\n//\n"},{"name":"MW_PX4_PWM.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw/../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2024 The MathWorks, Inc. */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"MW_PX4_PWM.h\"\n#include \"MW_Parameter.h\"\n#include <uORB/Publication.hpp>\n\n#define DEBUG 0\n\nstatic constexpr uint16_t PWM_SIM_DISARMED = 900;\nstatic constexpr uint16_t PWM_SIM_FAILSAFE = 600;\nstatic constexpr uint16_t PWM_SIM_PWM_MIN = 1000;\nstatic constexpr uint16_t PWM_SIM_PWM_MAX = 2000;\n#if USE_ACTUATOR_TEST\nuORB::Publication<actuator_test_s> actuator_test_pub{ORB_ID(actuator_test)};\n#endif\n\nvoid pwm_open(orb_advert_t* actuatorObj, orb_advert_t* armObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"*     actuatorObj: %d * \", actuatorObj);\n    PX4_INFO(\"*     armObj: %d *\\n\", armObj);\n#endif\n\n#if USE_ACTUATOR_TEST\n    getMainDAPWMValues(mainDAPWMValue);\n    getAUXDAPWMValues(auxDAPWMValue);\n    getMainMinValues(mainMinPWMValue);\n    getAUXMinValues(auxMinPWMValue);\n    getMainMaxValues(mainMaxPWMValue);\n    getAUXMaxValues(auxMaxPWMValue);\n#else\n    /* advertise actuator_outputs topic */\n    struct actuator_outputs_s outputs;\n    memset(&outputs, 0, sizeof(outputs));\n    *actuatorObj = orb_advertise_queue(ORB_ID(actuator_outputs_sim), &outputs, 1);\n\n    /* advertise actuator_armed topic */\n    struct actuator_armed_s armPWM;\n    memset(&armPWM, 0, sizeof(armPWM));\n    *armObj = orb_advertise_queue(ORB_ID(actuator_armed), &armPWM, 1);\n#endif\n}\n\nvoid pwm_arm(orb_advert_t* armObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_arm: *isArmed (status = %d)* \", *isArmed);\n    PX4_INFO(\"*     armObj: %d *\\n\", armObj);\n#endif\n\n#if USE_ACTUATOR_TEST\n\n#else\n    struct actuator_armed_s armPWM;\n    memset(&armPWM, 0, sizeof(armPWM));\n    armPWM.armed = true;\n    orb_publish(ORB_ID(actuator_armed), *armObj, &armPWM);\n#endif\n}\n\nvoid pwm_disarm(orb_advert_t* armObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_disarm: *isArmed (status = %d)* \", *isArmed);\n    PX4_INFO(\"*     armObj: %d *\\n\", armObj);\n#endif\n\n#if USE_ACTUATOR_TEST\n#else\n    struct actuator_armed_s armPWM;\n    memset(&armPWM, 0, sizeof(armPWM));\n    armPWM.armed = false;\n    orb_publish(ORB_ID(actuator_armed), *armObj, &armPWM);\n\n#if defined(MW_PX4_POSIX_BUILD)\n    struct vehicle_status_s arm_vehicle_stat;\n    /* Subscribe to current vehicle_status*/\n    int vehicle_status_fd = orb_subscribe(ORB_ID(vehicle_status));\n    orb_copy(ORB_ID(vehicle_status), vehicle_status_fd, &arm_vehicle_stat);\n    /* Arm vehicle status to ARMING_STATE_SHUTDOWN = 4*/\n    arm_vehicle_stat.arming_state = 4;\n    static bool isAdvertised_disarm = false;\n    static orb_advert_t vehicle_status_pub;\n    if (!isAdvertised_disarm) {\n        isAdvertised_disarm = true;\n        vehicle_status_pub = orb_advertise_queue(ORB_ID(vehicle_status), &arm_vehicle_stat, 1);\n    }\n    orb_publish(ORB_ID(vehicle_status), vehicle_status_pub, &arm_vehicle_stat);\n\n    orb_unsubscribe(vehicle_status_fd);\n#endif\n\n#endif\n}\n\nvoid pwm_forceFailsafe(orb_advert_t* armObj) {\n\n    pwm_disarm(armObj);\n}\n\nvoid pwm_setServo(unsigned servo_count,\n                  int channelMask,\n                  uint16_t* pwm_value,\n                  boolean_T isMain,\n                  orb_advert_t* actuatorObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_setServo: servo_count %d* \", servo_count);\n    PX4_INFO(\"*     isMain %d* \", isMain);\n    PX4_INFO(\"*     actuatorObj %d* \\n\", actuatorObj);\n    uint32_T iPWM;\n    printf(\"* pwm_setServo: PWM values :\");\n    for (iPWM = 0; iPWM < 8; iPWM++) {\n        printf(\"[%d]\", pwm_value[iPWM]);\n    }\n    printf(\"\\n\");\n#endif\n#if USE_ACTUATOR_TEST\n    float output = 0;\n    if (isMain) {\n        for (unsigned i = 0; i < servo_count; ++i) {\n            output = (float)pwm_value[i];\n            output = (output - mainMinPWMValue[i]) / (mainMaxPWMValue[i] - mainMinPWMValue[i]);\n            send_actuator_test_output(actuator_test_s::FUNCTION_MOTOR1 + i, output, false);\n        }\n    } else {\n        for (unsigned i = 0; i < servo_count; ++i) {\n            output = (float)pwm_value[i];\n            output = (output - ((auxMaxPWMValue[i] + auxMinPWMValue[i]) / 2)) /\n                     ((auxMaxPWMValue[i] - auxMinPWMValue[i]) / 2);\n            send_actuator_test_output(actuator_test_s::FUNCTION_SERVO1 + i, output, false);\n        }\n    }\n#else\n    if (isMain) {\n        struct actuator_outputs_s outputs;\n        memset(&outputs, 0, sizeof(outputs));\n        outputs.noutputs = servo_count;\n        outputs.timestamp = hrt_absolute_time();\n        for (unsigned i = 0; i < servo_count; i++) {\n\n            if (pwm_value[i] != PWM_SIM_DISARMED && channelMask & 1 << i) {\n\n                float output = (float)pwm_value[i];\n                /* Scale the motors that are non - reversible to[0, 1]*/\n                outputs.output[i] =\n                    (output - PWM_SIM_PWM_MIN) / (PWM_SIM_PWM_MAX - PWM_SIM_PWM_MIN);\n            }\n        }\n        orb_publish(ORB_ID(actuator_outputs_sim), *actuatorObj, &outputs);\n\n#if defined(MW_PX4_POSIX_BUILD)\n        /*Only for Host target vehicle_status needs to be armed, not for HITL*/\n        struct vehicle_status_s arm_vehicle_stat;\n        /* Subscribe to current vehicle_status*/\n        int vehicle_status_fd = orb_subscribe(ORB_ID(vehicle_status));\n        orb_copy(ORB_ID(vehicle_status), vehicle_status_fd, &arm_vehicle_stat);\n        /* Arm vehicle status to ARMING_STATE_ARMED = 2*/\n        arm_vehicle_stat.arming_state = 2;\n        orb_advert_t vehicle_status_pub =\n            orb_advertise_queue(ORB_ID(vehicle_status), &arm_vehicle_stat, 1);\n        orb_publish(ORB_ID(vehicle_status), vehicle_status_pub, &arm_vehicle_stat);\n        orb_unsubscribe(vehicle_status_fd);\n#endif\n    }\n#endif\n}\n\nvoid pwm_resetServo(unsigned servo_count, boolean_T isMain, orb_advert_t* actuatorObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_setServo: servo_count %d* \", servo_count);\n    PX4_INFO(\"*     isMain %d* \", isMain);\n    PX4_INFO(\"*     actuatorObj %d* \\n\", actuatorObj);\n#endif\n\n#if USE_ACTUATOR_TEST\n    if (isMain) {\n        for (unsigned i = 0; i < servo_count; ++i) {\n            send_actuator_test_output(actuator_test_s::FUNCTION_MOTOR1 + i, 0, true);\n        }\n    } else {\n        for (unsigned i = 0; i < servo_count; ++i) {\n            send_actuator_test_output(actuator_test_s::FUNCTION_SERVO1 + i, 0, true);\n        }\n    }\n#else\n    if (isMain) {\n        struct actuator_outputs_s outputs;\n        memset(&outputs, 0, sizeof(outputs));\n        outputs.noutputs = servo_count;\n        outputs.timestamp = hrt_absolute_time();\n        orb_publish(ORB_ID(actuator_outputs_sim), *actuatorObj, &outputs);\n    }\n\n#endif\n}\n\nvoid pwm_close(unsigned servo_count, orb_advert_t* actuatorObj, orb_advert_t* armObj) {\n#if (defined(PX4_CONNECTEDIO) && (DEBUG == 1))\n    PX4_INFO(\"* pwm_close: armObj %d* \", armObj);\n    PX4_INFO(\"*     actuatorObj %d*\\n\", actuatorObj);\n#endif\n\n#if USE_ACTUATOR_TEST\n    for (unsigned i = 0; i < servo_count; ++i) {\n        send_actuator_test_output(actuator_test_s::FUNCTION_MOTOR1 + i, 0, true);\n    }\n\n    for (unsigned i = 0; i < servo_count; ++i) {\n        send_actuator_test_output(actuator_test_s::FUNCTION_SERVO1 + i, 0, true);\n    }\n#else\n    orb_unadvertise(*actuatorObj);\n    orb_unadvertise(*armObj);\n#endif\n}\n\nvoid send_actuator_test_output(int motorNum, float value, bool isArmed) {\n#if USE_ACTUATOR_TEST\n    actuator_test_s actuator_test{};\n    actuator_test.timestamp = hrt_absolute_time();\n    actuator_test.function = motorNum;\n    actuator_test.value = value;\n    actuator_test.action =\n        isArmed ? actuator_test_s::ACTION_RELEASE_CONTROL : actuator_test_s::ACTION_DO_CONTROL;\n    actuator_test.timeout_ms = 0;\n    actuator_test_pub.publish(actuator_test);\n#endif\n}\n\nvoid getMainDAPWMValues(int32_t* daPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS1\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS2\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS3\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS4\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS5\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS6\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS7\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_MAIN_DIS8\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        }\n    }\n}\n\nvoid getAUXDAPWMValues(int32_t* daPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS1\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS2\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS3\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS4\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS5\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS6\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS7\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_AUX_DIS8\", &paramIntValue);\n            if (success) {\n                daPWMvalues[index] = paramIntValue;\n            } else {\n                daPWMvalues[index] = 1000;\n            }\n        } break;\n        }\n    }\n}\n\nvoid getMainMinValues(int32_t* minPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN1\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN2\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN3\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN4\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN5\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN6\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN7\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_MAIN_MIN8\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        }\n    }\n}\n\nvoid getAUXMinValues(int32_t* minPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN1\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN2\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN3\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN4\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN5\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN6\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN7\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_AUX_MIN8\", &paramIntValue);\n            if (success) {\n                minPWMvalues[index] = paramIntValue;\n            } else {\n                minPWMvalues[index] = 1000;\n            }\n        } break;\n        }\n    }\n}\n\nvoid getMainMaxValues(int32_t* maxPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX1\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX2\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX3\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX4\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX5\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX6\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX7\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_MAIN_MAX8\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        }\n    }\n}\n\nvoid getAUXMaxValues(int32_t* maxPWMvalues) {\n    bool success;\n    int32_t paramIntValue;\n    for (int index = 0; index < 8; index++) {\n        switch (index) {\n        case 0: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX1\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 1: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX2\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 2: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX3\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 3: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX4\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 4: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX5\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 5: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX6\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 6: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX7\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        case 7: {\n            success = getIntegerParamValue(\"PWM_AUX_MAX8\", &paramIntValue);\n            if (success) {\n                maxPWMvalues[index] = paramIntValue;\n            } else {\n                maxPWMvalues[index] = 2000;\n            }\n        } break;\n        }\n    }\n}\n\nbool getSingleParamValue(const char* parameterName, float* paramValue_float) {\n\n    bool success = false;\n    MW_Param_Handle param_handle = PARAM_INVALID;\n    param_handle = param_find(parameterName);\n\n#if DEBUG\n    printf(\"Parameter name = %s.\\n\", parameterName);\n    if (param_handle != PARAM_INVALID) {\n        printf(\"Valid Parameter Handle = %u.\\n\", param_handle);\n    } else {\n        printf(\"Invalid Parameter Handle. \\n\");\n    }\n#endif\n\n    if (param_handle != PARAM_INVALID) {\n        if (!param_get(param_handle, paramValue_float)) {\n            success = true;\n#if DEBUG\n            printf(\"MW_SINGLE. Value = %4.4f\\n\", *paramValue_float);\n#endif\n        }\n    }\n\n    return success;\n}\n\nbool getIntegerParamValue(const char* parameterName, int32_t* paramValue_int) {\n\n    bool success = false;\n    MW_Param_Handle param_handle = PARAM_INVALID;\n    param_handle = param_find(parameterName);\n\n#if DEBUG\n    printf(\"Parameter name = %s.\\n\", parameterName);\n    if (param_handle != PARAM_INVALID) {\n        printf(\"Valid Parameter Handle = %u.\\n\", param_handle);\n    } else {\n        printf(\"Invalid Parameter Handle. \\n\");\n    }\n#endif\n\n    if (param_handle != PARAM_INVALID) {\n        if (!param_get(param_handle, paramValue_int)) {\n            success = true;\n#if DEBUG\n            printf(\"Value = %ld\\n\", *paramValue_int);\n#endif\n        }\n    }\n\n    return success;\n}\n"},{"name":"MW_PX4_TaskControl.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw/../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2018-2023 The MathWorks, Inc.\n *\n * File: MW_PX4_TaskControl.c\n *\n * Abstract:\n *  This file contains the main application for Simulink that is launched\n *  by PX4 stack at boot up. The main function spawns a new task and assigns\n *  the main function in ert_main.c as callback.\n *\n */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n/*Simulink model generated code specific headers*/\n\n#define MW_StringifyDefine(x) MW_StringifyDefineExpanded(x)\n#define MW_StringifyDefineExpanded(x) #x\n\n#define MW_StringifyDefineFunction(x, y) MW_StringifyDefineExpandedFunction(x, y)\n#define MW_StringifyDefineExpandedFunction(x, y) x##y\n\n#define MW_StringifyDefineX(x) MW_StringifyDefineExpandedX(x)\n#define MW_StringifyDefineExpandedX(x) x.##h\n\n#define MW_StringifyDefineTypesX(x) MW_StringifyDefineExpandedTypesX(x)\n#define MW_StringifyDefineExpandedTypesX(x) x##_types.h\n\n#define MW_StringifyDefinePrivateX(x) MW_StringifyDefineExpandedPrivateX(x)\n#define MW_StringifyDefineExpandedPrivateX(x) x##_private.h\n\n#include MW_StringifyDefine(MODEL.h)\n#include MW_StringifyDefine(MW_StringifyDefineTypesX(MODEL))\n#include MW_StringifyDefine(MW_StringifyDefinePrivateX(MODEL))\n\n#ifndef MW_PX4_DISABLE_MAVLINK\n#include \"mavlink_main.h\"\n#endif\n\n#define DEBUG 0\n\n#ifdef PIL\nextern int errorOccurred;\n#endif\n\nextern \"C\" __EXPORT int px4_simulink_app_main(int argc,\n                                              char* argv[]); /* sbcheck:ok:extern_c needed */\n\nextern struct hrt_call\n    BaseRate_HRT; /* Base-rate HRT-callback is used to post base-rate semaphore */\nextern int terminatingmodel;\nextern int baserate_sem_copy; /* used for checking HRT semaphore water-mark*/\nstatic bool g_baseRateLife =\n    false;                        /* global storage to contain the status of the px4_simulink_app */\nstatic int px4_simulink_app_task; /* Handle of daemon thread */\nchar mavlink_shell_started = 0;\n\n/* Print the correct usage. */\nvoid px4_app_usage(const char* reason) {\n    if (reason) {\n        PX4_INFO(\"px4_simulink_app : %s\\n\", reason);\n    }\n    errx(1, \"usage: px4_simulink_app {start|stop|status} [-p <additional params>]\\n\\n\");\n}\n\n#if defined(MW_PX4_DISABLE_MAVLINK)\nuint8_t buffer[100];\nMavlinkShell shell;\nvoid shellWait(MavlinkShell* shell_ptr, uint8_t buf[]) {\n    /*The shell wait here is to be used for commands which are expected to\n      return a few characters (a max. of 100 characters.)*/\n    int read = 0, readTotal = 0;\n    for (int i = 0; i < 100; i++) {\n        buf[i] = 0;\n    }\n    while (strstr((char*)buf, \"nsh>\") == NULL) {\n        read = shell_ptr->read(buf + readTotal, 100 - readTotal);\n        readTotal = readTotal + read;\n    }\n}\n#endif\n\nvoid px4_simulink_app_control_MAVLink() {\n    if (mavlink_shell_started == 0) {\n#ifdef MW_PX4_DISABLE_MAVLINK\n        shell.start();\n        shellWait(&shell, buffer);\n#endif\n    }\n\n#ifdef MW_PX4_DISABLE_MAVLINK\n    shell.write((uint8_t*)\"mavlink stop-all\\n\", sizeof(\"mavlink stop-all\\n\"));\n    usleep(100000);\n#endif\n}\n\nint px4_simulink_app_main(int argc, char* argv[]) {\n    if (argc < 2) {\n        px4_app_usage(\"missing command\");\n    }\n\n    if (!strcmp(argv[1], \"start\")) {\n        if (g_baseRateLife == false) {\n            /* Start the Simulink Tasks here */\n#if DEBUG\n            printf(\"px4_simulink_app : Starting the Simulink model\\n\");\n            fflush(stdout);\n#endif\n\n            /* Reset semaphore */\n            g_baseRateLife = true;\n            terminatingmodel =\n                0; // reset global variable. For more info on the rational behind this, please see:\n            // http://nuttx.org/doku.php?id=wiki:nxinternal:tasks-vs-processes#nuttx_flat-build_behavior\n\n            px4_simulink_app_task = px4_task_spawn_cmd(\n                \"px4_simulink_app_task\", /* Definition of px4_task_spawn_cmd :\n                                            C:\\px4\\Firmware\\src\\platforms\\nuttx\\px4_layer\\px4_nuttx_tasks.c\n                                          */\n                SCHED_DEFAULT,           /* For STM32 F4, NuttX has SCHED_DEFAULT as SCHED_RR */\n                SCHED_PRIORITY_MAX - 15, /* SCHED_PRIORITY_MAX: 255 */\n                2048, px4_simulink_app_task_main, (char* const*)NULL);\n\n        } else {\n            warnx(\"px4_simulink_app : Simulink model is already running\\n\");\n            fflush(stdout);\n        }\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    if (!strcmp(argv[1], \"stop\")) {\n        if (g_baseRateLife == true) {\n#ifdef PIL\n            errorOccurred = 1;\n#else\n            rtmSetErrorStatus(MW_StringifyDefineFunction(MODEL, _M), \"Module stopped by user\");\n            g_baseRateLife = false;\n            px4_sem_post(&baserateTaskSem);\n#endif\n#if DEBUG\n            PX4_INFO(\"px4_simulink_app : Exiting the Simulink model\\n\");\n#endif\n        } else {\n            warnx(\"px4_simulink_app : No Simulink model is running\\n\");\n        }\n\n        fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    if (!strcmp(argv[1], \"status\")) {\n        if (g_baseRateLife) {\n            PX4_INFO(\"px4_simulink_app : model is running\\n\");\n        } else {\n            PX4_INFO(\"px4_simulink_app : model is not started\\n\");\n        }\n        fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n        exit(0);\n#else\n        return 0;\n#endif\n    }\n\n    px4_app_usage(\"unrecognized command\");\n#if defined(MW_PX4_NUTTX_BUILD)\n    exit(1);\n#else\n    return 1;\n#endif\n}\n\nvoid MW_PX4_Terminate() {\n    hrt_cancel(&BaseRate_HRT);\n    g_baseRateLife = false; // set status of PX4 Simulink App to stop\n\n#if defined(MW_HRT_CONSTRAINT) && (1 == MW_HRT_CONSTRAINT)\n    if (baserate_sem_copy > MW_SEM_WATERMARK) {\n        PX4_INFO(\"Hard real-time constraint violated, shutting down. Updating log file. \\n\");\n        FILE* fp_taskover_run = NULL;\n        char msg_watermark[100] = {0};\n        char msg_timestamp[50] = {0};\n        struct tm* sTm;\n        time_t now = time(NULL);\n        sTm = gmtime(&now);\n        sprintf(msg_watermark,\n                \"Base-rate semaphore exceeded water-mark value %d. Model base-rate = %.3f sec.\",\n                MW_SEM_WATERMARK, (float)MW_BASERATE_PERIOD);\n        strftime(msg_timestamp, sizeof(msg_timestamp), \"%Y-%m-%d %H:%M:%S\", sTm);\n        fp_taskover_run = fopen(\"/fs/microsd/log/task_overrun_log.txt\", \"a+\");\n        fprintf(fp_taskover_run, \"%s Timestamp=%s \\n\", msg_watermark, msg_timestamp);\n        fclose(fp_taskover_run);\n    }\n#endif\n\n#if DEBUG\n    PX4_INFO(\"px4_simulink_app : Received command to end the Simulink task \\n\");\n    fflush(stdout);\n#endif\n}\n\n// LocalWords:  HRT px nsh mavlink nuttx doku nxinternal Nutt SCHED fs microsd\n// LocalWords:  dev ACM tty\n"},{"name":"MW_ParameterRead.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw/../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2020 The MathWorks, Inc. */\n/* Reads the Parameter value and outputs the same.\n\n **/\n#include \"MW_ParameterRead.h\"\n\n//Below Macro can be enabled for debugging purposes\n#define DEBUG 0\n\n/*\n ****************************************************************************************************************************************************\n * Wrapper function For Initializing and getting the parameter handle\n * Input Params\n * isString  - Denotes if the Parameter is string or numeric\n * sampleTime - Sample time of the block\n \n * Output Params\n * param_handle  - Handle to the requested parameter.\n ****************************************************************************************************************************************************\n */\nMW_Param_Handle MW_Init_Param(void * ParameterName, uint8_T isString , double sampleTime)\n{\n\n    MW_Param_Handle param_handle = PARAM_INVALID;\n    char * parameterStr;\n    /* Check parameters */\n    if (0 == isString)\n    {\n        fprintf(stderr,\"Only string as ParameterName name is supported.\\n\");\n#if defined(MW_PX4_NUTTX_BUILD)\t\n\texit(1);\n#else\n\treturn 1;\n#endif\n    }\n    else\n    {\n        parameterStr = (char*)ParameterName;\n    }\n    param_handle = param_find(parameterStr);\n#if DEBUG\n    printf(\"In MW_Init_Param. Parameter name = %s.\\n\", parameterStr);\n#endif\n    if (param_handle != PARAM_INVALID)\n    {\n#if DEBUG\n        printf(\"In MW_Init_Param. Valid Parameter Handle = %u.\\n\", param_handle);\n#endif    \n    }\n    else\n    {\n#if DEBUG\n        printf(\"In MW_Init_Param. Invalid Parameter Handle. \\n\");\n#endif\n    }\n    return param_handle;\n}\n\n/*\n ****************************************************************************************************************************************************\n * Wrapper function For reading the parameter\n * Input Params\n * param_h  - Handle to the parameter requested\n * dataType - Data Type of the Parameter Requested\n * dataPtr - Pointer to the data, into which param_get is written to\n *\n * Output Params\n * status  - 0 for a valid Parameter Handle ; 1 for a valid Parameter Handle\n ****************************************************************************************************************************************************\n */\nbool MW_Param_Step(MW_Param_Handle param_h, MW_PARAM_DATA_TYPE dataType, void * dataPtr)\n{\n    //status - 0 for a valid Parameter Handle\n    //status - 1 for an invalid Parameter Handle\n    bool status = 1;\n    if (param_h != PARAM_INVALID)\n    {\n#if DEBUG\n        printf(\"In MW_Param_Step.Parameter Handle = %u.\\n\", param_h);\n#endif\n        int32_t  ReturnTmpInt;\n        float ReturnTmpFlt;\n        switch (dataType)\n        {\n            case MW_INT32:\n                if (!param_get(param_h, &ReturnTmpInt))\n                {\n                    *(int*)dataPtr  = ReturnTmpInt;\n#if DEBUG\n                    printf(\"In MW_Param_Step MW_INT32. Value = %ld\\n\", *(int*)dataPtr);\n#endif\n                }\n                break;\n            case MW_SINGLE:\n                if (!param_get(param_h, &ReturnTmpFlt))\n                {\n                    *(float*)dataPtr  = ReturnTmpFlt;\n#if DEBUG\n                    printf(\"In MW_Param_Step MW_SINGLE. Value = %4.4f\\n\", *(float*)dataPtr);\n#endif\n                }\n                break;\n            default:\n                break;\n        }\n         status = 0;\n    }\n    return status;\n}\n\nvoid MW_Param_terminate(void) \n{\n}\n"},{"name":"MW_custom_RTOS_header.h","type":"header","group":"other","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _MW_CUSTOM_RTOS_HEADER_H_\n#define _MW_CUSTOM_RTOS_HEADER_H_\n#define MW_BASERATE_PRIORITY           250\n#define MW_BASERATE_PERIOD             0.001\n#define MW_NUMBER_SUBRATES             1\n#define MW_NUMBER_APERIODIC_TASKS      0\n#define MW_IS_CONCURRENT               0\n#define MW_NUMBER_TIMER_DRIVEN_TASKS   0\n#define MW_HAS_MULTIPLE_RATES\n\nextern void exitFcn(int sig);\nextern void *terminateTask(void *arg);\nextern void *baseRateTask(void *arg);\nextern void *subrateTask(void *arg);\nextern pthread_t schedulerThread;\nextern pthread_t baseRateThread;\nextern pthread_t subRateThread[];\nextern px4_sem_t stopSem;\nextern px4_sem_t baserateTaskSem;\nextern px4_sem_t subrateTaskSem[];\nextern int taskId[];\nextern int subratePriority[];\n\n#endif\n\n#define MW_MAX_TASKNAME                16\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"MW_PX4_TaskControl.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE PX4 Pixhawk 6x\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERSIZE 1024\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_MAXCONTIGSAMPLES 10\n#define MW_CONNECTIONINFO_XCPONSERIAL_BAUDRATE codertarget.pixhawk.internal.getExternalModeBaudrate(hCS);\n#define MW_CONNECTIONINFO_XCPONSERIAL_COMPORT codertarget.pixhawk.internal.getExternalSerialPortName(hCS);\n#define MW_CONNECTIONINFO_XCPONSERIAL_VERBOSE 1\n#define MW_EXTMODE_CONFIGURATION XCP on Serial\n#define MW_RTOS NuttX\n#define MW_RTOSBASERATETASKPRIORITY 250\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_CMAKECONFIG px4_fmu-v6x_multicopter\n#define MW_CHANGECMAKECONFIG 48\n#define MW_AUTOMATIC_SERIAL_SCAN 1\n#define MW_COM_UPLOAD_STORAGE \n#define MW_NUTTX_SERIAL_PORT \n#define MW_ENABLE_HITL 0\n#define MW_SIMULATOR 0\n#define MW_CONNECTEDIOSERIALPORT /dev/ttyACM0\n#define MW_CONNECTEDIOSERIALPORT_CHECKBOX 1\n#define MW_CONNECTEDIOHOSTCOMPORT \n#define MW_SIMULINKIO_MODELTRANSPORTDATAFCN px4.internal.ConnectedIO.getConfigsetInfo\n#define MW_SIMULINKIO_SERVERDEPLOYFCN px4.internal.ConnectedIO.buildAndDeployPX4IOServer\n#define MW_CLOCKING_CPUCLOCKRATEMHZ 480\n#define MW_EXTSERIALPORT 0\n#define MW_EXTMODESERIALPORT_CHECKBOX 1\n#define MW_EXTMODEHOSTCOMPORT \n#define MW_PILSERIALPORT /dev/ttyACM0\n#define MW_PILSERIALPORT_CHECKBOX 1\n#define MW_PILHOSTCOMPORT COM6\n#define MW_I2C_BUS1SPEEDKHZ_INDEX 0\n#define MW_I2C_BUS2SPEEDKHZ_INDEX 0\n#define MW_I2C_BUS3SPEEDKHZ_INDEX 0\n#define MW_I2C_BUS1SPEEDKHZ 100\n#define MW_I2C_BUS2SPEEDKHZ 100\n#define MW_I2C_BUS3SPEEDKHZ 100\n#define MW_CAN_PORTINDEX 0\n#define MW_CAN_BAUDRATE_INDEX 2\n#define MW_CAN_BAUDRATE 500000\n#define MW_CAN_TESTMODE 0\n#define MW_ENABLEMAVLINKCHECKBOX 1\n#define MW_TTYACM0_BAUDRATE 27\n#define MW_TTYACM0_PARITY 0\n#define MW_TTYACM0_STOPBIT 0\n#define MW_TTYACM0_PORTMAP 48\n#define MW_TTYS0_BAUDRATE 27\n#define MW_TTYS0_PARITY 0\n#define MW_TTYS0_STOPBIT 0\n#define MW_TTYS0_PORTMAP 48\n#define MW_TTYS1_BAUDRATE 27\n#define MW_TTYS1_PARITY 0\n#define MW_TTYS1_STOPBIT 0\n#define MW_TTYS1_PORTMAP 48\n#define MW_TTYS1HWFLOWCONTROL_CHECKBOX 0\n#define MW_TTYS2_BAUDRATE 27\n#define MW_TTYS2_PARITY 0\n#define MW_TTYS2_STOPBIT 0\n#define MW_TTYS2_PORTMAP 48\n#define MW_TTYS2HWFLOWCONTROL_CHECKBOX 0\n#define MW_TTYS3_BAUDRATE 27\n#define MW_TTYS3_PARITY 0\n#define MW_TTYS3_STOPBIT 0\n#define MW_TTYS3_PORTMAP 48\n#define MW_TTYS3HWFLOWCONTROL_CHECKBOX 0\n#define MW_TTYS4_BAUDRATE 27\n#define MW_TTYS4_PARITY 0\n#define MW_TTYS4_STOPBIT 0\n#define MW_TTYS4_PORTMAP 48\n#define MW_TTYS5_BAUDRATE 27\n#define MW_TTYS5_PARITY 0\n#define MW_TTYS5_STOPBIT 0\n#define MW_TTYS5_PORTMAP 48\n#define MW_TTYS6_BAUDRATE 27\n#define MW_TTYS6_PARITY 0\n#define MW_TTYS6_STOPBIT 0\n#define MW_TTYS6_PORTMAP 48\n#define MW_TTYS7_BAUDRATE 27\n#define MW_TTYS7_PARITY 0\n#define MW_TTYS7_STOPBIT 0\n#define MW_TTYS7_PORTMAP 48\n#define MW_HRT_CONSTRAINT 0\n#define MW_SEM_WATERMARK 20\n#define MW_IOBLOCKSMODE deployed\n#define MW_DATAVERSION 2016.02\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"MW_uORB_Read.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw/../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018-2020 The MathWorks, Inc. */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"MW_uORB_Read.h\"\n\n#define DEBUG 0\n\nvoid uORB_read_initialize(orb_metadata_t* orbData, pollfd_t* eventStructObj) {\n    int fd = orb_subscribe(orbData);\n    eventStructObj->fd = fd;\n    eventStructObj->events = POLLIN;\n#if DEBUG\n    PX4_INFO(\"* Subscribed to topic: %s (fd = %d)*\\n\", orbData->o_name, fd);\n#endif\n}\n\nboolean_T uORB_read_step(orb_metadata_t* orbData,\n                         pollfd_t* eventStructObj,\n                         void* busData,\n                         boolean_T blockingMode,\n                         double blockingTimeout) {\n    boolean_T updated = 0;\n    bool isUpdated = false;\n    if (blockingMode) {\n#if defined(MW_PX4_NUTTX_BUILD)\n        int poll_ret = px4_poll(eventStructObj, 1, blockingTimeout);\n        static int error_counter = 0;\n        if (poll_ret == 0) {\n#if DEBUG\n            PX4_ERR(\"Got no data within %.9lf second\", blockingTimeout / 1000.0);\n#endif\n        } else if (poll_ret < 0) {\n            if (error_counter < 10 || error_counter % 500 == 0) {\n                /* use a counter to prevent flooding and slowing the system down */\n#if DEBUG\n                PX4_ERR(\"ERROR return value from poll(): %d\", poll_ret);\n#endif\n            }\n            error_counter++;\n\n        } else {\n            if (eventStructObj->revents & POLLIN) {\n                orb_copy(orbData, eventStructObj->fd, busData);\n                updated = 1;\n            }\n        }\n#elif defined(MW_PX4_POSIX_BUILD)\n        double count = 0;\n        /* The blocking timeout mentioned in the block mask is seconds but\n         * system object converts it to milliseconds*/\n        while (count < blockingTimeout) {\n            // Sleep for 1 ms and then again check if\n            // uORB topic is updated\n            usleep(1000);\n            orb_check(eventStructObj->fd, &isUpdated);\n            if (isUpdated) {\n                orb_copy(orbData, eventStructObj->fd, busData);\n                break;\n            }\n            count++;\n        }\n\n        updated = isUpdated ? 1 : 0;\n#endif\n    } else {\n        orb_check(eventStructObj->fd, &isUpdated);\n        if (isUpdated) {\n            orb_copy(orbData, eventStructObj->fd, busData);\n        }\n        updated = isUpdated ? 1 : 0;\n    }\n\n    return updated;\n}\n\nvoid uORB_read_terminate(const pollfd_t* eventStructObj) {\n    orb_unsubscribe(eventStructObj->fd);\n}\n"},{"name":"MW_uORB_Write.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw/../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 2018 The MathWorks, Inc. */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n#include \"MW_uORB_Write.h\"\n\n#define DEBUG 0\n\nvoid uORB_write_initialize(orb_metadata_t* orbData,\n                          orb_advert_t* orbAdvertObj,\n                          void* busData,\n                          int queueLen) {\n    *orbAdvertObj = orb_advertise_queue(orbData, busData, queueLen);    \n#if DEBUG\n    PX4_INFO(\"Started advertising topic: %s \\n\",  orbData->o_name);\n#endif    \n}\n\nvoid uORB_write_step(orb_metadata_t* orbData,\n                    orb_advert_t* orbAdvertObj,\n                    void* busData) {\n    orb_publish(orbData, *orbAdvertObj, busData);\n}\n\nvoid uORB_write_terminate(const orb_advert_t* orbAdvertObj) {\n    orb_unadvertise(*orbAdvertObj);\n}\n"},{"name":"MW_uORB_busstruct_conversion.h","type":"header","group":"other","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _MW_UORB_BUSSTRUCT_CONVERSION_H_\n#define _MW_UORB_BUSSTRUCT_CONVERSION_H_\n\n#include <uORB/topics/actuator_armed.h>\n#include <uORB/topics/actuator_controls_status.h>\n#include <uORB/topics/actuator_motors.h>\n#include <uORB/topics/input_rc.h>\n#include <uORB/topics/vehicle_angular_velocity.h>\n#include <uORB/topics/vehicle_attitude_setpoint.h>\n#include <uORB/topics/vehicle_local_position.h>\n#include <uORB/topics/vehicle_local_position_setpoint.h>\n#include <uORB/topics/vehicle_odometry.h>\n#include <uORB/topics/vehicle_rates_setpoint.h>\n#include <uORB/topics/vehicle_status.h>\n\ntypedef struct actuator_armed_s  px4_Bus_actuator_armed ;\ntypedef struct actuator_controls_status_s  px4_Bus_actuator_controls_status ;\ntypedef struct actuator_motors_s  px4_Bus_actuator_motors ;\ntypedef struct input_rc_s  px4_Bus_input_rc ;\ntypedef struct vehicle_angular_velocity_s  px4_Bus_vehicle_angular_velocity ;\ntypedef struct vehicle_attitude_setpoint_s  px4_Bus_vehicle_attitude_setpoint ;\ntypedef struct vehicle_local_position_s  px4_Bus_vehicle_local_position ;\ntypedef struct vehicle_local_position_setpoint_s  px4_Bus_vehicle_local_position_setpoint ;\ntypedef struct vehicle_odometry_s  px4_Bus_vehicle_odometry ;\ntypedef struct vehicle_rates_setpoint_s  px4_Bus_vehicle_rates_setpoint ;\ntypedef struct vehicle_status_s  px4_Bus_vehicle_status ;\n\n#endif\n"},{"name":"nuttxinitialize.cpp","type":"source","group":"legacy","path":"/home/sslee/Hexacopter_FDDProject/FLIGHT_hexacopter_ert_rtw/../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/px4/src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright 2018-2022 The MathWorks, Inc.\n *\n * File: nuttxinitialize.c\n *\n * Abstract:\n *  This file contains RTOS thread creation functions\n *\n */\n\n#include \"nuttxinitialize.h\"\n#include \"MW_PX4_TaskControl.h\"\n\n/***********************************************\n * Added for Simulink Threads\n ************************************************/\npthread_attr_t attr;\nstatic baseRateInfo_t g_info;\nstruct sched_param g_sp;\n// extern volatile boolean_T runModel ;\n\n/***********************************************\n * Added for HRT\n ************************************************/\nstruct hrt_call BaseRate_HRT;\nint baserate_sem_copy;\n\n\n#define MW_RTOS_DEBUG 0\n\nbaseRateInfo_t EXT_sig_info;\nbaseRateInfo_t SDCard_sig_info;\nextern pthread_t backgroundThread;\nextern pthread_t loggingThread;\nextern void exitFcn(int sig);\n\nvoid setTaskPeriod(double periodInSeconds, int sigNo) {\n    timer_t timerId;\n    struct sigevent sev;\n    struct itimerspec its;\n    long stNanoSec;\n    int status;\n\n    /* Create a timer */\n    sev.sigev_notify = SIGEV_SIGNAL;\n    sev.sigev_signo = sigNo;\n    sev.sigev_value.sival_ptr = &timerId;\n    status = timer_create(CLOCK_REALTIME, &sev, &timerId);\n    CHECK_STATUS(status, 0, \"timer_create\");\n\n    /* Arm real-time scheduling timer */\n    stNanoSec = (long)(periodInSeconds * 1e9);\n    its.it_value.tv_sec = stNanoSec / 1000000000;\n    its.it_value.tv_nsec = stNanoSec % 1000000000;\n    its.it_interval.tv_sec = its.it_value.tv_sec;\n    its.it_interval.tv_nsec = its.it_value.tv_nsec;\n    status = timer_settime(timerId, 0, &its, NULL);\n    CHECK_STATUS(status, 0, \"timer_settime\");\n}\n\nvoid print_sem_value() {\n    PX4_WARN(\"Sem value = %d\", baserate_sem_copy);\n}\n\nstatic void Base_HRT_Callback(void* arg) {\n#ifndef PX4_CONNECTEDIO\n    int sem_value_check;\n\n    px4_sem_getvalue(&baserateTaskSem, &sem_value_check);\n    px4_sem_post(&baserateTaskSem);\n    baserate_sem_copy = sem_value_check;\n\n#endif\n}\n\n/* ---------------------------- */\n/* Externally visible functions */\n/* ---------------------------- */\nvoid myWaitForThisEvent(int sigNo) {\n    sigset_t sigMask;\n\n    sigemptyset(&sigMask);\n    sigaddset(&sigMask, sigNo);\n    sigwaitinfo(&sigMask, NULL);\n    //\tCHECK_STATUS_NOT(status, -1, \"sigwaitinfo\");\n}\n\nvoid MW_PX4_WaitForThisEvent(void* arg) {\n#ifdef EXT_MODE\n    /*pace External mode thread at 10 Hz*/\n    usleep(100000);\n\n    /*Signaling is causing issue when sample time is greater than 0.1\n     and model runs for more than 60 seconds. In this case model stop is not\n     stopping External mode. Using usleep for now to sleep the External Mode thread.*/\n\n    // baseRateInfo_t ext_info = *((baseRateInfo_t *)arg);\n    // static boolean_T isTaskPeriodSet = false;\n    // boolean_T rtmStopReq = rtmGetStopRequested(MW_StringifyDefineFunction(MODEL, _M));\n\n    // if (!isTaskPeriodSet) {\n    //     setTaskPeriod(ext_info.period, ext_info.sigNo);\n    //     isTaskPeriodSet = true;\n    // }\n\n    // if (!rtmStopReq) {\n    //     myWaitForThisEvent(ext_info.sigNo);\n    // }\n\n#endif\n}\n\nvoid myAddBlockForThisEvent(int sigNo) {\n    int status;\n    sigset_t sigMask;\n\n    sigemptyset(&sigMask);\n    sigaddset(&sigMask, sigNo);\n    status = pthread_sigmask(SIG_BLOCK, &sigMask, NULL);\n    CHECK_STATUS(status, 0, \"pthread_sigmask\");\n}\n\nvoid nuttxRTOSInit(double baseRatePeriod, int numSubrates) {\n    /* This is because in Daren's original Task callback ,a sleep was added before creating the\n     * threads*/\n    sleep(1);\n\n    int status;\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    size_t stackSize;\n    int baseRatePriority = MW_BASERATE_PRIORITY;\n#endif\n\n#ifdef MW_HAS_MULTIPLE_RATES\n    int i;\n    // char taskName[20];\n#endif\n#if defined(MW_PX4_NUTTX_BUILD)\n    sched_lock();\n#endif\n    // status = px4_sem_init(&termSem, 0, 0); PX4 PSP Dev: termSem no longer needed\n    // CHECK_STATUS(status, 0,\"px4_sem_init:termSem\");\n    status = px4_sem_init(&stopSem, 0, 0);\n    CHECK_STATUS(status, 0, \"px4_sem_init:stopSem\");\n    status = px4_sem_init(&baserateTaskSem, 0, 0);\n    CHECK_STATUS(status, 0, \"px4_sem_init:baserateTaskSem\");\n\n    // or you can use/check: _POSIX_PRIORITY_SCHEDULING\n    // _POSIX_THREAD_PRIORITY_SCHEDULING\n#if !defined(_POSIX_PRIORITY_SCHEDULING)\n    PX4_INFO(\"Priority scheduling is NOT supported by your system.\");\n    PX4_INFO(\"The generated code will not run correctly because your\");\n    PX4_INFO(\"model contains multiple rates and uses multi-tasking\");\n    PX4_INFO(\"code generation mode. You can only run the generated code\");\n    PX4_INFO(\"in single-tasking mode in your system. Open\");\n    PX4_INFO(\"Simulation -> Configuration Parameters -> Solver dialog\");\n    PX4_INFO(\"and set \\\"Tasking mode for periodic sample times\\\" parameter to SingleTasking.\");\n    PX4_INFO(\n        \"Re-build the Simulink model with the new settings and try executing the generated code \"\n        \"again.\");\n    fflush(stdout);\n    exit(-1);\n#endif\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    /* Set scheduling policy of the main thread to SCHED_FIFO */\n    g_sp.sched_priority = sched_get_priority_max(SCHED_FIFO) - 50;\n    status = sched_setscheduler(0, SCHED_FIFO, &g_sp);\n    CHECK_STATUS(status, 0, \"sched_setscheduler\");\n\n    /*Added init attribute and scheduler policy */\n    pthread_attr_init(&attr);\n    status = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n    CHECK_STATUS(status, 0, \"pthread_attr_setinheritsched\");\n    status = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);\n    CHECK_STATUS(status, 0, \"pthread_attr_setschedpolicy\");\n    // status = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n    // CHECK_STATUS(status, 0, \"pthread_attr_setdetachstate\");\n\n    /* PTHREAD_STACK_MIN is the minimum stack size required to start a thread */\n    stackSize = 8192 + PTHREAD_STACK_MIN;\n\n    /*added stack attribute back in */\n    status = pthread_attr_setstacksize(&attr, stackSize);\n    CHECK_STATUS(status, 0, \"pthread_attr_setstacksize\");\n#endif\n    /* set up info structure */\n    g_info.period = baseRatePeriod;\n    g_info.sigNo = BASERATE_TIMER_SIGNAL; // SIGRTMIN;\n\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"   stackSize = %d sched_priority = %d\", stackSize, g_sp.sched_priority);\n    PX4_INFO(\"   MW_BASERATE_PERIOD = %8.5f MW_BASERATE_PRIORITY = %d SIGRTMIN = 0x%08X\",\n             (double)baseRatePeriod, (int)baseRatePriority, SIGRTMIN);\n    PX4_INFO(\"   Init info.period = %8.5f sigNo = 0x%04X\", g_info.period, g_info.sigNo);\n    PX4_INFO(\"**creating the Base Rate thread before calling pthread_create**\");\n    fflush(stdout);\n#endif\n\n    /* Create the Base Rate Task here */\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = baseRatePriority;\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&baseRateThread, &attr, &baseRateTask, (void*)&g_info);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&baseRateThread, nullptr, &baseRateTask, (void*)&g_info);\n#endif\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"** Base Rate Task ID = %d with Priority = %d\\n\", baseRateThread, g_sp.sched_priority);\n    fflush(stdout);\n#endif\n\n/* Create sub-rate Tasks here */\n#ifdef MW_HAS_MULTIPLE_RATES\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"Creating sub-rate task threads\\n\");\n    PX4_INFO(\"Number of sub rate tasks: %d \\n\", MW_NUMBER_SUBRATES);\n    fflush(stdout);\n#endif\n\n    for (i = 0; i < MW_NUMBER_SUBRATES; i++) {\n        taskId[i] = i;\n        status = px4_sem_init(&subrateTaskSem[i], 0, 0);\n        CHECK_STATUS(status, 0, \"px4_sem_init: subrateTaskSem\");\n        // g_sp.sched_priority = MW_BASERATE_PRIORITY -40 + subratePriority[i] - 1;\n        g_sp.sched_priority = subratePriority[i];\n#if MW_RTOS_DEBUG\n        PX4_INFO(\"MW_SUBRATE_PRIORITY = %d \", (int)g_sp.sched_priority);\n#endif\n\n#if defined(MW_PX4_NUTTX_BUILD)\n        status = pthread_attr_setschedparam(&attr, &g_sp);\n        CHECK_STATUS(status, 0, \"pthread_attr_setschedparam\");\n        status = pthread_create(&subRateThread[i], &attr, &subrateTask, (void*)&taskId[i]);\n#elif defined(MW_PX4_POSIX_BUILD)\n        status = pthread_create(&subRateThread[i], nullptr, &subrateTask, (void*)&taskId[i]);\n#endif\n        CHECK_STATUS(status, 0, \"pthread_create\");\n\n#if MW_RTOS_DEBUG\n        PX4_INFO(\"** Sub Rate Task ID = %d \", subRateThread[i]);\n        fflush(stdout);\n#endif\n    }\n#endif // End of \"If Multiple Rates\" check\n\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = baseRatePriority;\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n#endif\n\n    /* Create the Scheduler Task here */\n    long stMicroSec;\n    stMicroSec = (long)(g_info.period * 1e6);\n    hrt_call_every(&BaseRate_HRT, stMicroSec, stMicroSec, Base_HRT_Callback,\n                   NULL); // timing callback to post base-rate semaphore\n\n/* Create the External Mode Task here */\n#ifdef EXT_MODE\n    /*---------- Creating EXT-mode Background Task ------------------*/\n    /* Setup signal info to block for EXT Mode */\n    EXT_sig_info.period = 0.1; // Sample rate at which we want Simulink to update w/ ext mode\n    EXT_sig_info.sigNo = SIGRTMIN;\n    /* Signaling the thread not working for low sample frequency*/\n    // sigemptyset(&EXT_sig_info.sigMask);\n    // sigaddset(&EXT_sig_info.sigMask, EXT_sig_info.sigNo);\n    // myAddBlockForThisEvent(EXT_sig_info.sigNo);\n\n    /* Setup thread for Custom Task */\n    fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = 40; // default is 100\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&backgroundThread, &attr, &backgroundTask, (void*)&EXT_sig_info);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&backgroundThread, nullptr, &backgroundTask, (void*)&EXT_sig_info);\n#endif\n    CHECK_STATUS(status, 0, \"EXT Mode Background pthread_create\");\n/*---------------------------------------------------------*/\n#endif\n\n/* Create the SD Card Task here */\n#if MAT_FILE\n    /*---------- Creating SD Card Background Task ------------------*/\n    fflush(stdout);\n#if defined(MW_PX4_NUTTX_BUILD)\n    g_sp.sched_priority = 40; // default is 100\n    status = pthread_attr_setschedparam(&attr, &g_sp);\n    status = pthread_create(&loggingThread, &attr, &loggingThreadFcn, NULL);\n#elif defined(MW_PX4_POSIX_BUILD)\n    status = pthread_create(&loggingThread, nullptr, &loggingThreadFcn, NULL);\n#endif\n    CHECK_STATUS(status, 0, \"SD Card Background pthread_create\");\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"** SD Card Background ID = %d \", loggingThread);\n    fflush(stdout);\n#endif\n\n/*---------------------------------------------------------*/\n#endif\n\n#if MW_RTOS_DEBUG\n    PX4_INFO(\"px4_simulink_app : Created Simulink task threads successfully\\n\");\n    fflush(stdout);\n#endif\n#if defined(MW_PX4_NUTTX_BUILD)\n    sched_unlock();\n#endif\n}\n\n/*---------- Following function is added as a workaround for uavcan module build failure -------------\n  Original definition of the function is in the file <px4dir>\\Firmware\\Boards\\px4\\fmu-v5\\src\\can.c*/\n#if defined(MW_PX4_NUTTX_BUILD) && defined(CONFIG_CAN) && defined(UAVCAN_NUM_IFACES_RUNTIME)\n__EXPORT\nuint16_t board_get_can_interfaces(void)\n{\n\tuint16_t enabled_interfaces = 0x7;\n\n\tif (!PX4_MFT_HW_SUPPORTED(PX4_MFT_CAN2)) {\n\t\tenabled_interfaces &= ~(1 << 1);\n\t}\n\n\tif (!PX4_MFT_HW_SUPPORTED(PX4_MFT_CAN3)) {\n\t\tenabled_interfaces &= ~(1 << 2);\n\t}\n\n\treturn enabled_interfaces;\n }\n#endif\n/*---------------------------------------------------------*/\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};